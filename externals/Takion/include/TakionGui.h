// TakionGui.h : main header file for the TakionGui DLL
//

#pragma once

#ifndef __AFXWIN_H__
	#error "include 'stdafx.h' before including this file for PCH"
#endif

#include <TakionUtilsApi.h>
#include <UtilsGuiApi.h>

#ifdef TGUI_EXPORTS
#define TGUI_API __declspec(dllexport)
#else
#define TGUI_API __declspec(dllimport)
#endif

const char* const TakionGuiHeaderVersion = "1.0.4.222";
//const unsigned short highBit = 1 << 15;
//const unsigned int repeatBit = 1 << 30;
//const char settingDel = '|';
//const char settingSubdel = '`';
//const char sectionDel = '/';
//const char groupDel = '\'';
//const UINT dragListMessageId = RegisterWindowMessage(DRAGLISTMSGSTRING);

#define DEBUG_COLUMNS

#ifdef __cplusplus
extern "C"
{
#endif

//void WINAPI TGUI_IdleInterrupt(bool interrupt, unsigned short source);
//void WINAPI TGUI_IdleResume();
//bool WINAPI TGUI_OnIdle(LONG lCount);

//void WINAPI TGUI_SetCursor(HCURSOR cursor);

const char* WINAPI TGUI_GetHeaderVersion();
unsigned __int64 WINAPI TGUI_GetHeaderVersionNum();
const char* WINAPI TGUI_GetFilePathAndName();
const char* WINAPI TGUI_GetPlatform();
const char* WINAPI TGUI_GetModuleVersionStr();
unsigned __int64 WINAPI TGUI_GetModuleVersionNum();
const char* WINAPI TGUI_GetFileDescription();
void WINAPI TGUI_GetDllBuildDescription(std::string& buildStr);

bool WINAPI TGUI_IsPrioritizeUI();
void WINAPI TGUI_SetPrioritizeUI(bool prioritizeUI);
bool WINAPI TGUI_IsDestroyCanceledOrders();
void WINAPI TGUI_SetDestroyCanceledOrders(bool destroy);
bool WINAPI TGUI_IsDestroyBlockedOrders();
void WINAPI TGUI_SetDestroyBlockedOrders(bool destroy);

/*
bool WINAPI TGUI_ReadStrTokenToMandatoryDel(std::string& token, const char*& str, char del, char terminator);
bool WINAPI TGUI_ReadStrToken(std::string& token, const char*& str, char del);
bool WINAPI TGUI_ReadStrTokenWith2Delimiters(std::string& token, const char*& str, char del, char otherDelimiter = '\n');
*/
/*
UINT WINAPI TGUI_GetDragEnterRegisteredMessage();
UINT WINAPI TGUI_GetDragOverRegisteredMessage();
UINT WINAPI TGUI_GetDragDropRegisteredMessage();
UINT WINAPI TGUI_GetDragAbortRegisteredMessage();
*/
enum SoundEvent : unsigned char
{
	SE_CURRENTACCOUNT_STOCK_EXECUTION_FINAL_BUY,
	SE_CURRENTACCOUNT_STOCK_EXECUTION_FINAL_SELL,
	SE_CURRENTACCOUNT_STOCK_EXECUTION_FINAL_SHORT,
	SE_CURRENTACCOUNT_STOCK_EXECUTION_FINAL_BORROW,

	SE_CURRENTACCOUNT_STOCK_EXECUTION_PARTIAL_BUY,
	SE_CURRENTACCOUNT_STOCK_EXECUTION_PARTIAL_SELL,
	SE_CURRENTACCOUNT_STOCK_EXECUTION_PARTIAL_SHORT,
	SE_CURRENTACCOUNT_STOCK_EXECUTION_PARTIAL_BORROW,

	SE_CURRENTACCOUNT_ORDER_CANCELED_PARTIALEXECUTED_BUY,
	SE_CURRENTACCOUNT_ORDER_CANCELED_PARTIALEXECUTED_SELL,
	SE_CURRENTACCOUNT_ORDER_CANCELED_PARTIALEXECUTED_SHORT,
	SE_CURRENTACCOUNT_ORDER_CANCELED_PARTIALEXECUTED_BORROW,

	SE_CURRENTACCOUNT_ORDER_CANCELED_NOTEXECUTED_BUY,
	SE_CURRENTACCOUNT_ORDER_CANCELED_NOTEXECUTED_SELL,
	SE_CURRENTACCOUNT_ORDER_CANCELED_NOTEXECUTED_SHORT,
	SE_CURRENTACCOUNT_ORDER_CANCELED_NOTEXECUTED_BORROW,

	SE_CURRENTACCOUNT_ORDER_REJECTED_BUY,
	SE_CURRENTACCOUNT_ORDER_REJECTED_SELL,
	SE_CURRENTACCOUNT_ORDER_REJECTED_SHORT,
	SE_CURRENTACCOUNT_ORDER_REJECTED_BORROW,

	SE_CURRENTACCOUNT_ORDER_BLOCKED_BUY,
	SE_CURRENTACCOUNT_ORDER_BLOCKED_SELL,
	SE_CURRENTACCOUNT_ORDER_BLOCKED_SHORT,
	SE_CURRENTACCOUNT_ORDER_BLOCKED_BORROW,

	SE_CURRENTACCOUNT_LONG_POSITION_CLOSED,
	SE_CURRENTACCOUNT_SHORT_POSITION_CLOSED,

	SE_OTHERACCOUNT_STOCK_EXECUTION_FINAL_BUY,
	SE_OTHERACCOUNT_STOCK_EXECUTION_FINAL_SELL,
	SE_OTHERACCOUNT_STOCK_EXECUTION_FINAL_SHORT,
	SE_OTHERACCOUNT_STOCK_EXECUTION_FINAL_BORROW,

	SE_OTHERACCOUNT_STOCK_EXECUTION_PARTIAL_BUY,
	SE_OTHERACCOUNT_STOCK_EXECUTION_PARTIAL_SELL,
	SE_OTHERACCOUNT_STOCK_EXECUTION_PARTIAL_SHORT,
	SE_OTHERACCOUNT_STOCK_EXECUTION_PARTIAL_BORROW,

	SE_OTHERACCOUNT_ORDER_CANCELED_PARTIALEXECUTED_BUY,
	SE_OTHERACCOUNT_ORDER_CANCELED_PARTIALEXECUTED_SELL,
	SE_OTHERACCOUNT_ORDER_CANCELED_PARTIALEXECUTED_SHORT,
	SE_OTHERACCOUNT_ORDER_CANCELED_PARTIALEXECUTED_BORROW,

	SE_OTHERACCOUNT_ORDER_CANCELED_NOTEXECUTED_BUY,
	SE_OTHERACCOUNT_ORDER_CANCELED_NOTEXECUTED_SELL,
	SE_OTHERACCOUNT_ORDER_CANCELED_NOTEXECUTED_SHORT,
	SE_OTHERACCOUNT_ORDER_CANCELED_NOTEXECUTED_BORROW,

	SE_OTHERACCOUNT_ORDER_REJECTED_BUY,
	SE_OTHERACCOUNT_ORDER_REJECTED_SELL,
	SE_OTHERACCOUNT_ORDER_REJECTED_SHORT,
	SE_OTHERACCOUNT_ORDER_REJECTED_BORROW,

	SE_OTHERACCOUNT_ORDER_BLOCKED_BUY,
	SE_OTHERACCOUNT_ORDER_BLOCKED_SELL,
	SE_OTHERACCOUNT_ORDER_BLOCKED_SHORT,
	SE_OTHERACCOUNT_ORDER_BLOCKED_BORROW,

	SE_OTHERACCOUNT_LONG_POSITION_CLOSED,
	SE_OTHERACCOUNT_SHORT_POSITION_CLOSED,

	SE_CURRENTACCOUNT_POSITION_LOSS,
	SE_CURRENTACCOUNT_POSITION_LOSS_EXIT,
	SE_CURRENTACCOUNT_ACCOUNT_LOSS,
	SE_CURRENTACCOUNT_ACCOUNT_LOSS_90,
	SE_CURRENTACCOUNT_ACCOUNT_LOSS_EXIT,
	SE_CURRENTACCOUNT_ALERT_LONG_POSITION_HELD,
	SE_CURRENTACCOUNT_ALERT_SHORT_POSITION_HELD,

	SE_OTHERACCOUNT_POSITION_LOSS,
	SE_OTHERACCOUNT_POSITION_LOSS_EXIT,
	SE_OTHERACCOUNT_ACCOUNT_LOSS,
	SE_OTHERACCOUNT_ACCOUNT_LOSS_90,
	SE_OTHERACCOUNT_ACCOUNT_LOSS_EXIT,
	SE_OTHERACCOUNT_ALERT_LONG_POSITION_HELD,
	SE_OTHERACCOUNT_ALERT_SHORT_POSITION_HELD,

	SE_ALERT_PRINT,
	SE_ALERT_BID,
	SE_ALERT_ASK,
	SE_ALERT_VOLUME,
	SE_ALERT_TIME,
#ifndef TAKION_NO_OPTIONS
	SE_CURRENTACCOUNT_OPTION_EXECUTION_FINAL_BUY_TO_OPEN,
	SE_CURRENTACCOUNT_OPTION_EXECUTION_FINAL_BUY_TO_CLOSE,
	SE_CURRENTACCOUNT_OPTION_EXECUTION_FINAL_SELL_TO_OPEN,
	SE_CURRENTACCOUNT_OPTION_EXECUTION_FINAL_SELL_TO_CLOSE,

	SE_CURRENTACCOUNT_OPTION_EXECUTION_PARTIAL_BUY_TO_OPEN,
	SE_CURRENTACCOUNT_OPTION_EXECUTION_PARTIAL_BUY_TO_CLOSE,
	SE_CURRENTACCOUNT_OPTION_EXECUTION_PARTIAL_SELL_TO_OPEN,
	SE_CURRENTACCOUNT_OPTION_EXECUTION_PARTIAL_SELL_TO_CLOSE,

	SE_OTHERACCOUNT_OPTION_EXECUTION_FINAL_BUY_TO_OPEN,
	SE_OTHERACCOUNT_OPTION_EXECUTION_FINAL_BUY_TO_CLOSE,
	SE_OTHERACCOUNT_OPTION_EXECUTION_FINAL_SELL_TO_OPEN,
	SE_OTHERACCOUNT_OPTION_EXECUTION_FINAL_SELL_TO_CLOSE,

	SE_OTHERACCOUNT_OPTION_EXECUTION_PARTIAL_BUY_TO_OPEN,
	SE_OTHERACCOUNT_OPTION_EXECUTION_PARTIAL_BUY_TO_CLOSE,
	SE_OTHERACCOUNT_OPTION_EXECUTION_PARTIAL_SELL_TO_OPEN,
	SE_OTHERACCOUNT_OPTION_EXECUTION_PARTIAL_SELL_TO_CLOSE,
#endif
	SE_OptionEnd,

	SE_CURRENTACCOUNT_CANCEL_REJECTED = SE_OptionEnd,
	SE_OTHERACCOUNT_CANCEL_REJECTED,

	SE_ALERT_IMBALANCE,
	SE_ALERT_NEWS,
	
	SE_ALERT_L1_BID_SIZE,
	SE_ALERT_L1_ASK_SIZE,
	SE_ALERT_L2_BID_SIZE,
	SE_ALERT_L2_ASK_SIZE,

	SE_ALERT_BORROW,

	SE_ALERT_IMB_NY_REFERENCE_PRICE,

	SE_Count
};

void WINAPI TGUI_UpdateExtensionRow(HMODULE hmodule);

#ifdef __cplusplus
} //extern "C"
#endif

class TakionMainWnd;

class Command;

class TGUI_API ButtonCommand : public ButtonItem
{
public:
	ButtonCommand(int x, int y, int width, int height,// int borderSize,
		bool vertical,
		bool rightJustified,
		COLORREF bkColor,
		COLORREF lightColor,
		COLORREF darkColor,
		bool defaultBkColor,
		int borderSize,
		unsigned int ordinal,
		unsigned char charCount,
		const char* text,
		const char* tooltip,
		Command* command,
		Command* repeatCommand,
		CFont* font,
//		CFont* fontBold = NULL,
		COLORREF textColor,
		bool defaultTextColor,
		bool orderBoxSendToVenue,
		bool orderBoxApplyPriceOffset);
//		COLORREF activeBkColor = 0xFFFFFFFF,
//		COLORREF activeTextColor = 0xFFFFFFFF);
	virtual void DoDraw(HDC dc, const RECT& rcPaint) const override;
	const char* GetAbbreviatedText() const{return m_abbreviatedText.c_str();}
	const char* GetText() const{return m_text.c_str();}
	bool SetText(const char* text)
	{
		if(strcmp(m_text.c_str(), text))
		{
			m_text = text;
			UpdateAbbreviatedText();
			return true;
		}
		return false;
	}

	const char* GetTooltip() const{return m_tooltip.c_str();}
	bool SetTooltip(const char* tooltip)
	{
		if(strcmp(m_tooltip.c_str(), tooltip))
		{
			m_tooltip = tooltip;
			return true;
		}
		return false;
	}

	const Command* GetAttachedCommand() const{return m_command;}
	Command* GetAttachedCommand(){return m_command;}
	bool SetAttachedCommand(Command* command)
	{
		if(m_command != command)
		{
			m_command = command;
			return true;
		}
		return false;
	}
	const Command* GetRepeatCommand() const{return m_repeatCommand;}
	Command* GetRepeatCommand(){return m_repeatCommand;}
	bool SetRepeatCommand(Command* command)
	{
		if(m_repeatCommand != command)
		{
			m_repeatCommand = command;
			return true;
		}
		return false;
	}
	bool isOrderBoxSendToVenue() const{return m_orderBoxSendToVenue;}
	bool SetOrderBoxSendToVenue(bool orderBoxSendToVenue)
	{
		if(m_orderBoxSendToVenue != orderBoxSendToVenue)
		{
			m_orderBoxSendToVenue = orderBoxSendToVenue;
			return true;
		}
		return false;
	}
	bool isOrderBoxApplyPriceOffset() const{return m_orderBoxApplyPriceOffset;}
	bool SetOrderBoxApplyPriceOffset(bool orderBoxApplyPriceOffset)
	{
		if(m_orderBoxApplyPriceOffset != orderBoxApplyPriceOffset)
		{
			m_orderBoxApplyPriceOffset = orderBoxApplyPriceOffset;
			return true;
		}
		return false;
	}
//	virtual bool isActive() const{return m_active;}
//	bool SetActive(bool active);
/*
	virtual bool SetPressed(const bool& pressed)
	{
		if(m_pressed != pressed)
		{
			m_pressed = pressed;
			return true;
		}
		return false;
	}
*/
//	virtual bool shouldDrawPressed() const{return m_pressed || m_active;}
	virtual bool SetTextColor(const COLORREF& textColor) override
	{
		if(textColor != m_textColor)
		{
			m_textColor = textColor;
			return true;
		}
		return false;
	}
	void SetDefaultTextColor(bool defaultTextColor){m_defaultTextColor = defaultTextColor;}
//	void SetBkColor(COLORREF textColor, bool defaultTextColor){m_textColor = textColor, m_defaultTextColor = defaultTextColor;}
	void SetDefaultBkColor(bool defaultBkColor){m_defaultBkColor = defaultBkColor;}
	virtual bool isDefaultTextColor() const{return m_defaultTextColor;}
	virtual bool isDefaultBkColor() const{return m_defaultBkColor;}
	virtual bool SetTextFont(CFont* const& font) override
	{
		if(font != m_font)
		{
			m_font = font;
			return true;
		}
		return false;
	}
//	CFont* GetFontBold() const{return m_fontBold;}
	unsigned char GetCharCount() const{return m_charCount;}
	bool SetCharCount(unsigned char charCount);
protected:
	void UpdateAbbreviatedText();
	bool m_vertical;
	bool m_rightJustified;
	bool m_defaultBkColor;
	bool m_defaultTextColor;
	bool m_orderBoxSendToVenue;
	bool m_orderBoxApplyPriceOffset;
	unsigned char m_charCount;
//	bool m_active;
	std::string m_text;
	std::string m_abbreviatedText;
	std::string m_tooltip;
	CFont* m_font;
//	CFont* m_fontBold;
	COLORREF m_textColor;
//	COLORREF m_activeBkColor;
//	COLORREF m_activeTextColor;
	Command* m_command;
	Command* m_repeatCommand;
};

class TGUI_API ButtonRowCommand : public ButtonRowClipRgn
{
public:
	ButtonRowCommand(CWnd* wnd,
		HCURSOR cursor,
		int left,
		int top,
		int right,
		int bottom,
		bool vertical,
		bool rightJustified,
		unsigned char charCount,
		int width,
		int borderSize,
		int cursorOffsetLeft,
		int cursorOffsetTop,
		int cursorOffsetRight,
		int cursorOffsetBottom,
		COLORREF bkColor,
		COLORREF lightColor,
		COLORREF darkColor,
		COLORREF textColor,
		int buttonHeight,
		CFont* font):
		ButtonRowClipRgn(wnd, cursor,
			left,
			top,
			right,
			bottom,
			vertical, rightJustified,
			width, borderSize,
			cursorOffsetLeft,
			cursorOffsetTop,
			cursorOffsetRight,
			cursorOffsetBottom,
			bkColor,
			lightColor,
			darkColor,
			textColor,
			buttonHeight,
			font),
		m_charCount(charCount)
	{
	}
	ButtonCommand* AppendButton(const char* text,
		Command* command,
		Command* repeatCommand,
		const char* tooltip,
		COLORREF bkColor,
		COLORREF bkLightColor,
		COLORREF bkDarkColor,
		bool defaultBkColor,
		COLORREF textColor,
		bool defaultTextColor,
		bool orderBoxSendToVenue,
		bool orderBoxApplyPriceOffset);
	const unsigned char& GetCharCount() const{return m_charCount;}
	bool SetCharCount(const unsigned char charCount);
	virtual void UpdateRects();
protected:
	unsigned char m_charCount;
};

enum CommandCategory : unsigned char
{
	CC_AGGREGATE,
	CC_TRADE,
	CC_CANCEL,
	CC_TIERSIZE,
	CC_NAVIGATE,
	CC_SETTING,
	CC_EMAIL,

	CC_COUNT
};

enum OrderCommandInventoryType : unsigned char
{
	OCINV_DEFAULT,
	OCINV_INVENTORY,
	OCINV_NO_INVENTORY,

	OCINV_Count
};

class OrderSize;
class OrderPrice;
class CommandInfo;

class TakionTool;

class TGUI_API Command
{
friend void AddExternalCommand(Command* command);
public:
	virtual ~Command(){}
	Command& operator=(const Command& other)
	{
		m_name = other.m_name;
		m_nameCaseInsensitive = other.m_nameCaseInsensitive;
		m_category = other.m_category;
		m_external = other.m_external;
		return *this;
	}

	const char* GetName() const{return m_name.c_str();}
	const std::string& GetStringName() const{return m_name;}

	const char* GetCaseInsensitiveName() const{return m_nameCaseInsensitive.c_str();}
	const std::string& GetStringCaseInsensitiveName() const{return m_nameCaseInsensitive;}

	virtual void SetName(const char* name){}

	const CommandCategory& GetCategory() const{return m_category;}

	const Key& GetKey() const{return m_key;}
	bool isMapped() const{return !m_key.isNull();}
	void Map(const Key& key){m_key = key;}
	void Unmap(){m_key.Nullify();}

	virtual void Invoke(TakionTool* activeTool,
		TakionTool* activeCommandTool,
		bool repeat,
		bool aggregate = false,
		const CommandInfo* commandInfo = NULL){}
	virtual void InvokeForSecurity(TakionTool* activeTool,
		Account* account,
		const Security* security,
		const Position* position,
		unsigned int sendId,
		unsigned int tierSize,
		int count,
		bool closeout,
		bool closeOnly,
		bool passiveOnly,
		bool blockAggressiveOrders,
		unsigned char inventoryMode,
		const CommandInfo* commandInfo);

	virtual bool isAggregateCommand() const{return false;}
	virtual bool isCustomDialogOrderCommand() const{return false;}
	virtual bool isCustom() const{return false;}
	virtual bool isExitDialogCommand() const{return false;}
	virtual bool isToggleCommand() const{return false;}
	virtual bool isTradingCommand() const{return m_category <= CC_CANCEL;}
	virtual bool isExecutableOnRepeat() const{return !isTradingCommand() && !isToggleCommand();}
	virtual bool isOrderBoxCommand() const{return false;}
	virtual bool isCloseOrderBoxOnInvoke() const{return !isOrderBoxCommand();}
	virtual TakionTool* GetTakionTool(){return NULL;}
	virtual const TakionTool* GetTakionTool() const{return NULL;}
	virtual bool isSymbolToActiveCommandWindowCommand() const{return false;}
	virtual bool isActivateWindowCommand() const{return false;}

	virtual bool isApplyToOrderModule() const{return false;}
	virtual unsigned int GetExtensionCode() const{return 0;}
	virtual unsigned int GetUserExtensionCode() const{return 0;}

//	virtual const Security* GetSecurity(const TakionTool* activeTool, const TakionTool* activeCommandTool) const{return NULL;}
//	virtual bool isExecutableForSecurity(const Security* security) const{return true;}
	virtual bool isCommandExecutable(const TakionTool* activeTool, const TakionTool* activeCommandTool) const
	{
		return true;
//		const Security* security = GetSecurity(activeTool, activeCommandTool);
//		return security == NULL || isExecutableForSecurity(security);
	}

	virtual bool isCommandActive() const{return false;}
	virtual bool SetCommandActive(bool active){return false;}
/*
	virtual Command* GetOneExecutableCommand(const TakionTool* activeTool, const TakionTool* activeCommandTool) const
	{
		const Security* security = GetSecurity(activeTool, activeCommandTool);
		return security == NULL || isExecutableForSecurity(security) ? (Command*)this : NULL;
	}
*/
/*
	virtual isAdjustable() const{return false;}
	virtual void SetAdjustable(bool adjustable){}
*/
	const bool& isExternal() const{return m_external;}
	virtual bool isApplicableToCommandBox() const{return true;}
	virtual bool isExecutableInExtension() const{return false;}
protected:
	Command(const char* const& name, const CommandCategory& cc):
		m_name(name),
		m_nameCaseInsensitive(m_name),
		m_category(cc),
		m_external(false)
	{
		for(char* cursor = (char*)m_nameCaseInsensitive.c_str(); *cursor; ++cursor)
		{
			*cursor = toupper(*cursor);
		}
	}

	Command(const Command& other):
		m_name(other.m_name),
		m_nameCaseInsensitive(other.m_nameCaseInsensitive),
		m_category(other.m_category),
		m_external(other.m_external)
	{}
	std::string m_name;
	std::string m_nameCaseInsensitive;
	CommandCategory m_category;
	Key m_key;
	bool m_external;
};

enum CustomCommandType : unsigned char
{
	CCT_OTHER,
	CCT_AGGREGATE,
	CCT_WINDOW_ACTIVATE,
	CCT_SYMBOL_TO_ACTIVE_COMMAND_WINDOW,
	CCT_EXTENSION_KEYSTROKE,
	CCT_NEWS,
	CCT_EMAIL,

	CCT_Count
};

class TGUI_API CustomCommand : public Command
{
public:
	virtual CustomCommand* Clone() const = 0;
	virtual bool operator==(const CustomCommand& other) const{return m_name == other.m_name && m_category == other.m_category;}
	bool operator!=(const CustomCommand& other) const{return !operator==(other);}
	virtual void Copy(const CustomCommand& other){}
	virtual bool isCustom() const{return true;}
	virtual unsigned char GetCommandType() const{return CCT_OTHER;}
	virtual void SetName(const char* name)
	{
		if(strcmp(m_name.c_str(), name))
		{
			m_name = name;
			m_nameCaseInsensitive = name;
			for(char* cursor = (char*)m_nameCaseInsensitive.c_str(); *cursor; ++cursor)
			{
				*cursor = toupper(*cursor);
			}
		}
	}
	virtual void LinkCommand(){}
	virtual bool isAdjustable() const{return false;}
	virtual void SetAdjustable(const bool& adjustable){}
	virtual unsigned int GetTimeToActivate() const{return 0;}
	virtual void SetTimeToActivate(const unsigned int& timeToActivate){}
	virtual unsigned int GetTimeToExpire() const{return 0;}
	virtual void SetTimeToExpire(const unsigned int& timeToExpire){}
protected:
	CustomCommand(const char* const& name, const CommandCategory& cc):Command(name, cc){}
};

enum EmailReceipientFlags : unsigned char
{
	ERF_TO,
	ERF_CC,
	ERF_BCC,
	ERF_USE = 4,

	ERF_Count
};

class EmailReceipient
{
public:
	EmailReceipient(const std::string& receipientName, const unsigned char& flags):
		m_receipientName(receipientName),
		m_flags(flags)
	{
	}
	EmailReceipient(const char* const& receipientName, const unsigned char& flags):
		m_receipientName(receipientName),
		m_flags(flags)
	{
	}
	const unsigned char& GetFlags() const{return m_flags;}
	void SetFlags(const unsigned char& flags){m_flags = flags & 7;}

	bool isUsed() const{return (m_flags & ERF_USE) != 0;}
	unsigned char GetKind() const{return m_flags & (ERF_USE - 1);}
	bool isTo() const{return GetKind() == ERF_TO;}
	bool isCc() const{return GetKind() == ERF_CC;}
	bool isBcc() const{return GetKind() == ERF_BCC;}

	void SetUsed(const bool& used)
	{
		if(used)m_flags |= ERF_USE;
		else m_flags &= (ERF_USE - 1);
	}
	void SetKind(const unsigned char& kind)
	{
		m_flags &= ERF_USE;
		m_flags |= (kind & (ERF_USE - 1));
	}
	void ToggleKind()
	{
		unsigned char kind = GetKind();
		if(ERF_BCC <= kind)kind = ERF_TO;
		else ++kind;
		SetKind(kind);
	}

	const std::string& GetReceipientName() const{return m_receipientName;}
	void SetReceipientName(const std::string& receipientName){m_receipientName = receipientName;}

	bool operator<(const EmailReceipient& other) const
	{
//		const int ret = strcmp(m_receipientName.c_str(), other.m_receipientName.c_str());
//		return ret < 0 || !ret && m_flags < other.m_flags;
		return m_receipientName < other.m_receipientName || m_flags < other.m_flags && m_receipientName == other.m_receipientName;
	}
	bool operator<=(const EmailReceipient& other) const
	{
//		const int ret = strcmp(m_receipientName.c_str(), other.m_receipientName.c_str());
//		return ret < 0 || !ret && m_flags <= other.m_flags;
		return m_receipientName < other.m_receipientName || m_flags <= other.m_flags && m_receipientName == other.m_receipientName;
	}
	bool operator>(const EmailReceipient& other) const
	{
//		const int ret = strcmp(m_receipientName.c_str(), other.m_receipientName.c_str());
//		return ret > 0 || !ret && m_flags > other.m_flags;
		return m_receipientName > other.m_receipientName || m_flags > other.m_flags && m_receipientName == other.m_receipientName;
	}
	bool operator>=(const EmailReceipient& other) const
	{
//		const int ret = strcmp(m_receipientName.c_str(), other.m_receipientName.c_str());
//		return ret > 0 || !ret && m_flags >= other.m_flags;
		return m_receipientName > other.m_receipientName || m_flags >= other.m_flags && m_receipientName == other.m_receipientName;
	}
	bool operator==(const EmailReceipient& other) const
	{
		return m_flags == other.m_flags && m_receipientName == other.m_receipientName;
	}
	bool operator!=(const EmailReceipient& other) const
	{
		return !operator==(other);
	}
protected:
	std::string m_receipientName;
	unsigned char m_flags;//EmailReceipientFlags
};

class TGUI_API NewsCommand : public CustomCommand
{
public:
	NewsCommand(const char* const& name,
		const std::string& url):
		CustomCommand(name, CC_NAVIGATE),
		m_char1('%'),
		m_char2('s')
	{
		SetURL(url);
	}

	const std::string& GetURL() const{return m_url;}
	void SetURL(const std::string& url);
//	virtual bool isNewsCommand() const{return true;}
	virtual unsigned char GetCommandType() const override{return CCT_NEWS;}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
	virtual CustomCommand* Clone() const override;
	virtual bool operator==(const CustomCommand& other) const;
	virtual void Copy(const CustomCommand& other) override;
	typedef std::list<std::string> StringList;
protected:
	std::string m_url;
	StringList m_tokenList;
	char m_char1;
	char m_char2;
};

class TGUI_API EmailCommand : public CustomCommand
{
public:
	EmailCommand(const char* const& name,
		const std::string& server,
		const unsigned short& port,
		const unsigned char& emailSecurity,
		const bool& allowInvalidCertificate,
		const std::string& senderAddress,
		const std::string& senderId,
		const std::string& senderPassword,
		const std::string& senderName,
		const std::string& senderOrganization,
		const std::string& subject,
		const std::string& contents):

		CustomCommand(name, CC_EMAIL),//CC_NAVIGATE),
		m_server(server),
		m_port(port),
		m_emailSecurity(emailSecurity),
		m_allowInvalidCertificate(allowInvalidCertificate),
		m_senderAddress(senderAddress),
		m_senderId(senderId),
		m_senderPassword(senderPassword),
		m_senderName(senderName),
		m_senderOrganization(senderOrganization),
		m_emailReceipientMapEnd(m_emailReceipientMap.end()),
		m_breakChar('%'),
		m_missingChar(' ')
	{
		SetSubject(subject);
		SetContents(contents);
	}

	EmailCommand(const EmailCommand& other)://need this because of m_emailReceipientMapEnd
		CustomCommand(other),
		m_server(other.m_server),
		m_port(other.m_port),
		m_emailSecurity(other.m_emailSecurity),
		m_allowInvalidCertificate(other.m_allowInvalidCertificate),
		m_senderAddress(other.m_senderAddress),
		m_senderId(other.m_senderId),
		m_senderPassword(other.m_senderPassword),
		m_senderName(other.m_senderName),
		m_senderOrganization(other.m_senderOrganization),
		m_emailReceipientMap(other.m_emailReceipientMap),
		m_emailReceipientMapEnd(m_emailReceipientMap.end()),
		m_breakChar(other.m_breakChar),
		m_missingChar(other.m_missingChar)
	{
		SetSubject(other.m_subject);
		SetContents(other.m_contents);
	}

	EmailCommand& operator=(const EmailCommand& other)//need this because of m_emailReceipientMapEnd
	{
		CustomCommand::operator=(other);
		m_server = other.m_server;
		m_port = other.m_port;
		m_emailSecurity = other.m_emailSecurity;
		m_allowInvalidCertificate = other.m_allowInvalidCertificate;
		m_senderAddress = other.m_senderAddress;
		m_senderId = other.m_senderId;
		m_senderPassword = other.m_senderPassword;
		m_senderName = other.m_senderName;
		m_senderOrganization = other.m_senderOrganization;
		m_emailReceipientMap = other.m_emailReceipientMap;
		m_breakChar = other.m_breakChar;
		m_missingChar = other.m_missingChar;
		SetSubject(other.m_subject);
		SetContents(other.m_contents);
		return *this;
	}

	typedef std::list<std::string> StringList;

	static void AssembleString(const StringList& strList,
		const Account* account,
		const Position* position,
		const Security* security,
		const char breakChar,
		const char missingChar,
		std::string& result);

	void GetSubjectAndContents(std::string& subject,
		std::string& contents,
		const Account* account,
		const Position* position,
		const Security* security) const;

	void SendEmail(const std::string& subject, const std::string& contents) const;

	const std::string& GetServer() const{return m_server;}
	void SetServer(const std::string& server){m_server = server;}

	const std::string& GetSenderAddress() const{return m_senderAddress;}
	void SetSenderAddress(const std::string& senderAddress){m_senderAddress = senderAddress;}

	const std::string& GetSenderId() const{return m_senderId;}
	void SetSenderId(const std::string& senderId){m_senderId = senderId;}

	const std::string& GetSenderPassword() const{return m_senderPassword;}
	void SetSenderPassword(const std::string& senderPassword){m_senderPassword = senderPassword;}

	const std::string& GetSenderName() const{return m_senderName;}
	void SetSenderName(const std::string& senderName){m_senderName = senderName;}

	const std::string& GetSenderOrganization() const{return m_senderOrganization;}
	void SetSenderOrganization(const std::string& senderOrganization){m_senderOrganization = senderOrganization;}

	const unsigned short& GetPort() const{return m_port;}
	void SetPort(const unsigned short& port){m_port = port;}

	const unsigned char& GetEmailSecurity() const{return m_emailSecurity;}
	void SetEmailSecurity(const unsigned char& emailSecurity){m_emailSecurity = emailSecurity;}

	const bool& isAllowInvalidCertificate() const{return m_allowInvalidCertificate;}
	void SetAllowInvalidCertificate(const bool& allowInvalidCertificate){m_allowInvalidCertificate = allowInvalidCertificate;}

	const std::string& GetSubject() const{return m_subject;}
	const std::string& GetContents() const{return m_contents;}
	void SetSubject(const std::string& subject);
	void SetContents(const std::string& subject);

	virtual unsigned char GetCommandType() const override{return CCT_EMAIL;}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
	virtual void InvokeForSecurity(TakionTool* activeTool,
		Account* account,
		const Security* security,
		const Position* position,
		unsigned int sendId,
		unsigned int tierSize,
		int count,
		bool closeout,
		bool closeOnly,
		bool passiveOnly,
		bool blockAggressiveOrders,
		unsigned char inventoryMode,
		const CommandInfo* commandInfo) override;
	virtual CustomCommand* Clone() const override;
	virtual bool operator==(const CustomCommand& other) const;
	virtual void Copy(const CustomCommand& other);

	typedef std::map<std::string, EmailReceipient> EmailReceipientMap;
	const EmailReceipientMap& GetEmailReceipientMap() const{return m_emailReceipientMap;}
	EmailReceipientMap& GetEmailReceipientMap(){return m_emailReceipientMap;}
	const EmailReceipient* FindEmailReceipient(const std::string& receipientAddress) const
	{
		const EmailReceipientMap::const_iterator found = m_emailReceipientMap.find(receipientAddress);
		return found == m_emailReceipientMapEnd ? NULL : &found->second;
	}
	EmailReceipient* FindEmailReceipient(const std::string& receipientAddress)
	{
		const EmailReceipientMap::iterator found = m_emailReceipientMap.find(receipientAddress);
		return found == m_emailReceipientMapEnd ? NULL : &found->second;
	}
	void AddEmailReceipient(const std::string& receipientAddress, const std::string& receipientName, const unsigned char& flags)
	{
		const EmailReceipientMap::iterator found = m_emailReceipientMap.find(receipientAddress);
		if(found == m_emailReceipientMapEnd)
		{
			m_emailReceipientMap.insert(EmailReceipientMap::value_type(receipientAddress, EmailReceipient(receipientName, flags)));
		}
		else
		{
			EmailReceipient& receipient = found->second;
			receipient.SetReceipientName(receipientName);
			receipient.SetFlags(flags);
		}
	}
	bool RemoveEmailReceipient(const std::string& receipientAddress)
	{
		return m_emailReceipientMap.erase(receipientAddress) != 0;
	}
	void ClearEmailReceipients()
	{
		m_emailReceipientMap.clear();
	}
	unsigned int GetEmailReceipientCount() const{return (unsigned int)m_emailReceipientMap.size();}

protected:
	std::string m_server;
	unsigned short m_port;
	unsigned char m_emailSecurity;
	bool m_allowInvalidCertificate;
	std::string m_senderAddress;
	std::string m_senderId;
	std::string m_senderPassword;
	std::string m_senderName;
	std::string m_senderOrganization;

	std::string m_subject;
	std::string m_contents;
	StringList m_subjectTokenList;
	StringList m_contentsTokenList;

	EmailReceipientMap m_emailReceipientMap;
	EmailReceipientMap::const_iterator m_emailReceipientMapEnd;

	char m_breakChar;
	char m_missingChar;
};

enum OrderCommandSide : unsigned char
{
	OCS_SELL,
	OCS_BUY,
	OCS_CLOSE,
	OCS_ADD,

	OCS_COUNT
};

enum OrderCommandPositionType : unsigned char
{
	OCP_CURRENT,
	OCP_ALL,
	OCP_LONG,
	OCP_SHORT,

	OCP_COUNT
};

enum MainBarOverride : unsigned int
{
	MBO_CLOSEOUT,
	MBO_PROACTIVE,
	MBO_HIDDEN,
	MBO_REDIRECT,
	MBO_IMBALANCE_ONLY,

	MBO_COUNT
};

class TGUI_API CustomDialogOrderCommand : public CustomCommand
{
public:
	virtual bool isCustomDialogOrderCommand() const override{return true;}
	virtual bool isCloseOrderBoxOnInvoke() const{return !isAdjustable();}
	virtual bool isAdjustable() const override{return m_adjustable;}
	virtual void SetAdjustable(const bool& adjustable) override{m_adjustable = adjustable;}

	virtual unsigned int GetTimeToActivate() const override{return m_timeToActivate;}
	virtual void SetTimeToActivate(const unsigned int& timeToActivate) override{m_timeToActivate = timeToActivate;}

	virtual unsigned int GetTimeToExpire() const override{return m_timeToExpire;}
	virtual void SetTimeToExpire(const unsigned int& timeToExpire) override{m_timeToExpire = timeToExpire;}

	virtual unsigned int GetRenewTime() const{return 0;}
	virtual void SetRenewTime(unsigned int renewTime){}

	virtual bool MustBeSubscribed() const{return false;}

	virtual const Security* GetSecurity(const TakionTool* activeTool, const TakionTool* activeCommandTool) const{return NULL;}
	virtual bool isExecutableForSecurity(const Security* security) const{return true;}
	virtual bool isCommandExecutable(const TakionTool* activeTool, const TakionTool* activeCommandTool) const
	{
		const Security* security = GetSecurity(activeTool, activeCommandTool);
		return security == NULL || isExecutableForSecurity(security);
	}

//	static bool GetPriceByOffsetStatic(const SignedPrice& offset, unsigned char priceBase, bool priceOffsetPercent, Price& price, const Security* security, TakionTool* takionTool, int positionSize, const Price& positionPrice, Price& level1Bid, Price& level1Ask, Price& insideBid, Price& insideAsk, Price& lastPrint, char side, bool proper);
	static bool GetPriceByOffsetStatic(const SignedPrice& offset, unsigned char priceBase, bool priceOffsetPercent, Price& price, const Security* security, TakionTool* takionTool, int positionSize, const Price& positionPrice, const Price& positionCost, Price& level1Bid, Price& level1Ask, Price& insideBid, Price& insideAsk, Price& lastPrint, char side, bool proper);

	const bool& isPriceDynamic() const{return m_priceDynamic;}//Set in the UI that the price should change in the OrderBox from the initial value.
	void SetPriceDynamic(const bool& priceDynamic){m_priceDynamic = priceDynamic;}

	virtual bool isPriceRelative() const{return false;}//Set in the UI that the price should increment in the OrderBox relative to the initial value.

	const bool& isCloseOrderBox() const{return m_closeOrderBox;}
	void SetCloseOrderBox(const bool& closeOrderBox){m_closeOrderBox = closeOrderBox;}

	virtual unsigned int GetOverrideMask() const{return 0;}
	bool isNoRedirect() const{return (GetOverrideMask() & (1 << MBO_REDIRECT)) != 0;}
	virtual bool operator==(const CustomCommand& other) const;
	virtual void Copy(const CustomCommand& other);

//	bool ShowOrderDialog(TakionTool* activeTool, ToolMarketMaker* mm, bool repeat);
	bool ShowOrderDialog(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat);

//	typedef std::set<unsigned __int64> DestSet;
	typedef std::set<unsigned int> DestSet;//Set of names
	virtual bool isExcludeDestinations() const{return false;}
	virtual const DestSet* GetDestinationSet() const{return NULL;}
	virtual const char* GetOrderBoxDestination() const{return GetDestinationName();}
	virtual const char* GetDestinationName() const{return "";}

	virtual bool isTrigger() const{return false;}

	virtual bool isBorrow() const{return false;}

//	virtual bool isSwipe() const{return false;}

	virtual unsigned char hasMnemonic() const{return 0;}

	virtual bool isPreBorrow() const{return false;}
	virtual const Price& GetPreBorrowPrice() const{return Price::priceZero;}
	virtual bool isCloseOnly() const{return false;}
	virtual bool isResizeToClose() const{return false;}
//	virtual bool isProAts() const{return true;}
	virtual bool isImbalanceOnly() const{return false;}
/////////
	virtual bool isMarketOrder() const{return false;}
	virtual bool isDynamicPrice() const{return !isMarketOrder();}
//	virtual bool isPriceDynamic() const{return true;}//Set in the UI that the price should change in the OrderBox from the initial value.

	virtual bool isDynamicSize() const
	{
		switch(GetSide())
		{
			case OCS_CLOSE:
			case OCS_ADD:
			return true;

			default:
			return false;
		}
	}

	virtual const char* GetNotePtr() const{return NULL;}
	virtual COLORREF GetColor() const{return 0;}
	virtual unsigned char GetAlertType() const{return AT_SECURITY_PRINT;}
	virtual unsigned int GetDaysToKeep() const{return 0;}
	virtual bool isHasExpiration() const{return false;}
	virtual bool isPopup() const{return true;}
	virtual bool isSizeAbsolute() const{return false;}

	virtual bool HasNote() const{return false;}
	virtual bool HasSpray() const{return false;}
	virtual bool HasPrice() const{return true;}
	virtual unsigned char HasSize() const{return 1;}
	virtual bool HasVisibleSize() const{return !isBorrow();}
	virtual bool HasRouting() const{return !isBorrow();}
	virtual bool HasPeg() const{return !isBorrow();}
	virtual bool HasPegOffset() const{return !isBorrow();}
	virtual bool HasDiscOffset() const{return !isBorrow();}
	virtual bool HasTif() const{return true;}

	virtual char GetSideAsChar(int positionSize, bool reverse) const{return '\0';}
	virtual bool isPriceBasedOnBid(int positionSize, bool hasPrints) const{return true;}
	virtual bool isPriceBasedOnAsk(int positionSize, bool hasPrints) const{return false;}
	virtual bool isPriceBasedOnNysBid(int positionSize, bool hasPrints) const{return false;}
	virtual bool isPriceBasedOnNysAsk(int positionSize, bool hasPrints) const{return false;}
	virtual bool isPriceBasedOnEcnBid(int positionSize, bool hasPrints) const{return false;}
	virtual bool isPriceBasedOnEcnAsk(int positionSize, bool hasPrints) const{return false;}
	virtual bool isPriceBasedOnPosition(bool hasPrints) const{return false;}
	virtual bool isPriceBasedOnPrint(bool hasPrints) const{return false;}
	virtual bool isPriceBasedOnHigh(bool hasPrints) const{return false;}
	virtual bool isPriceBasedOnLow(bool hasPrints) const{return false;}
	virtual bool isPriceBasedOnImbExNear(bool hasPrints) const{return false;}

	virtual bool GetPriceByOffset(const SignedPrice& offset, unsigned char priceBase, bool priceOffsetPercent, Price& price, const Security* security, TakionTool* takionTool, int positionSize, const Price& positionPrice, const Price& positionCost, Price& from, Price& level1Ask, Price& insideBid, Price& insideAsk, Price& lastPrint, char side) const{return false;}

	virtual bool GetPrice(Price& price, const Security* security, TakionTool* takionTool, int positionSize, const Price& positionPrice, const Price& positionCost, Price& level1Bid, Price& level1Ask, Price& insideBid, Price& insideAsk, Price& lastPrint, char side) const
	{
		return GetPriceByOffset(GetPriceOffset(), GetPriceBase(), isPriceOffsetPercent(), price, security, takionTool, positionSize, positionPrice, positionCost, level1Bid, level1Ask, insideBid, insideAsk, lastPrint, side);
	}

	virtual bool GetPriceBySide(Price& price, bool hasPrints, int positionSize, const Price& level1Quote, const Price& level2Quote, const Price& level3Quote) const;
	virtual bool GetPriceByPrint(Price& price, bool hasPrints, int positionSize, const Price& nbboPrint) const;
	virtual bool GetPriceByHigh(Price& price, bool hasPrints, int positionSize, const Price& high) const;
	virtual bool GetPriceByLow(Price& price, bool hasPrints, int positionSize, const Price& low) const;

	virtual unsigned int GetSprayCount() const{return 0;}
	virtual bool isSprayPriceOffsetPercent() const{return false;}
	virtual const SignedPrice& GetSprayPriceOffset() const{return SignedPrice::signedPriceZero;}
	virtual int GetSpraySizeOffset() const{return 0;}

	virtual unsigned char GetPegType() const{return PEG_NONE;}
	virtual const SignedPrice& GetPegOffset() const{return SignedPrice::signedPriceZero;}
	virtual const SignedPrice& GetDiscretionaryOffset() const{return SignedPrice::signedPriceZero;}
	virtual const SignedPrice& GetStopOffset() const{return SignedPrice::signedPriceZero;}
//	virtual bool isStopOrder() const{return false;}
	virtual unsigned char GetStopOrderType() const{return 0;}
	virtual unsigned char GetStopOrderBase() const{return 0;}
	virtual unsigned char GetStopOrderTypeBase() const{return 0;}
	virtual bool isStopOffsetPercent() const{return false;}
////
	virtual unsigned int GetRoutingName() const{return 0;}
	virtual unsigned short GetRoutingId() const{return 0;}
	virtual unsigned short GetRoutingSubType() const{return 0;}
	virtual unsigned int GetMnemonic() const{return 0;}
///
	virtual bool isPostRemainder() const{return false;}
	virtual bool isPostRemainderOnIsoViolation() const{return false;}
	virtual bool isReiterate() const{return false;}
	virtual unsigned __int64 GetPostDestinationId() const{return 0;}
	virtual unsigned int GetPostDestinationName() const{return 0;}
	virtual unsigned short GetPostRoutingId() const{return 0;}
	virtual unsigned short GetPostRoutingSubType() const{return 0;}
	virtual unsigned int GetPostRoutingName() const{return 0;}
	virtual unsigned int GetPostMnemonic() const{return 0;}
	virtual unsigned char GetPostTifType() const{return TIF_DAY;}
	virtual unsigned int GetPostTif() const{return 0;}
///
	virtual bool isOrderModule() const{return false;}
	virtual bool isOrderModulePrice() const{return false;}
	virtual unsigned char GetSide() const{return OCS_BUY;}
	virtual unsigned char GetPositionType() const{return OCP_CURRENT;}
	virtual unsigned char GetInventoryType() const{return OCINV_DEFAULT;}
	virtual unsigned int GetTif() const{return 0;}

	virtual unsigned char GetPriceBase() const{return PB_SAME_SIDE;}
	virtual const SignedPrice& GetPriceOffset() const{return SignedPrice::signedPriceZero;}
	virtual bool isPriceOffsetPercent() const{return false;}
	virtual const SignedPrice& GetPriceOffsetIfNoPrint() const{return GetPriceOffset();}

	virtual bool isPriceAdjustableAbsolute() const{return true;}

	virtual unsigned char GetPriceBaseIfNoPrint() const{return GetPriceBase();}
	virtual bool isUseNoPrintPrice() const{return false;}
/*
*/
	virtual bool hasSizeAction() const{return false;}
	virtual unsigned char GetSizeAction() const{return 0;}

	virtual unsigned char GetDisplaySizeMode() const{return 0;}//0 - size fraction, 1 = round lot
	virtual unsigned int GetDisplaySize() const{return 0;}

	virtual unsigned int GetDisplaySizeFraction() const{return 0;}
	virtual unsigned int GetReserveQuantity() const{return 0;}

	virtual unsigned int GetExchangeFilter() const{return (1 << MCF_Count) - 1;}
	virtual void SetExchangeFilter(const unsigned int& filter){}
	void AddExchangeFilter(const unsigned int filter){SetExchangeFilter(GetExchangeFilter() | filter);}
	void RemoveExchangeFilter(const unsigned int filter){SetExchangeFilter(GetExchangeFilter() & ~filter);}

	bool isSecurityInExchangeFilter(const Security* security) const
	{
		const unsigned int filter = GetExchangeFilter();
		return filter == (1 << MCF_Count) - 1 || (filter & security->GetMarketCategoryFilter()) != 0;
	}

	virtual unsigned char GetCloseAuctionFilter() const{return 3;}
	virtual bool isSecurityInCloseAuctionFilter(const Security* security, bool buy) const
	{
		const unsigned char filter = GetCloseAuctionFilter();
		return filter == 3 || (filter & security->GetCloseAuctionFilter(buy)) != 0;
	}

	virtual bool isResetPrintSize() const{return false;}
	virtual unsigned __int64 GetPrintSize() const{return 0;}
	virtual bool isProactive() const{return false;}
	virtual unsigned char GetTifType() const{return TIF_IOC;}

#ifndef TAKION_NO_OPTIONS
	virtual unsigned int GetOptionStrikeCountUp() const{return 0;}
	virtual unsigned int GetOptionStrikeCountDown() const{return 0;}
	virtual unsigned int GetOptionExpirationCountUp() const{return 0;}
	virtual unsigned int GetOptionExpirationCountDown() const{return 0;}
	bool hasOptionCount() const{return GetOptionStrikeCountUp() || GetOptionStrikeCountDown() || GetOptionExpirationCountUp() || GetOptionExpirationCountDown();}
	virtual bool CanHaveOptionCount() const{return false;}
#endif
	virtual Command* GetCommandToExecute() const{return NULL;}
	virtual const char* GetCommandToExecuteName() const{return NULL;}
	virtual bool isTriggerWhenNoLiveOrders() const{return false;}
	virtual bool isTriggerOnConditionPreMet() const{return false;}
	virtual bool isMustSubscribe() const{return false;}
	virtual bool isTrailing() const{return false;}

	virtual bool isDisplayNote() const{return false;}
//	virtual COLORREF GetNoteColor() const{return 0;}//Use GetColor
//	virtual const char* GetNote() const{return NULL;}//Use GetNotePtr

	static void AdjustSignedPrice(const SignedPrice& offset, bool priceOffsetPercent, SignedPrice& price, char side);//, bool hasPrints) const;
	static bool AdjustPrice(const SignedPrice& offset, bool priceOffsetPercent, Price& price, char side);//, bool hasPrints) const;

	void GetPriceFromPriceBase(Price& price, char side) const;//, bool hasPrints) const;
	void GetSignedPriceFromPriceBase(SignedPrice& price, char side) const;//, bool hasPrints) const;

	virtual bool GetSizeByOrderSize(const OrderSize* orderSize, unsigned int& size, unsigned int& visibleSize, const Security* security, const Position* position, TakionTool* takionTool, unsigned int tierSize, const Price& price, int count, bool closeout, bool overrideUniversal) const{return false;}
	virtual bool GetSize(unsigned int& size, unsigned int& visibleSize, const Security* security, const Position* position, TakionTool* takionTool, unsigned int tierSize, const Price& price, int count, bool closeout, bool overrideUniversal) const{return false;}
	virtual unsigned int GetSizeProper(TakionTool* takionTool) const{return 0;}
	virtual unsigned int GetVisibleSizeProper(const Security* security, unsigned int totalQuantity) const{return totalQuantity;}
	virtual bool isTotallyVisible() const{return false;}
	virtual bool GetSizeBp(Money& money, bool* roundLot = NULL) const{return false;}

	virtual bool CanSizeBeNegative() const{return false;}
	virtual bool GetSignedSize(int& size, const Security* security) const{return false;}

	static unsigned int GetUIntCount(int count
#ifndef TAKION_NO_OPTIONS
		, bool optionView = false
#endif
	);

	Command* const& GetRepeatKeyCommand() const{return m_repeatKeyCommand;}
	const char* GetRepeatKeyCommandName() const{return m_repeatKeyCommand ? m_repeatKeyCommand->GetName() : NULL;}
	void SetRepeatKeyCommand(Command* const& command){m_repeatKeyCommand = command;}
	void SetRepeatKeyCommandByName(const std::string& commandName);
	bool CommandRemoved(const Command* const& command)
	{
		if(m_repeatKeyCommand == command)
		{
			m_repeatKeyCommand = NULL;
			return true;
		}
		return false;
	}
	virtual bool isShareSize() const{return true;}
	virtual bool isBpSize() const{return false;}
protected:
	CustomDialogOrderCommand(const char* name,
		CommandCategory cc,
		Command* repeatKeyCommand,
		unsigned int timeToActivate,
		unsigned int timeToExpire,
		bool adjustable,
		bool priceDynamic,
		bool closeOrderBox);
	CustomDialogOrderCommand(const CustomDialogOrderCommand& other);
//	OrderSizeAggregate* m_orderSize;
	Command* m_repeatKeyCommand;
	unsigned int m_timeToActivate;
	unsigned int m_timeToExpire;
	bool m_adjustable;
	bool m_priceDynamic;
	bool m_closeOrderBox;
};

class TGUI_API CustomOrderSizeCommand : public CustomDialogOrderCommand
{
public:
	virtual ~CustomOrderSizeCommand();

	const OrderSize* const& GetOrderSize() const{return m_orderSize;}
	OrderSize* const& GetOrderSize(){return m_orderSize;}
	void SetOrderSize(const OrderSize& orderSize);

	virtual bool isShareSize() const;
	virtual bool isBpSize() const;

	virtual unsigned int GetOverrideMask() const{return m_overrideMask;}
	void SetOverrideMask(const unsigned int& mask){m_overrideMask = mask;}

	virtual bool operator==(const CustomCommand& other) const;
	virtual void Copy(const CustomCommand& other);
	bool AdjustSizeByOrderSize(const OrderSize* orderSize, const unsigned char sizeAction, unsigned int& size, unsigned int& visibleSize, const Security* security, const Position* position, TakionTool* takionTool, unsigned int tierSize, const Price& price, int count, bool closeout, bool overrideUniversal) const;
	virtual bool GetSizeByOrderSize(const OrderSize* orderSize, unsigned int& size, unsigned int& visibleSize, const Security* security, const Position* position, TakionTool* takionTool, unsigned int tierSize, const Price& price, int count, bool closeout, bool overrideUniversal) const;
	virtual bool GetSize(unsigned int& size, unsigned int& visibleSize, const Security* security, const Position* position, TakionTool* takionTool, unsigned int tierSize, const Price& price, int count, bool closeout, bool overrideUniversal) const override
	{
		return GetSizeByOrderSize(m_orderSize, size, visibleSize, security, position, takionTool, tierSize, price, count, closeout, overrideUniversal);
	}
	virtual unsigned int GetSizeProper(TakionTool* takionTool) const override;
	virtual bool GetSizeBp(Money& money, bool* roundLot = NULL) const override;

	bool isOrderSizeEmpty() const;
	virtual bool isEmpty() const;
	CustomOrderSizeCommand& operator=(const CustomOrderSizeCommand& other);
protected:
	CustomOrderSizeCommand(const char* name, CommandCategory cc,
		const OrderSize& size,
		unsigned int overrideMask,
		Command* repeatKeyCommand,
		unsigned int timeToActivate,
		bool adjustable,
		bool priceDynamic,
		bool closeOrderBox);
	CustomOrderSizeCommand(const CustomOrderSizeCommand& other);
	OrderSize* m_orderSize;
//	Command* m_repeatKeyCommand;
//	bool m_adjustable;
	unsigned int m_overrideMask;
};

class TGUI_API AggregateCommandItem
{
public:
	AggregateCommandItem(Command* const& command, bool adjustableAllowed):m_command(command), m_adjustableAllowed(adjustableAllowed){}
	const char* GetName() const{return m_command->GetName();}
	const std::string& GetStringName() const{return m_command->GetStringName();}
	Command* const& GetCommand(){return m_command;}
	const Command* const& GetCommand() const{return m_command;}
	bool SetCommand(Command* const& command)
	{
		if(command != m_command)
		{
			m_command = command;
			return true;
		}
		return false;
	}
	const bool& isAdjustableAllowed() const{return m_adjustableAllowed;}
	bool SetAdjustableAllowed(const bool& adjustableAllowed)
	{
		if(adjustableAllowed != m_adjustableAllowed)
		{
			m_adjustableAllowed = adjustableAllowed;
			return true;
		}
		return false;
	}
	unsigned char SetCommandAndAdjustableAllowed(Command* const& command, const bool& adjustableAllowed)
	{
		unsigned char ret = 0;
		if(SetCommand(command))
		{
			ret |= 1;
		}
		if(SetAdjustableAllowed(adjustableAllowed))
		{
			ret |= 2;
		}
		return ret;
	}
	bool operator==(const AggregateCommandItem& other) const
	{
		return !strcmp(m_command->GetName(), other.m_command->GetName()) && m_adjustableAllowed == other.m_adjustableAllowed;
	}
	bool operator!=(const AggregateCommandItem& other) const
	{
		return !operator==(other);
	}
protected:
	Command* m_command;
	bool m_adjustableAllowed;
};

class TGUI_API CommandAggregate : public CustomOrderSizeCommand//CustomDialogOrderCommand//CustomCommand
{
public:
	CommandAggregate(const char* name,
		const OrderSize& size,
		const SignedPrice& priceOffset,
		bool priceOffsetPercent,
		unsigned char sizeAction,
		unsigned char inventoryType,
		Command* repeatKeyCommand,
		unsigned int timeToActivate,
		bool adjustable,
		bool priceAdjustableAbsolute,
		bool priceDynamic,
		bool closeOrderBox);

	virtual CustomCommand* Clone() const;
	virtual bool operator==(const CustomCommand& other) const;
	virtual bool isAggregateCommand() const override{return true;}
	virtual unsigned char GetCommandType() const override{return CCT_AGGREGATE;}
	virtual void Copy(const CustomCommand& other) override;
	virtual void Invoke(TakionTool* activeTool,
		TakionTool* activeCommandTool,
		bool repeat,
		bool aggregate = false,
		const CommandInfo* commandInfo = NULL) override;
	virtual void InvokeForSecurity(TakionTool* activeTool,
		Account* account,
		const Security* security,
		const Position* position,
		unsigned int sendId,
		unsigned int tierSize,
		int count,
		bool closeout,
		bool closeOnly,
		bool passiveOnly,
		bool blockAggressiveOrders,
		unsigned char inventoryMode,
		const CommandInfo* commandInfo) override;
//	typedef std::vector<Command*> CommandVector;
	typedef std::vector<AggregateCommandItem> CommandVector;
//	void AddCommand(Command* command){m_commandVector.push_back(command);}
	void AddCommandItem(Command* command, bool adjustableAllowed){m_commandVector.push_back(AggregateCommandItem(command, adjustableAllowed));}
//	void InsertCommand(Command* command, unsigned int at);
	void InsertCommandItem(Command* command, bool adjustableAllowed, unsigned int at);
	unsigned int RemoveCommandItem(const char* name, unsigned int count = 0xFFFFFFFF, unsigned int start = 0);
	void ClearCommandItems(){m_commandVector.clear();}
	void SetCommandItems(const CommandVector& commands){m_commandVector = commands;}
	const CommandVector& GetCommandVector() const{return m_commandVector;}
	CommandVector& GetCommandVector(){return m_commandVector;}
	virtual void LinkCommand();
//	virtual Command* GetOneExecutableCommand(const TakionTool* activeTool, const TakionTool* activeCommandTool) const;
	virtual bool isCommandExecutable(const TakionTool* activeTool, const TakionTool* activeCommandTool) const;

//	virtual bool isAdjustable() const{return m_adjustable;}
//	virtual void SetAdjustable(bool adjustable){m_adjustable = adjustable;}

//	virtual bool HasVisibleSize() const{return !isBorrow();}
	virtual bool HasRouting() const{return false;}
	virtual bool HasPeg() const{return false;}
	virtual bool HasPegOffset() const{return false;}
	virtual bool HasDiscOffset() const{return false;}
	virtual bool HasTif() const{return false;}
//	virtual bool isPriceBasedOnBid(int positionSize, bool hasPrints) const{return true;}
	static const char* const aggregateVenue;
	virtual const char* GetDestinationName() const{return aggregateVenue;}

	virtual const SignedPrice& GetPriceOffset() const override{return m_priceOffset;}
	virtual bool isPriceOffsetPercent() const override{return m_priceOffsetPercent;}

	void SetPriceOffset(const SignedPrice& priceOffset){m_priceOffset = priceOffset;}
	void SetPriceOffsetPercent(const bool& percent){m_priceOffsetPercent = percent;}

	virtual bool isPriceAdjustableAbsolute() const override{return m_priceAdjustableAbsolute;}
	void SetPriceAdjustableAbsolute(const bool& absolute){m_priceAdjustableAbsolute = absolute;}

	virtual bool hasSizeAction() const override{return true;}
	virtual unsigned char GetSizeAction() const override{return m_sizeAction;}
	void SetSizeAction(const unsigned char& sizeAction){m_sizeAction = sizeAction;}
	virtual bool isEmpty() const;

	virtual unsigned char GetInventoryType() const override{return m_inventoryType;}
	void SetInventoryType(const unsigned char& inventoryType){m_inventoryType = inventoryType;}

	const CustomDialogOrderCommand* GetFirstDialogOrderCommand() const;
//	CustomDialogOrderCommand* GetFirstDialogOrderCommand();

//Get values by the first trading command
	virtual char GetSideAsChar(int positionSize, bool reverse) const{const CustomDialogOrderCommand* command = GetFirstDialogOrderCommand(); return command ? command->GetSideAsChar(positionSize, reverse) : '\0';}
	virtual bool isMarketOrder() const override{const CustomDialogOrderCommand* command = GetFirstDialogOrderCommand(); return command && command->isMarketOrder();}
	virtual bool isDynamicSize() const override{const CustomDialogOrderCommand* command = GetFirstDialogOrderCommand(); return command && command->isDynamicSize();}
	virtual bool isPriceBasedOnBid(int positionSize, bool hasPrints) const override{const CustomDialogOrderCommand* command = GetFirstDialogOrderCommand(); return !command || command->isPriceBasedOnBid(positionSize, hasPrints);}
	virtual bool isPriceBasedOnAsk(int positionSize, bool hasPrints) const override{const CustomDialogOrderCommand* command = GetFirstDialogOrderCommand(); return command && command->isPriceBasedOnAsk(positionSize, hasPrints);}
	virtual bool isPriceBasedOnNysBid(int positionSize, bool hasPrints) const override{const CustomDialogOrderCommand* command = GetFirstDialogOrderCommand(); return command && command->isPriceBasedOnNysBid(positionSize, hasPrints);}
	virtual bool isPriceBasedOnNysAsk(int positionSize, bool hasPrints) const override{const CustomDialogOrderCommand* command = GetFirstDialogOrderCommand(); return command && command->isPriceBasedOnNysAsk(positionSize, hasPrints);}
	virtual bool isPriceBasedOnEcnBid(int positionSize, bool hasPrints) const override{const CustomDialogOrderCommand* command = GetFirstDialogOrderCommand(); return command && command->isPriceBasedOnEcnBid(positionSize, hasPrints);}
	virtual bool isPriceBasedOnEcnAsk(int positionSize, bool hasPrints) const override{const CustomDialogOrderCommand* command = GetFirstDialogOrderCommand(); return command && command->isPriceBasedOnEcnAsk(positionSize, hasPrints);}
	virtual bool isPriceBasedOnPosition(bool hasPrints) const override{const CustomDialogOrderCommand* command = GetFirstDialogOrderCommand(); return command && command->isPriceBasedOnPosition(hasPrints);}
	virtual bool isPriceBasedOnPrint(bool hasPrints) const override{const CustomDialogOrderCommand* command = GetFirstDialogOrderCommand(); return command && command->isPriceBasedOnPrint(hasPrints);}
	virtual bool isPriceBasedOnHigh(bool hasPrints) const override{const CustomDialogOrderCommand* command = GetFirstDialogOrderCommand(); return command && command->isPriceBasedOnHigh(hasPrints);}
	virtual bool isPriceBasedOnLow(bool hasPrints) const override{const CustomDialogOrderCommand* command = GetFirstDialogOrderCommand(); return command && command->isPriceBasedOnLow(hasPrints);}
	virtual bool isPriceBasedOnImbExNear(bool hasPrints) const override{const CustomDialogOrderCommand* command = GetFirstDialogOrderCommand(); return !command || command->isPriceBasedOnImbExNear(hasPrints);}
	virtual bool GetPriceByOffset(const SignedPrice& offset, unsigned char priceBase, bool priceOffsetPercent, Price& price, const Security* security, TakionTool* takionTool, int positionSize, const Price& positionPrice, const Price& positionCost, Price& from, Price& level1Ask, Price& insideBid, Price& insideAsk, Price& lastPrint, char side) const override
	{
		const CustomDialogOrderCommand* command = GetFirstDialogOrderCommand();
		return command && command->GetPriceByOffset(offset, priceBase, priceOffsetPercent, price, security, takionTool, positionSize, positionPrice, positionCost, from, level1Ask, insideBid, insideAsk, lastPrint, side);
	}

	virtual bool GetPrice(Price& price, const Security* security, TakionTool* takionTool, int positionSize, const Price& positionPrice, const Price& positionCost, Price& level1Bid, Price& level1Ask, Price& insideBid, Price& insideAsk, Price& lastPrint, char side) const override;

	virtual bool GetPriceBySide(Price& price, bool hasPrints, int positionSize, const Price& level1Quote, const Price& level2Quote, const Price& level3Quote) const override
	{
		const CustomDialogOrderCommand* command = GetFirstDialogOrderCommand();
		return command && command->GetPriceBySide(price, hasPrints, positionSize, level1Quote, level2Quote, level3Quote);
	}
	virtual bool GetPriceByPrint(Price& price, bool hasPrints, int positionSize, const Price& nbboPrint) const override
	{
		const CustomDialogOrderCommand* command = GetFirstDialogOrderCommand();
		return command && command->GetPriceByPrint(price, hasPrints, positionSize, nbboPrint);
	}
	virtual bool GetPriceByHigh(Price& price, bool hasPrints, int positionSize, const Price& high) const override
	{
		const CustomDialogOrderCommand* command = GetFirstDialogOrderCommand();
		return command && command->GetPriceByHigh(price, hasPrints, positionSize, high);
	}
	virtual bool GetPriceByLow(Price& price, bool hasPrints, int positionSize, const Price& low) const override
	{
		const CustomDialogOrderCommand* command = GetFirstDialogOrderCommand();
		return command && command->GetPriceByLow(price, hasPrints, positionSize, low);
	}
///
	virtual bool GetSizeByOrderSize(const OrderSize* orderSize, unsigned int& quantity, unsigned int& displayQuantity, const Security* security, const Position* position, TakionTool* mm, unsigned int tierSize, const Price& price, int count, bool closeout, bool overrideUniversal) const override
	{
		const CustomDialogOrderCommand* command = GetFirstDialogOrderCommand();
		return command && command->GetSizeByOrderSize(orderSize, quantity, displayQuantity, security, position, mm, tierSize, price, count, closeout, overrideUniversal);
	}
	virtual unsigned int GetVisibleSizeProper(const Security* security, unsigned int totalQuantity) const override
	{
		const CustomDialogOrderCommand* command = GetFirstDialogOrderCommand();
		return command && command->GetVisibleSizeProper(security, totalQuantity);
	}
	virtual bool isTotallyVisible() const override
	{
		const CustomDialogOrderCommand* command = GetFirstDialogOrderCommand();
		return command && command->isTotallyVisible();
	}

	virtual bool MustBeSubscribed() const override;
protected:
	CommandVector m_commandVector;
//	bool m_adjustable;
	SignedPrice m_priceOffset;
	bool m_priceOffsetPercent;
	bool m_priceAdjustableAbsolute;
	unsigned char m_sizeAction;
	unsigned char m_inventoryType;
private:
	mutable bool m_invoked;
};

class TGUI_API TakionToolCommand : public CustomCommand
{
public:
//	virtual bool operator==(const CustomCommand& other) const;
//	virtual void Copy(const CustomCommand& other);
	void SetTakionTool(TakionTool* const& tool){m_takionTool = tool;}
	virtual TakionTool* GetTakionTool(){return m_takionTool;}
	virtual const TakionTool* GetTakionTool() const{return m_takionTool;}
protected:
	TakionToolCommand(const char* name):CustomCommand(name, CC_NAVIGATE), m_takionTool(NULL){}
	TakionToolCommand(const TakionToolCommand& other):CustomCommand(other),m_takionTool(NULL){}
	TakionTool* m_takionTool;
};

class TGUI_API SymbolToActiveCommandWindowCommand : public TakionToolCommand
{
public:
	SymbolToActiveCommandWindowCommand(const char* const& name):TakionToolCommand(name){}
	SymbolToActiveCommandWindowCommand(const SymbolToActiveCommandWindowCommand& other):TakionToolCommand(other){}
	virtual CustomCommand* Clone() const;
//	virtual bool operator==(const CustomCommand& other) const;
//	virtual void Copy(const CustomCommand& other);
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
	virtual unsigned char GetCommandType() const override{return CCT_SYMBOL_TO_ACTIVE_COMMAND_WINDOW;}
	virtual bool isSymbolToActiveCommandWindowCommand() const override{return true;}
};

class TGUI_API ActivateWindowCommand : public TakionToolCommand
{
public:
	ActivateWindowCommand(const char* const& name):TakionToolCommand(name){}
	ActivateWindowCommand(const ActivateWindowCommand& other):TakionToolCommand(other){}
	virtual CustomCommand* Clone() const override;
//	virtual bool operator==(const CustomCommand& other) const;
//	virtual void Copy(const CustomCommand& other);
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
	virtual unsigned char GetCommandType() const override{return CCT_WINDOW_ACTIVATE;}
	virtual bool isActivateWindowCommand() const override{return true;}
};

class TGUI_API ExtensionKeystrokeCommand : public CustomCommand
{
public:
	ExtensionKeystrokeCommand(const char* const& name, const unsigned int& userExtensionCode):CustomCommand(name, CC_NAVIGATE), m_userExtensionCode(userExtensionCode){}
	ExtensionKeystrokeCommand(const ExtensionKeystrokeCommand& other):CustomCommand(other), m_userExtensionCode(other.m_userExtensionCode){}
	virtual CustomCommand* Clone() const override;
	virtual bool operator==(const CustomCommand& other) const;
	virtual void Copy(const CustomCommand& other) override;
	virtual unsigned int GetExtensionCode() const override{return 1;}
	virtual unsigned int GetUserExtensionCode() const override{return m_userExtensionCode;}
	void SetUserExtensionCode(unsigned int userExtensionCode){m_userExtensionCode = userExtensionCode;}
//	virtual bool isExtensionKeystrokeCommand() const{return true;}
	virtual unsigned char GetCommandType() const override{return CCT_EXTENSION_KEYSTROKE;}
protected:
	unsigned int m_userExtensionCode;
};

class TGUI_API CommandOcoNext : public Command
{
public:
	CommandOcoNext():Command("AccountOcoNext", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandOcoNone : public Command
{
public:
	CommandOcoNone():Command("AccountOcoNone", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandSelectDefaultAccountAsCurrent : public Command
{
public:
	CommandSelectDefaultAccountAsCurrent():Command("SelectDefaultAccount", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandToggleLockTrading : public Command
{
public:
	CommandToggleLockTrading():Command("ToggleLockTrading", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandToggleDefaultOnlyTrading : public Command
{
public:
	CommandToggleDefaultOnlyTrading():Command("ToggleDefaultOnlyTrading", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandToggleLockWindows : public Command
{
public:
	CommandToggleLockWindows() :Command("ToggleLockWindows", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandExitDialog : public Command
{
public:
	CommandExitDialog():Command("ExitDialog", CC_NAVIGATE){}
	virtual bool isExitDialogCommand() const override{return true;}
};

class TGUI_API CommandDrawType : public Command
{
protected:
	CommandDrawType(const char* const& name, const unsigned char& drawType):Command(name, CC_NAVIGATE), m_drawType(drawType){}
	unsigned char m_drawType;
};

class TGUI_API CommandSetToDrawLine : public CommandDrawType
{
public:
	CommandSetToDrawLine(const char* const& name, const unsigned char& drawType):CommandDrawType(name, drawType){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandClearDrawType : public CommandDrawType
{
public:
	CommandClearDrawType(const char* const& name, const unsigned char& drawType, const unsigned char& historical):CommandDrawType(name, drawType),m_historical(historical){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
protected:
	unsigned char m_historical;//1 historical, 2 today, 3 both
};

class TGUI_API CommandActiveStockPhantomBuy : public Command
{
public:
	CommandActiveStockPhantomBuy():Command("ActiveStockPhantomBuy", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandActiveStockPhantomSell : public Command
{
public:
	CommandActiveStockPhantomSell():Command("ActiveStockPhantomSell", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandActiveStockPhantomFlip : public Command
{
public:
	CommandActiveStockPhantomFlip():Command("ActiveStockPhantomFlip", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandActiveStockPhantomFlat : public Command
{
public:
	CommandActiveStockPhantomFlat():Command("ActiveStockPhantomFlat", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandPhantomFlatAll : public Command
{
public:
	CommandPhantomFlatAll():Command("PhantomFlatAll", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandRemoveSelectedStocks : public Command
{
public:
	CommandRemoveSelectedStocks():Command("RemoveSelectedStocks", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandRemoveActiveStock : public Command
{
public:
	CommandRemoveActiveStock():Command("RemoveActiveStock", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandActiveStockInclude : public Command
{
public:
	CommandActiveStockInclude():Command("ActiveStockInclude", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandActiveStockExclude : public Command
{
public:
	CommandActiveStockExclude():Command("ActiveStockExclude", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandActiveStockUnInclude : public Command
{
public:
	CommandActiveStockUnInclude():Command("ActiveStockUnInclude", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandActiveStockUnExclude : public Command
{
public:
	CommandActiveStockUnExclude():Command("ActiveStockUnExclude", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandStockInclude : public Command
{
public:
	CommandStockInclude():Command("StockInclude", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandStockExclude : public Command
{
public:
	CommandStockExclude():Command("StockExclude", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandStockUnInclude : public Command
{
public:
	CommandStockUnInclude():Command("StockUnInclude", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandStockUnExclude : public Command
{
public:
	CommandStockUnExclude():Command("StockUnExclude", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandActiveStockAddToBasket : public Command
{
public:
	CommandActiveStockAddToBasket():Command("+Basket", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandActiveStockRemoveFromBasket : public Command
{
public:
	CommandActiveStockRemoveFromBasket():Command("-Basket", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandCopySelectedStocksFromActiveTool : public Command
{
public:
	CommandCopySelectedStocksFromActiveTool():Command("CopySelectedStocks", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandCopyAllStocksFromActiveTool : public Command
{
public:
	CommandCopyAllStocksFromActiveTool():Command("CopyAllStocks", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandCopySelectedRowsToClipboard : public Command
{
public:
	CommandCopySelectedRowsToClipboard():Command("CopySelectedRows", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandCopyAllRowsToClipboard : public Command
{
public:
	CommandCopyAllRowsToClipboard():Command("CopyAllRows", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandSelectPositionRowsInActiveTool : public Command
{
public:
	CommandSelectPositionRowsInActiveTool(const char* name, unsigned int filter):Command(name, CC_NAVIGATE), m_filter(filter){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
protected:
	unsigned int m_filter;
};

class TGUI_API CommandCreateNewBasket : public Command
{
public:
	CommandCreateNewBasket():Command("CreateNewBasket", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandPasteBasketInActiveTool : public Command
{
public:
	CommandPasteBasketInActiveTool():Command("PasteBasketInActiveTool", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandPasteAddBasketInActiveTool : public Command
{
public:
	CommandPasteAddBasketInActiveTool():Command("PasteAddBasketInActiveTool", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandPasteBasketInActiveCommandTool : public Command
{
public:
	CommandPasteBasketInActiveCommandTool():Command("PasteBasketInActiveCommandTool", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandPasteAddBasketInActiveCommandTool : public Command
{
public:
	CommandPasteAddBasketInActiveCommandTool():Command("PasteAddBasketInActiveCommandTool", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandClearBasket : public Command
{
public:
	CommandClearBasket():Command("ClearActiveBasket", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandCloseActiveWindow : public Command
{
public:
	CommandCloseActiveWindow():Command("CloseActiveWindow", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandSetExternalManualLink : public Command
{
public:
	CommandSetExternalManualLink():Command("SetExternalManualLink", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};
/*
class TGUI_API CommandSetExternalManualLinkFocus : public Command
{
public:
	CommandSetExternalManualLinkFocus():Command("SetExternalManualLinkFocus", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};
*/
class TGUI_API CommandClearExternalManualLinks: public Command
{
public:
	CommandClearExternalManualLinks():Command("ClearExternalManualLinks", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandClearInvalidExternalManualLinks: public Command
{
public:
	CommandClearInvalidExternalManualLinks():Command("ClearInvalidExternalManualLinks", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API SettingCommand : public Command
{
public:
	SettingCommand(const char* name):Command(name, CC_SETTING){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandToggleLink : public Command
{
public:
	CommandToggleLink():Command("ToggleLink", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
	virtual bool isToggleCommand() const override{return true;}
protected:
	bool m_active;
};

class TGUI_API CommandToggleLinkActive : public Command
{
public:
	CommandToggleLinkActive():Command("ToggleLinkActive", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
	virtual bool isToggleCommand() const override{return true;}
};

class TGUI_API CommandWorkspace : public Command
{
public:
	CommandWorkspace(unsigned int workspace);
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
	virtual bool isApplicableToCommandBox() const override;
protected:
	unsigned int m_workspace;
};

class TGUI_API CommandWorkspaceLast : public Command
{
public:
	CommandWorkspaceLast():Command("WorkspaceLast", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
	virtual bool isApplicableToCommandBox() const override;
};

class TGUI_API CommandToggleGlobalInventoryView : public Command
{
public:
	CommandToggleGlobalInventoryView():Command("ToggleGlobalInventory", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
	virtual bool isToggleCommand() const override{return true;}
//	virtual bool isApplicableToCommandBox() const;
};

class TGUI_API CommandToggleLayer : public Command
{
public:
	CommandToggleLayer(unsigned int layer);
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
	virtual bool isToggleCommand() const override{return true;}
	virtual bool isApplicableToCommandBox() const;
protected:
	unsigned int m_layer;
};

class TGUI_API CommandNavigate : public Command
{
public:
	const bool& isReverse() const{return m_reverse;}
protected:
	CommandNavigate(const char* const& name, const char* const& nameReverse, const bool& reverse):
		Command(reverse ? nameReverse : name, CC_NAVIGATE),
		m_reverse(reverse)
	{}
	bool m_reverse;
};

class TGUI_API CommandLoadSelectedExtension : public CommandNavigate
{
public:
	CommandLoadSelectedExtension(const bool& reverse):CommandNavigate("LoadSelectedExtension", "UnloadSelectedExtension", reverse){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
	virtual bool isExecutableInExtension() const override{return true;}
};

class TGUI_API CommandToggleLoadSelectedExtension : public Command
{
public:
	CommandToggleLoadSelectedExtension():Command("ToggleLoadSelectedExtension", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
	virtual bool isExecutableInExtension() const override{return true;}
};

class TGUI_API CommandToggleInventoryView : public CommandNavigate
{
public:
	CommandToggleInventoryView(const bool& reverse):CommandNavigate("ToggleInventoryActiveWindow", "ToggleInventoryActiveWindowReverse", reverse){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
//	virtual bool isApplicableToCommandBox() const;
};

class TGUI_API CommandNavigateNonCommandBox : public CommandNavigate
{
public:
	virtual bool isApplicableToCommandBox() const override{return false;}
protected:
	CommandNavigateNonCommandBox(const char* const& name, const char* const& nameReverse, const bool& reverse):CommandNavigate(name, nameReverse, reverse){}
};

class CommandScrollMmBoxQuotes : public CommandNavigate//NonCommandBox
{
public:
	CommandScrollMmBoxQuotes(const bool& reverse):CommandNavigate("MmBoxPageDown", "MmBoxPageUp", reverse){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class CommandResizeWindowHorizontally : public CommandNavigate//NonCommandBox
{
public:
	CommandResizeWindowHorizontally(const bool& reverse):CommandNavigate("MakeWindowLarger", "MakeWindowSmaller", reverse){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class CommandResizeWindowVertically : public CommandNavigate//NonCommandBox
{
public:
	CommandResizeWindowVertically(const bool& reverse) :CommandNavigate("MakeWindowTaller", "MakeWindowShorter", reverse) {}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class CommandMmBoxQuotesTop : public Command
{
public:
	CommandMmBoxQuotesTop():Command("MmBoxTop", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
//	virtual bool isApplicableToCommandBox() const{return false;}
	virtual bool isExecutableOnRepeat() const override{return false;}
};

class CommandScrollActiveQuotes : public CommandNavigate
{
public:
	CommandScrollActiveQuotes(const bool& reverse):CommandNavigate("ActiveQuotesPageDown", "ActiveQuotesPageUp", reverse){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class CommandActiveQuotesTop : public Command
{
public:
	CommandActiveQuotesTop():Command("ActiveQuotesTop", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
	virtual bool isExecutableOnRepeat() const override{return false;}
};

class TGUI_API CommandCloseAlertWindow : public CommandNavigate
{
public:
	CommandCloseAlertWindow(const bool& reverse, const bool& renew):
		CommandNavigate(renew ? "RenewLastAlertWindow" : "CloseLastAlertWindow", renew ? "RenewFirstAlertWindow" : "CloseFirstAlertWindow", reverse),
		m_renew(renew)
	{
	}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
protected:
	bool m_renew;
};

class TGUI_API CommandSelectAll : public Command
{
public:
	CommandSelectAll():Command("SelectAllRows", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandUnselectAll : public Command
{
public:
	CommandUnselectAll():Command("UnselectAllRows", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandToggleSelectAll : public Command
{
public:
	CommandToggleSelectAll():Command("ToggleSelectAllRows", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandCloseAllAlertWindows : public Command
{
public:
	CommandCloseAllAlertWindows():Command("CloseAllAlertWindows", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
//	bool isExecutableOnRepeat() const{return false;}
};

class TGUI_API CommandCornerAllAlertWindows : public Command
{
public:
	CommandCornerAllAlertWindows():Command("CornerAllAlertWindows", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandCloseAllNewsContentsWindows : public Command
{
public:
	CommandCloseAllNewsContentsWindows(bool workspaceOnly):Command(workspaceOnly ? "CloseWorkspaceNewsContents" : "CloseAllNewsContents", CC_NAVIGATE), m_workspaceOnly(workspaceOnly){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
//	bool isExecutableOnRepeat() const{return false;}
protected:
	bool m_workspaceOnly;
};

class TGUI_API CommandToggleWorkspaceAllNewsContentsWindows : public Command
{
public:
	CommandToggleWorkspaceAllNewsContentsWindows():Command("ToggleNewsContents", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
	virtual bool isToggleCommand() const override{return true;}
//	bool isExecutableOnRepeat() const{return false;}
};

class TGUI_API CommandNextTool : public CommandNavigate
{
public:
	CommandNextTool(const bool& reverse):CommandNavigate("ToolNext", "ToolPrevious", reverse){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandNextWorkspace : public CommandNavigate
{
public:
	CommandNextWorkspace(const bool& populated, const bool& reverse):CommandNavigate(populated ? "WorkspaceNextPopulated" : "WorkspaceNext", populated ? "WorkspacePreviousPopulated" : "WorkspacePrevious", reverse), m_populated(populated){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
protected:
	bool m_populated;
};

class TGUI_API CommandNextMarketMaker : public CommandNavigate
{
public:
	CommandNextMarketMaker(const bool& reverse):CommandNavigate("MarketMakerNext", "MarketMakerPrevious", reverse){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandScrollActiveWindowHorizontally : public CommandNavigateNonCommandBox
{
public:
	CommandScrollActiveWindowHorizontally(const bool& reverse):CommandNavigateNonCommandBox("ScrollActiveWindowRight", "ScrollActiveWindowLeft", reverse){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandScrollActiveWindowLine : public CommandNavigateNonCommandBox
{
public:
	CommandScrollActiveWindowLine(const bool& reverse):CommandNavigateNonCommandBox("ScrollActiveWindowLineDown", "ScrollActiveWindowLineUp", reverse){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
//	virtual bool isApplicableToCommandBox() const{return false;}
};

class TGUI_API CommandScrollActiveWindowPage : public CommandNavigateNonCommandBox
{
public:
	CommandScrollActiveWindowPage(const bool& reverse):CommandNavigateNonCommandBox("ScrollActiveWindowPageDown", "ScrollActiveWindowPageUp", reverse){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
//	virtual bool isApplicableToCommandBox() const{return false;}
};

class TGUI_API CommandScrollActiveWindowExtreme : public CommandNavigateNonCommandBox
{
public:
	CommandScrollActiveWindowExtreme(const bool& reverse):CommandNavigateNonCommandBox("ScrollActiveWindowBottom", "ScrollActiveWindowTop", reverse){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
//	virtual bool isApplicableToCommandBox() const{return false;}
};

class TGUI_API CommandSaveLayout : public Command
{
public:
	CommandSaveLayout():Command("SaveLayout", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
	virtual bool isApplicableToCommandBox() const override{return false;}
};

class TGUI_API CommandSaveLayoutAs : public Command
{
public:
	CommandSaveLayoutAs():Command("SaveLayoutAs", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
	virtual bool isApplicableToCommandBox() const override{return false;}
};

class TGUI_API CommandCopySelectionInActiveWindow : public Command
{
public:
	CommandCopySelectionInActiveWindow():Command("CopyActiveWindowSelection", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
//	virtual bool isApplicableToCommandBox() const;
};

class TGUI_API CommandMaximizeActiveWindow : public Command
{
public:
	CommandMaximizeActiveWindow():Command("MaximizeActiveWindow", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
	virtual bool isApplicableToCommandBox() const;
};

class TGUI_API CommandCornerActiveWindow : public Command
{
public:
	CommandCornerActiveWindow():Command("CornerActiveWindow", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
	virtual bool isApplicableToCommandBox() const;
};

class TGUI_API CommandDebugActiveWindow : public Command
{
public:
	CommandDebugActiveWindow():Command("DebugActiveMM", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
	virtual bool isApplicableToCommandBox() const;
};

class TGUI_API CommandDebugMainWindow : public Command
{
public:
	CommandDebugMainWindow():Command("DebugMainWindow", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
//	virtual bool isApplicableToCommandBox() const{return false;}
};

class TGUI_API CommandMaximizeActiveCommandWindow : public Command
{
public:
	CommandMaximizeActiveCommandWindow():Command("MaximizeActiveMM", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandLoadAllOrdersAndExecutions : public Command
{
public:
	CommandLoadAllOrdersAndExecutions(const bool& loadOrders, const bool& loadExecutions):
		Command(loadOrders && loadExecutions ? "LoadAllOrdersAndExecutions" : loadOrders ? "LoadAllOrders" : loadExecutions ? "LoadAllExecutions" : "LoadNoOrdersNorExecutions", CC_NAVIGATE),
		m_loadOrders(loadOrders),
		m_loadExecutions(loadExecutions)
	{}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
protected:
	bool m_loadOrders;
	bool m_loadExecutions;
};

class CommandLogFileBookmark : public Command
{
public:
	CommandLogFileBookmark():Command("LogFileBookmark", CC_NAVIGATE){}
	static void LogBookmark();
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
	virtual bool isExecutableOnRepeat() const{return false;}
};

class TGUI_API CommandScrollCancelOrderWindowLine : public CommandNavigate
{
public:
	CommandScrollCancelOrderWindowLine(const bool& reverse):CommandNavigate("ScrollCancelOrderWndLineDown", "ScrollCancelOrderWndLineUp", reverse){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandScrollCancelOrderWindowPage : public CommandNavigate
{
public:
	CommandScrollCancelOrderWindowPage(const bool& reverse):CommandNavigate("ScrollCancelOrderWndPageDown", "ScrollCancelOrderWndPageUp", reverse){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandScrollCancelOrderWindowExtreme : public CommandNavigate
{
public:
	CommandScrollCancelOrderWindowExtreme(const bool& reverse):CommandNavigate("ScrollCancelOrderWndBottom", "ScrollCancelOrderWndTop", reverse){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
};

class TGUI_API CommandCancelSelectedOrder : public Command
{
public:
	CommandCancelSelectedOrder():Command("CancelSelectedOrder", CC_CANCEL){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
//	bool isExecutableOnRepeat() const{return false;}
	virtual bool isApplicableToCommandBox() const override;
};

class TGUI_API CommandCancelSelectedAlert : public Command
{
public:
	CommandCancelSelectedAlert():Command("CancelSelectedAlert", CC_CANCEL){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
//	bool isExecutableOnRepeat() const{return false;}
	virtual bool isApplicableToCommandBox() const override;
};

enum FallThroughKeys
{
	FTK_NUM = 1,
	FTK_RIGHT,
	FTK_CAPS,

	FTK_COUNT
};

class TGUI_API KeyCommandMapping
{
public:
	KeyCommandMapping(bool allowLettersWithoutModifier);
	~KeyCommandMapping(){DestroyCommands();}

	static const unsigned int fallThroughMaskBytes = 3;

#if (_MSC_VER > 1600)
	typedef std::unordered_map<std::string, Command*, TakionHashValue<std::string> > CommandMap;
	typedef std::unordered_set<Command*> CommandSet;
	typedef std::unordered_set<const Command*> ConstCommandSet;
	typedef std::unordered_set<std::string, TakionHashValue<std::string> > ConstStringSet;
#else
	typedef std::hash_map<std::string, Command*> CommandMap;
	typedef std::hash_set<Command*> CommandSet;
	typedef std::hash_set<const Command*> ConstCommandSet;
	typedef std::hash_set<std::string> ConstStringSet;
#endif
	bool AddCommand(Command* command);
	Command* RemoveCommand(const std::string& name);
	Command* RenameCommand(Command* command, const char* newName);
	void DestroyCommands();
	void ClearMapping();
	CommandSet& GetAllCommandSet(){return m_allCommandSet;}
	const CommandSet& GetAllCommandSet() const{return m_allCommandSet;}

	const CommandSet::const_iterator& GetAllCommandSetEnd() const{return m_allCommandSetEnd;}
	const CommandMap::const_iterator& GetAllCommandsEnd() const{return m_allCommandsEnd;}

	CommandMap& GetAllCommands(){return m_allCommands;}
	const CommandMap& GetAllCommands() const{return m_allCommands;}
	const Command* const* GetMappedCommands() const{return m_mappedCommands;}
	Command** GetMappedCommands(){return m_mappedCommands;}
	const Command* FindCommand(const std::string& name) const{CommandMap::const_iterator found = m_allCommands.find(name); return found == m_allCommandsEnd ? NULL : found->second;}
	Command* FindCommand(const std::string& name){CommandMap::iterator found = m_allCommands.find(name); return found == m_allCommandsEnd ? NULL : found->second;}
	const Command* FindCommandByPtr(Command* command) const{CommandSet::const_iterator found = m_allCommandSet.find(command); return found == m_allCommandSetEnd ? NULL : *found;}
	Command* FindCommandByPtr(Command* command){CommandSet::iterator found = m_allCommandSet.find(command); return found == m_allCommandSetEnd ? NULL : *found;}

#if (_MSC_VER > 1600)
	typedef std::unordered_set<Key, TakionHashValue<Key> > KeySet;
#else
	typedef std::hash_set<Key> KeySet;
#endif
	KeySet& GetAllKeys(){return m_allKeys;}
	const KeySet& GetAllKeys() const{return m_allKeys;}
	const KeySet::const_iterator& GetAllKeysEnd() const{return m_allKeysEnd;}

	typedef std::set<Key> KeySetSorted;
	KeySetSorted& GetAllKeysSorted(){return m_allKeysSorted;}
	const KeySetSorted& GetAllKeysSorted() const{return m_allKeysSorted;}
	const KeySetSorted::const_iterator& GetAllKeysSortedEnd() const{return m_allKeysSortedEnd;}

	bool MapCommand(const Key& key, Command* command, bool overridePreviousMapping = true);
	bool UnmapCommand(Command* command);
	Command* UnmapKey(const Key& key);
	Command* GetMappedCommand(const Key& key) const;
	Command* GetMappedCommandFromSet(const Key& key, const ConstStringSet& commandNameSet) const;
	Command* GetMappedCommandStrict(const Key& key) const{return m_mappedCommands[key.GetKey()];}

	void AddKey(unsigned char ascii, unsigned char modifier);
	Command* RemoveKey(unsigned char ascii, unsigned char modifier);

	void RemoveAllLetterKeysWithModifier(unsigned char modifier);

	void AddAllLetterKeysWithModifier(unsigned char modifier);
	void AddAllButLetterKeysWithModifier(unsigned char modifier);

	void AddAllKeys();

	unsigned int GetFallThroughKeys() const{return m_fallThroughKeys;}
	void SetFallThroughKeys(unsigned int fallThroughKeys){m_fallThroughKeys = fallThroughKeys;}

	bool isAllowLettersWithoutModifier() const{return m_allowLettersWithoutModifier;}
	bool SetAllowLettersWithoutModifier(bool allowLettersWithoutModifier);
protected:
	bool m_allowLettersWithoutModifier;
	unsigned int m_fallThroughKeys;
	CommandSet m_allCommandSet;
	CommandSet::const_iterator m_allCommandSetEnd;
	CommandMap m_allCommands;
	CommandMap::const_iterator m_allCommandsEnd;
	KeySet m_allKeys;
	KeySet::const_iterator m_allKeysEnd;
	KeySetSorted m_allKeysSorted;
	KeySetSorted::const_iterator m_allKeysSortedEnd;
	Command* m_mappedCommands[0x10000];
private:
	KeyCommandMapping(const KeyCommandMapping& other);
	KeyCommandMapping& operator=(const KeyCommandMapping& other);
};

class TGUI_API QuoteColor
{
public:
	QuoteColor(//const char* mmid = NULL,
		const COLORREF& bgColor = 0,
		const COLORREF& fgColor = 0,
		const bool& useBgColor = false,
		const bool& useFgColor = false,
		const bool& mmOnlyBgColor = false,
		const bool& mmOnlyFgColor = false):
//		m_mmid(mmid ? mmid : ""),
		m_bgColor(bgColor),
		m_fgColor(fgColor),
		m_useBgColor(useBgColor),
		m_useFgColor(useFgColor),
		m_mmOnlyBgColor(mmOnlyBgColor),
		m_mmOnlyFgColor(mmOnlyFgColor)
	{
//		m_numericMmid = U_RepresentStringAsUnsignedNumber<unsigned int>(m_mmid.c_str());
	}

	virtual ~QuoteColor(){}

//	const std::string& GetMmid() const{return m_mmid;}
//	unsigned int GetNumericMmid() const{return m_numericMmid;}
//	void SetMmid(const char* mmid){m_mmid = mmid ? mmid : ""; m_numericMmid = U_RepresentStringAsUnsignedNumber<unsigned int>(m_mmid.c_str());}

	const COLORREF& GetBgColor() const{return m_bgColor;}
	const COLORREF& GetFgColor() const{return m_fgColor;}
	const COLORREF& GetColor(const bool& background) const{return background ? m_bgColor : m_fgColor;}
	const bool& isUseBgColor() const{return m_useBgColor;}
	const bool& isUseFgColor() const{return m_useFgColor;}
	const bool& isUseColor(const bool& background) const{return background ? m_useBgColor : m_useFgColor;}
	const bool& isMmOnlyBgColor() const{return m_mmOnlyBgColor;}
	const bool& isMmOnlyFgColor() const{return m_mmOnlyFgColor;}
	const bool& isMmOnlyColor(const bool& background) const{return background ? m_mmOnlyBgColor : m_mmOnlyFgColor;}

	void SetBgColor(const COLORREF& color){m_bgColor = color;}
	void SetFgColor(const COLORREF& color){m_fgColor = color;}
	void SetColor(const bool& background, const COLORREF& color)
	{
		if(background)m_bgColor = color;
		else m_fgColor = color;
	}
	void SetUseBgColor(const bool& use){m_useBgColor = use;}
	void SetUseFgColor(const bool& use){m_useFgColor = use;}
	void SetUseColor(const bool& background, const bool& use)
	{
		if(background)m_useBgColor = use;
		else m_useFgColor = use;
	}
	void SetMmOnlyBgColor(const bool& only){m_mmOnlyBgColor = only;}
	void SetMmOnlyFgColor(const bool& only){m_mmOnlyFgColor = only;}
	void SetMmOnlyColor(const bool& background, const bool& only)
	{
		if(background)m_mmOnlyBgColor = only;
		else m_mmOnlyFgColor = only;
	}

	bool operator==(const QuoteColor& other) const
	{
		return m_bgColor == other.m_bgColor
			&& m_fgColor == other.m_fgColor
			&& m_useBgColor == other.m_useBgColor
			&& m_useFgColor == other.m_useFgColor
			&& m_mmOnlyBgColor == other.m_mmOnlyBgColor
			&& m_mmOnlyFgColor == other.m_mmOnlyFgColor;
	}
	bool operator!=(const QuoteColor& other) const
	{
		return !operator==(other);
	}
	bool isColoringAffected(const QuoteColor& other) const
	{
		return (m_useBgColor == other.m_useBgColor ? m_useBgColor && (m_bgColor != other.m_bgColor || m_mmOnlyBgColor != other.m_mmOnlyBgColor) : !m_useBgColor)
			|| (m_useFgColor == other.m_useFgColor ? m_useFgColor && (m_fgColor != other.m_fgColor || m_mmOnlyFgColor != other.m_mmOnlyFgColor) : !m_useFgColor);
	}
	void Copy(const QuoteColor& other)
	{
		m_bgColor = other.m_bgColor;
		m_fgColor = other.m_fgColor;
		m_useBgColor = other.m_useBgColor;
		m_useFgColor = other.m_useFgColor;
		m_mmOnlyBgColor = other.m_mmOnlyBgColor;
		m_mmOnlyFgColor = other.m_mmOnlyFgColor;
	}
protected:
//	std::string m_mmid;
//	unsigned int m_numericMmid;
	COLORREF m_bgColor;
	COLORREF m_fgColor;
	bool m_useBgColor;
	bool m_useFgColor;
	bool m_mmOnlyBgColor;
	bool m_mmOnlyFgColor;
};

class TGUI_API WindowLinkParamsBase
{
public:
	WindowLinkParamsBase(const char* className, const char* title, bool sendSymbols):m_className(className),m_title(title),m_hWnd(NULL),m_sendSymbols(sendSymbols){}
	virtual ~WindowLinkParamsBase(){}
	virtual void StartThread(){}
	virtual void WriteMessage(const Message* message){}//called from main thread
	virtual void WriteBuffers(WSABUF* data, unsigned int count, unsigned int totalLength){}//called from main thread
	void FindLinkWindow(){m_hWnd = FindWindow(m_className.empty() ? NULL : m_className.c_str(), m_title.empty() ? NULL : m_title.c_str());}
	const std::string& GetWindowClassName() const{return m_className;}
	const std::string& GetWindowTitle() const{return m_title;}
	bool operator==(const WindowLinkParamsBase& other) const{return m_className == other.m_className && m_title == other.m_title;}
	bool operator!=(const WindowLinkParamsBase& other) const{return !operator==(other);}
	bool operator<(const WindowLinkParamsBase& other) const{return m_className < other.m_className || m_className == other.m_className && m_title < other.m_title;}
	bool isWindow() const{return m_hWnd && IsWindow(m_hWnd) == TRUE;}
	HWND GetWindow() const{return m_hWnd;}
	void SetWindow(HWND hwnd){m_hWnd = hwnd;}
	void SetClassName(const char* className){m_className = className;}
	void SetTitle(const char* title){m_title = title;}
	bool isSendSymbols() const{return m_sendSymbols;}
	void SetSendSymbols(bool sendSymbols){m_sendSymbols = sendSymbols;}
protected:
	std::string m_className;
	std::string m_title;
	HWND m_hWnd;
	bool m_sendSymbols;
};

class TGUI_API WindowLinkParams : public WindowLinkParamsBase
{
friend class WindowLinkThread;
public:
	WindowLinkParams(const char* className, const char* title, bool sendSymbols);
	WindowLinkParams(const WindowLinkParamsBase& other);
	virtual ~WindowLinkParams();
	virtual void StartThread();
	virtual void WriteMessage(const Message* message) override;//called from main thread
	virtual void WriteBuffers(WSABUF* data, unsigned int count, unsigned int totalLength) override;//called from main thread
protected:
	WindowLinkThread* m_thread;
private:
	WindowLinkParams(const WindowLinkParams& other);
	WindowLinkParams& operator=(const WindowLinkParams& other);
};

class TGUI_API LinkSettingValue : public AggregateSetting
{
public:
	LinkSettingValue(bool checked = true, bool sendSymbols = true):
		AggregateSetting('\\'),
		m_checked(checked),
		m_sendSymbols(sendSymbols)
	{
		AddSettings();
	}

	LinkSettingValue(const LinkSettingValue& other):
		AggregateSetting(other),
		m_checked(other.m_checked),
		m_sendSymbols(other.m_sendSymbols)
	{
		AddSettings();
	}

	void UpdateWindowLinkParams(WindowLinkParamsBase& params) const
	{
		params.SetSendSymbols(m_sendSymbols.GetValue());
	}

	BoolSetting m_checked;
	BoolSetting m_sendSymbols;
protected:
	void AddSettings()
	{
		AddSetting(m_checked);
		AddSetting(m_sendSymbols);
	}
};

class TGUI_API TakionVisual : public VisualBase
{
public:
	TakionVisual(HINSTANCE exeHinstance, const unsigned __int64& exeVersion, const unsigned __int64& takionDataHeaderVersion);
//	virtual ~TakionVisual();

	CMenu* GetMainSysMenu(){return &m_mainSysMenu;}
	CMenu* GetToolSysMenu(){return &m_toolSysMenu;}

//	typedef CMap<const std::string, const std::string&, const WSABUF, const WSABUF&> FileMemoryMap;
//	typedef std::hash_map<const std::string, const WSABUF> FileMemoryMap;

//	HCURSOR GetCursorScroll() const{return m_cursorScroll;}

//	CBitmap* GetUnpinBitmap(){return &m_unpinBitmap;}
//	CBitmap* GetPinBitmap(){return &m_pinBitmap;}
/*
	CBitmap* GetCheckCheckedBitmap(){return &m_checkCheckedBitmap;}
	CBitmap* GetCheckUncheckedBitmap(){return &m_checkUncheckedBitmap;}
	CBitmap* GetRadioCheckedBitmap(){return &m_radioCheckedBitmap;}
	CBitmap* GetRadioUncheckedBitmap(){return &m_radioUncheckedBitmap;}
*/
	HMENU GetMainSysMenuCost() const{return m_mainSysMenuCost;}
	HMENU GetMainSysMenuHelp() const{return m_mainSysMenuHelp;}
	HMENU GetMainSysMenuLayout() const{return m_mainSysMenuLayout;}
	HMENU GetMainSysMenuView() const{return m_mainSysMenuView;}
	HMENU GetMainSysMenuExtLink() const{return m_mainSysMenuExtLink;}
	HMENU GetMainSysMenuEsignal() const{return m_mainSysMenuEsignal;}
	HMENU GetMainSysMenuBloomberg() const{return m_mainSysMenuBloomberg;}
	HMENU GetMainSysMenuLayoutRecover() const{return m_layoutRecoverMenu;}
	HMENU GetMainSysMenuLock() const{return m_mainSysMenuLock;}
	HMENU GetMainSysMenuOnTop() const{return m_mainSysMenuOnTop;}
	HMENU GetMainSysMenuLoadHistory() const{return m_mainSysMenuLoadHistory;}
	HMENU GetMainSysMenuCommand() const{return m_mainSysMenuCommand;}
	HMENU GetMainSysMenuNewWindow() const{return m_mainSysMenuNewWindow;}
	HMENU GetMainSysMenuWindow() const{return m_mainSysMenuWindow;}
	HMENU GetMainSysMenuCorner() const{return m_mainSysMenuCorner;}
	HMENU GetMainSysMenuWorkspace() const{return m_mainSysMenuWorkspace;}
	HMENU GetMainSysMenuAccount() const{return m_mainSysMenuAccount;}

	const COLORREF& GetNamedFilterIntersectionColor() const{return m_namedFilterIntersectionColor;}
	CBrush* GetNamedFilterIntersectionBrush() const{return m_namedFilterIntersectionBrush;}

	const COLORREF* GetCommandColors() const{return m_commandColors;}
	virtual const COLORREF& GetCommandColorAt(unsigned int at) const{return at < CC_COUNT ? m_commandColors[at] : m_unknownCommandColor;}
	const COLORREF& GetUnknownCommandColor() const{return m_unknownCommandColor;}

	const unsigned __int64& GetTakionDataHeaderVersion() const{return m_takionDataHeaderVersion;}

protected:
//	const char* LoadWav(const std::string& fileName);
	HINSTANCE m_hInstance;
	unsigned __int64 m_takionDataHeaderVersion;

	CMenu m_mainSysMenu;
	CMenu m_toolSysMenu;

	HMENU m_mainSysMenuCost;
	HMENU m_mainSysMenuHelp;
	HMENU m_mainSysMenuLayout;
	HMENU m_mainSysMenuView;
	HMENU m_mainSysMenuExtLink;
	HMENU m_mainSysMenuEsignal;
	HMENU m_mainSysMenuBloomberg;
	HMENU m_layoutRecoverMenu;
	HMENU m_mainSysMenuLock;
	HMENU m_mainSysMenuOnTop;
	HMENU m_mainSysMenuLoadHistory;
	HMENU m_mainSysMenuCommand;
	HMENU m_mainSysMenuNewWindow;
	HMENU m_mainSysMenuWindow;
	HMENU m_mainSysMenuCorner;
	HMENU m_mainSysMenuWorkspace;
	HMENU m_mainSysMenuAccount;

//	CBitmap m_unpinBitmap;
//	CBitmap m_pinBitmap;
/*
	CBitmap m_checkCheckedBitmap;
	CBitmap m_checkUncheckedBitmap;
	CBitmap m_radioCheckedBitmap;
	CBitmap m_radioUncheckedBitmap;
*/
	COLORREF m_namedFilterIntersectionColor;
	CBrush* m_namedFilterIntersectionBrush;

	COLORREF m_unknownCommandColor;// = RGB(32, 96, 32);
	COLORREF m_commandColors[CC_COUNT];
private:
	TakionVisual(const TakionVisual& other);//{}
	TakionVisual& operator=(const TakionVisual& other);//{return *this;}
};

class TGUI_API ToggleConfigBooleanSettingCommand : public Command
{
public:
	ToggleConfigBooleanSettingCommand(const char* name, CommandCategory cc, BoolSetting& setting):
		Command(name, cc),
		m_setting(setting)
	{}
	virtual bool isToggleCommand() const{return true;}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL) override;
protected:
	virtual void OnInvoke(const bool settingValue){}
	BoolSetting& m_setting;
};

class TGUI_API QuoteColorSetting : public AggregateSetting
{
public:
	QuoteColorSetting(COLORREF bgColor = 0,
		COLORREF fgColor = 0,
		bool useBgColor = false,
		bool useFgColor = false,
		bool mmOnlyBgColor = false,
		bool mmOnlyFgColor = false):
		m_bgColor(bgColor),
		m_fgColor(fgColor),
		m_useBgColor(useBgColor),
		m_useFgColor(useFgColor),
		m_mmOnlyBgColor(mmOnlyBgColor),
		m_mmOnlyFgColor(mmOnlyFgColor)
	{
		AddSettings();
	}

	QuoteColorSetting(const QuoteColorSetting& other):
		AggregateSetting(other),
		m_bgColor(other.m_bgColor),
		m_fgColor(other.m_fgColor),
		m_useBgColor(other.m_useBgColor),
		m_useFgColor(other.m_useFgColor),
		m_mmOnlyBgColor(other.m_mmOnlyBgColor),
		m_mmOnlyFgColor(other.m_mmOnlyFgColor)
	{
		AddSettings();
	}

	void UpdateQuoteColor(QuoteColor& quoteColor) const
	{
		quoteColor.SetBgColor(m_bgColor.GetValue());
		quoteColor.SetFgColor(m_fgColor.GetValue());
		quoteColor.SetUseBgColor(m_useBgColor.GetValue());
		quoteColor.SetUseFgColor(m_useFgColor.GetValue());
		quoteColor.SetMmOnlyBgColor(m_mmOnlyBgColor.GetValue());
		quoteColor.SetMmOnlyFgColor(m_mmOnlyFgColor.GetValue());
	}

	UIntSetting m_bgColor;
	UIntSetting m_fgColor;
	BoolSetting m_useBgColor;
	BoolSetting m_useFgColor;
	BoolSetting m_mmOnlyBgColor;
	BoolSetting m_mmOnlyFgColor;
protected:
	void AddSettings()
	{
		AddSetting(m_bgColor);
		AddSetting(m_fgColor);
		AddSetting(m_useBgColor);
		AddSetting(m_useFgColor);
		AddSetting(m_mmOnlyBgColor);
		AddSetting(m_mmOnlyFgColor);
	}
};

class AlertKeySetting : public AggregateSetting
{
public:
//	AlertKeySetting(const char* symbol = "", unsigned char type = 0, __int64 to = 0):
	AlertKeySetting(const unsigned __int64& numericSymbol = 0, const unsigned char& type = 0, const __int64& to = 0, const __int64& modifierValue = 0):
		m_numericSymbol(numericSymbol),
		m_type(type),
		m_to(to),
		m_modifierValue(modifierValue)
	{
		AddSettings();
	}
	AlertKeySetting(const AlertKeySetting& other):
		m_numericSymbol(other.m_numericSymbol),
		m_type(other.m_type),
		m_to(other.m_to),
		m_modifierValue(other.m_modifierValue)
	{
		AddSettings();
	}
//	StringSetting m_symbol;
	StringAsUInt64Setting m_numericSymbol;
	UCharSetting m_type;
	Int64Setting m_to;
	Int64Setting m_modifierValue;
protected:
	void AddSettings()
	{
		AddSetting(m_numericSymbol);
		AddSetting(m_type);
		AddSetting(m_to);
		AddSetting(m_modifierValue);
	}
};

class AlertTriggeredKeySetting : public AlertKeySetting
{
public:
//	AlertTriggeredKeySetting(const char* symbol = "", unsigned char type = 0, __int64 to = 0, unsigned int timeTriggered = 0):
	AlertTriggeredKeySetting(const unsigned __int64& numericSymbol = 0, const unsigned char& type = 0, const __int64& to = 0, const unsigned int& timeTriggered = 0, const __int64& modifierValue = 0):
		AlertKeySetting(numericSymbol, type, to, modifierValue),
		m_timeTriggered(timeTriggered)
	{
		AddSettings1();
	}
	AlertTriggeredKeySetting(const AlertTriggeredKeySetting& other):
		AlertKeySetting(other),
		m_timeTriggered(other.m_timeTriggered)
	{
		AddSettings1();
	}
	UIntSetting m_timeTriggered;
protected:
	void AddSettings1()
	{
		AddSetting(m_timeTriggered);
	}
};

class TGUI_API AlertValueSetting : public AggregateSetting
{
public:
	AlertValueSetting(const unsigned int& expirationDate = 0,
		const unsigned int& color = 0,
		const __int64& from = 0,
		const bool& initialized = false,
		const bool& popup = true,
		const char* const& note = NULL,
		const unsigned int& dateCreated = 0,
		const unsigned int& timeCreated = 0,
		const unsigned int& dateTriggered = 0):
		m_expirationDate(expirationDate),
		m_color(color),
		m_from(from),
		m_initialized(initialized),
		m_popup(popup),
		m_note(note ? note : ""),
		m_dateCreated(dateCreated),
		m_timeCreated(timeCreated),
		m_dateTriggered(dateTriggered)
	{
		AddSettings();
	}
	AlertValueSetting(const AlertValueSetting& other):
		m_expirationDate(other.m_expirationDate),
		m_color(other.m_color),
		m_from(other.m_from),
		m_initialized(other.m_initialized),
		m_popup(other.m_popup),
		m_note(other.m_note),
		m_dateCreated(other.m_dateCreated),
		m_timeCreated(other.m_timeCreated),
		m_dateTriggered(other.m_dateTriggered)
	{
		AddSettings();
	}
	UIntSetting m_expirationDate;
	UIntSetting m_color;
	Int64Setting m_from;
	BoolSetting m_initialized;
	BoolSetting m_popup;
	StringSetting m_note;
	UIntSetting m_dateCreated;
	UIntSetting m_timeCreated;
	UIntSetting m_dateTriggered;
protected:
	void AddSettings()
	{
		AddSetting(m_expirationDate);
		AddSetting(m_color);
		AddSetting(m_from);
		AddSetting(m_initialized);
		AddSetting(m_note);
		AddSetting(m_dateCreated);
		AddSetting(m_timeCreated);
		AddSetting(m_dateTriggered);
		AddSetting(m_popup);
	}
};

class TGUI_API MainWndSetting : public AggregateSetting
{
public:
	MainWndSetting():
		m_left(0),
		m_top(0),
		m_width(100),
		m_height(50),
		m_workspaceWidth(0),
		m_toolboxWidth(0),
		m_titleHeight(0),
		m_valueWidth(0),
		m_defaultViewVersion(0)
//		m_inventoryView(false)
	{
		AddSettings();
	}
	MainWndSetting(const MainWndSetting& other):
		AggregateSetting(other),
		m_left(other.m_left),
		m_top(other.m_top),
		m_width(other.m_width),
		m_height(other.m_height),
		m_workspaceWidth(other.m_workspaceWidth),
		m_toolboxWidth(other.m_toolboxWidth),
		m_titleHeight(other.m_titleHeight),
		m_valueWidth(other.m_valueWidth),
		m_defaultViewVersion(other.m_defaultViewVersion)
//		m_inventoryView(other.m_inventoryView)
	{
		AddSettings();
	}
	IntSetting m_left;
	IntSetting m_top;
	IntSetting m_width;
	IntSetting m_height;
	IntSetting m_workspaceWidth;
	IntSetting m_toolboxWidth;
	IntSetting m_titleHeight;
	IntSetting m_valueWidth;

	VersionSetting m_defaultViewVersion;
//	BoolSetting m_inventoryView;
protected:
	void AddSettings()
	{
		AddSetting(m_left);
		AddSetting(m_top);
		AddSetting(m_width);
		AddSetting(m_height);
		AddSetting(m_workspaceWidth);
		AddSetting(m_toolboxWidth);
		AddSetting(m_titleHeight);
		AddSetting(m_valueWidth);
//		AddSetting(m_inventoryView);
		AddSetting(m_defaultViewVersion);
	}
};

class TGUI_API OrderSizeSetting : public AggregateSetting
{
public:
	OrderSizeSetting(const unsigned char& unit = 0, const unsigned int& size = 0, const unsigned int& fraction = 0, const char* const& name = ""):
		m_unit(unit),
		m_size(size),
		m_fraction(fraction),
		m_name(name)
	{
		AddSettings();
	}
	OrderSizeSetting(const OrderSizeSetting& other):
		m_unit(other.m_unit),
		m_size(other.m_size),
		m_fraction(other.m_fraction),
		m_name(other.m_name)
	{
		AddSettings();
	}
	OrderSize* CreateOrderSize() const;
	UCharSetting m_unit;
	UIntSetting m_size;
	UIntSetting m_fraction;
	StringSetting m_name;
protected:
	void AddSettings()
	{
		AddSetting(m_unit);
		AddSetting(m_size);
		AddSetting(m_fraction);
		AddSetting(m_name);
	}
};

class TGUI_API OrderPriceSetting : public AggregateSetting
{
public:
	OrderPriceSetting(const unsigned char& priceBase = 0, const SignedPrice& priceOffset = SignedPrice::signedPriceZero, const bool& percent = false, const char* const& name = ""):
		m_priceBase(priceBase),
		m_priceOffset(4, priceOffset),
		m_percent(percent),
		m_name(name)
	{
		AddSettings();
	}
	OrderPriceSetting(const OrderPriceSetting& other):
		m_priceBase(other.m_priceBase),
		m_priceOffset(other.m_priceOffset),
		m_percent(other.m_percent),
		m_name(other.m_name)
	{
		AddSettings();
	}
	OrderPrice* CreateOrderPrice() const;
	UCharSetting m_priceBase;
	SignedPriceSetting m_priceOffset;
	BoolSetting m_percent;
	StringSetting m_name;
protected:
	void AddSettings()
	{
		AddSetting(m_priceBase);
		AddSetting(m_priceOffset);
		AddSetting(m_percent);
		AddSetting(m_name);
	}
};

class TGUI_API AggregateOrderSizeSetting : public AggregateSetting
{
public:
	AggregateOrderSizeSetting(unsigned char relationship = 0, char orderSizeVectorDelimiter2 = '\n'):
		AggregateSetting('\\'),
		m_relationship(relationship),
		m_orderSizeVector('`', '\\', true)
	{
		AddSettings();
	}
	AggregateOrderSizeSetting(const AggregateOrderSizeSetting& other):
		AggregateSetting(other),
		m_relationship(other.m_relationship),
		m_orderSizeVector(other.m_orderSizeVector)
	{
		AddSettings();
	}
	bool FillOrderSize(const OrderSize* orderSize);
	bool UpdateOrderSize(OrderSize* orderSize) const;
//	OrderSize* CreateOrderSize() const;
	UCharSetting m_relationship;
	VectorSetting<OrderSizeSetting> m_orderSizeVector;
protected:
	void AddSettings()
	{
		AddSetting(m_relationship);
		AddSetting(m_orderSizeVector);
	}
};

class TGUI_API AggregateOrderPriceSetting : public AggregateSetting
{
public:
	AggregateOrderPriceSetting(unsigned char relationship = 0, char orderSizeVectorDelimiter2 = '\n'):
		AggregateSetting('\\'),
		m_relationship(relationship),
		m_orderPriceVector('`', '\\', true)
	{
		AddSettings();
	}
	AggregateOrderPriceSetting(const AggregateOrderPriceSetting& other):
		AggregateSetting(other),
		m_relationship(other.m_relationship),
		m_orderPriceVector(other.m_orderPriceVector)
	{
		AddSettings();
	}
	bool FillOrderPrice(const OrderPrice* orderPrice);
	bool UpdateOrderPrice(OrderPrice* orderSize) const;
//	OrderSize* CreateOrderSize() const;
	UCharSetting m_relationship;
	VectorSetting<OrderPriceSetting> m_orderPriceVector;
protected:
	void AddSettings()
	{
		AddSetting(m_relationship);
		AddSetting(m_orderPriceVector);
	}
};

class TGUI_API CommandAggregateItemSetting : public AggregateSetting
{
public:
	CommandAggregateItemSetting(const char* name = "", bool allowAdjustable = false):
		m_name(name),
		m_allowAdjustable(allowAdjustable)
	{
		AddSettings();
	}
	CommandAggregateItemSetting(const CommandAggregateItemSetting& other):
		m_name(other.m_name),
		m_allowAdjustable(other.m_allowAdjustable)
	{
		AddSettings();
	}
	virtual void fromString(const char*& cursor, unsigned __int64 version, char delimiter) override;

	StringSetting m_name;
	BoolSetting m_allowAdjustable;
protected:
	void AddSettings()
	{
		AddSetting(m_name);
		AddSetting(m_allowAdjustable);
	}
};

class TGUI_API CommandAggregateSetting : public AggregateOrderSizeSetting
{
public:
	typedef std::vector<AggregateCommandItem> AggregateCommandItemVector;
	CommandAggregateSetting(unsigned char relationship = 0,
		int priceOffsetDollars = 0,
		int priceOffsetFraction = 0,
		bool priceOffsetPercent = false,
		bool priceAdjustableAbsolute = false,
		bool priceDynamic = false,
		unsigned char sizeAction = 0,
		unsigned char inventoryType = OCINV_DEFAULT,
		const char* repeatKeyCommandName = NULL,
		unsigned int timeToActivate = 0,
		bool adjustable = false,
		bool closeOrderBox = false,
		const AggregateCommandItemVector* commandNames = NULL,
		char orderSizeVectorDelimiter2 = '\n'):
//		AggregateSetting('\\'),
		AggregateOrderSizeSetting(relationship, orderSizeVectorDelimiter2),
		m_commandNameVector('`', orderSizeVectorDelimiter2, true),
		m_repeatKeyCommandName(repeatKeyCommandName ? repeatKeyCommandName : ""),
		m_timeToActivate(timeToActivate),
		m_adjustable(adjustable),
		m_closeOrderBox(closeOrderBox),
		m_priceOffsetDollars(priceOffsetDollars),
		m_priceOffsetFraction(priceOffsetFraction),
		m_priceOffsetPercent(priceOffsetPercent),
		m_priceAdjustableAbsolute(priceAdjustableAbsolute),
		m_priceDynamic(priceDynamic),
		m_sizeAction(sizeAction),
		m_inventoryType(inventoryType)
	{
		if(commandNames)
		{
			SetCommandNames(*commandNames);
		}
		AddSettings();
	}
	CommandAggregateSetting(const CommandAggregateSetting& other):
		AggregateOrderSizeSetting(other),
		m_commandNameVector(other.m_commandNameVector),
		m_repeatKeyCommandName(other.m_repeatKeyCommandName),
		m_timeToActivate(other.m_timeToActivate),
		m_adjustable(other.m_adjustable),
		m_closeOrderBox(other.m_closeOrderBox),
		m_priceOffsetDollars(other.m_priceOffsetDollars),
		m_priceOffsetFraction(other.m_priceOffsetFraction),
		m_priceOffsetPercent(other.m_priceOffsetPercent),
		m_priceAdjustableAbsolute(other.m_priceAdjustableAbsolute),
		m_priceDynamic(other.m_priceDynamic),
		m_sizeAction(other.m_sizeAction),
		m_inventoryType(other.m_inventoryType)
	{
		AddSettings();
	}
	virtual void fromString(const char*& cursor, unsigned __int64 version, char delimiter = settingDel) override;
	void UpdateCommand(CommandAggregate& command) const;
//	void SetCommandNames(const std::vector<std::string>& commandNames)
	void SetCommandNames(const AggregateCommandItemVector& commandNames)
	{
		m_commandNameVector.Clear();
		for(AggregateCommandItemVector::const_iterator it = commandNames.begin(), itend = commandNames.end(); it != itend; ++it)
		{
			const AggregateCommandItem& item = *it;
			m_commandNameVector.AddValue(CommandAggregateItemSetting(item.GetName(), item.isAdjustableAllowed()));
		}
	}
//	VectorSetting<StringSetting> m_commandNameVector;
	VectorSetting<CommandAggregateItemSetting> m_commandNameVector;
	StringSetting m_repeatKeyCommandName;
	UIntSetting m_timeToActivate;
	BoolSetting m_adjustable;
	BoolSetting m_closeOrderBox;
	IntSetting m_priceOffsetDollars;
	IntSetting m_priceOffsetFraction;
	BoolSetting m_priceOffsetPercent;
	BoolSetting m_priceAdjustableAbsolute;
	BoolSetting m_priceDynamic;
	UCharSetting m_sizeAction;
	UCharSetting m_inventoryType;
protected:
	void AddSettings()
	{
		AddSetting(m_commandNameVector);
		AddSetting(m_repeatKeyCommandName);
		AddSetting(m_adjustable);
		AddSetting(m_closeOrderBox);
		AddSetting(m_priceOffsetDollars);
		AddSetting(m_priceOffsetFraction);
		AddSetting(m_priceOffsetPercent);
		AddSetting(m_sizeAction);
		AddSetting(m_inventoryType);
		AddSetting(m_timeToActivate);
		AddSetting(m_priceAdjustableAbsolute);
		AddSetting(m_priceDynamic);
	}
};

class TGUI_API TokenExpressionItemSetting : public AggregateSetting
{
public:
//	TokenExpressionItemSetting(bool simple = false, bool not = false, bool caseSensitive = false, bool wholeWord = false):
	TokenExpressionItemSetting(bool not = false, bool caseSensitive = false, bool wholeWord = false) :
		AggregateSetting('/'),
//		m_simple(simple),
		m_not(not),
		m_caseSensitive(caseSensitive),
		m_wholeWord(wholeWord)
	{
		AddSettings();
	}
	TokenExpressionItemSetting(const TokenExpressionItemSetting& other):
		AggregateSetting(other),
//		m_simple(other.m_simple),
		m_not(other.m_not),
		m_caseSensitive(other.m_caseSensitive),
		m_wholeWord(other.m_wholeWord)
	{
		AddSettings();
	}
/*
	virtual void fromString(const char*& cursor, unsigned __int64 version, char delimiter = settingDel) override
	{
		if(version < U_GetVersion64(1, 0, 0, 169))
		{
		}
	}
*/
//	BoolSetting m_simple;
	BoolSetting m_not;
	BoolSetting m_caseSensitive;
	BoolSetting m_wholeWord;
protected:
	void AddSettings()
	{
//		AddSetting(m_simple);
		AddSetting(m_not);
		AddSetting(m_caseSensitive);
		AddSetting(m_wholeWord);
	}
};

//typedef MapSetting<StringSetting, TokenExpressionItemSetting, std::map<StringSetting, TokenExpressionItemSetting>, settingDel> TokenExpressionSymbolMap;
typedef MapSetting<PairSetting<StringSetting, UCharSetting>, TokenExpressionItemSetting, std::map<PairSetting<StringSetting, UCharSetting>, TokenExpressionItemSetting>, settingDel> TokenExpressionSymbolMap;

class TGUI_API TokenExpressionSetting : public AggregateSetting
{
public:
	TokenExpressionSetting(const bool& and = true):
		AggregateSetting('\\'),
		m_and(and),
		m_tokenExpressionSymbolMap('|', '\n', true)
	{
		AddSettings();
	}
	TokenExpressionSetting(const TokenExpressionSetting& other):
		AggregateSetting(other),
		m_and(other.m_and),
		m_tokenExpressionSymbolMap(other.m_tokenExpressionSymbolMap)
	{
		AddSettings();
	}
	BoolSetting m_and;
	TokenExpressionSymbolMap m_tokenExpressionSymbolMap;
protected:
	void AddSettings()
	{
		AddSetting(m_and);
		AddSetting(m_tokenExpressionSymbolMap);
	}
};

class TGUI_API InventorySettingOld : public AggregateSetting
{
public:
	InventorySettingOld():
		AggregateSetting('\\'),
		m_inventoryUsed(true)
	{
		AddSettings();
	}
	InventorySettingOld(const InventorySettingOld& other):
		AggregateSetting(other),
		m_inventorySize(other.m_inventorySize),
		m_inventoryUsed(other.m_inventoryUsed)
	{
		AddSettings();
	}

	IntSetting m_inventorySize;
	BoolSetting m_inventoryUsed;
protected:
	void AddSettings()
	{
		AddSetting(m_inventorySize);
		AddSetting(m_inventoryUsed);
	}
};

class TGUI_API InventorySetting : public AggregateSetting
{
public:
	InventorySetting():
//		AggregateSetting('\\'),
		AggregateSetting('/'),
		m_inventoryUsed(true)
	{
		AddSettings();
	}
	InventorySetting(const InventorySetting& other):
		AggregateSetting(other),
		m_inventorySize(other.m_inventorySize),
		m_inventoryCost(other.m_inventoryCost),
		m_inventoryFloating(other.m_inventoryFloating),
		m_inventoryUsed(other.m_inventoryUsed)
	{
		AddSettings();
	}

	InventorySetting(const InventorySettingOld& other):
		AggregateSetting('/'),
		m_inventorySize(other.m_inventorySize),
//		m_inventoryCost(other.m_inventoryCost),
//		m_inventoryFloating(other.m_inventoryFloating),
		m_inventoryUsed(other.m_inventoryUsed)
	{
		AddSettings();
	}
	IntSetting m_inventorySize;
	PriceSetting m_inventoryCost;
	BoolSetting m_inventoryFloating;
	BoolSetting m_inventoryUsed;
protected:
	void AddSettings()
	{
		AddSetting(m_inventorySize);
		AddSetting(m_inventoryUsed);
		AddSetting(m_inventoryCost);
		AddSetting(m_inventoryFloating);
	}
};

typedef MapSetting<StringSetting, InventorySetting, std::map<StringSetting, InventorySetting>, settingDel> PositionInventoryMap;

class TGUI_API AccountInventorySetting : public AggregateSetting
{
public:
	AccountInventorySetting(const unsigned char& securityTypeHidden = 0):
		AggregateSetting('\\'),
		m_securityTypeHidden(securityTypeHidden),
		m_positionInventoryMap('|', '\n', true)
	{
		AddSettings();
	}
	AccountInventorySetting(const AccountInventorySetting& other):
		AggregateSetting(other),
		m_securityTypeHidden(other.m_securityTypeHidden),
		m_positionInventoryMap(other.m_positionInventoryMap)
	{
		AddSettings();
	}
	UCharSetting m_securityTypeHidden;
	PositionInventoryMap m_positionInventoryMap;
protected:
	void AddSettings()
	{
		AddSetting(m_securityTypeHidden);
		AddSetting(m_positionInventoryMap);
	}
};



class ColumnInfo;

class TGUI_API ColumnArraySetting : public AggregateSetting
{
friend class ColumnInfo;
public:
//	ColumnArraySetting(char orderSizeVectorDelimiter2 = '\n'):
	ColumnArraySetting(char orderSizeVectorDelimiter2 = '|'):
//		AggregateSetting('\\'),
		m_sortId(0),
		m_followedId(0xFFFF),
		m_savedNoOptionBuiltInColumnCount(0),
		m_columnVector('\'', orderSizeVectorDelimiter2)
//		m_noOptionBuiltInColumnCount(0)
	{
		AddSettings();
	}
	ColumnArraySetting(const ColumnArraySetting& other):
		AggregateSetting(other),
		m_sortId(other.m_sortId),
		m_followedId(other.m_followedId),
		m_savedNoOptionBuiltInColumnCount(other.m_savedNoOptionBuiltInColumnCount),
		m_columnVector(other.m_columnVector)
//		m_noOptionBuiltInColumnCount(other.m_noOptionBuiltInColumnCount)
	{
		AddSettings();
	}

	void Init(const ColumnInfo& columns);
//	const unsigned short& GetNoOptionBuiltInColumnCount() const{return m_noOptionBuiltInColumnCount;}

/*
	void SetCommandNames(const std::vector<std::string>& commandNames)
	{
		m_commandNameVector.Clear();
		for(std::vector<std::string>::const_iterator it = commandNames.begin(), itend = commandNames.end(); it != itend; ++it)
		{
			m_commandNameVector.AddValue(StringSetting(*it));
		}
	}
*/
	UShortSetting m_sortId;
	UShortSetting m_followedId;
	UShortSetting m_savedNoOptionBuiltInColumnCount;
//	VectorSetting<ColumnSetting, '\''> m_columnVector;
	VectorSetting<ColumnSetting> m_columnVector;
protected:
	void AddSettings()
	{
		AddSetting(m_sortId);
		AddSetting(m_columnVector);
		AddSetting(m_followedId);
		AddSetting(m_savedNoOptionBuiltInColumnCount);
	}
//	unsigned short m_noOptionBuiltInColumnCount;
};

class TGUI_API EmptyCommandSetting : public AggregateSetting
{
public:
	EmptyCommandSetting()
	{
		AddSettings();
	}
	EmptyCommandSetting(const EmptyCommandSetting& other)//:
	{
		AddSettings();
	}
protected:
	void AddSettings()
	{
	}
};

class TGUI_API ExtensionKeystrokeCommandSetting : public AggregateSetting
{
public:
	ExtensionKeystrokeCommandSetting(unsigned int userExtensionCode = 0):
		m_userExtensionCode(userExtensionCode)
	{
		AddSettings();
	}
	ExtensionKeystrokeCommandSetting(const ExtensionKeystrokeCommandSetting& other):
		m_userExtensionCode(other.m_userExtensionCode)
	{
		AddSettings();
	}
	void UpdateCommand(ExtensionKeystrokeCommand& command) const;
	UIntSetting m_userExtensionCode;
protected:
	void AddSettings()
	{
		AddSetting(m_userExtensionCode);
	}
};

class TGUI_API SymbolToActiveCommandWindowCommandSetting : public AggregateSetting
{
public:
	SymbolToActiveCommandWindowCommandSetting()
	{
		AddSettings();
	}
	SymbolToActiveCommandWindowCommandSetting(const SymbolToActiveCommandWindowCommandSetting& other)//:
	{
		AddSettings();
	}
	void UpdateCommand(SymbolToActiveCommandWindowCommand& command) const{}
protected:
	void AddSettings()
	{
//		AddSetting(m_alertType);
	}
};

class NewsSetting : public AggregateSetting
{
public:
	NewsSetting(const std::string& url = std::string()):
		AggregateSetting('\\'),
		m_url(url)
	{
		AddSettings();
	}
	NewsSetting(const NewsSetting& other):
		AggregateSetting(other),
		m_url(other.m_url)
	{
		AddSettings();
	}
	void UpdateCommand(NewsCommand& command) const;
	StringSetting m_url;
protected:
	void AddSettings()
	{
		AddSetting(m_url);
	}
};

class PasswordSetting : public StringSettingRest
{
public:
	PasswordSetting(const std::string& value = std::string(""), const bool& useIp = false, const bool& encrypt = true):
		StringSettingRest(value),
		m_useIp(useIp)
	{
		if(encrypt)
		{
			void EncryptValue();
		}
	}
	virtual bool operator==(const Setting& other) const override;
	virtual bool operator<(const Setting& other) const override;
	const bool& isUseIp() const{return m_useIp;}
	static bool EncryptValueStatic(const std::string& valueToEncrypt, bool useIp, std::string& result);
	static bool DecryptValueStatic(const std::string& valueToDecrypt, std::string& result);
	bool EncryptValue()
	{
		std::string result;
		if(EncryptValueStatic(m_value, m_useIp, result))
		{
			m_value = result;
			return true;
		}
		return false;
	}
	bool DecryptValue(std::string& result) const
	{
		return DecryptValueStatic(m_value, result);
	}
protected:
	bool m_useIp;
};

class EmailReceipientSetting : public AggregateSetting
{
public:
	EmailReceipientSetting(const std::string& receipientName = std::string(), const unsigned char& flags = 0):
//		AggregateSetting('\\'),
		AggregateSetting('|'),
		m_receipientName(receipientName),
		m_flags(flags)
	{
		AddSettings();
	}
	EmailReceipientSetting(const EmailReceipientSetting& other):
		AggregateSetting(other),
		m_receipientName(other.m_receipientName),
		m_flags(other.m_flags)
	{
		AddSettings();
	}
	StringSetting m_receipientName;
	UCharSetting m_flags;
protected:
	void AddSettings()
	{
		AddSetting(m_receipientName);
		AddSetting(m_flags);
	}
};

class EmailSetting : public AggregateSetting
{
public:
	typedef std::vector<std::string> StringVector;

	EmailSetting(const std::string& server = std::string(),
		const unsigned short& port = 0,
		const unsigned char& emailSecurity = 0,
		const bool& allowInvalidCertificate = false,
		const std::string& senderAddress = std::string(),
		const std::string& senderId = std::string(),
//		const std::string& senderPassword = std::string(),
		const std::string& senderName = std::string(),
		const std::string& senderOrganization = std::string(),
		const std::string& subject = std::string(),
		const std::string& contents = std::string()):

		AggregateSetting('\\'),

		m_server(server),
		m_port(port),
		m_emailSecurity(emailSecurity),
		m_allowInvalidCertificate(allowInvalidCertificate),
		m_senderAddress(senderAddress),
		m_senderId(senderId),
//		m_senderPassword(senderPassword),
		m_senderName(senderName),
		m_senderOrganization(senderOrganization),
		m_subject(subject),
		m_contents('`', '\\', false, '\\'),//m_contents(contents),
		m_emailReceipients('`', '\n', false, false)//true)
	{
		if(!contents.empty())
		{
			StringVector lines;
			U_TextBreakLines(contents, lines);
			StringSetting setting;
			for(StringVector::const_iterator it = lines.begin(), itend = lines.end(); it != itend; ++it)
			{
				setting.SetValue(*it);
				m_contents.AddValue(setting);
			}
		}
		AddSettings();
	}
	EmailSetting(const EmailSetting& other):
		AggregateSetting(other),
		m_server(other.m_server),
		m_port(other.m_port),
		m_emailSecurity(other.m_emailSecurity),
		m_allowInvalidCertificate(other.m_allowInvalidCertificate),
		m_senderAddress(other.m_senderAddress),
		m_senderId(other.m_senderId),
//		m_senderPassword(other.m_senderPassword),
		m_senderName(other.m_senderName),
		m_senderOrganization(other.m_senderOrganization),
		m_subject(other.m_subject),
		m_contents(other.m_contents),
		m_emailReceipients(other.m_emailReceipients)
	{
		AddSettings();
	}
	void UpdateCommand(EmailCommand& command) const;
	void FillEmailReceipients(const EmailCommand& command);
	void FillCommandEmailReceipients(EmailCommand& command) const;
	void GetContentsAsString(std::string& contents) const;

//	bool UpdateSettingPassword(const EmailCommand& command);
//	bool UpdateCommandPassword(EmailCommand& command) const;

	StringSetting m_server;
	UShortSetting m_port;
	UCharSetting m_emailSecurity;
	BoolSetting m_allowInvalidCertificate;
	StringSetting m_senderAddress;
	StringSetting m_senderId;
//	StringSetting m_senderPassword;
	StringSetting m_senderName;
	StringSetting m_senderOrganization;

	StringSetting m_subject;
//	StringSetting m_contents;
	VectorSetting<StringSetting> m_contents;

	typedef MapSetting<StringSetting, EmailReceipientSetting, std::map<StringSetting, EmailReceipientSetting> > EmailMap;
	EmailMap m_emailReceipients;
protected:
	void AddSettings()
	{
		AddSetting(m_server);
		AddSetting(m_port);
		AddSetting(m_emailSecurity);
		AddSetting(m_allowInvalidCertificate);
		AddSetting(m_senderAddress);
		AddSetting(m_senderId);
//		AddSetting(m_senderPassword);
		AddSetting(m_senderName);
		AddSetting(m_senderOrganization);
		AddSetting(m_subject);
		AddSetting(m_contents);
		AddSetting(m_emailReceipients);
	}
};

class TGUI_API LinkSetting : public AggregateSetting
{
public:
	LinkSetting(const char* className = NULL,
		const char* title = NULL):
		AggregateSetting('\\'),
		m_className(className ? className : ""),
		m_title(title ? title : "")
	{
		AddSettings();
	}

	LinkSetting(const LinkSetting& other):
		AggregateSetting(other),
		m_className(other.m_className),
		m_title(other.m_title)
	{
		AddSettings();
	}

	void UpdateWindowLinkParams(WindowLinkParamsBase& params) const
	{
		params.SetClassName(m_className.GetValue().c_str());
		params.SetTitle(m_title.GetValue().c_str());
	}

	StringSetting m_className;
	StringSetting m_title;
protected:
	void AddSettings()
	{
		AddSetting(m_className);
		AddSetting(m_title);
	}
};

typedef MapSetting<UIntSetting, StringSettingRest, std::map<UIntSetting, StringSettingRest> > WindowMapSetting;

class TGUI_API WindowViewSetting : public AggregateSetting
{
public:
	WindowViewSetting() :
		AggregateSetting(settingDel, ';'),//'\\')
		m_version(0),
		m_left(0),
		m_top(0),
		m_width(100),
		m_height(50),
		m_workspaceWidth(0),
		m_toolboxWidth(0),
		m_titleHeight(0),
		m_valueWidth(0),
		m_defaultCommandToolOrdinal(0xFFFFFFFF),
		m_settingDlgPosition(0, 0),
		m_settingDialogOnTop(true)
//		m_tools(groupDel, groupDel, true)
	{
		AddSettings();
	}

	WindowViewSetting(const WindowViewSetting& other):
		AggregateSetting(other),
		m_version(other.m_version),
		m_left(other.m_left),
		m_top(other.m_top),
		m_width(other.m_width),
		m_height(other.m_height),
		m_workspaceWidth(other.m_workspaceWidth),
		m_toolboxWidth(other.m_toolboxWidth),
		m_titleHeight(other.m_titleHeight),
		m_valueWidth(other.m_valueWidth),
		m_defaultCommandToolOrdinal(other.m_defaultCommandToolOrdinal),
		m_settingDlgPosition(other.m_settingDlgPosition),
		m_settingDialogOnTop(other.m_settingDialogOnTop),
		m_tools(other.m_tools)
	{
		AddSettings();
	}
	virtual void fromString(const char*& cursor, unsigned __int64 version, char delimiter) override;
	VersionSetting m_version;
	IntSetting m_left;
	IntSetting m_top;
	IntSetting m_width;
	IntSetting m_height;
	IntSetting m_workspaceWidth;
	IntSetting m_toolboxWidth;
	IntSetting m_titleHeight;
	IntSetting m_valueWidth;
	UIntHexSetting m_defaultCommandToolOrdinal;
	PairSetting<IntSetting, IntSetting> m_settingDlgPosition;
	BoolSetting m_settingDialogOnTop;
	WindowMapSetting m_tools;
protected:
	void AddSettings()
	{
		AddSetting(m_version);
		AddSetting(m_left);
		AddSetting(m_top);
		AddSetting(m_width);
		AddSetting(m_height);
		AddSetting(m_workspaceWidth);
		AddSetting(m_toolboxWidth);
		AddSetting(m_titleHeight);
		AddSetting(m_valueWidth);
		AddSetting(m_defaultCommandToolOrdinal);
		AddSetting(m_settingDlgPosition);
		AddSetting(m_settingDialogOnTop);
		AddSetting(m_tools);
	}
};


enum ToolTipFilter : unsigned char
{
	TTFR_WORKSPACE,
	TTFR_LAYER,
	TTFR_TOOL,
	TTFR_VALUE,
	TTFR_CONTROL,

	TTFR_COUNT,
};

#define SECONDARY_ROWS

class TGUI_API TakionConfig : public ConfigBase
{
public:
	static const unsigned int maxRepeatOrderCount;
//	virtual ~TakionConfig();
	TakionConfig& operator=(const TakionConfig& other);

//	bool operator==(const TakionConfig& other) const;
//	bool operator!=(const TakionConfig& other) const{return !operator==(other);}
	virtual unsigned char GetFlagCount() const{return LF_COUNT;}
//	virtual unsigned __int64 GetSavedDateVersion() const{return U_GetVersion64(1, 0, 0, 135);}
//	virtual unsigned __int64 GetTotalScreenVersion() const{return U_GetVersion64(1, 0, 0, 147);}
//	virtual unsigned __int64 GetOptionVersion() const{return U_GetVersion64(1, 0, 1, 107);}

	virtual void Update();

	static void SaveView(WindowMapSetting& view);

//	virtual TakionConfig* Clone() const = 0;
	virtual void Copy(const ConfigBase& other){operator=((const TakionConfig&)other);}

	MainWndSetting m_mainWnd;

	WindowMapSetting m_defaultView;

	typedef MapSetting<StringSetting, WindowViewSetting, std::map<StringSetting, WindowViewSetting> > WindowViewMap;
	WindowViewMap m_windowViews;

	UInt64Setting m_externalLinkMask;
	UIntSetting m_workspaceCount;
	UIntSetting m_layerCount;
	typedef MapSetting<StringSetting, StringSetting, std::map<StringSetting, StringSetting> > StringStringMappingSetting;
	StringStringMappingSetting m_keyCommandMapping;
	UIntSetting m_fallThroughKeys;
	UCharSetting m_commandFilter;
	UShortSetting m_keyFilter;
	BoolSetting m_mappedOnTopKeys;
	BoolSetting m_mappedOnTopCommands;

	typedef MapSetting<StringSetting, StringSettingRest, std::map<StringSetting, StringSettingRest> > StringStringRestMappingSetting;
	StringStringRestMappingSetting m_namedFilterMapping;

	BoolSetting m_unuseUnselectedColumns;

	BoolSetting m_dragLinking;
//	BoolSetting m_confirmExit;
//	BoolSetting m_saveLayoutOnExit;

	BoolSetting m_cancelDefaultAccountOrdersOnExit;
	BoolSetting m_cancelDefaultAccountOrdersExceptGtcOnExit;

	BoolSetting m_cancelOtherAccountOrdersOnExit;
	BoolSetting m_cancelOtherAccountOrdersExceptGtcOnExit;

	BoolSetting m_marketSorterOnIdle;
	BoolSetting m_marketSorterImbalanceOnIdle;
	BoolSetting m_marketSorterUseTimeFrame;
	UShortSetting m_marketSorterTimeFrame;

	BoolSetting m_layoutAutosave;
	UIntSetting m_layoutAutosaveMillisecond;

//	typedef VectorSetting<StringSetting> StringVector;
//	typedef VectorSetting<StringVector> StringVectorVector;

#ifndef TAKION_NO_OPTIONS
	BoolSetting m_optionOnIdle;
	UIntSetting m_idleOptionUnderlierMinute;
	BoolSetting m_optionTitleAlign;
	StringVectorVector m_optionTitleValues;
	BoolSetting m_optionChainTitleAlign;
	StringVectorVector m_optionChainTitleValues;

	BoolSetting m_optionColorRecycle;
	VectorSetting<UIntSetting> m_optionColors;
	BoolSetting m_optionChainColorRecycle;
	VectorSetting<UIntSetting> m_optionChainColors;
#endif
	BoolSetting m_logDefaultAccountOnly;
//	BoolSetting m_closeDialogsOnEscape;
	UCharHexSetting m_mainWndToolTipFilter;
	BoolSetting m_toolTipsInFilterDialogs;
	BoolSetting m_lockWindows;
	BoolSetting m_alphabetizeWindowsInMenu;
	BoolSetting m_inventoryView;
	UCharSetting m_esignalLinkGroup;
	UCharSetting m_bloombergLinkGroup;
	BoolSetting m_extLinkWaitRefresh;
	BoolSetting m_extLinkRecipient;
	UIntSetting m_idleStockMinute;
	UIntSetting m_repeatOrderCommandCount;
	UIntSetting m_repeatOrderBoxCount;
	
//	BoolSetting m_settingDialogOnTop;

	UIntSetting m_maxBasketTierCount;
	UIntSetting m_maxOptionTierCount;

	BoolSetting m_useLevel2LockFailCount;
	UIntSetting m_level2LockFailCount;

	UIntSetting m_extLinkAdvancedGetMillisecond;
	BoolSetting m_extLinkAdvancedGetForceSend;

	UShortSetting m_marketSorterColumnCount;

	BoolSetting m_usePositionAlert;
	BoolSetting m_positionAlertAllAccounts;

	UIntSetting m_soundPurgeMillisecond;
	BoolSetting m_soundDisableAll;

	StringSettingRest m_newsContentsTemplate;

	BoolSetting m_tsRememberTempTier;
	typedef MapSetting<StringSetting, UIntSetting, std::map<StringSetting, UIntSetting> > TierSizeMap;
	TierSizeMap m_tierSizeMap;
	TierSizeMap m_customDateMap;
	typedef MapSetting<StringSetting, PriceSetting, std::map<StringSetting, PriceSetting> > CustomPriceBaseMap;
	CustomPriceBaseMap m_customPriceBaseMap;
	typedef MapSetting<StringSetting, AggregateOrderSizeSetting, std::map<StringSetting, AggregateOrderSizeSetting> > NamedOrderSizeMap;
	NamedOrderSizeMap m_namedOrderSizes;
	typedef MapSetting<StringSetting, AggregateOrderPriceSetting, std::map<StringSetting, AggregateOrderPriceSetting> > NamedOrderPriceMap;
	NamedOrderPriceMap m_namedOrderPrices;

//	PairSetting<IntSetting, IntSetting> m_fontDlgSize;
//	PairSetting<IntSetting, IntSetting> m_settingDlgPosition;
	PairSetting<IntSetting, IntSetting> m_mmFilterDlgSize;
	PairSetting<IntSetting, IntSetting> m_mmAttributionDlgSize;
	PairSetting<IntSetting, IntSetting> m_mmLevel1DlgSize;
	PairSetting<IntSetting, IntSetting> m_mmTitleDlgSize;

	typedef MapSetting<StringSetting, ColumnArraySetting, std::map<StringSetting, ColumnArraySetting> > ColumnMap;
	ColumnMap m_columns;
#ifdef SECONDARY_ROWS
	ColumnMap m_secondaryColumns;
	BoolSetting m_unuseUnselectedSecondaryColumns;
#endif
	typedef MapSetting<StringSetting, CommandAggregateSetting, std::map<StringSetting, CommandAggregateSetting> > CommandAggregateMap;
	CommandAggregateMap m_aggregateCommands;

	typedef MapSetting<StringSetting, SymbolToActiveCommandWindowCommandSetting, std::map<StringSetting, SymbolToActiveCommandWindowCommandSetting> > SymbolToActiveCommandWindowCommandMap;
	SymbolToActiveCommandWindowCommandMap m_symbolToActiveCommandWindowCommands;

//	typedef MapSetting<StringSetting, ActivateWindowCommandSetting, std::map<StringSetting, ActivateWindowCommandSetting> > ActivateWindowCommandMap;
	typedef MapSetting<StringSetting, EmptyCommandSetting, std::map<StringSetting, EmptyCommandSetting> > EmptyCommandMap;
	EmptyCommandMap m_activateWindowCommands;

	typedef MapSetting<StringSetting, ExtensionKeystrokeCommandSetting, std::map<StringSetting, ExtensionKeystrokeCommandSetting> > ExtensionKeystrokeCommandMap;
	ExtensionKeystrokeCommandMap m_extensionKeystrokeCommands;

	typedef MapSetting<StringSetting, NewsSetting, std::map<StringSetting, NewsSetting> > NewsCommandMap;
	NewsCommandMap m_newsCommands;

	typedef MapSetting<StringSetting, EmailSetting, std::map<StringSetting, EmailSetting> > EmailCommandMap;
	EmailCommandMap m_emailCommands;

	typedef MapSetting<StringSetting, PasswordSetting, std::map<StringSetting, PasswordSetting> > PasswordMap;
	PasswordMap m_emailPasswords;

	typedef MapSetting<StringSetting, StringSetting, std::map<StringSetting, StringSetting> > AcceleratorMap;
	AcceleratorMap m_acceleratorMap;

	typedef MapSetting<UIntSetting, UIntHexSetting, std::map<UIntSetting, UIntHexSetting> > PositionAlertMap;
	PositionAlertMap m_positionAlertMap;

	StringVector m_soundFileNames;

	StringVector m_level1Values;
	StringVector m_chartInfoValues;
	StringVector m_mainWndValues;

	StringVectorVector m_mmTitleValues;
//	SetSetting<StringSetting, std::set<StringSetting> > m_test;

	typedef MapSetting<LinkSetting, LinkSettingValue, std::map<LinkSetting, LinkSettingValue> > LinkMap;
	LinkMap m_apiLinks;

	typedef MapSetting<StringSetting, InventorySettingOld, std::map<StringSetting, InventorySettingOld>, settingDel> PositionInventoryMapOld;
	typedef MapSetting<StringSetting, PositionInventoryMapOld, std::map<StringSetting, PositionInventoryMapOld> > InventoryMap;
//	InventoryMap m_inventoryPositions;
	InventoryMap m_inventoryPositionMap;

	typedef MapSetting<StringSetting, AccountInventorySetting, std::map<StringSetting, AccountInventorySetting > > AccountInventoryMap;
	AccountInventoryMap m_accountInventoryMap;

//	typedef MapSetting<StringSetting, UCharSetting, std::map<StringSetting, UCharSetting> > InventoryHiddenSecurityTypeMap;
//	InventoryHiddenSecurityTypeMap m_inventoryHiddenSecurityTypes;

	typedef MapSetting<StringSetting, BoolSetting, std::map<StringSetting, BoolSetting>, settingDel> PositionPhantomMap;
	typedef MapSetting<StringSetting, PositionPhantomMap, std::map<StringSetting, PositionPhantomMap> > PhantomMap;
	PhantomMap m_phantomPositions;
	BoolSetting m_phantomPositionsSaveOvernight;

	typedef MapSetting<StringSetting, TokenExpressionSetting, std::map<StringSetting, TokenExpressionSetting > > SettingTokenExpressionMap;
	SettingTokenExpressionMap m_tokenExpressions;

	UCharSetting m_alertDefaultType;
	PriceSetting m_alertDefaultPrice;
	SignedPriceSetting m_alertDefaultIndex;
	UInt64Setting m_alertDefaultVolume;
//	UInt64Setting m_alertDefaultImbalance;
	IntSetting m_alertDefaultImbalance;
	UIntSetting m_alertDefaultColor;
	BoolSetting m_alertDefaultPopup;
	BoolSetting m_alertDefaultExpiration;

	VectorSetting<UIntHexSetting> m_alertCustomColors;

	IntSetting m_alertPinX;
	IntSetting m_alertPinY;
	BoolSetting m_alertPin;
	UIntHexSetting m_defaultCommandToolOrdinal;

	typedef MapSetting<AlertKeySetting, AlertValueSetting, std::map<AlertKeySetting, AlertValueSetting> > AlertMap;
	AlertMap m_alertMap;
	typedef MapSetting<AlertTriggeredKeySetting, AlertValueSetting, std::map<AlertTriggeredKeySetting, AlertValueSetting> > AlertTriggeredMap;
	AlertTriggeredMap m_alertTriggeredMap;

	IntSetting m_triggerPinX;
	IntSetting m_triggerPinY;
	BoolSetting m_triggerPin;

	IntSetting m_optionStuckPinX;
	IntSetting m_optionStuckPinY;
	BoolSetting m_optionStuckPin;

	typedef SetSetting<StringAsUIntSetting, std::set<StringAsUIntSetting> > StringAsUIntSet;
	StringAsUIntSet m_dQuoteMnemonicSet;

	unsigned int GetFilterMnemonicAt(const unsigned int& at) const
	{
		unsigned int ret = 0;
		if(at < m_filterMnemonicSet.GetCount())
		{
			unsigned int i = 0;
			for(StringAsUIntSet::ConstIterator it = m_filterMnemonicSet.GetConstBegin(), itend = m_filterMnemonicSet.GetConstEnd(); it != itend; ++it, ++i)
			{
				if(i >= at)
				{
					ret = it->GetValue();
					break;
				}
			}
		}
		return ret;
	}
	StringAsUIntSet m_filterMnemonicSet;

	typedef MapSetting<StringAsUInt64Setting, StringSetting, std::map<StringAsUInt64Setting, StringSetting> > StringAsUInt64Map;
	StringAsUInt64Map m_securityNoteMap;

	IntSetting m_positionAlertPinX;
	IntSetting m_positionAlertPinY;
	BoolSetting m_positionAlertPin;
	BoolSetting m_positionAlertExclude;
	typedef MapSetting<StringSetting, UIntSetting, std::map<StringSetting, UIntSetting> > StringUIntMap;
	StringUIntMap m_positionAlertExclusionMap;

	typedef std::set<std::string> StringSet;

	virtual bool isSettingNameToRead(unsigned int flags, const std::string& name) const override;

	bool isCommandString(const std::string& str) const{return m_commandStringSet.find(str) != m_commandStringSetEnd;}
	bool isCommandMapString(const std::string& str) const{return m_commandMapStringSet.find(str) != m_commandMapStringSetEnd;}
	bool isWindowsString(const std::string& str) const{return m_windowsStringSet.find(str) != m_windowsStringSetEnd;}
	bool isColumnString(const std::string& str) const{return m_columnStringSet.find(str) != m_columnStringSetEnd;}
	bool isAlertsString(const std::string& str) const{return m_alertsStringSet.find(str) != m_alertsStringSetEnd;}
	bool isPhantomsString(const std::string& str) const{return m_phantomsStringSet.find(str) != m_phantomsStringSetEnd;}
	bool isGraphicsString(const std::string& str) const{return m_graphicsMapStringSet.find(str) != m_graphicsMapStringSetEnd;}
	bool isSecurityNotesString(const std::string& str) const{return m_securityNotesMapStringSet.find(str) != m_securityNotesMapStringSetEnd;}
	bool isNamedFiltersString(const std::string& str) const{return m_namedFiltersMapStringSet.find(str) != m_namedFiltersMapStringSetEnd;}
	bool isBasketsString(const std::string& str) const{return m_basketsMapStringSet.find(str) != m_basketsMapStringSetEnd;}
	bool isNewsFilterString(const std::string& str) const{return m_newsFilterStringSet.find(str) != m_newsFilterStringSetEnd;}
	bool isIndexString(const std::string& str) const{return m_indexStringSet.find(str) != m_indexStringSetEnd;}

	unsigned __int64 GetNewsContentsTemplateVersion() const{return m_newsContentsTemplateVersion;}
	void UpdateNewsContentsTemplateVersion();
	void SetNewsContentsTemplateVersion(unsigned __int64 version){m_newsContentsTemplateVersion = version;}
protected:
	TakionConfig();
	TakionConfig(const TakionConfig& other);
	void AddSettings();
	virtual void AdjustOldVersion() override;
	virtual bool PreReadSetting(Setting* setting, const std::string& name, const char* cursor) override;

	unsigned __int64 m_newsContentsTemplateVersion;

	void AddCommandString(const char* str){m_commandStringSet.insert(std::string(str));}
	void AddCommandMapString(const char* str){m_commandMapStringSet.insert(std::string(str));}
	void AddWindowsString(const char* str){m_windowsStringSet.insert(std::string(str));}
	void AddColumnString(const char* str){m_columnStringSet.insert(std::string(str));}
	void AddAlertsString(const char* str){m_alertsStringSet.insert(std::string(str));}
	void AddPhantomsString(const char* str){m_phantomsStringSet.insert(std::string(str));}
	void AddGraphicsString(const char* str){m_graphicsMapStringSet.insert(std::string(str));}
	void AddSecurityNotesString(const char* str){m_securityNotesMapStringSet.insert(std::string(str));}
	void AddNamedFiltersString(const char* str){m_namedFiltersMapStringSet.insert(std::string(str));}
	void AddBasketsString(const char* str){m_basketsMapStringSet.insert(std::string(str));}
	void AddNewsFilterString(const char* str){m_newsFilterStringSet.insert(std::string(str));}
	void AddIndexString(const char* str){m_indexStringSet.insert(std::string(str));}
	StringSet m_commandStringSet;
	StringSet m_commandMapStringSet;
	StringSet m_windowsStringSet;
	StringSet m_columnStringSet;
	StringSet m_alertsStringSet;
	StringSet m_phantomsStringSet;
	StringSet m_graphicsMapStringSet;
	StringSet m_securityNotesMapStringSet;
	StringSet m_namedFiltersMapStringSet;
	StringSet m_basketsMapStringSet;
	StringSet m_newsFilterStringSet;
	StringSet m_indexStringSet;
	StringSet::const_iterator m_commandStringSetEnd;
	StringSet::const_iterator m_commandMapStringSetEnd;
	StringSet::const_iterator m_windowsStringSetEnd;
	StringSet::const_iterator m_columnStringSetEnd;
	StringSet::const_iterator m_alertsStringSetEnd;
	StringSet::const_iterator m_phantomsStringSetEnd;
	StringSet::const_iterator m_graphicsMapStringSetEnd;
	StringSet::const_iterator m_securityNotesMapStringSetEnd;
	StringSet::const_iterator m_namedFiltersMapStringSetEnd;
	StringSet::const_iterator m_basketsMapStringSetEnd;
	StringSet::const_iterator m_newsFilterStringSetEnd;
	StringSet::const_iterator m_indexStringSetEnd;
};

class TGUI_API LinkExternal
{
public:
	virtual ~LinkExternal(){}
	bool EstablishLink(bool force);
	virtual bool isLinkEstablished() const{return m_mainWindow != NULL && m_entryField != NULL;}
	virtual bool isLinkValid() const{return IsWindow(m_mainWindow) == TRUE && IsWindow(m_entryField) == TRUE;}
	virtual bool isManual() const{return false;}
	const std::string& GetName() const{return m_name;}
	const unsigned char& GetId() const{return m_id;}
	void SetId(const unsigned char& id){m_id = id;}
	void DecrementId(const unsigned char& id){if(m_id > id)m_id -= id; else m_id = 0;}
	void IncrementId(const unsigned char& id){m_id += id;}
	virtual void EraseSymbol() const{}

	bool SendSymbol(const char* symbol, TakionTool* tool, unsigned int mmOrdinal);//main thread
	
	void PostCharToEntryField(char c) const;
	virtual void PostCtrlKeyToField(HWND hwnd, WPARAM code) const;
	void PostCtrlKeyToEntryField(WPARAM code) const{PostCtrlKeyToField(m_entryField, code);}
	virtual void PostEnterKeyToEntryField() const;
//	virtual void PostDeleteKeyToEntryField() const;
	unsigned int GetUseCount() const{return m_useCount;}
	void IncrementUseCount();
	void DecrementUseCount();
	void Unlink();
	
	unsigned int GetSymbolBufferLength() const{return m_symbolBufferLength;}

	const HWND& GetMainWnd() const{return m_mainWindow;}
	const HWND& GetEntryField() const{return m_entryField;}

	virtual HWND isWindowLinkable(HWND hWhd) const{return NULL;}
	virtual void SetLinkToSpecificWindow(unsigned int mmOrdinal, HWND hWnd){}
	virtual void CommandWindowDestroyed(unsigned int mmOrdinal){}
	virtual void ClearSpecificWindowLink(unsigned int mmOrdinal){}
	virtual void ClearSpecificWindowLinks(){}
	virtual void SetActiveTool(unsigned int mmOrdinal){}

	virtual unsigned int GetActivateWindowSleepMilliseconds() const{return 0;}
	virtual void SetActivateWindowSleepMilliseconds(unsigned int milliseconds){}
	virtual bool isForceSendSymbol() const{return false;}
	virtual void SetForceSendSymbol(bool force){}
	virtual unsigned int GetLinkThreadId() const{return 0;}
	LinkExternal& operator=(const LinkExternal& other)
	{
		m_name = other.m_name;
		m_id = other.m_id;
		m_symbolBufferLength = other.m_symbolBufferLength;
		m_mainWindow = other.m_mainWindow;
		m_entryField = other.m_entryField;
		m_lastSymbol = other.m_lastSymbol;

//		m_symbolToSend = other.m_symbolToSend;//modified in link thread
//		m_symbolLastSent = other.m_symbolLastSent;//modified in link thread

//		m_useCount = other.m_useCount;
		m_postCtrlKeyAsWmChar = other.m_postCtrlKeyAsWmChar;
		m_sendMessages = other.m_sendMessages;
		m_escapeBeforeSymbol = other.m_escapeBeforeSymbol;
		m_activateBeforeSendSymbol = other.m_activateBeforeSendSymbol;

		m_delayAfterFirstChar = other.m_delayAfterFirstChar;
		m_delayAfterSymbol = other.m_delayAfterSymbol;

		m_delayAfterCharCount = other.m_delayAfterCharCount;
		m_delayCharCount = other.m_delayCharCount;
		m_delayAfterEscape = other.m_delayAfterEscape;
		m_delayBeforeSymbol = other.m_delayBeforeSymbol;
		return *this;
	}

//For Multi Windows
	virtual HWND FindActiveEntryField(){return NULL;}
	bool SetLinkToActiveExternalWindow(unsigned int mmOrdinal)
	{
		HWND entry = FindActiveEntryField();
		if(entry)
		{
			SetLinkToSpecificWindow(mmOrdinal, entry);
			return true;
		}
		else
		{
			ClearSpecificWindowLink(mmOrdinal);
			return false;
		}
	}
protected:
//	LinkExternal(const char* name, unsigned char id):m_name(name),m_id(id),m_mainWindow(NULL),m_entryField(NULL){}
	LinkExternal(const char* const& name,
		const unsigned int& symbolBufferLength,
		const bool& postCtrlKeyAsWmChar,
		const bool& sendMessages,
		const unsigned int& delayAfterFirstChar,
		const unsigned int& delayAfterSymbol,
		const unsigned int& delayAfterCharCount = 0,
		const unsigned int& delayCharCount = 0,
		const bool& escapeBeforeSymbol = false,
		const unsigned int& delayAfterEscape = 0,
		const unsigned int& delayBeforeSymbol = 0,
		const bool& activateBeforeSendSymbol = false):

//		m_linkThread(NULL),
		m_name(name),
		m_id(0xFF),
		m_symbolBufferLength(symbolBufferLength),
		m_mainWindow(NULL),
		m_entryField(NULL),
		m_useCount(0),
		m_postCtrlKeyAsWmChar(postCtrlKeyAsWmChar),
		m_sendMessages(sendMessages),
		m_escapeBeforeSymbol(escapeBeforeSymbol),
		m_activateBeforeSendSymbol(activateBeforeSendSymbol),
		m_delayAfterFirstChar(delayAfterFirstChar),
		m_delayAfterSymbol(delayAfterSymbol),
		m_delayAfterCharCount(delayAfterCharCount),
		m_delayCharCount(delayCharCount),
		m_delayAfterEscape(delayAfterEscape),
		m_delayBeforeSymbol(delayBeforeSymbol)

//		m_prevFocus(NULL),
//		m_forceFocus(forceFocus)
	{}
	LinkExternal(const LinkExternal& other):
		m_name(other.m_name),
		m_id(other.m_id),
		m_symbolBufferLength(other.m_symbolBufferLength),
		m_mainWindow(other.m_mainWindow),
		m_entryField(other.m_entryField),
		m_useCount(0),
		m_postCtrlKeyAsWmChar(other.m_postCtrlKeyAsWmChar),
		m_sendMessages(other.m_sendMessages),
		m_escapeBeforeSymbol(other.m_escapeBeforeSymbol),
		m_activateBeforeSendSymbol(other.m_activateBeforeSendSymbol),
		m_delayAfterFirstChar(other.m_delayAfterFirstChar),
		m_delayAfterSymbol(other.m_delayAfterSymbol),
		m_delayAfterCharCount(other.m_delayAfterCharCount),
		m_delayCharCount(other.m_delayCharCount),
		m_delayAfterEscape(other.m_delayAfterEscape),
		m_delayBeforeSymbol(other.m_delayBeforeSymbol)
	{
	}
	virtual void StartUsing(){}
	virtual void StopUsing(){}

	virtual void PreSendSymbol(HWND hwnd){}
	virtual void PostSendSymbol(HWND hwnd){}
	virtual unsigned int PrepareSendingSymbol(const char* symbol, TakionTool* tool);//main thread
	virtual void DoSendSymbol(const char* symbol, unsigned int length, TakionTool* tool, unsigned int mmOrdinal);//main thread
	virtual bool DoEstablishLink(){return false;}
	virtual void InvalidateLink(){}

	virtual void DoSetLinkToSpecificWindowInThread(unsigned int mmOrdinal, HWND hWnd){}
	virtual void DoSetActiveToolInThread(unsigned int mmOrdinal){}
	virtual void HandleCommandWindowDestroyedInThread(unsigned int mmOrdinal){}
	virtual void DoClearSpecificWindowLinksInThread(){}
	virtual void DoClearSpecificWindowLinkInThread(unsigned int mmOrdinal){}

	virtual void DoAddLinkWindowInThread(HWND hWnd){}

	void DeliverMessage(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) const;
	virtual void DeliverMessageToEntryField(UINT message, WPARAM wParam, LPARAM lParam) const
	{
		DeliverMessage(m_entryField, message, wParam, lParam);
	}

	virtual void SendSymbolToExternalApp();//link thread
	virtual void DoSendSymbolToExternalApp(const char* symbol);
	virtual void NewSymbol(const char* symbol, unsigned int length);//link thread
	virtual void Reset();

	virtual void LinkEstablished(){}

//	LinkThread* m_linkThread;
	std::string m_name;
	unsigned char m_id;
	unsigned int m_symbolBufferLength;
	HWND m_mainWindow;
	HWND m_entryField;
	std::string m_lastSymbol;//modified in main thread

	std::string m_symbolToSend;//modified in link thread
	std::string m_symbolLastSent;//modified in link thread

	unsigned int m_useCount;
	bool m_postCtrlKeyAsWmChar;
	bool m_sendMessages;
	bool m_escapeBeforeSymbol;
	bool m_activateBeforeSendSymbol;

	unsigned int m_delayAfterFirstChar;
	unsigned int m_delayAfterSymbol;

	unsigned int m_delayAfterCharCount;
	unsigned int m_delayCharCount;
	unsigned int m_delayAfterEscape;
	unsigned int m_delayBeforeSymbol;
//	HWND m_prevFocus;
//	bool m_forceFocus;
};

class TGUI_API LinkExternalThreaded : public LinkExternal
{
friend class LinkThread;
friend class RingBufferLinkControlMessageReader;
public:
	virtual ~LinkExternalThreaded(){DestroyLinkThread();}
	virtual unsigned int GetLinkThreadId() const override;
//	virtual void IncrementUseCount() override;
//	virtual void DecrementUseCount() override;
//	virtual void Unlink() override;
	LinkExternalThreaded& operator=(const LinkExternalThreaded& other);
protected:
	LinkExternalThreaded(const char* const& name,
		const unsigned int& symbolBufferLength,
		const bool& postCtrlKeyAsWmChar,
		const bool& sendMessages,
		const unsigned int& delayAfterFirstChar,
		const unsigned int& delayAfterSymbol,
		const unsigned int& delayAfterCharCount = 0,
		const unsigned int& delayCharCount = 0,
		const bool& escapeBeforeSymbol = false,
		const unsigned int& delayAfterEscape = 0,
		const unsigned int& delayBeforeSymbol = 0,
		const bool& activateBeforeSendSymbol = false):

		LinkExternal(name,
			symbolBufferLength,
			postCtrlKeyAsWmChar,
			sendMessages,
			delayAfterFirstChar,
			delayAfterSymbol,
			delayAfterCharCount,
			delayCharCount,
			escapeBeforeSymbol,
			delayAfterEscape,
			delayBeforeSymbol,
			activateBeforeSendSymbol),

		m_linkThread(NULL)
	{}
	LinkExternalThreaded(const LinkExternalThreaded& other);
	virtual void StartUsing() override;
	virtual void StopUsing() override;
	virtual void OnInitThread(){}
	virtual void DoSendSymbol(const char* symbol, unsigned int length, TakionTool* tool, unsigned int mmOrdinal) override;//main thread
	void CreateLinkThread();
	void DestroyLinkThread();
	virtual void LinkEstablished() override;
	LinkThread* m_linkThread;
};

class TGUI_API LinkExternalActivate : public LinkExternal
{
protected:
	LinkExternalActivate(const char* const& name,
		const unsigned int& symbolBufferLength,
		const bool& postCtrlKeyAsWmChar,
		const bool& sendMessages,
		const unsigned int& delayAfterFirstChar,
		const unsigned int& delayAfterSymbol,
		const unsigned int& delayAfterCharCount = 0,
		const unsigned int& delayCharCount = 0,
		const bool& escapeBeforeSymbol = false,
		const unsigned int& delayAfterEscape = 0,
		const unsigned int& delayBeforeSymbol = 0):

		LinkExternal(name,
			symbolBufferLength,
			postCtrlKeyAsWmChar,
			sendMessages,
			delayAfterFirstChar,
			delayAfterSymbol,
			delayAfterCharCount,
			delayCharCount,
			escapeBeforeSymbol,
			delayAfterEscape,
			delayBeforeSymbol),
		m_myThreadId(0),
		m_linkThreadId(0)
	{}
	virtual void DoSendSymbol(const char* symbol, unsigned int length, TakionTool* tool, unsigned int mmOrdinal) override;//main thread
	virtual void LinkEstablished() override;
	virtual void StartUsing() override;
	virtual void StopUsing() override;
	void CreateWindowThreadInput();
	void DestroyWindowThreadInput();
	DWORD m_myThreadId;
	DWORD m_linkThreadId;
};

typedef std::set<HWND> WindowSet;

class TGUI_API LinkWindowSet
{
public:
	LinkWindowSet():m_windowSetEnd(m_windowSet.end()){}
	LinkWindowSet(const LinkWindowSet& other):
		m_lastSymbolSent(other.m_lastSymbolSent),
		m_windowSet(other.m_windowSet),
		m_windowSetEnd(m_windowSet.end())
	{}
	LinkWindowSet& operator=(const LinkWindowSet& other)
	{
		m_lastSymbolSent = other.m_lastSymbolSent;
		m_windowSet = other.m_windowSet;
		return *this;
	}
	std::string m_lastSymbolSent;
	WindowSet m_windowSet;
	WindowSet::iterator m_windowSetEnd;
};

class TGUI_API LinkExternalMultipleWindows : public LinkExternalThreaded
{
public:
//	virtual bool SendSymbol(const char* symbol, TakionTool* tool, unsigned int mmOrdinal) override;// const;//main thread
	virtual void SetLinkToSpecificWindow(unsigned int mmOrdinal, HWND hWnd) override;
	virtual void CommandWindowDestroyed(unsigned int mmOrdinal) override;
	virtual void ClearSpecificWindowLink(unsigned int mmOrdinal) override;
	virtual void ClearSpecificWindowLinks() override;
	virtual void SetActiveTool(unsigned int mmOrdinal) override;
	virtual unsigned int GetActivateWindowSleepMilliseconds() const override{return m_activateWindowSleepMilliseconds;}
	virtual void SetActivateWindowSleepMilliseconds(unsigned int milliseconds) override{m_activateWindowSleepMilliseconds = milliseconds;}
	virtual bool isForceSendSymbol() const override{return m_forceSendSymbol;}
	virtual void SetForceSendSymbol(bool force) override{m_forceSendSymbol = force;}
	typedef std::map<unsigned int, LinkWindowSet> WindowMap;
//	typedef std::map<HWND, std::string> WindowSymbolMap;
	typedef std::map<unsigned int, std::string> StringMap;
	LinkExternalMultipleWindows& operator=(const LinkExternalMultipleWindows& other)
	{
		LinkExternalThreaded::operator=(other);
		m_activateWindowSleepMilliseconds = other.m_activateWindowSleepMilliseconds;
		m_forceSendSymbol = other.m_forceSendSymbol;
		m_windowMap = other.m_windowMap;
		m_symbolMap = other.m_symbolMap;
		return *this;
	}
protected:
	LinkExternalMultipleWindows(const char* const& name, 
		const unsigned int& symbolBufferLength,
		const bool& postCtrlKeyAsWmChar,
		const bool& sendMessages,
		const unsigned int& activateWindowSleepMilliseconds,
		const bool& forceSendSymbol,
		const unsigned int& delayAfterFirstChar,
		const unsigned int& delayAfterSymbol,
		const unsigned int& delayAfterCharCount = 0,
		const unsigned int& delayCharCount = 0,
		const bool& escapeBeforeSymbol = false,
		const unsigned int& delayAfterEscape = 0,
		const unsigned int& delayBeforeSymbol = 0,
		const bool& activateBeforeSendSymbol = false,
		const bool& mmBoxToOneWindowOnly = false):

		LinkExternalThreaded(name,
			symbolBufferLength,
			postCtrlKeyAsWmChar,
			sendMessages,
			delayAfterFirstChar,
			delayAfterSymbol,
			delayAfterCharCount,
			delayCharCount,
			escapeBeforeSymbol,
			delayAfterEscape,
			delayBeforeSymbol,
			activateBeforeSendSymbol),
		m_activateWindowSleepMilliseconds(activateWindowSleepMilliseconds),
		m_forceSendSymbol(forceSendSymbol),
		m_windowMapEnd(m_windowMap.end()),
		m_symbolMapEnd(m_symbolMap.end()),
		m_mmBoxToOneWindowOnly(mmBoxToOneWindowOnly)
	{}
	LinkExternalMultipleWindows(const LinkExternalMultipleWindows& other):
		LinkExternalThreaded(other),
		m_activateWindowSleepMilliseconds(other.m_activateWindowSleepMilliseconds),
		m_forceSendSymbol(other.m_forceSendSymbol),
		m_windowMap(other.m_windowMap),
		m_windowMapEnd(m_windowMap.end()),
		m_symbolMap(other.m_symbolMap),
		m_symbolMapEnd(m_symbolMap.end()),
		m_mmBoxToOneWindowOnly(other.m_mmBoxToOneWindowOnly)
	{}
	virtual unsigned int PrepareSendingSymbol(const char* symbol, TakionTool* tool) override;//main thread
	virtual void DoSendSymbol(const char* symbol, unsigned int length, TakionTool* tool, unsigned int mmOrdinal) override;//main thread
	virtual void NewSymbol(const char* symbol, unsigned int length) override;//link thread
	virtual void SendSymbolToExternalApp() override;

	virtual void DoSetLinkToSpecificWindowInThread(unsigned int mmOrdinal, HWND hWnd) override;
	virtual void DoSetActiveWindow(HWND hwnd) const{}
	virtual void DoSetActiveToolInThread(unsigned int mmOrdinal);
	virtual void HandleCommandWindowDestroyedInThread(unsigned int mmOrdinal);
	virtual void DoClearSpecificWindowLinksInThread();
	virtual void DoClearSpecificWindowLinkInThread(unsigned int mmOrdinal);
	virtual void SymbolSent(){}
	unsigned int m_activateWindowSleepMilliseconds;
	bool m_forceSendSymbol;
	WindowMap m_windowMap;
	WindowMap::iterator m_windowMapEnd;
	StringMap m_symbolMap;
	StringMap::iterator m_symbolMapEnd;
	bool m_mmBoxToOneWindowOnly;
//	WindowSymbolMap m_windowSymbolMap;
//	WindowSymbolMap::iterator m_windowSymbolMapEnd;
};

///////////////////////////////
//AccountConstraint
enum ConstraintId : unsigned int
{
	CI_BUYING_POWER,
	CI_HARD_BUYING_POWER,
	CI_DAY_POS_INVESTMENT,
	CI_NIGHT_POS_INVESTMENT,
	CI_DAY_LONG_INVESTMENT,
	CI_NIGHT_LONG_INVESTMENT,
	CI_DAY_SHORT_INVESTMENT,
	CI_NIGHT_SHORT_INVESTMENT,
	CI_NIGHT_INVESTMENT,
	CI_LOSS,
	CI_LOSS_SLACK,
	CI_LOSS_CLOSE,
	CI_LOSS_PER_POSITION,
	CI_LOSS_PER_POSITION_SLACK,
	CI_LOSS_PER_POSITION_CLOSE,
	CI_OPEN_LOSS_PER_POSITION,
	CI_TRADED_MONEY,
	CI_SHORT_PRICE,
	CI_SHARES_TOTAL,
	CI_SHARES_TRADED,
	CI_DAY_POS_SHARES,
	CI_NIGHT_POS_SHARES,
	CI_POS_PENDING_ORDERS,
	CI_OPEN_POSITIONS,
	CI_ORDER_SIZE,
	CI_ORDER_VALUE,
	CI_COMMISSION_FEE,
//	CI_AUTO_CLOSE_START_DELAY,
//	CI_AUTO_CLOSE_END_DELAY,

#ifndef TAKION_NO_OPTIONS
	CI_OPTION_BUYING_POWER,
	CI_OPTION_SHARES_TRADED,
	CI_OPTION_ORDER_SIZE,
	CI_OPTION_ORDER_VALUE,
	CI_OPTION_NAKED,
	CI_OPTION_CONTRACTS_OPEN,
	CI_OPTION_OPEN_POSITIONS,
#endif
	CI_ISO_ALLOWED,

	CI_SPOOFING_BIG_PRICE_OFFSET,
	CI_SPOOFING_SMALL_PRICE_OFFSET,
	CI_SPOOFING_ORDER_COUNT_RATIO,
	CI_SPOOFING_ORDER_SIZE_RATIO,

	CI_MIN_SHARE_PRICE,
	CI_MAX_SHARE_PRICE,

	CI_ADV_ORDER_COUNT,
	CI_ADV_ORDER_SIZE_RATIO,
	CI_ADV_BORDER,
	CI_ADV_FORCE_HIDDEN,
	CI_ADV_FORCE_HIDDEN_CLOSE,
	CI_ADV_REJECT,
	CI_BLOCK_AGGR_PRICE_PERCENT,

	CI_TIME_FRAME_VENUES,
	CI_ORDER_TIME_FRAME,
	CI_TIME_FRAME_ORDER_COUNT,

	CI_ORDER_SIZE_NBBO_VENUES,
	CI_ORDER_SIZE_NBBO_MULTIPLIER,

	CI_HTBT_ALLOWED,

	CI_MORNING_POS_INVESTMENT,
	CI_MORNING_LONG_INVESTMENT,
	CI_MORNING_SHORT_INVESTMENT,
	CI_MORNING_INVESTMENT,
	CI_MORNING_POS_SHARES,

	CI_NIGHT_LOSS,
	CI_MORNING_LOSS,
	CI_NIGHT_LOSS_CLOSE,
	CI_MORNING_LOSS_CLOSE,

	CI_NIGHT_LOSS_PER_POSITION,
	CI_MORNING_LOSS_PER_POSITION,
	CI_NIGHT_LOSS_PER_POSITION_CLOSE,
	CI_MORNING_LOSS_PER_POSITION_CLOSE,

	CI_CONSERVATIVE_ORDER_MARKING,
	CI_LOCAL_SIDE_MARKING,

	CI_MARGIN_EXCESS,
	CI_HARD_MARGIN_EXCESS,

	CI_POOL_LOCATES,

	CI_Count
};

class ConstraintItem
{
public:
	virtual ~ConstraintItem(){U_ReplaceText(m_tooltip, NULL);}
	const std::string& GetName() const{return m_name;}
	const char* const& GetTooltip() const{return m_tooltip;}
	bool isChecked() const{return m_baseItem.isCustom();}
	void SetChecked(bool checked){m_baseItem.SetCustom(checked);}
	virtual bool Spin(bool increment, unsigned int value){return false;}
	void Update()
	{
		if(m_item)
		{
			m_item->SetCustomEqual(m_baseItem);
		}
	}
	bool Reset()
	{
		bool ret = false;
		if(m_item)
		{
			if(!m_item->isSimulationEqual(m_baseItem))
			{
				m_baseItem.SetSimulationEqual(*m_item);
				ret = true;
			}
/*
			if(!m_item->isCustomEqual(m_baseItem))
			{
				m_baseItem.SetCustomEqual(*m_item);
				ret = true;
			}
*/
			if(!m_item->isEqual(m_baseItem))
			{
				m_baseItem.SetEqual(*m_item);
				ret = true;
			}
		}
		else
		{
			if(m_baseItem.isSimulation())
			{
				m_baseItem.SetSimulation(false);
				ret = true;
			}
			if(!m_baseItem.isZero())
			{
				m_baseItem.SetZero();
				ret = true;
			}
		}
		return ret;
	}
	bool SetItem(ConstraintBase* const& item, const bool& reset)
	{
		m_item = item;
		return reset && Reset();
	}
	bool isModified() const{return m_item && !m_item->isCustomEqual(m_baseItem);}
	virtual void ValueToString(std::string& str) const = 0;
	virtual void CustomValueToString(std::string& str) const = 0;
	virtual bool HasValue() const{return m_baseItem.HasValue();}
	virtual bool ZeroValueMeansNoConstraint() const{return !m_baseItem.ConstraintBase::HasValue();}
	virtual unsigned int GetIncrementValue(bool leftSideSpin, unsigned char ordinalSpin) const{return 0;}
	virtual bool isCustomValueUsed() const{return !m_item || m_item->isCustomValueUsed();}
	virtual bool isCustomValueNotUsed() const{return m_item && m_item->isCustomValueNotUsed();}
	const unsigned char& GetUpper() const{return m_baseItem.GetUpper();}//0 - lower, 1 - upper, 2 - upper with 0 as no constraint
	const bool& isFlags() const{return m_baseItem.isFlags();}
protected:
	ConstraintItem(const char* name, ConstraintBase& baseItem, const char* tooltip = NULL):
		m_name(name),
		m_tooltip(NULL),
		m_baseItem(baseItem),
		m_item(NULL)
	{
		U_ReplaceText(m_tooltip, tooltip);
	}
	std::string m_name;
	char* m_tooltip;
	ConstraintBase& m_baseItem;
	ConstraintBase* m_item;
};

template<class T>
class ConstraintItemTyped : public ConstraintItem
{
public:
	typedef T ValueType;
	virtual void GetDeltaValueFromUInt(ValueType& delta, unsigned int incrValue) const = 0;
	virtual bool Spin(bool increment, unsigned int incrValue)
	{
		if(m_item)
		{
			ValueType delta;
			GetDeltaValueFromUInt(delta, incrValue);
			ValueType& value = m_itemCopy.GetCustomValue();
			if(increment)
			{
				if(value < m_maxValue)
				{
					ValueType newValue = value + delta;
//					value += delta;
					if(newValue > m_maxValue || newValue < value)
					{
						value = m_maxValue;
					}
					else
					{
						value = newValue;
					}
					return true;
				}
			}
			else
			{
				if(value > m_minValue)
				{
					ValueType newValue = value - delta;
					if(newValue < m_minValue || newValue > value)
					{
						value = m_minValue;
					}
					else
					{
						value = newValue;
					}
					return true;
				}
			}
		}
		return false;
	}
	virtual void toString(const ValueType& value, std::string& str) const = 0;
	virtual void ValueToString(std::string& str) const{toString(m_itemCopy.GetValue(), str);}
	virtual void CustomValueToString(std::string& str) const{toString(m_itemCopy.GetCustomValue(), str);}
	virtual bool isCustomValueUsed() const{return m_itemCopy.isCustomValueUsed();}
	virtual bool isCustomValueNotUsed() const{return m_itemCopy.isCustomValueNotUsed();}
	const T& GetValue() const{return m_itemCopy.GetValue();}
	const T& GetCustomValue() const{return m_itemCopy.GetCustomValue();}
	const T& GetValueOrCustomValue() const{return isChecked() ? GetCustomValue() : GetValue();}
protected:
	ConstraintItemTyped(const char* name, const ValueType& maxValue, const ValueType& zeroValue, unsigned char upper, const ValueType& minValue, const char* tooltip = NULL):
		ConstraintItem(name, m_itemCopy, tooltip),
		m_itemCopy(zeroValue, zeroValue, false, upper),
		m_maxValue(maxValue),
		m_minValue(minValue)
	{}
	Constraint<T> m_itemCopy;
	T m_maxValue;
	T m_minValue;
};

template<class T>
class ConstraintItemMonetary : public ConstraintItemTyped<T>
{
public:
	virtual void GetDeltaValueFromUInt(ValueType& delta, unsigned int incrValue) const
	{
		unsigned int dollars = incrValue / m_divider;
		delta.SetValue(dollars, (incrValue - dollars * m_divider) * m_multiplier);
	}
protected:
	ConstraintItemMonetary(const char* name, const ValueType& maxValue, const T& zeroValue, unsigned char upper, unsigned char decDigits, const ValueType& minValue, const char* tooltip = NULL):
		ConstraintItemTyped(name, maxValue, zeroValue, upper, minValue, tooltip),
		m_decDigits(decDigits),
		m_divider(1),
		m_multiplier(T::divider)
	{
		for(decDigits = 0; decDigits < m_decDigits; ++decDigits)
		{
			m_divider *= 10;
		}
		m_multiplier /= m_divider;
	}

	unsigned char m_decDigits;
	unsigned int m_divider;
	unsigned int m_multiplier;
};

class ConstraintItemMoney : public ConstraintItemMonetary<Money>
{
public:
	ConstraintItemMoney(const char* name, const ValueType& maxValue, unsigned char upper, unsigned char decDigits, const ValueType& minValue = Money::moneyZero, const char* tooltip = NULL):
		ConstraintItemMonetary(name, maxValue, Money::moneyZero, upper, decDigits, minValue, tooltip)
	{
	}
	virtual void toString(const ValueType& value, std::string& str) const
	{
		U_MoneyToStr(str, value, m_decDigits, '\0');
	}
	virtual unsigned int GetIncrementValue(bool leftSideSpin, unsigned char ordinalSpin) const override
	{
		if(!leftSideSpin)
		{
			switch(ordinalSpin)
			{
				case 0:
				return 100;

				case 1:
				return 10000;

				case 3:
				return 10000000;

				case 4:
				return 100000000;
			}
		}
		return 0;
	}
};

class ConstraintItemPrice : public ConstraintItemMonetary<Price>
{
public:
	ConstraintItemPrice(const char* name, const ValueType& maxValue, unsigned char upper, unsigned char decDigits, const ValueType& minValue = Price::priceZero, const char* tooltip = NULL):
		ConstraintItemMonetary(name, maxValue, Price::priceZero, upper, decDigits, minValue, tooltip)
	{
	}
	virtual void toString(const ValueType& value, std::string& str) const
	{
		U_PriceToStr(str, value, m_decDigits, 0);
	}
	virtual unsigned int GetIncrementValue(bool leftSideSpin, unsigned char ordinalSpin) const override
	{
		if(!leftSideSpin)
		{
			switch(ordinalSpin)
			{
				case 0:
				return 1;

				case 1:
				return 100;

				case 2:
				return 10000;

				case 3:
				return 1000000;

				case 4:
				return 100000000;
			}
		}
		return 0;
	}
};

class ConstraintItemBool : public ConstraintItemTyped<unsigned char>
{
public:
//	ConstraintItemBool(const char* name, const char* tooltip = NULL):ConstraintItemTyped(name, 1, 0, 2, 0, tooltip){}
	ConstraintItemBool(const char* name, const char* tooltip = NULL):ConstraintItemTyped(name, 1, 0, 1, 0, tooltip){}
	virtual void GetDeltaValueFromUInt(ValueType& delta, unsigned int incrValue) const
	{
		delta = 1;
	}
	virtual void toString(const ValueType& value, std::string& str) const
	{
		str += value ? "Yes" : "No";
	}
	virtual bool HasValue() const{return true;}
};

class ConstraintItemUInt : public ConstraintItemTyped<unsigned int>
{
public:
	ConstraintItemUInt(const char* name, const ValueType& maxValue, unsigned char upper, const ValueType& minValue = 0, const char* tooltip = NULL):
		ConstraintItemTyped(name, maxValue, 0, upper, minValue, tooltip){}
	virtual void GetDeltaValueFromUInt(ValueType& delta, unsigned int incrValue) const
	{
		delta = incrValue;
	}
	virtual void toString(const ValueType& value, std::string& str) const
	{
		char num[33];
		str += U_UnsignedNumberToStrWithCommas(value, num, sizeof(num));
	}
};

class ConstraintItemInt : public ConstraintItemTyped<int>
{
public:
	ConstraintItemInt(const char* name, const ValueType& maxValue, const ValueType& minValue, unsigned char upper, const char* tooltip = NULL):
		ConstraintItemTyped(name, maxValue, 0, upper, minValue, tooltip){}
	virtual void GetDeltaValueFromUInt(ValueType& delta, unsigned int incrValue) const
	{
		delta = incrValue;
	}
	virtual void toString(const ValueType& value, std::string& str) const
	{
		char num[33];
		str += U_SignedNumberToStrWithCommas(value, num, sizeof(num));
	}
};

class TakionDialog;

class TGUI_API ListBoxConstraint : private ListBoxOwnerDraw
{
public:
	ListBoxConstraint(const COLORREF& colorBkValue,
		const COLORREF& colorCustomUsed = RGB(0, 0, 128),
		const COLORREF& colorCustomNotUsed = RGB(128, 0, 0),
		const COLORREF& colorZeroValueMeansNoConstraint = RGB(0, 0, 128),
		const COLORREF& colorLower = RGB(0, 128, 0)):
//		m_constraintCollection(NULL),
		m_constraintCollection("", false),
		m_colorBkValue(colorBkValue),
		m_colorCustomUsed(colorCustomUsed),
		m_colorCustomNotUsed(colorCustomNotUsed),
		m_colorZeroValueMeansNoConstraint(colorZeroValueMeansNoConstraint),
		m_colorLower(colorLower),
		m_valueWidth(0),
		m_nameLeft(0),
		m_nameRight(0),
		m_valueLeft(0),
		m_valueRight(0),
		m_customValueLeft(0),
		m_customValueRight(0),
		m_gap(3),
		m_accountPresent(false)
	{
		m_checkable = 1;
		m_selectable = false;
		AddSpinCell(false, 1);
		AddSpinCell(false, 100);
		AddSpinCell(false, 100000);
		AddSpinCell(false, 100000000);
		AddSpinCell(false, 1000000000);
	}
	void SetAccountPresent(const bool& accountPresent)
	{
		if(accountPresent != m_accountPresent)
		{
			m_accountPresent = accountPresent;
			if(m_hWnd)::InvalidateRect(m_hWnd, &CRect(m_valueLeft, 0, m_valueRight + m_gap, m_listBoxHeight), FALSE);
		}
	}
	virtual void DestroyItem(const void* item) const;
//	virtual void* CloneItem(const void* item) const;
//	virtual void ItemToString(const void* item, std::string& itemStr) const;//{itemStr = ((const StringUInt*)item)->GetNameStr();}
	virtual const char* GetItemName(const void* item) const;//{return ((const StringUInt*)item)->GetName();}
	virtual bool SpinItem(unsigned int at, bool increment, unsigned int value, bool leftSideSpin, unsigned char ordinalSpin);
	virtual bool isItemChecked(const void* item) const;
	virtual unsigned char GetRightVisibleSpinCellCount(unsigned int i) const;
//	unsigned int GetCount() const{return ListBoxOwnerDraw::GetCount();}
	const unsigned int& GetCount() const{return ListBoxOwnerDraw::GetItemCount();}
	const ConstraintItem* GetConstraintItem(unsigned int i) const{return (const ConstraintItem*)GetItemDataPtr(i);}
	ConstraintItem* GetConstraintItem(unsigned int i){return (ConstraintItem*)GetItemDataPtr(i);}
	bool isModified() const
	{
		for(unsigned int i = 0, end = GetCount(); i < end; ++i)
		{
			if(GetConstraintItem(i)->isModified())
			{
				return true;
			}
		}
		return false;
	}
	void Update()
	{
		for(unsigned int i = 0, end = GetCount(); i < end; ++i)
		{
			GetConstraintItem(i)->Update();
		}
	}
//	ConstraintCollection* const& GetConstraintCollection(){return m_constraintCollection;}
//	const ConstraintCollection* const& GetConstraintCollection() const{return m_constraintCollection;}
//	ConstraintCollection& GetConstraintCollection(){return m_constraintCollection;}
	const ConstraintCollection& GetConstraintCollection() const{return m_constraintCollection;}
	void SetConstraintCollection(ConstraintCollection* constraintCollection);
	void SetConstraintCollection(const Account* account);
	void SetItems(bool reset);
	void SetItem(const unsigned int& i, ConstraintBase* item, bool reset)
	{
		ConstraintItem* it = GetConstraintItem(i);
		if(item && it->SetItem(item, reset))InvalidateItem(i);
	}
	CWnd& GetWnd(){return *this;}
	const CWnd& GetWnd() const{return *this;}
//	HWND GetHwnd(){return m_hWnd;}
	HWND GetHwnd() const{return m_hWnd;}
	void AddListBoxToTakionDialog(TakionDialog* dlg);
	void SetSearchString(const char* searchString){ListBoxOwnerDraw::SetSearchString(searchString);}
	int MakeHighlightedItemVisibleIfNoneVisible(){return ListBoxOwnerDraw::MakeHighlightedItemVisibleIfNoneVisible();}
	bool EnableTooltips(const bool& enable, CToolTipCtrl* externalToolTip){return ListBoxOwnerDraw::EnableTooltips(enable, externalToolTip);}
//	virtual bool HasItemToolTips() const override{return false;}
protected:
	virtual void SetItemChecked(void* item, unsigned int i, bool checked) override;
	virtual bool GetToolTipInfo(unsigned int ordinal, const void* item, std::string& tooltipText, int& left, int& right) const override;
	void CalculateRects();
	virtual void DoDrawItem(const DRAWITEMSTRUCT* lpDrawItemStruct, const CRect& drawItemRect);
	virtual void ListBoxCreated();
//	virtual void Resize(int cx, int cy);
	virtual void SizeChanged(bool horizontalChange, bool verticalChange);

	virtual void DoCreateColumnToolTips() override;
	virtual void UpdateColumnToolTipsHorizontalBounds() override;

//	ConstraintCollection* m_constraintCollection;
	ConstraintCollection m_constraintCollection;

	COLORREF m_colorBkValue;
	COLORREF m_colorCustomUsed;
	COLORREF m_colorCustomNotUsed;

	COLORREF m_colorZeroValueMeansNoConstraint;
	COLORREF m_colorLower;

	int m_valueWidth;

	int m_nameLeft;
	int m_nameRight;
	int m_valueLeft;
	int m_valueRight;
	int m_customValueLeft;
	int m_customValueRight;

	int m_gap;

	bool m_accountPresent;
};
///////////////////////////////

class TGUI_API ChartStudy : public ColorStringItem
{
public:
	enum StudyType : unsigned char
	{
		ST_MOVING_AVERAGE,
		ST_RSI,
		ST_PRICE_RANGE_PERCENT,

		ST_Count
	};
//	virtual ~ChartStudy(){}
	virtual void ItemToString(std::string& itemStr) const{itemStr += m_name;}
	virtual void DrawValue(HDC dc, const CRect& rect) const{}
	virtual StudyType isA() const = 0;
	bool operator<(const ChartStudy& other) const
	{
		StudyType type = isA();
		StudyType otherType = other.isA();
//		return type == otherType ? m_historical == other.m_historical ? isLessSameType(other) : !m_historical : type < otherType;
		return type == otherType ? isLessSameType(other) < 0 : type < otherType;
	}
	bool operator==(const ChartStudy& other) const{return !(operator<(other) || other < *this);}
	bool operator!=(const ChartStudy& other) const{return operator<(other) || other < *this;}
	virtual ChartStudy* Clone() const = 0;
	virtual bool isHistorical() const{return false;}
	virtual void SetHistorical(const bool& historical){}//m_historical = historical;}
protected:
	ChartStudy(const char* name, COLORREF color):ColorStringItem(name, color){}
	virtual char isLessSameType(const ChartStudy& other) const = 0;//-1 if *this < other; 1 if *this > other; 0 if *this == other
};

class TGUI_API HistoricalChartStudy : public ChartStudy
{
public:
	virtual bool isHistorical() const override{return m_historical;}
	virtual void SetHistorical(const bool& historical) override{m_historical = historical;}
protected:
	HistoricalChartStudy(const char* name, COLORREF color, bool historical):ChartStudy(name, color), m_historical(historical){}
	virtual char isLessSameType(const ChartStudy& other) const override
	{
//		const HistoricalChartStudy& otherStudy = (const HistoricalChartStudy&)other;
		return m_historical == ((const HistoricalChartStudy&)other).m_historical ? 0:
			m_historical ? 1 : -1;
//		return !m_historical && ((const HistoricalChartStudy&)other).m_historical;
	}
	bool m_historical;
};

class TGUI_API ChartMovingAverage : public HistoricalChartStudy
{
public:
	enum WeightType : unsigned char
	{
		WT_SIMPLE,
		WT_EXPONENTIAL,

		WT_Count
	};
	enum PointType : unsigned char
	{
		PT_LAST,
		PT_LOW,
		PT_HIGH,

		PT_Count
	};
//	ChartMovingAverage(COLORREF color, bool historical, WeightType weightType, PointType pointType, unsigned short minuteCount);
	ChartMovingAverage(const COLORREF& color, const bool& historical, const WeightType& weightType, const PointType& pointType, const unsigned short& minuteCount):
		HistoricalChartStudy("MA", color, historical),
		m_weightType(weightType),
		m_pointType(pointType),
		m_minuteCount(minuteCount),
		m_alphaExponential(CalculateAlphaExponential(m_minuteCount))
	{
	}

	const WeightType& GetWeightType() const{return m_weightType;}
	bool SetWeightType(const WeightType& weightType)
	{
		if(weightType != m_weightType)
		{
			m_weightType = weightType;
			return true;
		}
		return false;
	}
	const PointType& GetPointType() const{return m_pointType;}
	bool SetPointType(const PointType& pointType)
	{
		if(pointType != m_pointType)
		{
			m_pointType = pointType;
			return true;
		}
		return false;
	}

	const unsigned short& GetMinuteCount() const{return m_minuteCount;}
	bool SetMinuteCount(const unsigned short& minuteCount)
	{
		if(minuteCount != m_minuteCount)
		{
			m_minuteCount = minuteCount;
			m_alphaExponential = CalculateAlphaExponential(m_minuteCount);
			return true;
		}
		return false;
	}
	virtual void ItemToString(std::string& itemStr) const override;
	void GetPointTypeAsString(std::string& itemStr) const;
	void GetWeightTypeAsString(std::string& itemStr) const;
	virtual void DrawValue(HDC dc, const CRect& rect) const;
	virtual StudyType isA() const override{return ST_MOVING_AVERAGE;}
	ChartStudy* Clone() const;
	static const unsigned int alphaMultiplier = 10000;
	static unsigned int CalculateAlphaExponential(unsigned short minuteCount);
	unsigned int GetAlphaExponential() const{return m_alphaExponential;}
protected:
	virtual char isLessSameType(const ChartStudy& other) const override
	{
		char ret = HistoricalChartStudy::isLessSameType(other);
		if(ret)
		{
			return ret;
		}
		else
		{
			const ChartMovingAverage& otherStudy = (const ChartMovingAverage&)other;
			return m_minuteCount < otherStudy.m_minuteCount ? -1:
				m_minuteCount > otherStudy.m_minuteCount ? 1:
				m_weightType < otherStudy.m_weightType ? -1:
				m_weightType > otherStudy.m_weightType ? 1:
				m_pointType < otherStudy.m_pointType ? -1:
				m_pointType > otherStudy.m_pointType ? 1:
				0;
		}
	}

	WeightType m_weightType;
	PointType m_pointType;
	unsigned short m_minuteCount;
	unsigned int m_alphaExponential;
};

class TGUI_API ChartRsi : public HistoricalChartStudy
{
public:
//	ChartRsi(const COLORREF& color, const bool& historical, const bool& daily, const unsigned short& priorPointCount, const unsigned short& periodLength, const unsigned short& periodCount, const unsigned short& startMinute):
//	ChartRsi(const COLORREF& color, const bool& historical, const unsigned short& priorPointCount, const unsigned short& periodLength, const unsigned short& periodCount, const unsigned short& startMinute):
//	ChartRsi(const COLORREF& color, const bool& historical, const unsigned short& periodLength, const unsigned short& periodCount):
	ChartRsi(const COLORREF& color, const bool& historical, const unsigned short& periodCount):
		HistoricalChartStudy("RSI", color, historical),
//		m_priorPointCount(priorPointCount),
//		m_periodLength(periodLength),
		m_periodCount(periodCount)
//		m_startMinute(startMinute)
//		m_daily(daily)
	{
	}
/*
	const unsigned short& GetPriorPointCount() const{return m_priorPointCount;}
	bool SetPriorPointCount(const unsigned short& priorPointCount)
	{
		if(priorPointCount != m_priorPointCount)
		{
			m_priorPointCount = priorPointCount;
			return true;
		}
		return false;
	}
*/
/*
	const unsigned short& GetPeriodLength() const{return m_periodLength;}
	bool SetPeriodLength(const unsigned short& periodLength)
	{
		if(periodLength != m_periodLength)
		{
			m_periodLength = periodLength;
			return true;
		}
		return false;
	}
*/
	const unsigned short& GetPeriodCount() const{return m_periodCount;}
	bool SetPeriodCount(const unsigned short& periodCount)
	{
		if(periodCount != m_periodCount)
		{
			m_periodCount = periodCount;
			return true;
		}
		return false;
	}
/*
	const unsigned short& GetStartMinute() const{return m_startMinute;}
	bool SetStartMinute(const unsigned short& startMinute)
	{
		if(startMinute != m_startMinute)
		{
			m_startMinute = startMinute;
			return true;
		}
		return false;
	}
*/
/*
	const bool& isDaily() const{return m_daily;}
	bool SetDaily(const bool& daily)
	{
		if(daily != m_daily)
		{
			m_daily = daily;
			return true;
		}
		return false;
	}
*/
	virtual void ItemToString(std::string& itemStr) const override;
	virtual void DrawValue(HDC dc, const CRect& rect) const;
	virtual StudyType isA() const override{return ST_RSI;}
	ChartStudy* Clone() const;
protected:
	virtual char isLessSameType(const ChartStudy& other) const override
	{
		char ret = HistoricalChartStudy::isLessSameType(other);
		if(ret)
		{
			return ret;
		}
		else
		{
			const ChartRsi& otherStudy = (const ChartRsi&)other;
			return //m_daily != otherStudy.m_daily ? m_daily ? -1 : 1:
//				m_priorPointCount < otherStudy.m_priorPointCount ? -1:
//				m_priorPointCount > otherStudy.m_priorPointCount ? 1:
//				m_periodLength < otherStudy.m_periodLength ? -1:
//				m_periodLength > otherStudy.m_periodLength ? 1:
				m_periodCount < otherStudy.m_periodCount ? -1:
				m_periodCount > otherStudy.m_periodCount ? 1:
//				m_startMinute < otherStudy.m_startMinute ? -1:
//				m_startMinute > otherStudy.m_startMinute ? 1:
				0;
		}
	}

//	unsigned short m_priorPointCount;
//	unsigned short m_periodLength;
	unsigned short m_periodCount;
//	unsigned short m_startMinute;
//	bool m_daily;
};

class TGUI_API ChartPriceRangePercent : public ChartStudy
{
public:
	ChartPriceRangePercent(COLORREF color, unsigned char percent):ChartStudy("$%", color), m_percent(percent){}
	const unsigned char& GetPercent() const{return m_percent;}
	bool SetPercent(unsigned char percent)
	{
		if(percent > 100)percent = 100;
		if(percent != m_percent)
		{
			m_percent = percent;
			return true;
		}
		return false;
	}
	virtual void ItemToString(std::string& itemStr) const override;
	virtual void DrawValue(HDC dc, const CRect& rect) const override;
	virtual StudyType isA() const{return ST_PRICE_RANGE_PERCENT;}
	ChartStudy* Clone() const;
protected:
	virtual char isLessSameType(const ChartStudy& other) const override
	{
		const ChartPriceRangePercent& otherStudy = (const ChartPriceRangePercent&)other;
		return m_percent < otherStudy.m_percent ? -1:
			m_percent > otherStudy.m_percent ? 1:
			0;
	}
	unsigned char m_percent;
};

class TGUI_API ListBoxChartStudy : public ListBoxColorString
{
public:
	ListBoxChartStudy(int nameWidth, COLORREF* customColors = NULL, unsigned int customColorCount = 0, COLORREF bkColor = 0xFFFFFFFF, int itemHeight = 0, bool rbuttonSelection = true, bool rbuttonMenu = true, bool draggable = false):
		ListBoxColorString(customColors, customColorCount, bkColor, itemHeight, rbuttonSelection, rbuttonMenu, draggable),
		m_nameWidth(nameWidth)
	{
	}
	virtual void ItemToString(const void* item, std::string& itemStr) const{((const ChartStudy*)item)->ItemToString(itemStr);}
    virtual int Compare(const void* item1, const void* item2) const;
protected:
	virtual void DrawNumber(const DRAWITEMSTRUCT* lpDrawItemStruct, const CRect& r);
	int m_nameWidth;
};

class TGUI_API KeyCommandPair
{
public:
	KeyCommandPair(const Key& key, Command* const& command, const bool& owner = false):
		m_key(key),
		m_command(command),
		m_searchRank(0),
		m_textWidth(0),
		m_owner(owner),
		m_fit(true)
	{
		if(m_command)
		{
			m_commandName = m_command->GetName();
			m_caseInsensitiveCommandName = m_command->GetCaseInsensitiveName();
		}
	}
	KeyCommandPair(Command* const& command, const bool& owner = false):
		m_key(command ? command->GetKey() : Key(0)),
		m_command(command),
		m_searchRank(0),
		m_textWidth(0),
		m_owner(owner),
		m_fit(true)
	{
		if(m_command)
		{
			m_commandName = m_command->GetName();
			m_caseInsensitiveCommandName = m_command->GetCaseInsensitiveName();
		}
	}
	virtual ~KeyCommandPair()
	{
		if(m_owner && m_command)
		{
			delete m_command;
		}
	}
	const Key& GetKey() const{return m_key;}
	Command* const& GetCommand(){return m_command;}
	const Command* const& GetCommand() const{return m_command;}
	const unsigned int& GetSearchRank() const{return m_searchRank;}

	void NullifyKey(){m_key.Nullify();}
	void SetKey(const Key& key){m_key = key;}
	void SetCommand(Command* const& command)
	{
		if(m_command != command)
		{
			m_command = command;
			if(m_command)
			{
				m_commandName = m_command->GetName();
				m_caseInsensitiveCommandName = m_command->GetCaseInsensitiveName();
			}
			else
			{
				m_commandName.clear();
				m_caseInsensitiveCommandName.clear();
			}
		}
	}
	void SetSearchRank(const unsigned int& rank){m_searchRank = rank;}

	int CompareKey(const KeyCommandPair& other, bool mappedOnTop) const;
	int CompareCommand(const KeyCommandPair& other, bool mappedOnTop) const;

	bool isKeyNull() const{return m_key.isNull();}
	bool isCommandNull() const{return m_command == NULL;}
	const char* GetCommandName() const{return m_commandName.c_str();}
	const char* GetCaseInsensitiveCommandName() const{return m_caseInsensitiveCommandName.c_str();}
	const std::string& GetCommandNameStr() const{return m_commandName;}
	const std::string& GetCaseInsensitiveCommandNameStr() const{return m_caseInsensitiveCommandName;}
	void SetCommandName(const char* const& commandName)
	{
		if(strcmp(m_commandName.c_str(), commandName))
		{
			m_commandName = commandName;
			m_caseInsensitiveCommandName = commandName;
			for(char* cursor = (char*)m_caseInsensitiveCommandName.c_str(); *cursor; ++cursor)
			{
				*cursor = toupper(*cursor);
			}
		}
	}
	void ResetCommandName()
	{
		if(m_command)
		{
			SetCommandName(m_command->GetName());
		}
		else
		{
			m_commandName.clear();
			m_caseInsensitiveCommandName.clear();
		}
	}
	bool operator==(const KeyCommandPair& other) const{return m_key == other.m_key && (m_command == other.m_command || m_command && other.m_command && !strcmp(m_command->GetName(), other.m_command->GetName()));}
	bool operator!=(const KeyCommandPair& other) const{return !operator==(other);}
	bool operator<(const KeyCommandPair& other) const
	{
		return m_command == other.m_command ? m_key < other.m_key :
			m_command != NULL && (!other.m_command || strcmp(m_command->GetName(), other.m_command->GetName()) < 0);
	}
	bool operator>(const KeyCommandPair& other) const
	{
		return other.m_command == m_command ? other.m_key < m_key :
			other.m_command != NULL && (!m_command || strcmp(other.m_command->GetName(), m_command->GetName()) < 0);
	}
	bool operator<=(const KeyCommandPair& other) const
	{
		return m_command == other.m_command ? m_key <= other.m_key :
			m_command != NULL && (!other.m_command || strcmp(m_command->GetName(), other.m_command->GetName()) <= 0);
	}
	bool operator>=(const KeyCommandPair& other) const
	{
		return other.m_command == m_command ? other.m_key <= m_key :
			other.m_command != NULL && (!m_command || strcmp(other.m_command->GetName(), m_command->GetName()) <= 0);
	}
	void SetFit(const bool& fit){m_fit = fit;}
	const bool& isFit() const{return m_fit;}
	void SetTextWidth(const int& width){m_textWidth = width;}
	const int& GetTextWidth() const{return m_textWidth;}
protected:
	Key m_key;
	Command* m_command;
	unsigned int m_searchRank;
	int m_textWidth;
	bool m_owner;
	bool m_fit;
	std::string m_commandName;
	std::string m_caseInsensitiveCommandName;
};

class TGUI_API AggregateKeyCommandPair : public KeyCommandPair
{
public:
	AggregateKeyCommandPair(const Key& key, Command* const& command, const bool& adjustableAllowed, const bool& owner = false):KeyCommandPair(key, command, owner), m_adjustableAllowed(adjustableAllowed){}
	AggregateKeyCommandPair(const KeyCommandPair& other, const bool& adjustableAllowed = false):KeyCommandPair(other), m_adjustableAllowed(adjustableAllowed){}
	const bool& isAdjustableAllowed() const{return m_adjustableAllowed;}
	bool SetAdjustableAllowed(const bool& adjustableAllowed)
	{
		if(adjustableAllowed != m_adjustableAllowed)
		{
			m_adjustableAllowed = adjustableAllowed;
			return true;
		}
		return false;
	}
protected:
	bool m_adjustableAllowed;
};

class TGUI_API KeyCommandListBox : public ListBoxOwnerDraw
{
public:
	const bool& isMappedOnTop() const{return m_mappedOnTop;}
	void SetMappedOnTop(bool mappedOnTop);
	const bool& isOwner() const{return m_owner;}
	bool SetOwner(const bool& owner)
	{
		if(owner != m_owner)
		{
			m_owner = owner;
			return true;
		}
		return false;
	}
	virtual bool isOneTooltipPerItem() const override{return false;}
	virtual bool isPairMapped(const KeyCommandPair* kcPair) const = 0;
	void Search(const char* searchStr);
	virtual COLORREF GetBkColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override;
	virtual COLORREF GetSelectedBkColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override;
	virtual COLORREF GetCommandColor(const Command* command) const;
	virtual bool isCommandMappable(const KeyCommandPair* kcPair) const{return kcPair && kcPair->GetCommand();}
//	virtual bool isKeyMappable(const KeyCommandPair* kcPair) const{return kcPair != NULL && !kcPair->GetCommand();}
	virtual bool isCommandUnmappable(const KeyCommandPair* kcPair) const{return kcPair && !kcPair->GetKey().isNull() && kcPair->GetCommand();}
	virtual bool isCommandMappableOrUnmappable(const KeyCommandPair* kcPair) const{return kcPair != NULL;}
	int CalculateKeyUnderMouse(CPoint point) const;
	void InvalidateCommand(int index) const;
	void InvalidateKey(int index) const;
	virtual unsigned int GetCommandJustification() const{return DT_LEFT;}
	void UpdateKeyUnderMouse();
//	static const COLORREF unknownCommandColor = RGB(32, 96, 32);
//	COLORREF GetCommandColor(unsigned int i) const{return i < CC_COUNT ? m_commandColors[i] : unknownCommandColor;}

	virtual void DestroyItem(const void* item) const override;
	virtual void* CloneItem(const void* item) const override;
	virtual bool toCloneItemOnDrop() const override{return m_owner;}
	virtual bool CanDropDuplicates() const override{return m_canDropDuplicates;}
	void SetCanDropDuplicates(const bool& can){m_canDropDuplicates = can;}
	const bool& isActiveMapping() const{return m_activeMapping;}
	void SetActiveMapping(const bool& active){m_activeMapping = active;}
	bool CopyNameSelectedCommand() const;
	bool EditSelectedCommand() const;
	virtual bool MapSelectedCommand() const;
	virtual bool UnmapSelectedCommand() const;
	const unsigned int& GetUnfitCount() const{return m_unfitCount;}
	int AddKeyCommandAndUpdateTooltips(const KeyCommandPair* kcPair);
	bool DeleteKeyCommandAndUpdateTooltips(unsigned int at);

	void EnableKeyTooltips(const bool& enable)
	{
		if(enable != m_keyTooltipsEnabled)
		{
			m_keyTooltipsEnabled = enable;
//			UpdateToolTipTexts();
			UpdateToolTips();
		}
	}

	void SetMapCommandMenu(const bool& mapCommandMenu){m_mapCommandMenu = mapCommandMenu;}

protected:
	KeyCommandListBox(int itemHeight, bool rbuttonSelection = false, bool rbuttonMenu = false, bool draggable = false, bool mapCommandMenu = false);

	void UpdateFit();
	void UpdateFitByWidth();
	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;
	virtual void OnItemAdded(void* item, unsigned int at, bool checked) override;
	virtual void BeforeItemDeleted(unsigned int at, bool checked) override;
//	virtual void AfterItemDeleted(unsigned int at, bool failed, bool checked) override;
	virtual void AfterItemsCleared() override;
	virtual bool GetToolTipInfo(unsigned int ordinal, const void* item, std::string& tooltipText, int& left, int& right) const override;

	virtual void OnFontSet(CFont* font, HDC hdc) override;
	void UpdateSizes(HDC hdc);

	virtual void AddMenuItems(CMenu& menu) override;
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;

	virtual void DeleteItem(LPDELETEITEMSTRUCT lpDeleteItemStruct) override;
	virtual void ListBoxCreated() override;
	virtual void BeforeDestroy() override;
//	virtual void Resize(int cx, int cy);
	virtual void SizeChanged(bool horizontalChange, bool verticalChange) override;
	virtual void CalculateKeyCommandRects(int width){}
	virtual void MouseLeft() override;
//	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	virtual void DoDrawItem(const DRAWITEMSTRUCT* lpDrawItemStruct, const CRect& drawItemRect) override;
	virtual void GetFocusItemRect(const DRAWITEMSTRUCT* lpDrawItemStruct, CRect& drawItemRect) const override;
	virtual void GetSelectionItemRect(const DRAWITEMSTRUCT* lpDrawItemStruct, CRect& drawItemRect) const override;

	void SetKeyUnderMouse(int itemUnderMouse);

	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	DECLARE_MESSAGE_MAP()

	bool m_mappedOnTop;
	bool m_owner;
	bool m_canDropDuplicates;
	bool m_activeMapping;
	COLORREF m_bkColor;
	COLORREF m_textColor;
	COLORREF m_shiftColor;
	COLORREF m_ctrlColor;
	COLORREF m_altColor;
	COLORREF m_capsColor;
	COLORREF m_numColor;
	COLORREF m_lightColor;
	COLORREF m_darkColor;
	int m_keyUnderMouse;
	int m_keyPressed;

	int m_keyWidth;
	int m_keyHeight;
	int m_modifierWidth;
	int m_locknumWidth;

	int m_keyLeftBorder;
	int m_keyRightBorder;
	int m_commandLeftBorder;
	int m_commandRightBorder;

	unsigned int m_unfitCount;

	bool m_keyTooltipsEnabled;
	bool m_mapCommandMenu;

	CFont* m_asciiFont;
	CFont* m_modifierFont;
//	CFont* m_commandFont;

//	COLORREF m_commandColors[CC_COUNT];
};

class TGUI_API KeyListBox : public KeyCommandListBox
{
public:
	KeyListBox(const int& itemHeight, const bool& rbuttonSelection = false, const bool& rbuttonMenu = false, bool draggable = false, bool mapCommandMenu = false) :
		KeyCommandListBox(itemHeight, rbuttonSelection, rbuttonMenu, draggable, mapCommandMenu){}//, m_commandToMap(NULL){}
	virtual bool isPairMapped(const KeyCommandPair* kcPair) const override{return !kcPair->isCommandNull();}
	virtual unsigned int GetCommandJustification() const override{return DT_RIGHT;}
protected:
//	virtual void BeforeDestroy() override{KeyCommandListBox::BeforeDestroy();  m_commandToMap = NULL;}
	virtual void CalculateKeyCommandRects(int width) override;
    virtual int Compare(const void* item1, const void* item2) const override;
	virtual bool GetToolTipInfo(unsigned int ordinal, const void* item, std::string& tooltipText, int& left, int& right) const override;
//	const Command* m_commandToMap;
};

class TGUI_API CommandListBox : public KeyCommandListBox
{
public:
	CommandListBox(const int& itemHeight, const bool& rbuttonSelection = false, const bool& rbuttonMenu = false, const bool& draggable = false, bool mapCommandMenu = false):
		KeyCommandListBox(itemHeight, rbuttonSelection, rbuttonMenu, draggable, mapCommandMenu),
		m_sortByCategory(true){}
	virtual bool isPairMapped(const KeyCommandPair* kcPair) const override{return !kcPair->isKeyNull();}
//	int FindItemByCommandName(const char* name) const;
	virtual const char* GetItemName(const void* item) const override;
	const bool& isSortByCategory() const{return m_sortByCategory;}
	void SetSortByCategory(const bool& byCategory){m_sortByCategory = byCategory;}
protected:
	virtual void CalculateKeyCommandRects(int width) override;
    virtual int Compare(const void* item1, const void* item2) const override;
	virtual bool GetToolTipInfo(unsigned int ordinal, const void* item, std::string& tooltipText, int& left, int& right) const override;
	bool m_sortByCategory;
};

class TGUI_API AggregateCommandListBox : public CommandListBox
{
public:
	AggregateCommandListBox(const int& itemHeight, const bool& rbuttonSelection = false, const bool& rbuttonMenu = false, const bool& draggable = false, bool mapCommandMenu = false):
		CommandListBox(itemHeight, rbuttonSelection, rbuttonMenu, draggable, mapCommandMenu)
	{
		m_checkable = 1;
		m_checkOnDoubleClick = false;
	}
	virtual bool isCheckItemEnabled(const void* item) const override
	{
		const Command* command = ((const KeyCommandPair*)item)->GetCommand();
		return command->isCustomDialogOrderCommand() || command->isAggregateCommand();
	}
	virtual bool isItemChecked(const void* item) const override{return ((const AggregateKeyCommandPair*)item)->isAdjustableAllowed();}
protected:
	virtual void AddMenuItems(CMenu& menu) override;
	virtual void SetItemChecked(void* item, unsigned int i, bool checked) override{((AggregateKeyCommandPair*)item)->SetAdjustableAllowed(checked);}
	virtual void CalculateKeyCommandRects(int width) override;
};

class MappableKeyCommandListBoxHelper
{
public:
	void SetKcPairToMap(const KeyCommandPair* const& kcPair){m_kcPairToMap = kcPair;}
	const KeyCommandPair* const& GetKcPairToMap() const{return m_kcPairToMap;}
protected:
	MappableKeyCommandListBoxHelper():m_kcPairToMap(NULL){}
	const KeyCommandPair* m_kcPairToMap;
};

class TGUI_API MappableCommandListBox : public CommandListBox, public MappableKeyCommandListBoxHelper
{
public:
	MappableCommandListBox(const int& itemHeight, const bool& rbuttonSelection = false, const bool& rbuttonMenu = false, const bool& draggable = false, bool mapCommandMenu = true):
		CommandListBox(itemHeight, rbuttonSelection, rbuttonMenu, draggable, mapCommandMenu)
	{}
	virtual bool isCommandMappable(const KeyCommandPair* kcPair) const override{return kcPair && kcPair->GetCommand() && kcPair->GetKey().isNull() && m_kcPairToMap && !m_kcPairToMap->GetCommand() && !m_kcPairToMap->GetKey().isNull();}
	virtual bool isCommandMappableOrUnmappable(const KeyCommandPair* kcPair) const override{return kcPair && !kcPair->GetKey().isNull() || m_kcPairToMap && !m_kcPairToMap->GetCommand();}
//	virtual bool isKeyMappable(const KeyCommandPair* kcPair) const{return kcPair != NULL && !kcPair->GetCommand();}
//	virtual bool isKeyUnmappable(const KeyCommandPair* kcPair) const{return kcPair != NULL && !kcPair->GetKey().isNull() && kcPair->GetCommand();}
	virtual bool MapSelectedCommand() const override;
	virtual bool UnmapSelectedCommand() const override;
protected:
	virtual void BeforeDestroy() override{CommandListBox::BeforeDestroy(); SetKcPairToMap(NULL);}
	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;
};

class TGUI_API MappableKeyListBox : public KeyListBox, public MappableKeyCommandListBoxHelper
{
public:
	MappableKeyListBox(const int& itemHeight, const bool& rbuttonSelection = false, const bool& rbuttonMenu = false, const bool& draggable = false, bool mapCommandMenu = true):
		KeyListBox(itemHeight, rbuttonSelection, rbuttonMenu, draggable, mapCommandMenu)
	{}
//	virtual bool isCommandMappable(const KeyCommandPair* kcPair) const override{return kcPair != NULL && kcPair->GetCommand() == NULL && m_commandToMap != NULL;}
	virtual bool isCommandMappable(const KeyCommandPair* kcPair) const override{return kcPair && !kcPair->GetCommand() && m_kcPairToMap && m_kcPairToMap->GetCommand() && m_kcPairToMap->GetKey().isNull();}
	virtual bool isCommandMappableOrUnmappable(const KeyCommandPair* kcPair) const override{return kcPair && kcPair->GetCommand() || m_kcPairToMap && m_kcPairToMap->GetKey().isNull();}
//	virtual bool isKeyMappable(const KeyCommandPair* kcPair) const{return kcPair != NULL && m_commandToMap != NULL && m_commandToMap->GetKey().isNull();}
	virtual bool MapSelectedCommand() const override;
	virtual bool UnmapSelectedCommand() const override;
protected:
	virtual void BeforeDestroy() override{KeyListBox::BeforeDestroy(); SetKcPairToMap(NULL);}
	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;
};

class TGUI_API ListBoxColumnInfoType : public ListBoxOwnerDraw
{
public:
	virtual const char* GetItemName(const void* item) const override;
	virtual void DestroyItem(const void* item) const override;
};

class StringOrderedSet;

class TGUI_API ListBoxEventSound : public ListBoxNamedFile
{
public:
	ListBoxEventSound();
	virtual void GetFileSet(StringOrderedSet& fileSet) const override;
	virtual COLORREF GetBkColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override;
	void SetItemTested(const int& itemTested)
	{
		if(itemTested != m_itemTested)
		{
			if(m_itemTested >= 0 && m_hWnd)
			{
				InvalidateItem(m_itemTested);
			}
			m_itemTested = itemTested;
			if(m_itemTested >= 0 && m_hWnd)
			{
				InvalidateItem(m_itemTested);
			}
		}
	}
protected:
	virtual void AddMenuItems(CMenu& menu) override;
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;
	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;
	virtual void ListBoxCreated() override;
	COLORREF m_grayColor;
	int m_itemTested;
};

class TGUI_API ListBoxKeyFallThrough : public ListBoxUInt
{
public:
	ListBoxKeyFallThrough(const bool& draggable = true):
		ListBoxUInt(false, false, draggable),
		m_checkMask(0)
	{
		m_checkable = 1;
		m_hAlignment = DT_LEFT;
	}
	virtual const char* GetItemName(const void* item) const
	{
		switch((unsigned int)
#if (_MSC_VER > 1600)
			(size_t)
#endif
			item)
		{
			case FTK_NUM:
			return "Num";
			
			case FTK_RIGHT:
			return "Right";
			
			case FTK_CAPS:
			return "Caps";
			
			default:
			return "";
		}
	}
//	virtual const char* GetItemToolTip(int sel, const void* item) const override
	virtual bool GetToolTipInfo(unsigned int ordinal, const void* item, std::string& tooltipText, int& left, int& right) const override
	{
		if(!ordinal)
		{
			switch((unsigned int)
#if (_MSC_VER > 1600)
				(size_t)
#endif
				item)
			{
				case FTK_NUM:
				tooltipText = "If a Keystroke with \"NumLock\" is not mapped to a Command, try to invoke the Command mapped to the same Keystroke without \"NumLock\"";
				break;

				case FTK_RIGHT:
				tooltipText = "If a Keystroke with a Right hand side modifier (Shift, Alt, Ctrl) is not mapped to a Command, try to invoke the Command mapped to the same Keystroke with the Left hand side modifier";
				break;

				case FTK_CAPS:
				tooltipText = "If a Keystroke with \"CapsLock\" is not mapped to a Command, try to invoke the Command mapped to the same Keystroke without \"CapsLock\"";
				break;

				default:
				return false;
			}
			return true;
		}
		return false;
	}
	virtual bool isItemChecked(const void* item) const{return (m_checkMask & (1 << (unsigned int)
#if (_MSC_VER > 1600)
		(size_t)
#endif
		item)) != 0;}

	const unsigned int& GetCheckMask() const{return m_checkMask;}
protected:
	virtual void SetItemChecked(void* item, unsigned int i, bool checked) override
	{
		if(checked)m_checkMask |= (1 << (unsigned int)
#if (_MSC_VER > 1600)
			(size_t)
#endif
			item);
		else m_checkMask &= ~(1 << (unsigned int)
#if (_MSC_VER > 1600)
			(size_t)
#endif
			item);
	}
	unsigned int m_checkMask;
//	virtual void DoDrawItem(const DRAWITEMSTRUCT* lpDrawItemStruct, const CRect& drawItemRect);
};

class TGUI_API ListBoxIndex : public ListBoxOwnerDraw
{
public:
	ListBoxIndex(const bool& rbuttonSelection = false, const bool& rbuttonMenu = false, const bool& draggable = false):ListBoxOwnerDraw(0, rbuttonSelection, rbuttonMenu, draggable){}
//	virtual ~ListBoxIndex();
//	virtual CBrush* GetBkBrush() const{return m_brush;}
	virtual const char* GetItemName(const void* item) const;
//	void SetBrush(CBrush* brush, bool own);
//	virtual COLORREF GetBkColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const;
//	virtual COLORREF GetStringColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const;
protected:
//	COLORREF m_bkColor;
//	CBrush* m_brush;
//	bool m_ownBrush;
};

class TGUI_API MmItem : public StringUChar
{
public:
	MmItem(const char* const& name,
		const unsigned char& number,
		const unsigned char& marketCenterId,
		const unsigned char& bookId,
		const bool& canHaveLevel1):
		StringUChar(name, number),
		m_marketCenterId(marketCenterId),
		m_bookId(bookId),
		m_canHaveLevel1(canHaveLevel1)
	{}
	const unsigned char& GetMarketCenterId() const{return m_marketCenterId;}
	const unsigned char& GetBookId() const{return m_bookId;}
	const bool& CanHaveLevel1() const{return m_canHaveLevel1;}
protected:
	unsigned char m_marketCenterId;
	unsigned char m_bookId;
	bool m_canHaveLevel1;
};

class TGUI_API ListBoxMmFilter : public ListBoxStringUInt
{
public:
	ListBoxMmFilter(const unsigned char& maxQuoteFilterCount, const char* const& tooltipText = NULL):
		ListBoxStringUInt(0, true, true, false, tooltipText),
		m_maxQuoteFilterCount(maxQuoteFilterCount),
		m_colorFilter(RGB(128, 0, 0))
	{}
	virtual COLORREF GetSelectedBkColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override;
	virtual COLORREF GetStringColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override
	{
		return (lpDrawItemStruct->itemState & ODS_SELECTED) == 0 ? GetSelectedBkColor(lpDrawItemStruct) : GetSysColor(COLOR_HIGHLIGHTTEXT);
	}
	virtual void* CloneItem(const void* item) const override;
	virtual bool SpinItem(unsigned int at, bool increment, unsigned int value, bool leftSideSpin, unsigned char ordinalSpin) override;
	const unsigned char& GetMaxQuoteFilterCount() const{return m_maxQuoteFilterCount;}
	unsigned char GetItemMaxCount(const MmItem* const& item) const
	{
		return item->GetBookId() == 0xFF ? 1 : m_maxQuoteFilterCount;
	}
	unsigned char GetItemMaxCount(const unsigned int& index) const
	{
		return index < m_itemCount ? GetItemMaxCount((const MmItem*)GetItemDataPtr(index)) : 0;
	}
	unsigned int GetCopy(unsigned char* ecnFilter) const;//returns exchangeFilter
	int FillListBox(const unsigned int& exchangeFilterMask, const unsigned char* lineCount);//returns -2 if nothing changed; -1 if multiple items changed;>= 0 if a single item changed
	int Paste();//Takes the values from TakionMainWnd; Notifies Parent with WM_USER + 28; returns -2 if nothing changed; -1 if multiple items changed;>= 0 if a single item changed
	void MakeCopy() const;//Copies state into TakionMainWnd
	static bool IncrementMmNumber(MmItem* item, const unsigned char maxCount);
	bool IncrementListBoxMmNumber();
	void GetCountState(bool& zero, bool& one, bool& all) const;
protected:
	virtual void DrawNumber(const DRAWITEMSTRUCT* lpDrawItemStruct, const CRect& r) override;
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;
	virtual void AddMenuItems(CMenu& menu) override;
	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;
	COLORREF m_colorFilter;
	unsigned char m_maxQuoteFilterCount;
};

class TGUI_API ListBoxEcn : public ListBoxOwnerDraw
{
public:
//	ListBoxEcn(const char* nullObjectName = "", unsigned char checkable = 1, bool owner = false, bool rButtonSelection = false);
	ListBoxEcn(const char* const& nullObjectName, const unsigned char& checkable, const bool& owner, const bool& rButtonSelection, const char* const& tooltipText = NULL):
		ListBoxOwnerDraw(0, rButtonSelection, checkable != 0, false, tooltipText),
		m_nullObjectName(nullObjectName),
		m_checkMask(0),
		m_owner(owner)
	{
		m_checkable = checkable;
	}
	virtual void* CloneItem(const void* item) const;
	virtual const char* GetItemName(const void* item) const;
	void SetCheckMask(unsigned int mask);
	const unsigned int& GetCheckMask() const{return m_checkMask;}
//	virtual bool SpinItem(unsigned int at, bool increment, unsigned int value, bool leftSideSpin, unsigned char ordinalSpin);
	virtual bool isItemChecked(const void* item) const;
	virtual void DestroyItem(const void* item) const;
	virtual bool HasItemToolTips() const{return false;}
protected:
	virtual void SetItemChecked(void* item, unsigned int i, bool checked) override;
//	virtual void DrawNumber(const DRAWITEMSTRUCT* lpDrawItemStruct, const CRect& r);
//	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual void AddMenuItems(CMenu& menu);
	const char* m_nullObjectName;
	unsigned int m_checkMask;
	bool m_owner;
};

class TGUI_API ComboBoxEcn : public ComboBoxOwnerDraw
{
public:
	ComboBoxEcn(const char* nullObjectName = "", bool owner = false, const char* tooltipText = NULL);
	virtual const char* GetItemName(const void* item) const override;
	virtual void DestroyItem(const void* item) const override;
protected:
	const char* m_nullObjectName;
	bool m_owner;
};

class TGUI_API CommandComboBox : public ComboBoxOwnerDraw
{
public:
	CommandComboBox(bool editCommandMenu, bool mapCommandMenu, COLORREF disabledColor = 0xFFFFFFFF, int itemHeight = 0, const char* tooltipText = NULL, bool owner = true);
	static const COLORREF unknownCommandColor = RGB(32, 96, 32);
//	COLORREF GetCommandColor(unsigned int i) const{return i < CC_COUNT ? m_commandColors[i] : unknownCommandColor;}
	COLORREF GetCommandColor(const Command* command) const;
	virtual COLORREF GetSelectedBkColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override;
	const bool& isMappedOnTop() const{return m_mappedOnTop;}
	void SetMappedOnTop(bool mappedOnTop);
//	virtual
	bool isPairMapped(const KeyCommandPair* kcPair) const{return !kcPair->isKeyNull();}
	const bool& isOwner() const{return m_owner;}
	bool SetOwner(const bool& owner)
	{
		if(owner != m_owner)
		{
			m_owner = owner;
			return true;
		}
		return false;
	}
    virtual int Compare(const void* item1, const void* item2) const override;
//	int FindItemByCommandName(const char* name) const;
	virtual const char* GetItemName(const void* item) const override;
	bool CopyNameSelectedCommand() const;
	bool EditSelectedCommand() const;
	virtual bool MapSelectedCommand() const;
	virtual bool UnmapSelectedCommand() const;

	const unsigned int& GetUnfitCount() const{return m_unfitCount;}
	virtual const char* GetItemToolTip(int sel, const void* item) const override;

protected:
//	virtual void Resize(int cx, int cy);
	void UpdateFit();
	void UpdateFitByWidth();
	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;
	virtual void SizeChanged(bool horizontalChange, bool verticalChange) override;
	virtual void CalculateKeyCommandRects(int width);
	virtual void DeleteItem(LPDELETEITEMSTRUCT lpDeleteItemStruct) override;
	virtual void DoDrawItem(const DRAWITEMSTRUCT* lpDrawItemStruct, const CRect& drawItemRect) override;
	virtual void AddMenuItems(CMenu& menu) override;
	virtual void ComboBoxCreated() override;
	virtual void BeforeDestroy() override;

	virtual void OnItemAdded(void* item, unsigned int at) override;
	virtual void BeforeItemDeleted(unsigned int at) override;
	virtual void AfterItemsCleared() override;

//	virtual void OnItemSelected() override;

	virtual void OnFontSet(CFont* font, HDC hdc) override;
	void UpdateSizes(HDC hdc);

	bool m_mappedOnTop;
	bool m_owner;
	bool m_editCommandMenu;
	bool m_mapCommandMenu;
	COLORREF m_bkColor;
	COLORREF m_textColor;
	COLORREF m_shiftColor;
	COLORREF m_ctrlColor;
	COLORREF m_altColor;
	COLORREF m_capsColor;
	COLORREF m_numColor;
	COLORREF m_lightColor;
	COLORREF m_darkColor;

	int m_keyWidth;
	int m_keyHeight;
	int m_modifierWidth;
	int m_locknumWidth;

	int m_keyLeftBorder;
	int m_keyRightBorder;
	int m_commandLeftBorder;
	int m_commandRightBorder;

//	void UpdateFit(HDC hdc);
	unsigned int m_unfitCount;

	CFont* m_asciiFont;
	CFont* m_modifierFont;
//	CFont* m_commandFont;

//	COLORREF m_commandColors[CC_COUNT];
};

class TGUI_API CommandComboBoxSimpleSort : public CommandComboBox
{
public:
	CommandComboBoxSimpleSort(bool editCommandMenu, bool mapCommandMenu, COLORREF disabledColor = 0xFFFFFFFF, int itemHeight = 0, const char* tooltipText = NULL, bool owner = true):
		CommandComboBox(editCommandMenu, mapCommandMenu, disabledColor, itemHeight, tooltipText, owner)
	{}
    inline static int CompareCommands(const Command* const& c1, const Command* const& c2)
	{
		return c1->GetCategory() < c2->GetCategory() ? -1:
			c1->GetCategory() > c2->GetCategory() ? 1:
			strcmp(c1->GetName(), c2->GetName());
	}

//	virtual int Compare(const void* item1, const void* item2) const override;
};

class TGUI_API CommandComboBoxSimpleSortNull : public CommandComboBoxSimpleSort
{
public:
	CommandComboBoxSimpleSortNull(bool editCommandMenu, bool mapCommandMenu, COLORREF disabledColor = 0xFFFFFFFF, int itemHeight = 0, const char* tooltipText = NULL, bool owner = true):
		CommandComboBoxSimpleSort(editCommandMenu, mapCommandMenu, disabledColor, itemHeight, tooltipText, owner)
	{}
    virtual int Compare(const void* item1, const void* item2) const override
	{
		const Command* c1 = ((const KeyCommandPair*)item1)->GetCommand();
		const Command* c2 = ((const KeyCommandPair*)item2)->GetCommand();
		return c1 == c2 ? 0:
			!c1 ? -1:
			!c2 ? 1:
			CompareCommands(c1, c2);
/*
		const KeyCommandPair* kc1 = (const KeyCommandPair*)item1;
		const KeyCommandPair* kc2 = (const KeyCommandPair*)item2;
		return kc1 == kc2 ? 0:
			!kc1 ? -1:
			!kc2 ? 1:
			CompareCommands(kc1->GetCommand(), kc2->GetCommand());
*/
	}
};

class TGUI_API ListBoxConstraintCollection : public ListBoxFit
{
public:
	ListBoxConstraintCollection(bool rbuttonSelection = false, bool rbuttonMenu = false, bool draggable = false, const char* nullAccountName = "", bool useBoldFont = true, const char* tooltipText = NULL):
		ListBoxFit(0, rbuttonSelection, rbuttonMenu, draggable, useBoldFont, tooltipText),
		m_nullAccountName(nullAccountName)
	{}
	virtual int Compare(const void* item1, const void* item2) const override;
	virtual void DestroyItem(const void* item) const override;
	virtual const char* GetItemName(const void* item) const override;
	virtual bool isNullItemOk() const{return true;}//Can you pass a NULL in the FindItem function ?
protected:
	std::string m_nullAccountName;
};

class TGUI_API ComboBoxConstraintCollection : public ComboBoxBoldItem
{
public:
	ComboBoxConstraintCollection(COLORREF disabledColor = 0xFFFFFFFF, const char* nullAccountName = "", bool useBoldFont = true, const char* tooltipText = NULL):
		ComboBoxBoldItem(disabledColor, useBoldFont, tooltipText),
		m_nullAccountName(nullAccountName)
	{}
	virtual int Compare(const void* item1, const void* item2) const override;
	virtual void DestroyItem(const void* item) const override;
	virtual const char* GetItemName(const void* item) const override;
protected:
	std::string m_nullAccountName;
};
/*
class TGUI_API ListBoxAccount : public ListBoxConstraintCollection
{
public:
	ListBoxAccount(bool rbuttonSelection = false, bool rbuttonMenu = false, bool draggable = false, const char* nullAccountName = "", bool useBoldFont = true, const char* tooltipText = NULL):
		ListBoxConstraintCollection(rbuttonSelection, rbuttonMenu, draggable, nullAccountName, useBoldFont, tooltipText)
	{}
	virtual void DestroyItem(const void* item) const override{}
	virtual COLORREF GetStringColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override;
	virtual COLORREF GetSelectedBkColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override;
	virtual COLORREF GetBkColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const;
};

class TGUI_API ComboBoxAccount : public ComboBoxConstraintCollection
{
public:
	ComboBoxAccount(COLORREF disabledColor = 0xFFFFFFFF, const char* nullAccountName = "", bool useBoldFont = true, const char* tooltipText = NULL):
		ComboBoxConstraintCollection(disabledColor, nullAccountName, useBoldFont, tooltipText)
	{}
	virtual void DestroyItem(const void* item) const override{}
protected:
};
*/
class TGUI_API ListBoxAccount : public ListBoxFit
{
public:
	ListBoxAccount(bool rbuttonSelection = false, bool rbuttonMenu = false, bool draggable = false, const char* nullAccountName = "", bool useBoldFont = true, const char* tooltipText = NULL):
		ListBoxFit(0, rbuttonSelection, rbuttonMenu, draggable, useBoldFont, tooltipText),
		m_nullAccountName(nullAccountName)
	{}
//	virtual void DestroyItem(const void* item) const override{}
	virtual COLORREF GetStringColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override;
	virtual COLORREF GetSelectedBkColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override;
	virtual COLORREF GetBkColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override;
	virtual int Compare(const void* item1, const void* item2) const override
	{
		return item1 ?
			item2 ? ListBoxFit::Compare(item1, item2) : 1 :
			item2 ? -1 : 0;
	}
	virtual const char* GetItemName(const void* item) const override{return item ? ((const Account*)item)->GetId() : m_nullAccountName.c_str();}
	virtual bool isNullItemOk() const override{return true;}//Can you pass a NULL in the FindItem function ?
protected:
	std::string m_nullAccountName;
};

class TGUI_API ComboBoxAccount : public ComboBoxBoldItem
{
public:
	ComboBoxAccount(COLORREF disabledColor = 0xFFFFFFFF, const char* nullAccountName = "", bool useBoldFont = true, const char* tooltipText = NULL):
		ComboBoxBoldItem(disabledColor, useBoldFont, tooltipText),
		m_nullAccountName(nullAccountName)
	{}
//	virtual void DestroyItem(const void* item) const override{}
	virtual int Compare(const void* item1, const void* item2) const override
	{
		return item1 ?
			item2 ? ComboBoxBoldItem::Compare(item1, item2) : 1 :
			item2 ? -1 : 0;
	}
	virtual const char* GetItemName(const void* item) const override{return item ? ((const Account*)item)->GetId() : m_nullAccountName.c_str();}
protected:
	std::string m_nullAccountName;
};

class TGUI_API ComboBoxClearingFirm : public ComboBoxOwnerDraw
{
public:
	ComboBoxClearingFirm(COLORREF disabledColor = 0xFFFFFFFF, const char* tooltipText = NULL):
		ComboBoxOwnerDraw(disabledColor, 0, false, tooltipText)
	{}
//	virtual int Compare(const void* item1, const void* item2) const override;
	virtual const char* GetItemName(const void* item) const override{return ((const FirmBase*)item)->GetName();}
};

class TGUI_API ListBoxCheckDestination : public ListBoxBoldItem
{
public:
	ListBoxCheckDestination(unsigned char checkable = 1,
		bool rbuttonSelection = false,
		bool rbuttonMenu = false,
		bool draggable = false,
		const char* nullItemName = NULL,
		bool useBoldItem = true,
		const char* tooltipText = NULL):
		ListBoxBoldItem(0, rbuttonSelection, rbuttonMenu, draggable, useBoldItem, tooltipText),
		m_checkedSetEnd(m_checkedSet.end()),
		m_exclude(true)
//		m_itgAccount(0)
	{
		m_checkable = checkable;
		if(nullItemName)m_nullItemName = nullItemName;
	}
	const std::string& GetNullItemName() const{return m_nullItemName;}
	void SetNullItemName(const char* nullItemName)
	{
		if(!nullItemName)nullItemName = "";
		if(strcmp(nullItemName, m_nullItemName.c_str()))
		{
			m_nullItemName = nullItemName;
			if(m_hWnd)Invalidate(FALSE);
		}
	}
	typedef std::set<const Destination*> DestinationSet;
	const DestinationSet& GetCheckedSet() const{return m_checkedSet;}

	virtual unsigned char AreAllItemsChecked() const override//0 - none; 1 - not all; 2 - all
	{
		unsigned int checkedCount = (unsigned int)m_checkedSet.size();
		return !checkedCount ? 0:
			checkedCount < m_itemCount ? 1:
			2;
	}

	virtual bool isItemChecked(const void* item) const override{return m_checkedSet.find((Destination*)item) != m_checkedSetEnd;}
	virtual const char* GetItemName(const void* item) const override;
	virtual int Compare(const void* item1, const void* item2) const override;
	virtual CBrush* GetBkBrush() const override;
	virtual COLORREF GetBkColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override;
	virtual COLORREF GetStringColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override;
	virtual COLORREF GetSelectedBkColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override;
	COLORREF GetDestinationColor(const Destination* destination) const;
	const bool& isExclude() const{return m_exclude;}
	void SetExclude(const bool& exclude)
	{
		if(exclude != m_exclude)
		{
			m_exclude = exclude;
			if(m_hWnd)Invalidate(TRUE);
		}
	}
	bool hasDestinations() const{return m_exclude ? (unsigned int)m_checkedSet.size() < m_itemCount : !m_checkedSet.empty();}
/*
	const bool& isRelevant() const{return m_relevant;}
	void SetRelevant(const bool& relevant)
	{
		if(relevant != m_relevant)
		{
			m_relevant = relevant;
			if(m_hWnd)Invalidate(TRUE);
		}
	}
*/
//	void SetItgAccount(unsigned char itgAccount);//{m_itgAccount = itgAccount;}
//	unsigned char GetItgAccount() const{return m_itgAccount;}
protected:
	virtual void SetItemChecked(void* item, unsigned int i, bool checked) override
	{
		if(checked)m_checkedSet.insert((Destination*)item);
		else m_checkedSet.erase((Destination*)item);
	}
	virtual void ListBoxCreated() override
	{
		m_checkedSet.clear();
		ListBoxBoldItem::ListBoxCreated();
	}
	virtual void ItemToString(const void* item, std::string& itemStr) const override;
	virtual void AddMenuItems(CMenu& menu) override;
	DestinationSet m_checkedSet;
	DestinationSet::iterator m_checkedSetEnd;
	bool m_exclude;
//	bool m_relevant;
//	unsigned char m_itgAccount;
	std::string m_nullItemName;
};

class TGUI_API ListBoxRouting : public ListBoxBoldItem
{
public:
	ListBoxRouting(int itemHeight = 0,
		bool rbuttonSelection = false,
		bool rbuttonMenu = false,
		bool draggable = false,
		bool useBoldItem = true,
		const char* tooltipText = NULL):
		ListBoxBoldItem(itemHeight, rbuttonSelection, rbuttonMenu, draggable, useBoldItem, tooltipText),
		m_descriptionLeft(0)
	{}
	virtual const char* GetItemName(const void* item) const override;
/*
	void SetFontBold(CFont* font){m_fontBold = font;}
	void SetItemBold(int itemBold){m_itemBold = itemBold;}
	virtual void SetFont(CFont* font);
*/
	void SetDescriptionLeft(int left)
	{
		if(m_descriptionLeft != left)
		{
			m_descriptionLeft = left;
//			if(m_hWnd && GetCount() > 0)
			if(m_hWnd && m_itemCount > 0)
			{
				Invalidate(FALSE);
			}
		}
	}
	int GetDescriptionLeft() const{return m_descriptionLeft;}
protected:
//	virtual void Resize(int cx, int cy);
	virtual void DoDrawItem(const DRAWITEMSTRUCT* lpDrawItemStruct, const CRect& drawItemRect);
	virtual void ListBoxCreated();
	int m_descriptionLeft;
};

class TGUI_API ListBoxMarketCategory : public ListBoxSimpleFilter<unsigned int>//, 32>
{
public:
	ListBoxMarketCategory(const char* const& tooltipText = NULL):ListBoxSimpleFilter((1 << MCF_COUNT) - 1, MCF_COUNT, MCF_OTHER, tooltipText){}
	virtual const char* GetItemName(const void* item) const{return TU_GetMarketCategoryName((unsigned char)
#if (_MSC_VER > 1600)
		(size_t)
#endif
		item);}
};

class TGUI_API ListBoxSecurityType : public ListBoxSimpleFilter<unsigned char>//, 8>
{
public:
	ListBoxSecurityType():ListBoxSimpleFilter(
#ifndef TAKION_NO_OPTIONS
		(1 << ST_COUNT) - 1, ST_COUNT
#else
		(1 << ST_STOCK_Count) - 1, ST_STOCK_Count
#endif
		)
	{}
	virtual bool GetToolTipInfo(unsigned int ordinal, const void* item, std::string& tooltipText, int& left, int& right) const override
	{
		switch((unsigned char)
#if (_MSC_VER > 1600)
			(size_t)
#endif
			item)
		{
			case ST_STOCK:
			tooltipText = "Stocks";
			break;

#ifndef TAKION_NO_OPTIONS
			case ST_OPTION:
			tooltipText = "Options";
			break;
#endif
			default:
			tooltipText.clear();
			return false;
		}
		return true;
	}
	virtual const char* GetItemName(const void* item) const override
	{
		switch((unsigned char)
#if (_MSC_VER > 1600)
			(size_t)
#endif
			item)
		{
			case ST_STOCK:
			return "Stocks";

#ifndef TAKION_NO_OPTIONS
			case ST_OPTION:
			return "Options";
#endif
			default:
			return "";
		}
	}
};

class TGUI_API ComboBoxMarketCategory : public ComboBoxString
{
public:
	ComboBoxMarketCategory(const char* tooltipText = NULL):ComboBoxString(false, tooltipText){}
protected:
	virtual void ComboBoxCreated() override
	{
		ComboBoxString::ComboBoxCreated();
		for(unsigned char i = 0, end = TU_GetMarketCategoryCount(); i < end; ++i)
		{
			AddString(TU_GetMarketCategoryName(i));
		}
	}
};

#ifndef TAKION_NO_OPTIONS
class TGUI_API ListBoxMarketCategoryAndOption : public ListBoxSimpleFilter<unsigned int>//, 32>
{
public:
	ListBoxMarketCategoryAndOption(const char* const& tooltipText = NULL):ListBoxSimpleFilter((1 << MCF_ALL_Count) - 1, MCF_ALL_Count, MCF_OTHER, tooltipText){}
	virtual bool HasItemToolTips() const{return false;}
	virtual const char* GetItemName(const void* item) const
	{
		unsigned char id = (unsigned char)
#if (_MSC_VER > 1600)
			(size_t)
#endif
			item;
//		return id < MCF_COUNT ? TU_GetMarketCategoryName(id) : "Option";
		return TU_GetMarketCategoryName(id);
	}
};
#endif

class TGUI_API ComboBoxDestination : public ComboBoxOwnerDraw
{
public:
	ComboBoxDestination(const char* nullItemName = NULL, const char* tooltipText = NULL):
		ComboBoxOwnerDraw(0xFFFFFFFF, 0, false, tooltipText)
//		m_itgAccount(0)
	{
		if(nullItemName)m_nullItemName = nullItemName;
	}
	const std::string& GetNullItemName() const{return m_nullItemName;}
	void SetNullItemName(const char* nullItemName)
	{
		if(!nullItemName)nullItemName = "";
		if(strcmp(nullItemName, m_nullItemName.c_str()))
		{
			m_nullItemName = nullItemName;
			if(m_hWnd)Invalidate(FALSE);
		}
	}
	virtual const char* GetItemName(const void* item) const override;
	virtual int Compare(const void* item1, const void* item2) const override;
//	void SetItgAccount(unsigned char itgAccount){m_itgAccount = itgAccount;}
//	unsigned char GetItgAccount() const{return m_itgAccount;}
	virtual COLORREF GetStringColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override;
	virtual COLORREF GetSelectedBkColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override;
	COLORREF GetDestinationColor(const Destination* destination) const;
	int FindItemByNumericName(const unsigned int numericName) const;
//	virtual const char* GetItemToolTip(int sel, const void* item) const override{return GetDescription(item);}
protected:
//	unsigned char m_itgAccount;
	std::string m_nullItemName;
};

class TGUI_API ComboBoxRouting : public ComboBoxNameDescriptionBase
{
public:
	ComboBoxRouting(const char* tooltipText = NULL):ComboBoxNameDescriptionBase(DT_LEFT, tooltipText){}
	virtual const char* GetItemName(const void* item) const override;
	virtual const char* GetDescription(const void* item) const override;
	int FindItemByNumericName(const unsigned int numericName) const;
	virtual const char* GetItemToolTip(int sel, const void* item) const override{return GetDescription(item);}
};

class TGUI_API ComboBoxPrimaryExchangeDescription : public ComboBoxNameDescription
{
public:
	ComboBoxPrimaryExchangeDescription(const char* tooltipText = NULL) :ComboBoxNameDescription(DT_LEFT, tooltipText) {}
protected:
	//	virtual int Compare(const void* item1, const void* item2) const override{return CompareByDescription(item1, item2);}
	virtual void ComboBoxCreated() override
	{
//		ComboBoxNameDescription::ComboBoxCreated();
		char code;
		m_descriptionWidth = 0;
/*
		const char* description;
		HDC hdc = ::GetDC(m_hWnd);
		HGDIOBJ oldFont = SelectObject(hdc, *m_font);
		CRect rect(0, 0, 0, 0);
*/
		for(unsigned char i = 0, end = TU_GetPrimaryExchangeCount(); i < end; ++i)
		{
			code = TU_GetPrimaryExchangeCode(i);
			AddItem(code, TU_GetPrimaryExchangeNameByCode(code));
/*
			description = TU_GetPrimaryExchangeNameByCode(code);
			AddItem(code, description);//OnAddString(WPARAM w, LPARAM l) is not called from PreSubclass

			DrawText(hdc, description, -1, &rect, DT_CALCRECT | DT_LEFT | DT_NOCLIP | DT_SINGLELINE);
			if(m_descriptionWidth < rect.right)
			{
				SetDescriptionWidth(rect.right);
			}
			rect.right = rect.bottom = 0;
*/
		}
//		SelectObject(hdc, oldFont);
//		::ReleaseDC(m_hWnd, hdc);
		ComboBoxNameDescription::ComboBoxCreated();
	}
	virtual void FinishPreSubclassWindow() override//OnAddString(WPARAM w, LPARAM l) is not called from PreSubclass
	{
		m_descriptionWidth = 0;
		const char* description;
		const NameDescriptionItem* item;
		HDC hdc = ::GetDC(m_hWnd);
		HGDIOBJ oldFont = SelectObject(hdc, *m_font);
		CRect rect(0, 0, 0, 0);
		for(unsigned int i = 0, end = m_itemCount; i < end; ++i)
		{
			item = (const NameDescriptionItem*)GetItemDataPtr(i);
			description = item->GetDescription().c_str();
			DrawText(hdc, description, -1, &rect, DT_CALCRECT | DT_LEFT | DT_NOCLIP | DT_SINGLELINE);
			if(m_descriptionWidth < rect.right)
			{
				SetDescriptionWidth(rect.right);
			}
			rect.right = rect.bottom = 0;
		}
		SelectObject(hdc, oldFont);
		::ReleaseDC(m_hWnd, hdc);
	}
};

class TGUI_API ComboBoxPrimaryExchange : public ComboBoxString
{
public:
	ComboBoxPrimaryExchange(const char* tooltipText = NULL):ComboBoxString(false, tooltipText){}
protected:
	virtual void ComboBoxCreated() override
	{
		ComboBoxString::ComboBoxCreated();
		for(unsigned char i = 0; i < PEE_Count; ++i)
		{
			AddString(TU_GetPrimaryExchangeNameByEnum(i));
		}
	}
};

class TGUI_API DialogListAccount : public DialogList
{
public:
	DialogListAccount(TakionMainWnd* mainWnd, CWnd* parent, unsigned int maxVisibleItemtCount);
	const Account* GetAccountAt(int i) const;
	const Account* GetSelectedAccount() const;
	void Display(unsigned int code,
		bool rightButton,
		const void* item,
		CWnd* parent,
		int x,
		int y,
		int w,
		int h,
		bool fastSelection,
		unsigned int maxVisibleItemCount = 0,
		CWnd* receipient = NULL,
		COLORREF bkColor = 0xFFFFFFFF,
		COLORREF selectionBkColor = 0xFFFFFFFF,
		COLORREF textColor = 0xFFFFFFFF,
		COLORREF selectionTextColor = 0xFFFFFFFF);
//	void* FindItemByName(const char* name) const;
//	int FindItemIndexByName(const char* name) const{return m_ListBoxAccount.FindItemByName(name);}
	virtual bool NullItemOk() const{return true;}
	const int& GetListBoxItemWidth() const{return m_ListBoxAccount.GetMaxWidth();}
protected:
	virtual BOOL OnInitDialog();
	virtual void BeforeShow();
//	virtual void OnDisplay();
	ListBoxAccount m_ListBoxAccount;
//	afx_msg void OnSelchangeItem();
//	DECLARE_MESSAGE_MAP()
};

class TGUI_API DialogListRouting : public DialogList
{
public:
	DialogListRouting(TakionMainWnd* mainWnd, CWnd* parent, unsigned int maxVisibleItemtCount);//, bool ownItems);// = 0, CWnd* receipient = NULL);
	const DestinationRouting* GetRoutingAt(int i) const;
	const DestinationRouting* GetSelectedRouting() const;
	void Display(unsigned int code,
		bool rightButton,
		const Destination* destination,
		const void* item,
		int additionalWidth,
		CWnd* parent,
		int x,
		int y,
		int w,
		int h,
		bool fastSelection,
		unsigned int maxVisibleItemCount = 0,
		CWnd* receipient = NULL,
		COLORREF bkColor = 0xFFFFFFFF,
		COLORREF selectionBkColor = 0xFFFFFFFF,
		COLORREF textColor = 0xFFFFFFFF,
		COLORREF selectionTextColor = 0xFFFFFFFF);
	void SetDestination(const Destination* destination);
	const Destination* GetDestination() const{return m_destination;}
	void SetDescriptionLeft(int left){m_ListBoxRouting.SetDescriptionLeft(left);}
	int GetDescriptionLeft() const{return m_ListBoxRouting.GetDescriptionLeft();}
//	void* FindItemByName(const char* name) const;
//	int FindItemIndexByName(const char* name) const;
	virtual bool NullItemOk() const{return true;}
protected:
	virtual BOOL OnInitDialog();
	virtual void BeforeShow();
//	virtual void OnDisplay();
	ListBoxRouting m_ListBoxRouting;
//	afx_msg void OnSelchangeItem();
//	DECLARE_MESSAGE_MAP()
	const Destination* m_destination;
	int m_additionalWidth;
};

class TGUI_API DialogListDestination : public DialogList
{
public:
	DialogListDestination(TakionMainWnd* mainWnd, CWnd* parent, unsigned int maxVisibleItemtCount, bool sort);
	const Destination* GetDestinationAt(int i) const;
	const Destination* GetSelectedDestination() const;
	void Display(unsigned int code,
		bool rightButton,
		const void* item,
		CWnd* parent,
		int x,
		int y,
		int w,
		int h,
		bool fastSelection,
		unsigned int maxVisibleItemCount = 0,
		CWnd* receipient = NULL,
		COLORREF bkColor = 0xFFFFFFFF,
		COLORREF selectionBkColor = 0xFFFFFFFF,
		COLORREF textColor = 0xFFFFFFFF,
		COLORREF selectionTextColor = 0xFFFFFFFF);
//	void* FindItemByName(const char* name) const;
//	int FindItemIndexByName(const char* name) const{return m_ListBoxDestination.FindItemByName(name);}

//	void SetItgAccount(unsigned char itgAccount){m_ListBoxDestination.SetItgAccount(itgAccount);}
//	unsigned char GetItgAccount() const{return m_ListBoxDestination.GetItgAccount();}
protected:
	virtual BOOL OnInitDialog();
	virtual void BeforeShow();
	ListBoxCheckDestination m_ListBoxDestination;
};

class TGUI_API DialogTextEntryHandleCommand : public DialogTextEntry
{
public:
	DialogTextEntryHandleCommand(TakionMainWnd* mainWnd,
		const bool& toDestroyOnFocus = false,
		TakionFrame* const& receipient = NULL,
		CWnd* const& parent = NULL,
		const char* const& charSet = NULL,
		const bool& exclude = true,
		const bool& uppercase = true,
		const bool& lowercase = false,
		const bool& scroll = true,
		const bool& readonly = false,
		const bool& multiline = false,
		const bool& executeCommands = true,
		const bool& closeOnCommandExecution = true);
protected:
	virtual bool HandleCommand(const Key& key, bool ctrlChar, bool repeatKey) override;
};

class TGUI_API DialogMmFilter : public DialogResetCustomDefault
{
public:
	DialogMmFilter(TakionMainWnd* mainWnd, unsigned char maxFilterCount, bool toDestroyOnFocus = false, TakionFrame* receipient = NULL, CWnd* parent = NULL);
	void Display(TakionFrame* receipient, unsigned int code, CWnd* parent, int x, int y, int w, int h,
		const unsigned int* exchangeFilterMaskDefaultOpen,
		const unsigned int* lineCountDefaultOpen,
		const unsigned int* exchangeFilterMaskDefaultClosed,
		const unsigned int* lineCountDefaultClosed,
		const unsigned int* exchangeFilterMaskCustomOpen,
		const unsigned int* lineCountCustomOpen,
		const unsigned int* exchangeFilterMaskCustomClosed,
		const unsigned int* lineCountCustomClosed,
		unsigned char primaryExchange,
		bool custom);
	void SetCustomFilter();
	void SetDefaultFilter();
//	void ResetFilter();
//	bool isCustom() const{return m_custom;}
	bool isModifiedCustom() const{return m_modifiedOpenCustom || m_modifiedClosedCustom;}
	const bool& isModifiedOpenCustom() const{return m_modifiedOpenCustom;}
	const bool& isModifiedClosedCustom() const{return m_modifiedClosedCustom;}
	const bool& isModifiedOpenDefault() const{return m_modifiedOpenDefault;}
	const bool& isModifiedClosedDefault() const{return m_modifiedClosedDefault;}
	bool isModifiedDefault() const{return m_modifiedOpenDefault || m_modifiedClosedDefault;}
	const unsigned char& GetPrimaryExchange() const{return m_primaryExchange;}

	bool isModifiedPeCustom(const bool& open, const unsigned char& pe) const{return pe < PEE_Count && (open ? m_modifiedPeOpenCustom[pe] : m_modifiedPeClosedCustom[pe]);}
	bool isModifiedPeCustom(const unsigned char& pe) const{return pe < PEE_Count && (m_modifiedPeOpenCustom[pe] || m_modifiedPeClosedCustom[pe]);}
	bool isModifiedPeDefault(const bool& open, const unsigned char& pe) const{return pe < PEE_Count && (open ? m_modifiedPeOpenDefault[pe] : m_modifiedPeClosedDefault[pe]);}
	bool isModifiedPeDefault(const unsigned char& pe) const{return pe < PEE_Count && (m_modifiedPeOpenDefault[pe] || m_modifiedPeClosedDefault[pe]);}

	bool isQuarterChanged(bool open, bool custom) const;

	const unsigned int* GetExchangeFilterMaskCustomOpen() const{return m_exchangeFilterMaskCustomOpen;}
	const unsigned int* GetExchangeFilterMaskCustomClosed() const{return m_exchangeFilterMaskCustomClosed;}
	const unsigned char* GetLineCountCustomOpen() const{return *m_lineCountCustomOpen;}
	const unsigned char* GetLineCountCustomClosed() const{return *m_lineCountCustomClosed;}

	const unsigned int* GetExchangeFilterMaskDefaultOpen() const{return m_exchangeFilterMaskDefaultOpen;}
	const unsigned int* GetExchangeFilterMaskDefaultClosed() const{return m_exchangeFilterMaskDefaultClosed;}
	const unsigned char* GetLineCountDefaultOpen() const{return *m_lineCountDefaultOpen;}
	const unsigned char* GetLineCountDefaultClosed() const{return *m_lineCountDefaultClosed;}

	virtual bool DoReset() override;
	virtual bool isChanged() const override;
	virtual bool isDefaultChanged() const override;

	bool isSameFilteringForAllPrimaryExchanges(bool open) const;
//	static bool IncrementMmNumber(MmItem* item, const unsigned int maxCount);
//	static int FillListBox(ListBoxMmFilter& lb, unsigned int exchangeFilterMask, const unsigned int* lineCount, unsigned int maxFilterCount);//returns -2 if nothing changed; -1 if multiple items changed;>= 0 if a single item changed
//	static bool IncrementListBoxMmNumber(ListBoxMmFilter& listBox);
	static void InitMmFilterListBoxes(ListBoxMmFilter& lbMarketOpen, ListBoxMmFilter& lbMarketClosed, unsigned char maxFilterCount);
	static void UpdateExchangeFilterMask(unsigned int& exchangeFilterMask, const unsigned char& count, const unsigned char& mcId)
	{
		if(count)exchangeFilterMask |= (1 << mcId);
		else exchangeFilterMask &= ~(1 << mcId);
	}
protected:
	virtual void DoDefault() override;
	virtual void CustomModified() override;
	virtual void DoDataExchange(CDataExchange* pDX) override;
	virtual void BeforeShow() override{}
	virtual void DoApply() override;
	virtual BOOL OnInitDialog() override;
	virtual void Resize(bool widthChanged = true, bool heightChanged = true) override;
	virtual void FinishDialog(int result) override;
	virtual void ToolTipsEnabled(bool enable) override;
	void SetInitialParams(unsigned int exchangeFilterMaskOpen,
		const unsigned char* lineCountOpen,
		unsigned int exchangeFilterMaskClosed,
		const unsigned char* lineCountClosed,
		bool custom,
		bool setCustomCheckBox);
//	afx_msg void OnGetMinMaxInfo(MINMAXINFO* lpMMI);
//	afx_msg void OnCustom();
//	afx_msg void OnReset();

	afx_msg void OnSelchangePrimaryExchange();

	afx_msg void OnMarketOpenSame();
	afx_msg void OnMarketOpenZero();
	afx_msg void OnMarketOpenOne();
	afx_msg void OnMarketOpenAll();

	afx_msg void OnMarketClosedSame();
	afx_msg void OnMarketClosedZero();
	afx_msg void OnMarketClosedOne();
	afx_msg void OnMarketClosedAll();

	afx_msg void OnDblclkFilterMarketOpen();
	afx_msg void OnDblclkFilterMarketClosed();

	afx_msg LRESULT OnShowHide(WPARAM w, LPARAM l);
	afx_msg LRESULT OnFilterSpinned(WPARAM w, LPARAM l);
	DECLARE_MESSAGE_MAP()

	bool MakeSameFilteringForAllPrimaryExchanges(bool open);
	void UpdateEnableMakeSameFilteringButton(bool open);

	void UpdateCurrentFilter(bool open, int ordinal);

//	void RememberCustomFilter();
//	void RememberDefaultFilter();

	void SetCountModified(unsigned int id, int item);

	void NullifyFiltering();

	unsigned int m_exchangeFilterMaskDefaultOpen[PEE_Count];
	unsigned int m_exchangeFilterMaskDefaultClosed[PEE_Count];
	unsigned int m_exchangeFilterMaskCustomOpen[PEE_Count];
	unsigned int m_exchangeFilterMaskCustomClosed[PEE_Count];

	unsigned int m_exchangeFilterMaskDefaultOpenOriginal[PEE_Count];
	unsigned int m_exchangeFilterMaskDefaultClosedOriginal[PEE_Count];
	unsigned int m_exchangeFilterMaskCustomOpenOriginal[PEE_Count];
	unsigned int m_exchangeFilterMaskCustomClosedOriginal[PEE_Count];

	unsigned char m_lineCountDefaultOpen[PEE_Count][ECNBOOK_COUNT];
	unsigned char m_lineCountCustomOpen[PEE_Count][ECNBOOK_COUNT];
	unsigned char m_lineCountDefaultClosed[PEE_Count][ECNBOOK_COUNT];
	unsigned char m_lineCountCustomClosed[PEE_Count][ECNBOOK_COUNT];

	unsigned char m_lineCountDefaultOpenOriginal[PEE_Count][ECNBOOK_COUNT];
	unsigned char m_lineCountCustomOpenOriginal[PEE_Count][ECNBOOK_COUNT];
	unsigned char m_lineCountDefaultClosedOriginal[PEE_Count][ECNBOOK_COUNT];
	unsigned char m_lineCountCustomClosedOriginal[PEE_Count][ECNBOOK_COUNT];

	void ResetModified();
//	void UpdateModified();
	bool m_modifiedPeOpenCustom[PEE_Count];
	bool m_modifiedPeClosedCustom[PEE_Count];
	bool m_modifiedPeOpenDefault[PEE_Count];
	bool m_modifiedPeClosedDefault[PEE_Count];

	bool m_modifiedOpenCustom;
	bool m_modifiedClosedCustom;

	bool m_modifiedOpenDefault;
	bool m_modifiedClosedDefault;

	ComboBoxPrimaryExchange m_ComboBoxPrimaryExchange;
//	CButton m_CheckBoxCustom;
	ListBoxMmFilter m_ListBoxFilterMarketOpen;
	ListBoxMmFilter m_ListBoxFilterMarketClosed;
	CStatic m_StaticMarketOpen;
	CStatic m_StaticMarketClosed;
//	CButton m_ButtonHelp;

	ButtonToolTip m_ButtonMarketOpenSame;
	ButtonToolTip m_ButtonMarketOpenZero;
	ButtonToolTip m_ButtonMarketOpenOne;
	ButtonToolTip m_ButtonMarketOpenAll;

	ButtonToolTip m_ButtonMarketClosedSame;
	ButtonToolTip m_ButtonMarketClosedZero;
	ButtonToolTip m_ButtonMarketClosedOne;
	ButtonToolTip m_ButtonMarketClosedAll;

	void FillListBoxes();

	unsigned char m_maxFilterCount;
/*
	unsigned int m_minWidth;
	unsigned int m_minHeight;
	unsigned int m_maxWidth;
	unsigned int m_maxHeight;
*/
	int m_lbLeft;
	int m_lbTop;
//	int m_lbWidth;
	int m_buttonWidth;
	int m_buttonHeight;
	int m_gapH;
	int m_gapV;
	int m_staticHeight;
	int m_countButtonHeight;

	unsigned char m_primaryExchange;
};

class TGUI_API DialogEcnAttribution : public DialogResetCustom
{
public:
	DialogEcnAttribution(TakionMainWnd* mainWnd, bool toDestroyOnFocus = false, TakionFrame* receipient = NULL, CWnd* parent = NULL);
	void Display(TakionFrame* receipient, unsigned int code, CWnd* parent, int x, int y, int w, int h,
		unsigned int attributionMaskDefaultOpen,
		unsigned int attributionMaskDefaultClosed,
		unsigned int attributionMaskCustomOpen,
		unsigned int attributionMaskCustomClosed,
		bool custom);
	void SetCustomFilter();
	void SetDefaultFilter();
//	void ResetFilter();
//	bool isCustom() const{return m_custom;}
	const bool& isModifiedCustom() const{return m_modifiedCustom;}
	const bool& isModifiedOpenDefault() const{return m_modifiedOpenDefault;}
	const bool& isModifiedClosedDefault() const{return m_modifiedClosedDefault;}
	bool isModifiedDefault() const{return m_modifiedOpenDefault || m_modifiedClosedDefault;}
	const unsigned int& GetAttributionMaskCustomOpen() const{return m_attributionMaskCustomOpen;}
	const unsigned int& GetAttributionMaskCustomClosed() const{return m_attributionMaskCustomClosed;}
	const unsigned int& GetAttributionMaskDefaultOpen() const{return m_attributionMaskDefaultOpen;}
	const unsigned int& GetAttributionMaskDefaultClosed() const{return m_attributionMaskDefaultClosed;}
	virtual bool DoReset() override;
	virtual bool isChanged() const override;
protected:
	virtual void CustomModified() override;
	virtual void DoDataExchange(CDataExchange* pDX);
	virtual void BeforeShow() override{}
	virtual void DoApply() override;
	virtual void ToolTipsEnabled(bool enable) override;
	virtual BOOL OnInitDialog();
	virtual void Resize(bool widthChanged = true, bool heightChanged = true) override;
	virtual void FinishDialog(int result) override;
	void SetInitialParams(unsigned int attributionMaskOpen,
		unsigned int attributionMaskClosed,
		bool custom,
		bool setCustomCheckBox);
	afx_msg LRESULT OnListBoxChecked(WPARAM w, LPARAM l);
	DECLARE_MESSAGE_MAP()

	void RememberCustomFilter();
	void RememberDefaultFilter();

	unsigned int m_attributionMaskDefaultOpen;
	unsigned int m_attributionMaskDefaultClosed;
	unsigned int m_attributionMaskCustomOpen;
	unsigned int m_attributionMaskCustomClosed;

	ListBoxEcn m_ListBoxAttributionMarketOpen;
	ListBoxEcn m_ListBoxAttributionMarketClosed;
	CStatic m_StaticMarketOpen;
	CStatic m_StaticMarketClosed;
	int m_lbLeft;
	int m_lbTop;
	int m_lbWidth;
	int m_buttonWidth;
	int m_buttonHeight;
	int m_gapH;
	int m_gapV;
	int m_staticHeight;

	bool m_modifiedCustomTemp;
	bool m_modifiedCustom;
	bool m_modifiedOpenDefault;
	bool m_modifiedClosedDefault;
};

template <class T> inline void TypeToString(const T& value, std::string& str){U_AppendUInt(str, value, settingDel);}
template <class T> inline void TypeFromString(T& value, const char*& cursor){value = U_ReadUIntToken(cursor, settingDel);}

template <> inline void TypeToString(const unsigned __int64& value, std::string& str){U_AppendUInt64(str, value, settingDel);}
template <> inline void TypeFromString(unsigned __int64& value, const char*& cursor){value = U_ReadUInt64Token(cursor, settingDel);}

template <> inline void TypeToString(const Price& value, std::string& str){U_PriceToStr(str, value, 2, '\0', false, settingDel);}
template <> inline void TypeFromString(Price& value, const char*& cursor){U_StrToPrice(value, cursor, 2, settingDel);}

template <> inline void TypeToString(const Money& value, std::string& str){U_MoneyToStr(str, value, 2, '\0', false, settingDel);}
template <> inline void TypeFromString(Money& value, const char*& cursor){U_StrToMoney(value, cursor, 2, settingDel);}

template <> inline void TypeToString(const SignedPrice& value, std::string& str){U_SignedPriceToStr(str, value, 2, '\0', false, settingDel);}
template <> inline void TypeFromString(SignedPrice& value, const char*& cursor){U_StrToSignedPrice(value, cursor, 2, settingDel);}

template <class T> inline void SetValueToZero(T& value){value = 0;}
template <> inline void SetValueToZero(SignedPrice& value){value.SetZero();}
template <> inline void SetValueToZero(Price& value){value.SetZero();}
template <> inline void SetValueToZero(Money& value){value.SetZero();}

template <class T> inline bool IsNegative(const T& value){return value < 0;}
template <> inline bool IsNegative(const SignedPrice& value){return value.isNegative();}
template <> inline bool IsNegative(const Price& value){return false;}
template <> inline bool IsNegative(const Money& value){return value.isNegative();}

template <class T> inline bool IsPositive(const T& value){return value > 0;}
template <> inline bool IsPositive(const SignedPrice& value){return value.isPositive();}
template <> inline bool IsPositive(const Price& value){return !value.isZero();}
template <> inline bool IsPositive(const Money& value){return value.isPositive();}

template <class P, class N> inline void ConvertToPositive(const N& value, P& positiveValue){positiveValue = value < 0 ? -value : value;}
template <> inline void ConvertToPositive(const SignedPrice& value, Price& positiveValue){positiveValue = Price(value.isNegative() ? -value : value);}
template <> inline void ConvertToPositive(const Price& value, Price& positiveValue){positiveValue = value;}
template <> inline void ConvertToPositive(const Money& value, Money& positiveValue){positiveValue = value.isNegative() ? -value : value;}

enum TRPN : unsigned char
{
	TRPN_POSITIVE = 1,
	TRPN_NEGATIVE = 2,
	TRPN_ALL = TRPN_POSITIVE | TRPN_NEGATIVE
};

class TGUI_API TakionUse
{
public:
	TakionUse(bool use = false):m_use(use){}
	virtual ~TakionUse(){}
	inline const bool& isUse() const{return m_use;}
	void SetUse(bool use){m_use = use;}
	bool operator==(const TakionUse& other) const{return m_use == other.m_use;}
	virtual void toString(std::string& str) const{U_AppendBool(str, m_use, settingDel);}
	virtual void fromString(const char*& cursor){m_use = U_ReadBoolToken(cursor, settingDel);}
	virtual bool isValid() const{return true;}
	virtual unsigned char GetPositiveNegative() const{return TRPN_ALL;}
	virtual void SetPositiveNegative(unsigned char positiveNegative){}
	virtual void Reset(){m_use = false;}
	bool isSameFiltering(const TakionUse& other) const{return m_use == other.m_use;}
	static unsigned char GetValidPositiveNegative(const unsigned char& positiveNegative){return positiveNegative >= TRPN_POSITIVE && positiveNegative < TRPN_ALL ? positiveNegative : TRPN_ALL;}
	bool isPositiveUsed() const{return (GetPositiveNegative() & TRPN_POSITIVE) != 0;}
	bool isNegativeUsed() const{return (GetPositiveNegative() & TRPN_NEGATIVE) != 0;}
protected:
	bool m_use;
};

template<class T, class N = T>
class TakionRange : public TakionUse
{
public:
	typedef N SignedRangeType;
//	typename typedef std::make_signed<V>::type SignedRangeType;
	const T& GetMin() const{return m_min;}
	const T& GetMax() const{return m_max;}
	const T& GetMinMax(bool minValue) const{return minValue ? m_min : m_max;}
	inline const bool& isZeroValid() const{return m_zeroValid;}
//	virtual bool isValid() const{return !m_use || m_min <= m_max && (m_zeroValid || !EqualsZero(m_min) || m_min < m_max);}
//10/17/2018
//	inline bool isMinMaxValid() const{return m_min <= m_max && (m_zeroValid || !!m_min || m_min < m_max);}
	inline bool isMinMaxValid() const{return (m_min <= m_max || !m_max) && (m_zeroValid || !!m_min || m_min < m_max);}

	virtual bool isValid() const{return !m_use || isMinMaxValid();}
	void SetMin(const T& minValue){m_min = minValue;}
	void SetMax(const T& maxValue){m_max = maxValue;}
	void SetMinMax(const T& minValue, const T& maxValue){m_min = minValue; m_max = maxValue;}
//	inline bool isPositiveValueIn(const T& value) const{return m_min <= value && (EqualsZero(m_max) && m_min > m_max || value <= m_max);}
	inline bool isPositiveValueIn(const T& value) const{return (m_min < value || m_minInclusive && m_min == value) && (m_min > m_max || value <= m_max);}
	inline bool isPositiveValueOut(const T& value) const{return m_min > value || value > m_max || m_minInclusive && (m_min == value || m_max == value);}
	virtual bool isValueIn(const SignedRangeType& value) const = 0;//{return m_min <= value && (EqualsZero(m_max) && m_min > m_max || value <= m_max);}
	bool ValueBelongs(const SignedRangeType& value) const{return !m_use || isValueIn(value);}
	virtual bool operator==(const TakionRange& other) const{return TakionUse::operator==(other) && m_min == other.m_min && m_max == other.m_max;}// && m_zeroValid == other.m_zeroValid && m_minInclusive == other.m_minInclusive;}
	bool operator!=(const TakionRange& other) const{return !operator==(other);}
	virtual bool isSameFiltering(const TakionRange& other) const{return !m_use && !other.m_use || operator==(other);}
	virtual void toString(std::string& str) const override
	{
		TakionUse::toString(str);
		TypeToString(m_min, str);
		TypeToString(m_max, str);
	}
	virtual void fromString(const char*& cursor) override
	{
		TakionUse::fromString(cursor);
		TypeFromString(m_min, cursor);
		TypeFromString(m_max, cursor);
	}
	inline const bool& isMinInclusive() const{return m_minInclusive;}
//	void SetMinInclusive(bool minInclusive){m_minInclusive = minInclusive;}
	virtual void Reset()
	{
		TakionUse::Reset();
		SetValueToZero(m_min);
		SetValueToZero(m_max);
	}
	virtual bool isEmpty() const{return !m_use && !m_min && !m_max;}
	virtual bool isFiltering() const{return m_use && isMinMaxValid();}
protected:
	TakionRange(const T& minValue, const T& maxValue, bool use = false, bool zeroValid = true, bool minInclusive = true):TakionUse(use),m_min(minValue),m_max(maxValue),m_zeroValid(zeroValid),m_minInclusive(minInclusive){}
	TakionRange(const T& value, bool use = false, bool zeroValid = true, bool minInclusive = true):TakionUse(use),m_min(value),m_max(value),m_zeroValid(zeroValid),m_minInclusive(minInclusive){}
	T m_min;
	T m_max;
	bool m_zeroValid;
	bool m_minInclusive;
};

template<class T>
class TakionRangePositive : public TakionRange<T, T>
{
public:
	TakionRangePositive(const T& minValue, const T& maxValue, bool use = false, bool zeroValid = true, bool minInclusive = true):TakionRange(minValue, maxValue, use, zeroValid, minInclusive){}
	TakionRangePositive(const T& value, bool use = false, bool zeroValid = true, bool minInclusive = true):TakionRange(value, use, zeroValid, minInclusive){}
	virtual bool isValueIn(const T& value) const override{return isPositiveValueIn(value);}
};

template<class T>//, class N>
class TakionRangePositiveNegative : public TakionRange<T, typename std::make_signed<T>::type>
{
public:
	TakionRangePositiveNegative(unsigned char positiveNegative, const T& minValue, const T& maxValue, bool use = false, bool zeroValid = true, bool minInclusive = true):TakionRange(minValue, maxValue, use, zeroValid, minInclusive), m_positiveNegative(GetValidPositiveNegative(positiveNegative)){}
	TakionRangePositiveNegative(unsigned char positiveNegative, const T& value, bool use = false, bool zeroValid = true, bool minInclusive = true):TakionRange(value, use, zeroValid, minInclusive), m_positiveNegative(GetValidPositiveNegative(positiveNegative)){}
	virtual bool isEmpty() const{return TakionRange::isEmpty() && m_positiveNegative == TRPN_ALL;}
	virtual unsigned char GetPositiveNegative() const override{return m_positiveNegative;}
	virtual void SetPositiveNegative(unsigned char positiveNegative){m_positiveNegative = GetValidPositiveNegative(positiveNegative);}
	virtual void toString(std::string& str) const
	{
		TakionRange::toString(str);
		U_AppendUChar(str, GetValidPositiveNegative(m_positiveNegative), settingDel);
	}
	virtual void fromString(const char*& cursor) override
	{
		TakionRange::fromString(cursor);
//		unsigned short positiveNegative = U_ReadUShortToken(cursor, settingDel, 3);
//		m_positiveNegative = positiveNegative < 0x100 ? GetValidPositiveNegative((unsigned char)positiveNegative) : 3;
		unsigned char positiveNegative = U_ReadUCharToken(cursor, settingDel, TRPN_ALL);
		m_positiveNegative = GetValidPositiveNegative(positiveNegative);
	}
	virtual bool operator==(const TakionRange& other) const override{return TakionRange::operator==(other) && m_positiveNegative == other.GetPositiveNegative();}
	virtual bool isValueIn(const SignedRangeType& value) const override
	{
		if(IsNegative(value))
		{
			if(m_positiveNegative & TRPN_NEGATIVE)
			{
				T positiveValue;
				ConvertToPositive(value, positiveValue);
				return isPositiveValueIn(positiveValue);
			}
		}
		else if(IsPositive(value))
		{
			if(m_positiveNegative & TRPN_POSITIVE)
			{
				T positiveValue;
				ConvertToPositive(value, positiveValue);
				return isPositiveValueIn(positiveValue);
			}
		}
		else if(m_positiveNegative)
		{
			T positiveValue;
			ConvertToPositive(value, positiveValue);
			return isPositiveValueIn(positiveValue);
		}
		return false;
	}
//Used for LULD
	bool are2ValuesIn(const SignedRangeType& valuePositive, const SignedRangeType& valueNegative) const
	{
		if(m_positiveNegative & TRPN_NEGATIVE)
		{
			if(isPositiveValueIn(valueNegative))return true;
		}
		if(m_positiveNegative & TRPN_POSITIVE)
		{
			if(isPositiveValueIn(valuePositive))return true;
		}
		return false;
	}
	virtual void Reset() override
	{
		TakionRange::Reset();
		m_positiveNegative = TRPN_ALL;
	}
protected:
	unsigned char m_positiveNegative;
};

#define RSI_PRECISE

class ChartPointRingVector;

class TGUI_API SecurityChartRow : public Observer
{
public:
	SecurityChartRow(const Security* security, const Position* position, unsigned short timeFrame, unsigned short timeFrameInSeconds);//0 if timeFrameInMinutes
	virtual ~SecurityChartRow();

	virtual bool isUseOddLotPrints() const{return true;}
//	Position* GetPosition(){return m_position;}
	const Position* const& GetPosition() const{return m_position;}
	virtual bool SetPosition(const Position* position);
	int GetPositionSize() const{return m_position ? m_position->GetSize() : 0;}

//	Security* GetSecurity(){return m_security;}
	const Security* GetSecurity() const{return m_security;}
	virtual bool SetSecurity(const Security* security);
//	unsigned short GetChartStartMinute() const{return m_chartStartMinute;}
//	const ChartPointVector& GetChart() const{return m_chart;}
	virtual bool SetTimeFrame(unsigned short minutes, unsigned short timeFrameInSeconds);
//	virtual bool SetTimeFrameInMinutes(bool timeFrameInMinutes);

	bool SetRsiMhParams(const bool calculate,
		const unsigned short rsiMhPriorPointCount,
		const unsigned short rsiMhPeriodLength,
		unsigned short rsiMhPeriodCount,
		const unsigned short rsiMhStartMinute,
		const bool todayOnly,
		const bool postMarket);

	bool SetRsiDaysParams(const bool calculate,
		const unsigned short rsiDaysPriorPointCount,
		const unsigned short rsiDaysPeriodLength,
		unsigned short rsiDaysPeriodCount,
		const unsigned short rsiDaysStartMinute,
		const bool postMarket);

	const Price& GetFirstPrice() const{return m_firstPrice;}
	const Price& GetLastPrice() const{return m_lastPrice;}
	const Price& GetHighPrice() const{return m_highPrice;}
	const Price& GetLowPrice() const{return m_lowPrice;}
	const SignedPrice& GetNetChange() const{return m_netChange;}
	const SignedPrice& GetNetPercentChange() const{return m_netPercentChange;}
	const Price& GetNetPercentChangeAbs() const{return m_netPercentChangeAbs;}
	const Price& GetPriceRange() const{return m_priceRange;}
	const Price& GetPriceRangePercent() const{return m_priceRangePercent;}
	const SignedPrice& GetLastPriceInRange() const{return m_lastPriceInRange;}
	const Price& GetFromHigh() const{return m_fromHigh;}
	const Price& GetFromHighPercent() const{return m_fromHighPercent;}
	const Price& GetFromLow() const{return m_fromLow;}
	const Price& GetFromLowPercent() const{return m_fromLowPercent;}
	const Price& GetVWAP() const{return m_vwap;}
	const Money& GetMoneyTraded() const{return m_moneyTraded;}
	const Money& GetMhRelativeVolume() const{return m_mhRelativeVolume;}
	const unsigned __int64& GetVolume() const{return m_volume;}
	const unsigned int& GetLastMinuteVolume() const{return m_lastMinuteVolume;}
	const unsigned int& GetPrevVolumeRate() const{return m_prevVolumeRate;}
	const unsigned int& GetVolumeRate() const{return m_volumeRate;}
//	const unsigned int& GetDayAvgVolumeRate() const{return m_dayAvgVolumeRate;}
	const Price& GetLastMinuteVolumeFraction() const{return m_lastMinuteVolumeFraction;}
	const Price& GetPrevMinuteVolumeFraction() const{return m_prevMinuteVolumeFraction;}
	const Price& GetMaxMinuteVolumeFraction() const{return m_prevMinuteVolumeFraction < m_lastMinuteVolumeFraction ? m_lastMinuteVolumeFraction : m_prevMinuteVolumeFraction;}

	const bool& isRsiMhPriorLoaded() const{return m_rsiMhPriorLoaded;}
	const Price& GetRsiMh() const{return m_rsiMh;}//relative strength index
	const bool& isRsiMhCalculate() const{return m_rsiMhCalculate;}
	const unsigned short& GetRsiMhPriorPointCount() const{return m_rsiMhPriorPointCount;}
	const unsigned short& GetRsiMhPeriodLength() const{return m_rsiMhPeriodLength;}//in minutes
	const unsigned short& GetRsiMhPeriodCount() const{return m_rsiMhPeriodCount;}
	const unsigned short& GetRsiMhStartMinute() const{return m_rsiMhStartMinute;}
	const unsigned short& GetRsiMhRealStartMinute() const{return m_rsiMhRealStartMinute;}
	const unsigned short& GetRsiMhPeriodStart() const{return m_rsiMhPeriodStart;}
	const bool& isRsiMhTodayOnly() const{return m_rsiMhTodayOnly;}
	const bool& isRsiMhPostMarket() const{return m_rsiMhPostMarket;}
	void UninitializeRsiMh(){m_rsiMhInitialized = false;}

	const bool& isRsiDaysPriorLoaded() const{return m_rsiDaysPriorLoaded;}
	const Price& GetRsiDays() const{return m_rsiDays;}//relative strength index
	const Price& GetRsiDaysPrior() const{return m_rsiDaysPrior;}//relative strength index
	const bool& isRsiDaysCalculate() const{return m_rsiDaysCalculate;}
	const unsigned short& GetRsiDaysPriorPointCount() const{return m_rsiDaysPriorPointCount;}
	const unsigned short& GetRsiDaysPeriodLength() const{return m_rsiDaysPeriodLength;}//in minutes
	const unsigned short& GetRsiDaysPeriodCount() const{return m_rsiDaysPeriodCount;}
	const unsigned short& GetRsiDaysStartMinute() const{return m_rsiDaysStartMinute;}
//	const unsigned short& GetRsiDaysPeriodStart() const{return m_rsiDaysPeriodStart;}
	const bool& isRsiDaysPostMarket() const{return m_rsiDaysPostMarket;}
	void UninitializeRsiDays(){m_rsiDaysInitialized = false;}

	const unsigned int& GetLastPrintSize() const{return m_lastPrintSize;}

	const int& GetHiLoCount() const{return m_hiloCount;}
	const int& GetHiLoCountRepeat() const{return m_hiloCountRepeat;}

	const unsigned int& GetTotalHighCount() const{return m_totalHighCount;}
	const unsigned int& GetTotalLowCount() const{return m_totalLowCount;}
	const unsigned int& GetTotalRepeatHighCount() const{return m_totalRepeatHighCount;}
	const unsigned int& GetTotalRepeatLowCount() const{return m_totalRepeatLowCount;}

	const unsigned int& GetHighMillisecond() const{return m_highMillisecond;}
	const unsigned int& GetLowMillisecond() const{return m_lowMillisecond;}

	const int& GetTickCount() const{return m_tickCount;}
	const int& GetTickCountRepeat() const{return m_tickCountRepeat;}

//	const bool& isTimeFrameInMinutes() const{return m_timeFrameInMinutes;}
	const unsigned short& GetTimeFrameInSeconds() const{return m_timeFrameInSecondsValue;}
	const unsigned short& GetTimeFrame() const{return m_timeFrame;}
	const unsigned short& GetCurrentMinute() const{return m_currentMinute;}
	const unsigned short& GetEndChartMinute() const{return m_endChartMinute;}
	const unsigned short& GetLowPriceMinute() const{return m_lowPriceMinute;}
	const unsigned short& GetHighPriceMinute() const{return m_highPriceMinute;}

	virtual bool InitializeChart(bool fromConstructor = false);
	virtual void AddPrint(const Price& price, unsigned int size, char marketCenterId, unsigned char printFlags);
	virtual bool SetCurrentMinute(unsigned short currentMinute, bool fromServer);
	virtual bool SetEndChartMinute(unsigned short endChartMinute, bool fromServer);

	virtual void InvalidateRsiMhCellIfVisible() const{}
	virtual void InvalidateRsiDaysCellIfVisible() const{}

	void ResetPriceAndVolume();//calls ResetPrice and also rests Volume.
	void ResetPrice();

	bool UpdateYesterdayClosePrice();

	void ResetAll();
	bool ClearChart();
	void ClearChartAndResetAll()
	{
		ClearChart();
		ResetAll();
	}
	virtual void NextDayReset(){ClearChartAndResetAll();}

	typedef std::map<Price, unsigned int> LowPriceMap;
	typedef std::map<Price, unsigned int, std::greater<Price> > HighPriceMap;
	typedef std::set<unsigned short> PositivePriceSet;
	virtual const Security* GetSelectedSecurity() const{return NULL;}
#ifdef _DEBUG
	unsigned __int64 GetChartVolume() const;//for debugging only
#endif
	const unsigned int& GetRoundLot() const{return m_roundLot;}
protected:
	virtual void IncrementHiCount(){}
	virtual void DecrementHiCount(){}
	virtual void IncrementLoCount(){}
	virtual void DecrementLoCount(){}
	virtual void LowReached(bool dayLowReached){m_lowMillisecond = TL_GetCurrentMillisecond();}
	virtual void HighReached(bool dayHighReached){m_highMillisecond = TL_GetCurrentMillisecond();}
	void CalculateValues();

	void UpdateFirstPriceValues();

	const Security* m_security;
	const Position* m_position;
	ChartPointRingVector* m_chart;
	ChartPoint* m_lastChartPoint;
	Price m_firstPrice;
	Price m_lastPrice;
	Price m_highPrice;
	Price m_lowPrice;
	SignedPrice m_netChange;
	SignedPrice m_netPercentChange;
	Price m_netPercentChangeAbs;
	Price m_priceRange;
	Price m_priceRangePercent;
	SignedPrice m_lastPriceInRange;

	Price m_fromHigh;
	Price m_fromHighPercent;
	Price m_fromLow;
	Price m_fromLowPercent;

	Price m_vwap;
	Money m_moneyTraded;

	void UpdateRelativeVolume();
	Money m_mhRelativeVolume;

	unsigned short m_timeFrame;
	unsigned short m_currentMinute;
	unsigned short m_endChartMinute;
	unsigned short m_highPriceMinute;
	unsigned short m_lowPriceMinute;
	unsigned short m_timeFrameInSecondsValue;
//	bool m_timeFrameInMinutes;

	unsigned int m_lastPrintSize;

	int m_hiloCount;
	int m_hiloCountRepeat;
	int m_hiloCountPrev;
	int m_hiloCountRepeatPrev;

	unsigned int m_highMillisecond;
	unsigned int m_lowMillisecond;

	int m_tickCount;
	int m_tickCountRepeat;
	int m_tickCountPrev;
	int m_tickCountRepeatPrev;

	unsigned int m_totalHighCount;
	unsigned int m_totalLowCount;
	unsigned int m_totalRepeatHighCount;
	unsigned int m_totalRepeatLowCount;

	void CalculateLastMinuteVolumeFraction();

	unsigned __int64 m_volume;
	unsigned int m_lastMinuteVolume;
	unsigned int m_prevVolumeRate;
	unsigned int m_volumeRate;
	Price m_lastMinuteVolumeFraction;
	Price m_prevMinuteVolumeFraction;
//	unsigned int m_dayAvgVolumeRate;
	unsigned int m_roundLot;
#ifdef RSI_PRECISE
	typedef PricePrecise CalcPrice;
#else
	typedef Price CalcPrice;
#endif
//RSI Minutes
	bool DoSetRsiMhParams(const bool calculate,
		const unsigned short rsiMhPriorPointCount,
		const unsigned short rsiMhPeriodLength,
		const unsigned short rsiMhPeriodCount,
		const unsigned short rsiMhStartMinute,
		const bool todayOnly,
		const bool postMarket);
	void RsiMhDataLoaded(const Price* priceChart, unsigned short size, bool loaded);
	bool PreCalculateRsiMh(const Price* priceChart, unsigned short size);
	void CalculateRsiMh();
	void DoCalculateRsiMh(const CalcPrice& positive, const CalcPrice& negative);
	void AdjustRsiMhByLastPrice(const Price& lastPrice);
	Price m_rsiMh;//relative strength index
	Price m_rsiMhStartPrice;
	Price m_rsiMhEndPrice;
	CalcPrice m_rsiMhAvgPositiveNet;
	CalcPrice m_rsiMhAvgNegativeNet;
	CalcPrice m_rsiMhAvgPositiveNetNotAdjusted;
	CalcPrice m_rsiMhAvgNegativeNetNotAdjusted;
	CalcPrice m_rsiMhSumPositiveNet;
	CalcPrice m_rsiMhSumNegativeNet;
#ifdef _DEBUG
	Price m_prevEndPrice;
	unsigned short m_rsiMhLastNonZeroMinutePrev;
	unsigned short m_rsiMhLastNonZeroMinute;
	unsigned short m_rsiMhStartPriceMinute;
	unsigned short m_rsiMhPreStartPriceMinute;
	bool m_periodSkipped;
#endif
//	Price m_rsiMhAvgPositiveNetDynamic;
//	Price m_rsiMhAvgNegativeNetDynamic;
	unsigned short m_rsiMhPriorPointCount;
	unsigned short m_rsiMhPeriodLength;//in minutes
	unsigned short m_rsiMhPeriodCount;
	unsigned short m_rsiMhPeriodCount1;
	unsigned short m_currentRsiMhPeriod;
	unsigned short m_rsiMhStartMinute;
	unsigned short m_rsiMhRealStartMinute;

//Prior
	unsigned short m_currentRsiMhPeriodPrior;
	Price m_rsiMhPrior;
//	m_rsiMhStartPricePrior.SetZero();
	Price m_rsiMhEndPricePrior;

	CalcPrice m_rsiMhAvgPositiveNetPrior;
	CalcPrice m_rsiMhAvgNegativeNetPrior;
	CalcPrice m_rsiMhAvgPositiveNetNotAdjustedPrior;
	CalcPrice m_rsiMhAvgNegativeNetNotAdjustedPrior;
	CalcPrice m_rsiMhSumPositiveNetPrior;
	CalcPrice m_rsiMhSumNegativeNetPrior;
//Calc
//	unsigned short m_rsiMhRealPriorPointCount;
	unsigned short m_rsiMhPeriodStart;

	bool m_rsiMhCalculate;
	bool m_rsiMhTodayOnly;
	bool m_rsiMhPostMarket;
	bool m_rsiMhInitialized;
	bool m_rsiMhPriorLoaded;

//RSI Days
	bool DoSetRsiDaysParams(const bool calculate,
		const unsigned short rsiDaysPriorPointCount,
		const unsigned short rsiDaysPeriodLength,
		const unsigned short rsiDaysPeriodCount,
		const unsigned short rsiDaysStartMinute,
		const bool postMarket);
	void RsiDaysDataLoaded(const Price* priceChart, unsigned short size, bool loaded);
	bool PreCalculateRsiDays(const Price* priceChart, unsigned short size);
	void CalculateRsiDays();
	void DoCalculateRsiDays(const CalcPrice& positive, const CalcPrice& negative);
	void AdjustRsiDaysByLastPrice(const Price& lastPrice);
	Price m_rsiDays;//relative strength index
	Price m_rsiDaysStartPrice;
	Price m_rsiDaysEndPrice;
	CalcPrice m_rsiDaysAvgPositiveNet;
	CalcPrice m_rsiDaysAvgNegativeNet;
	CalcPrice m_rsiDaysAvgPositiveNetNotAdjusted;
	CalcPrice m_rsiDaysAvgNegativeNetNotAdjusted;
	CalcPrice m_rsiDaysSumPositiveNet;
	CalcPrice m_rsiDaysSumNegativeNet;

	unsigned short m_rsiDaysPriorPointCount;
	unsigned short m_rsiDaysPeriodLength;//in days
	unsigned short m_rsiDaysPeriodCount;
	unsigned short m_rsiDaysPeriodCount1;
	unsigned short m_currentRsiDaysPeriod;
	unsigned short m_rsiDaysStartMinute;

	Price m_rsiDaysPrior;
/*
//Prior
	unsigned short m_currentRsiDaysPeriodPrior;
	Price m_rsiDaysPrior;
//	m_rsiMhStartPricePrior.SetZero();
	Price m_rsiDaysEndPricePrior;

	Price m_rsiDaysAvgPositiveNetPrior;
	Price m_rsiDaysAvgNegativeNetPrior;
	Price m_rsiDaysAvgPositiveNetNotAdjustedPrior;
	Price m_rsiDaysAvgNegativeNetNotAdjustedPrior;
	Price m_rsiDaysSumPositiveNetPrior;
	Price m_rsiDaysSumNegativeNetPrior;
//Calc
//	unsigned short m_rsiMhPeriodStart;
*/
	bool m_rsiDaysCalculate;
	bool m_rsiDaysPostMarket;
	bool m_rsiDaysInitialized;
	bool m_rsiDaysPriorLoaded;
//

	LowPriceMap m_loPriceMap;
	LowPriceMap::const_iterator m_loPriceMapEnd;
	HighPriceMap m_hiPriceMap;
	HighPriceMap::const_iterator m_hiPriceMapEnd;
	PositivePriceSet m_positivePriceSet;
	PositivePriceSet::const_iterator m_positivePriceSetEnd;
private:
	SecurityChartRow(const SecurityChartRow& other);
	SecurityChartRow& SecurityChartRow::operator=(const SecurityChartRow& other);
};

class IndexChartPointRingVector;

class TGUI_API IndexChartRow : public Observer
{
public:
	IndexChartRow(Index* index, unsigned short timeFrame);
	virtual ~IndexChartRow();

	Index* GetIndex(){return m_index;}
	const Index* GetIndex() const{return m_index;}
//	unsigned short GetChartStartMinute() const{return m_chartStartMinute;}
//	const ChartPointVector& GetChart() const{return m_chart;}

	const SignedPrice& GetFirstPrice() const{return m_firstPrice;}
	const SignedPrice& GetLastPrice() const{return m_lastPrice;}
	const SignedPrice& GetHighPrice() const{return m_highPrice;}
	const SignedPrice& GetLowPrice() const{return m_lowPrice;}
	const SignedPrice& GetNetChange() const{return m_netChange;}
	const SignedPrice& GetNetPercentChange() const{return m_netPercentChange;}
	const Price& GetPriceRange() const{return m_priceRange;}
	const Price& GetPriceRangePercent() const{return m_priceRangePercent;}
	const SignedPrice& GetLastPriceInRange() const{return m_lastPriceInRange;}

	const int& GetHiLoCount() const{return m_hiloCount;}
	const int& GetHiLoCountRepeat() const{return m_hiloCountRepeat;}

	const int& GetTickCount() const{return m_tickCount;}
	const int& GetTickCountRepeat() const{return m_tickCountRepeat;}

	const unsigned short& GetTimeFrame() const{return m_timeFrame;}
	const unsigned short& GetCurrentMinute() const{return m_currentMinute;}
	const unsigned short& GetEndChartMinute() const{return m_endChartMinute;}
	const unsigned short& GetLowPriceMinute() const{return m_lowPriceMinute;}
	const unsigned short& GetHighPriceMinute() const{return m_highPriceMinute;}

	virtual bool SetTimeFrame(unsigned short minutes, unsigned short timeFrameInSeconds);
	virtual bool InitializeChart(bool fromConstructor = false);
/*
	virtual void AddValue(const SignedPrice& price);
	virtual bool SetCurrentMinute(unsigned short currentMinute);
	virtual bool SetEndChartMinute(unsigned short endChartMinute);
*/
	void Reset();
	typedef std::map<SignedPrice, unsigned int> LowPriceMap;
	typedef std::map<SignedPrice, unsigned int, std::greater<SignedPrice> > HighPriceMap;
//	virtual const Security* GetSelectedSecurity() const{return NULL;}

protected:
	virtual void IncrementHiCount(){}
	virtual void DecrementHiCount(){}
	virtual void IncrementLoCount(){}
	virtual void DecrementLoCount(){}
	virtual void LowReached(bool dayLowReached){}
	virtual void HighReached(bool dayHighReached){}
	void CalculateValues();
	Index* m_index;
	IndexChartPointRingVector* m_chart;
	IndexChartPoint* m_lastChartPoint;
	SignedPrice m_firstPrice;
	SignedPrice m_lastPrice;
	SignedPrice m_highPrice;
	SignedPrice m_lowPrice;
	SignedPrice m_netChange;
	SignedPrice m_netPercentChange;
	Price m_priceRange;
	Price m_priceRangePercent;
	SignedPrice m_lastPriceInRange;
	unsigned short m_timeFrame;
	unsigned short m_currentMinute;
	unsigned short m_endChartMinute;
	unsigned short m_highPriceMinute;
	unsigned short m_lowPriceMinute;

	int m_hiloCount;
	int m_hiloCountRepeat;
	int m_hiloCountPrev;
	int m_hiloCountRepeatPrev;

	int m_tickCount;
	int m_tickCountRepeat;
	int m_tickCountPrev;
	int m_tickCountRepeatPrev;

	LowPriceMap m_loPriceMap;
	HighPriceMap m_hiPriceMap;
};

#ifdef _DEBUG
//#define USE_CMAP_FOR_FILTER_SYMBOLS
#endif

enum FilterDoNotCopyFlags
{
	FDNC_SYMBOL,

	FilterDoNotCopyFlagsCount
};

enum FilterType : unsigned char
{
	FT_STOCK,
	FT_MARKET_SORTER,
	FT_INDEX_SORTER,
	FT_HILO_SCROLLER,
	FT_NEWS_HEADLINE,
#ifndef TAKION_NO_OPTIONS
	FT_OPTION_SORTER,
	FT_OPTION_CHAIN,
#endif
	FilterTypeCount
};

class TGUI_API SymbolFilter : public TakionFilter
{
public:
	virtual unsigned char isA() const = 0;
	virtual bool isPriceFilter() const{return false;}
	virtual bool isStockFilter() const{return false;}
	virtual bool isIndexFilter() const{return false;}
	virtual bool isTimeFrameFilter() const{return false;}
	virtual bool isMarketSorterFilter() const{return false;}
	virtual bool isSecurityScrollerFilter() const{return false;}
	virtual bool isBaseOptionSorterFilter() const{return false;}
	virtual bool isHiLoScrollerFilter() const{return false;}
	virtual bool isNewsHeadlineSecurityFilter() const{return false;}
	virtual bool isOptionSorterFilter() const{return false;}
	virtual bool isOptionChainFilter() const{return false;}
	const char* GetFilterTypeName() const
	{
		switch(isA())
		{
			case FT_STOCK:
			return "pr";

			case FT_MARKET_SORTER:
			return "ms";

			case FT_INDEX_SORTER:
			return "is";

			case FT_HILO_SCROLLER:
			return "hl";

			case FT_NEWS_HEADLINE:
			return "nh";

#ifndef TAKION_NO_OPTIONS
			case FT_OPTION_SORTER:
			return "op";

			case FT_OPTION_CHAIN:
			return "oc";
#endif
			default:
			return NULL;
		}
	}
	virtual void Copy(const TakionFilter& other) override;
	virtual void CopyFilterOfOtherKind(const TakionFilter& other, unsigned int doNotCopyFlags) override
	{
		CopySymbolFilterOfOtherKind((const SymbolFilter&)other, doNotCopyFlags);
	}
	void CopyMyFields(const SymbolFilter& other, unsigned int doNotCopyFlags);
	virtual void CopySymbolFilterOfOtherKind(const SymbolFilter& other, unsigned int doNotCopyFlags)
	{
		CopyMyFields(other, doNotCopyFlags);
	}
	bool MyFieldsEqual(const SymbolFilter& other, unsigned int doNotCopyFlags) const;
	virtual bool isIntersectionEqual(const TakionFilter& other) const override//, unsigned int doNotCopyFlags) const
	{
		return isSymbolIntersectionEqual((const SymbolFilter&)other, 1 << FDNC_SYMBOL);
	}
	virtual bool isSymbolIntersectionEqual(const SymbolFilter& other, unsigned int doNotCopyFlags) const
	{
		return MyFieldsEqual(other, doNotCopyFlags);
	}
	virtual bool operator==(const TakionFilter& other) const override
	{
		return MyFieldsEqual((const SymbolFilter&)other, 0);
	}

	virtual void toString(std::string& str) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual unsigned char isPotentialFilterSame(const TakionFilter& filter) const override;//0 - same; 1 - to add; 2 - to remove; 3 - to add and remove
	virtual bool isFilterSame(const TakionFilter& filter) const override;

	virtual bool isFiltering() const override;
	virtual bool isEmpty() const override;

#if (_MSC_VER > 1600)
	typedef std::unordered_set<char> CharSet;
#else
	typedef std::hash_set<char> CharSet;
#endif
	const CharSet& GetFirstCharSet() const{return m_firstCharSet;}
	const CharSet& GetNoFirstCharSet() const{return m_noFirstCharSet;}
	const CharSet& GetCharSet() const{return m_charSet;}
	const CharSet& GetNoCharSet() const{return m_noCharSet;}
/*
	CharSet& GetFirstCharSet(){return m_firstCharSet;}
	CharSet& GetNoFirstCharSet(){return m_noFirstCharSet;}
	CharSet& GetCharSet(){return m_charSet;}
	CharSet& GetNoCharSet(){return m_noCharSet;}
*/
	const std::string& GetFirstCharString() const{return m_firstCharString;}
	const std::string& GetNoFirstCharString() const{return m_noFirstCharString;}
	const std::string& GetCharString() const{return m_charString;}
	const std::string& GetNoCharString() const{return m_noCharString;}

	void SetFirstCharString(const std::string& str);
	void SetNoFirstCharString(const std::string& str);
	void SetCharString(const std::string& str);
	void SetNoCharString(const std::string& str);

	const bool& isUseFirstCharSet() const{return m_useFirstCharSet;}
	const bool& isUseNoFirstCharSet() const{return m_useNoFirstCharSet;}
	const bool& isUseCharSet() const{return m_useCharSet;}
	const bool& isUseNoCharSet() const{return m_useNoCharSet;}
	void SetUseFirstCharSet(const bool& use){m_useFirstCharSet = use;}
	void SetUseNoFirstCharSet(const bool& use){m_useNoFirstCharSet = use;}
	void SetUseCharSet(const bool& use){m_useCharSet = use;}
	void SetUseNoCharSet(const bool& use){m_useNoCharSet = use;}
#ifdef USE_CMAP_FOR_FILTER_SYMBOLS
	typedef CMap<unsigned __int64, const unsigned __int64&, unsigned char, const unsigned char&> UInt64Set;
	void ClearExcludeIncludeSymbolSet()
	{
		m_excludeSymbolSet.RemoveAll();
		m_includeSymbolSet.RemoveAll();
		m_excludeIncludeSymbolMap.clear();
	}
	void ClearExcludeSymbolSet()
	{
		for(const UInt64Set::CPair* p = m_excludeSymbolSet.PGetFirstAssoc(); p; p = m_excludeSymbolSet.PGetNextAssoc(p))
		{
			m_excludeIncludeSymbolMap.erase(p->key);
		}
		m_excludeSymbolSet.RemoveAll();
	}
	void ClearIncludeSymbolSet()
	{
		for(const UInt64Set::CPair* p = m_includeSymbolSet.PGetFirstAssoc(); p; p = m_includeSymbolSet.PGetNextAssoc(p))
		{
			m_excludeIncludeSymbolMap.erase(p->key);
		}
		m_includeSymbolSet.RemoveAll();
	}
	void EraseExcludeSymbol(const unsigned __int64& symbol)
	{
		m_excludeSymbolSet.RemoveKey(symbol);
		m_excludeIncludeSymbolMap.erase(symbol);
	}
	void EraseIncludeSymbol(const unsigned __int64& symbol)
	{
		m_includeSymbolSet.RemoveKey(symbol);
		m_excludeIncludeSymbolMap.erase(symbol);
	}
	bool UnExcludeSymbol(const unsigned __int64& symbol)
	{
		if(m_useExclude)
		{
			const UInt64Set::CPair* found = m_excludeSymbolSet.PLookup(symbol);
			if(found)
			{
				m_excludeSymbolSet.RemoveKey(symbol);
				m_excludeIncludeSymbolMap.erase(symbol);
				return true;
			}
		}
		else
		{
			m_excludeSymbolSet.RemoveKey(symbol);
			m_excludeIncludeSymbolMap.erase(symbol);
		}
		return false;
	}
	bool UnIncludeSymbol(const unsigned __int64& symbol)//{return m_includeSymbolSet.erase(symbol) != 0 && m_useInclude;}
	{
		if(m_useInclude)
		{
			const UInt64Set::CPair* found = m_includeSymbolSet.PLookup(symbol);
			if(found)
			{
				m_includeSymbolSet.RemoveKey(symbol);
				m_excludeIncludeSymbolMap.erase(symbol);
				return true;
			}
		}
		else
		{
			m_includeSymbolSet.RemoveKey(symbol);
			m_excludeIncludeSymbolMap.erase(symbol);
		}
		return false;
	}
	bool isSymbolInExcludeSet(const unsigned __int64& symbol) const{return m_excludeSymbolSet.PLookup(symbol) != NULL;}
	bool isSymbolInIncludeSet(const unsigned __int64& symbol) const{return m_includeSymbolSet.PLookup(symbol) != NULL;}
	bool isExcludeSetEmpty() const{return m_excludeSymbolSet.IsEmpty() == TRUE;}
	bool isIncludeSetEmpty() const{return m_includeSymbolSet.IsEmpty() == TRUE;}
#else
#ifdef _DEBUG
	typedef std::set<unsigned __int64> UInt64Set;
#else
#if (_MSC_VER > 1600)
	typedef std::unordered_set<unsigned __int64> UInt64Set;
#else
	typedef std::hash_set<unsigned __int64> UInt64Set;
#endif
#endif
	void ClearExcludeIncludeSymbolSet()
	{
		m_excludeSymbolSet.clear();
		m_includeSymbolSet.clear();
		m_excludeIncludeSymbolMap.clear();
	}
	void ClearExcludeSymbolSet()
	{
		for(UInt64Set::const_iterator it = m_excludeSymbolSet.cbegin(); it != m_excludeSymbolSetEnd; ++it)
		{
			m_excludeIncludeSymbolMap.erase(*it);
		}
		m_excludeSymbolSet.clear();
	}
	void ClearIncludeSymbolSet()
	{
		for(UInt64Set::const_iterator it = m_includeSymbolSet.cbegin(); it != m_includeSymbolSetEnd; ++it)
		{
			m_excludeIncludeSymbolMap.erase(*it);
		}
		m_includeSymbolSet.clear();
	}
	void EraseExcludeSymbol(const unsigned __int64& symbol)
	{
		m_excludeSymbolSet.erase(symbol);
		m_excludeIncludeSymbolMap.erase(symbol);
	}
	void EraseIncludeSymbol(const unsigned __int64& symbol)
	{
		m_includeSymbolSet.erase(symbol);
		m_excludeIncludeSymbolMap.erase(symbol);
	}
	bool UnExcludeSymbol(const unsigned __int64& symbol)
	{
		if(m_excludeSymbolSet.erase(symbol) != 0)
		{
			m_excludeIncludeSymbolMap.erase(symbol);
			return m_useExclude;
		}
		return false;
	}
	bool UnIncludeSymbol(const unsigned __int64& symbol)
	{
		if(m_includeSymbolSet.erase(symbol) != 0)
		{
			m_excludeIncludeSymbolMap.erase(symbol);
			return m_useInclude;
		}
		return false;
	}
	bool isSymbolInExcludeSet(const unsigned __int64& symbol) const{return m_excludeSymbolSet.find(symbol) != m_excludeSymbolSetEnd;}
	bool isSymbolInIncludeSet(const unsigned __int64& symbol) const{return m_includeSymbolSet.find(symbol) != m_includeSymbolSetEnd;}
	bool isExcludeSetEmpty() const{return m_excludeSymbolSet.empty();}
	bool isIncludeSetEmpty() const{return m_includeSymbolSet.empty();}
#endif
	bool isSymbolExcluded(const unsigned __int64& symbol) const{return m_useExclude && isSymbolInExcludeSet(symbol);}
	bool isSymbolIncluded(const unsigned __int64& symbol) const{return m_useInclude && isSymbolInIncludeSet(symbol);}
	const UInt64Set& GetExcludeSymbolSet() const{return m_excludeSymbolSet;}
	const UInt64Set& GetIncludeSymbolSet() const{return m_includeSymbolSet;}
	UInt64Set& GetExcludeSymbolSet(){return m_excludeSymbolSet;}
	UInt64Set& GetIncludeSymbolSet(){return m_includeSymbolSet;}
	unsigned char ExcludeSymbol(unsigned __int64 symbol);
	unsigned char IncludeSymbol(unsigned __int64 symbol);

	typedef std::map<unsigned __int64, bool, lessUIntAsStr<unsigned __int64> > ExcludeIncludeSymbolMap;
	const ExcludeIncludeSymbolMap& GetExcludeIncludeSymbolMap() const{return m_excludeIncludeSymbolMap;}//Union of m_excludeSymbolSet & m_includeSymbolSet
	ExcludeIncludeSymbolMap& GetExcludeIncludeSymbolMap(){return m_excludeIncludeSymbolMap;}//Union of m_excludeSymbolSet & m_includeSymbolSet

	const bool& isUseExclude() const{return m_useExclude;}
	const bool& isUseInclude() const{return m_useInclude;}
	void SetUseExclude(const bool& use){m_useExclude = use;}
	void SetUseInclude(const bool& use){m_useInclude = use;}

	SymbolFilter& operator=(const SymbolFilter& other);
	virtual void Reset();

protected:
	SymbolFilter();
	SymbolFilter(const SymbolFilter& other);
	bool m_useExclude;
	bool m_useInclude;
	UInt64Set m_excludeSymbolSet;
	UInt64Set m_includeSymbolSet;

#ifndef USE_CMAP_FOR_FILTER_SYMBOLS
	UInt64Set::const_iterator m_excludeSymbolSetEnd;
	UInt64Set::const_iterator m_includeSymbolSetEnd;
#endif

	ExcludeIncludeSymbolMap m_excludeIncludeSymbolMap;//Union of m_excludeSymbolSet & m_includeSymbolSet
	ExcludeIncludeSymbolMap::const_iterator m_excludeIncludeSymbolMapEnd;

	bool m_useFirstCharSet;
	bool m_useNoFirstCharSet;
	bool m_useCharSet;
	bool m_useNoCharSet;
	std::string m_firstCharString;
	std::string m_noFirstCharString;
	std::string m_charString;
	std::string m_noCharString;
	CharSet m_firstCharSet;
	CharSet m_noFirstCharSet;
	CharSet m_charSet;
	CharSet m_noCharSet;
	CharSet::const_iterator m_firstCharSetEnd;
	CharSet::const_iterator m_noFirstCharSetEnd;
	CharSet::const_iterator m_charSetEnd;
	CharSet::const_iterator m_noCharSetEnd;
};

class TGUI_API PriceFilter : public SymbolFilter
{
public:
	virtual void Copy(const TakionFilter& other) override;

	virtual bool isPriceFilter() const override{return true;}
	void CopyMyFields(const PriceFilter& other, unsigned int doNotCopyFlags);
	virtual void CopySymbolFilterOfOtherKind(const SymbolFilter& other, unsigned int doNotCopyFlags) override
	{
		if(other.isPriceFilter())CopyMyFields((const PriceFilter&)other, doNotCopyFlags);
		SymbolFilter::CopySymbolFilterOfOtherKind(other, doNotCopyFlags);
	}
	bool MyFieldsEqual(const PriceFilter& other, unsigned int doNotCopyFlags) const;
	virtual bool isSymbolIntersectionEqual(const SymbolFilter& other, unsigned int doNotCopyFlags) const override
	{
		return SymbolFilter::isSymbolIntersectionEqual(other, doNotCopyFlags) && (!other.isPriceFilter() || MyFieldsEqual((const PriceFilter&)other, doNotCopyFlags));
	}
	virtual bool operator==(const TakionFilter& other) const override
	{
		return SymbolFilter::operator==(other) && MyFieldsEqual((const PriceFilter&)other, 0);
	}

	virtual bool isFiltering() const override;
	virtual bool isEmpty() const override;

	TakionRangePositive<Price>& GetPriceRange(){return m_priceRange;}
	TakionRangePositive<Price>& GetOpenPriceRange(){return m_openPriceRange;}
	TakionRangePositiveNegative<Price>& GetDayNetChangeRange(){return m_dayNetChangeRange;}
	TakionRangePositive<Price>& GetDayPriceRangeRange(){return m_dayPriceRangeRange;}
	TakionRangePositiveNegative<Price>& GetDayNetChangePercentRange(){return m_dayNetChangePercentRange;}
	TakionRangePositiveNegative<Price>& GetDayNetOpenChangePercentRange(){return m_dayNetOpenChangePercentRange;}
	TakionRangePositive<Price>& GetDayPriceRangePercentRange(){return m_dayPriceRangePercentRange;}

	const TakionRangePositive<Price>& GetPriceRange() const{return m_priceRange;}
	const TakionRangePositive<Price>& GetOpenPriceRange() const{return m_openPriceRange;}
	const TakionRangePositiveNegative<Price>& GetDayNetChangeRange() const{return m_dayNetChangeRange;}
	const TakionRangePositive<Price>& GetDayPriceRangeRange() const{return m_dayPriceRangeRange;}
	const TakionRangePositiveNegative<Price>& GetDayNetChangePercentRange() const{return m_dayNetChangePercentRange;}
	const TakionRangePositiveNegative<Price>& GetDayNetOpenChangePercentRange() const{return m_dayNetOpenChangePercentRange;}
	const TakionRangePositive<Price>& GetDayPriceRangePercentRange() const{return m_dayPriceRangePercentRange;}

	virtual void toString(std::string& str) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;

	virtual unsigned char isPotentialFilterSame(const TakionFilter& filter) const override;//0 - same; 1 - to add; 2 - to remove; 3 - to add and remove
	virtual bool isFilterSame(const TakionFilter& filter) const override;
	virtual void Reset() override;

	bool SecBelongsByValues(const Security* security) const;
protected:
	PriceFilter();
	TakionRangePositive<Price> m_priceRange;
	TakionRangePositive<Price> m_openPriceRange;

	TakionRangePositiveNegative<Price> m_dayNetChangeRange;
	TakionRangePositive<Price> m_dayPriceRangeRange;

	TakionRangePositiveNegative<Price> m_dayNetChangePercentRange;
	TakionRangePositiveNegative<Price> m_dayNetOpenChangePercentRange;
	TakionRangePositive<Price> m_dayPriceRangePercentRange;
};

class TGUI_API StockFilter : public PriceFilter
{
public:
	StockFilter();
	virtual void Copy(const TakionFilter& other);

	virtual TakionFilter* CreateFilterCopy() const override;
	virtual unsigned char isA() const override{return FT_STOCK;}
	virtual bool isStockFilter() const override{return true;}
	void CopyMyFields(const StockFilter& other, unsigned int doNotCopyFlags);
	virtual void CopySymbolFilterOfOtherKind(const SymbolFilter& other, unsigned int doNotCopyFlags) override
	{
		if(other.isStockFilter())CopyMyFields((const StockFilter&)other, doNotCopyFlags);
		PriceFilter::CopySymbolFilterOfOtherKind(other, doNotCopyFlags);
	}
	bool MyFieldsEqual(const StockFilter& other, unsigned int doNotCopyFlags) const;
	virtual bool isSymbolIntersectionEqual(const SymbolFilter& other, unsigned int doNotCopyFlags) const override
	{
		return PriceFilter::isSymbolIntersectionEqual(other, doNotCopyFlags) && (!other.isStockFilter() || MyFieldsEqual((const StockFilter&)other, doNotCopyFlags));
	}
	virtual bool operator==(const TakionFilter& other) const override
	{
		return PriceFilter::operator==(other) && MyFieldsEqual((const StockFilter&)other, 0);
	}

	virtual bool isFiltering() const override;
	virtual bool isEmpty() const override;

	TakionRangePositive<unsigned __int64>& GetYesterdaysVolumeRange(){return m_yesterdaysVolumeRange;}
	TakionRangePositive<unsigned __int64>& GetTodaysVolumeRange(){return m_todaysVolumeRange;}
	TakionRangePositive<unsigned __int64>& GetTodaysPxMhVolumeRange(){return m_todaysPxMhVolumeRange;}

	TakionRangePositive<unsigned __int64>& GetAvgDailyVolumeRange(){return m_avgDailyVolumeRange;}
	TakionRangePositive<Money>& GetRelativeVolumeRange(){return m_relativeVolumeRange;}
	TakionRangePositive<Money>& GetPreMhVolRelRange(){return m_preMhVolRelRange;}
	TakionRangePositive<Price>& GetYesterdaysPriceRangeRange(){return m_yesterdaysPriceRangeRange;}
	TakionRangePositive<Price>& GetYesterdaysPriceRangePercentRange(){return m_yesterdaysPriceRangePercentRange;}

	TakionRangePositiveNegative<unsigned int>& GetImbalanceNyseRange(){return m_imbalanceNyseRange;}
	TakionRangePositiveNegative<unsigned int>& GetImbalanceNyseRegRange(){return m_imbalanceNyseRegRange;}
	TakionRangePositiveNegative<unsigned int>& GetImbalanceNsdqRange(){return m_imbalanceNsdqRange;}
	TakionRangePositiveNegative<unsigned int>& GetImbalanceArcaRange(){return m_imbalanceArcaRange;}
	TakionRangePositiveNegative<unsigned int>& GetImbalanceExchRange(){return m_imbalanceExchRange;}
	TakionRangePositiveNegative<Price>& GetRateImbalanceRange(){return m_rateImbalanceRange;}
	TakionRangePositiveNegative<Price>& GetImbNyDeltaInfRange(){return m_imbNyDeltaInfRange;}
	TakionRangePositiveNegative<Price>& GetImbExFarPriceDeltaRange(){return m_imbExFarPriceDeltaRange;}
	TakionRangePositiveNegative<Price>& GetImbNqFarPriceDeltaRange(){return m_imbNqFarPriceDeltaRange;}
	TakionRangePositiveNegative<Price>& GetImbNqThruRange(){return m_imbNqThruRange;}
	TakionRangePositiveNegative<Money>& GetImbExValueRange(){return m_imbExValueRange;}

	TakionRangePositive<Price>& GetImbExNearRange(){return m_imbExNearRange;}
	TakionRangePositive<Price>& GetImbExFarRange(){return m_imbExFarRange;}

	TakionRangePositive<unsigned int>& GetImbExMatchRange(){return m_imbExMatchRange;}
	TakionRangePositive<Money>& GetImbExVolPercentRange(){return m_imbExVolPercentRange;}
	TakionRangePositive<Money>& GetImbExYestVolPercentRange(){return m_imbExYestVolPercentRange;}

	TakionRangePositive<Price>& GetDeltaPvRange(){return m_deltaPvRange;}
	TakionRangePositive<Price>& GetRsiMhRange(){return m_rsiMhRange;}
	TakionRangePositive<Price>& GetRsiDaysRange(){return m_rsiDaysRange;}
	TakionRangePositive<Price>& GetBorrowPriceRange(){return m_borrowPriceRange;}
	TakionRangePositive<Price>& GetPmiSpreadRange(){return m_pmiSpreadRange;}
	TakionRangePositive<Price>& GetTodaysClosePriceRange(){return m_todaysClosePriceRange;}

	TakionRangePositiveNegative<Price>& GetBidNetRange(){return m_bidNetRange;}
	TakionRangePositiveNegative<Price>& GetAskNetRange(){return m_askNetRange;}

//Bid/Ask as % of Today's Close Price
	TakionRangePositiveNegative<Price>& GetTBidNetRange(){return m_tBidNetRange;}
	TakionRangePositiveNegative<Price>& GetTAskNetRange(){return m_tAskNetRange;}

	TakionRangePositiveNegative<Price>& GetBidNetPercentRange(){return m_bidNetPercentRange;}
	TakionRangePositiveNegative<Price>& GetAskNetPercentRange(){return m_askNetPercentRange;}

//Bid/Ask as % of Today's Close Price
	TakionRangePositiveNegative<Price>& GetTBidNetPercentRange(){return m_tBidNetPercentRange;}
	TakionRangePositiveNegative<Price>& GetTAskNetPercentRange(){return m_tAskNetPercentRange;}

	TakionRangePositiveNegative<SignedPrice>& GetLuldRange(){return m_luldRange;}
	TakionRangePositiveNegative<Money>& GetLuldPercentRange(){return m_luldPercentRange;}

//RSI Minutes
	const bool& isRsiMhCalculate() const{return m_rsiMhCalculate;}
	const unsigned short& GetRsiMhPriorPointCount() const{return m_rsiMhPriorPointCount;}
	const unsigned short& GetRsiMhPeriodLength() const{return m_rsiMhPeriodLength;}
	const unsigned short& GetRsiMhPeriodCount() const{return m_rsiMhPeriodCount;}
	const unsigned short& GetRsiMhStartMinute() const{return m_rsiMhStartMinute;}
	const bool& isRsiMhTodayOnly() const{return m_rsiMhTodayOnly;}
	const bool& isRsiMhPostMarket() const{return m_rsiMhPostMarket;}

	void SetRsiMhCalculate(const bool& calculate){m_rsiMhCalculate = calculate;}
	void SetRsiMhPriorPointCount(const unsigned short& count){m_rsiMhPriorPointCount = count;}
	void SetRsiMhPeriodLength(const unsigned short& length){m_rsiMhPeriodLength = length;}
	void SetRsiMhPeriodCount(const unsigned short& count){m_rsiMhPeriodCount = count;}
	void SetRsiMhStartMinute(const unsigned short& minute){m_rsiMhStartMinute = minute;}
	void SetRsiMhTodayOnly(const bool& todayOnly){m_rsiMhTodayOnly = todayOnly;}
	void SetRsiMhPostMarket(const bool& postMarket){m_rsiMhPostMarket = postMarket;}
//RSI Days
	const bool& isRsiDaysCalculate() const{return m_rsiDaysCalculate;}
	const unsigned short& GetRsiDaysPriorPointCount() const{return m_rsiDaysPriorPointCount;}
	const unsigned short& GetRsiDaysPeriodLength() const{return m_rsiDaysPeriodLength;}
	const unsigned short& GetRsiDaysPeriodCount() const{return m_rsiDaysPeriodCount;}
	const unsigned short& GetRsiDaysStartMinute() const{return m_rsiDaysStartMinute;}
	const bool& isRsiDaysPostMarket() const{return m_rsiDaysPostMarket;}

	void SetRsiDaysCalculate(const bool& calculate){m_rsiDaysCalculate = calculate;}
	void SetRsiDaysPriorPointCount(const unsigned short& count){m_rsiDaysPriorPointCount = count;}
	void SetRsiDaysPeriodLength(const unsigned short& length){m_rsiDaysPeriodLength = length;}
	void SetRsiDaysPeriodCount(const unsigned short& count){m_rsiDaysPeriodCount = count;}
	void SetRsiDaysStartMinute(const unsigned short& minute){m_rsiDaysStartMinute = minute;}
	void SetRsiDaysPostMarket(const bool& postMarket){m_rsiDaysPostMarket = postMarket;}

//
	const TakionRangePositive<unsigned __int64>& GetYesterdaysVolumeRange() const{return m_yesterdaysVolumeRange;}
	const TakionRangePositive<unsigned __int64>& GetTodaysVolumeRange() const{return m_todaysVolumeRange;}
	const TakionRangePositive<unsigned __int64>& GetTodaysPxMhVolumeRange() const{return m_todaysPxMhVolumeRange;}

	const TakionRangePositive<unsigned __int64>& GetAvgDailyVolumeRange() const{return m_avgDailyVolumeRange;}
	const TakionRangePositive<Money>& GetRelativeVolumeRange() const{return m_relativeVolumeRange;}
	const TakionRangePositive<Money>& GetPreMhVolRelRange() const{return m_preMhVolRelRange;}
	const TakionRangePositive<Price>& GetYesterdaysPriceRangeRange() const{return m_yesterdaysPriceRangeRange;}
	const TakionRangePositive<Price>& GetYesterdaysPriceRangePercentRange() const{return m_yesterdaysPriceRangePercentRange;}

	const TakionRangePositiveNegative<unsigned int>& GetImbalanceNyseRange() const{return m_imbalanceNyseRange;}
	const TakionRangePositiveNegative<unsigned int>& GetImbalanceNyseRegRange() const{return m_imbalanceNyseRegRange;}
	const TakionRangePositiveNegative<unsigned int>& GetImbalanceNsdqRange() const{return m_imbalanceNsdqRange;}
	const TakionRangePositiveNegative<unsigned int>& GetImbalanceArcaRange() const{return m_imbalanceArcaRange;}
	const TakionRangePositiveNegative<unsigned int>& GetImbalanceExchRange() const{return m_imbalanceExchRange;}
	const TakionRangePositiveNegative<Price>& GetRateImbalanceRange() const{return m_rateImbalanceRange;}
	const TakionRangePositiveNegative<Price> & GetImbNyDeltaInfRange() const{return m_imbNyDeltaInfRange;}
	const TakionRangePositiveNegative<Price>& GetImbExFarPriceDeltaRange() const{return m_imbExFarPriceDeltaRange;}
	const TakionRangePositiveNegative<Price>& GetImbNqFarPriceDeltaRange() const{return m_imbNqFarPriceDeltaRange;}
	const TakionRangePositiveNegative<Price>& GetImbNqThruRange() const{return m_imbNqThruRange;}
	const TakionRangePositiveNegative<Money>& GetImbExValueRange() const{return m_imbExValueRange;}
	const TakionRangePositive<Price>& GetImbExNearRange() const{return m_imbExNearRange;}
	const TakionRangePositive<Price>& GetImbExFarRange() const{return m_imbExFarRange;}
	const TakionRangePositive<unsigned int>& GetImbExMatchRange() const{return m_imbExMatchRange;}
	const TakionRangePositive<Money>& GetImbExVolPercentRange() const{return m_imbExVolPercentRange;}
	const TakionRangePositive<Money>& GetImbExYestVolPercentRange() const{return m_imbExYestVolPercentRange;}
	const TakionRangePositive<Price>& GetDeltaPvRange() const{return m_deltaPvRange;}
	const TakionRangePositive<Price>& GetRsiMhRange() const{return m_rsiMhRange;}
	const TakionRangePositive<Price>& GetRsiDaysRange() const{return m_rsiDaysRange;}
	const TakionRangePositive<Price>& GetBorrowPriceRange() const{return m_borrowPriceRange;}
	const TakionRangePositive<Price>& GetPmiSpreadRange() const{return m_pmiSpreadRange;}
	const TakionRangePositive<Price>& GetTodaysClosePriceRange() const{return m_todaysClosePriceRange;}

	const TakionRangePositiveNegative<Price>& GetBidNetRange() const{return m_bidNetRange;}
	const TakionRangePositiveNegative<Price>& GetAskNetRange() const{return m_askNetRange;}

//Bid/Ask as % of Today's Close Price
	const TakionRangePositiveNegative<Price>& GetTBidNetRange() const{return m_tBidNetRange;}
	const TakionRangePositiveNegative<Price>& GetTAskNetRange() const{return m_tAskNetRange;}

	const TakionRangePositiveNegative<Price>& GetBidNetPercentRange() const{return m_bidNetPercentRange;}
	const TakionRangePositiveNegative<Price>& GetAskNetPercentRange() const{return m_askNetPercentRange;}

//Bid/Ask as % of Today's Close Price
	const TakionRangePositiveNegative<Price>& GetTBidNetPercentRange() const{return m_tBidNetPercentRange;}
	const TakionRangePositiveNegative<Price>& GetTAskNetPercentRange() const{return m_tAskNetPercentRange;}

	const TakionRangePositiveNegative<SignedPrice>& GetLuldRange() const{return m_luldRange;}
	const TakionRangePositiveNegative<Money>& GetLuldPercentRange() const{return m_luldPercentRange;}

	const unsigned int& GetMarketCategoryFilter() const{return m_marketCategoryFilter;}
	void SetMarketCategoryFilter(const unsigned int& filter){m_marketCategoryFilter = filter;}

	const unsigned int& GetTestStockFilter() const{return m_testStockFilter;}
	void SetTestStockFilter(const unsigned int& filter){m_testStockFilter = filter;}

	const unsigned int& GetSecurityTypeFilter() const{return m_securityTypeFilter;}
	void SetSecurityTypeFilter(const unsigned int& filter){m_securityTypeFilter = filter;}

	const unsigned int& GetHtbFilter() const{return m_htbFilter;}
	void SetHtbFilter(const unsigned int& filter){m_htbFilter = filter;}

	const unsigned int& GetTradingStateFilter() const{return m_tradingStateFilter;}
	void SetTradingStateFilter(const unsigned int& filter){m_tradingStateFilter = filter;}

	const unsigned int& GetCircuitBreakerFilter() const{return m_circuitBreakerFilter;}
	void SetCircuitBreakerFilter(const unsigned int& filter){m_circuitBreakerFilter = filter;}

	const unsigned int& GetNasdaqQuoteConditionFilter() const{return m_nasdaqQuoteConditionFilter;}
	void SetNasdaqQuoteConditionFilter(const unsigned int& filter){m_nasdaqQuoteConditionFilter = filter;}
	const unsigned int& GetListedQuoteConditionFilter() const{return m_listedQuoteConditionFilter;}
	void SetListedQuoteConditionFilter(const unsigned int& filter){m_listedQuoteConditionFilter = filter;}

	virtual void toString(std::string& str) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;

	virtual bool SecurityBelongs(const SecurityChartRow* securityChartRow) const;
	bool SecurityBelongsByCalcValues(const SecurityChartRow* securityChartRow) const;
	bool SecurityBelongsByRsiMh(const SecurityChartRow* securityChartRow) const;
	bool SecurityBelongsByRsiDays(const SecurityChartRow* securityChartRow) const;

	bool SecBelongs(const Security* security) const;
	bool SecBelongsBySymbolInclude(const Security* security) const{return isSymbolIncluded(security->GetNumericSymbol());}//m_useInclude && isSymbolInIncludeSet(security->GetNumericSymbol());}
	bool SecBelongsBySymbolExclude(const Security* security) const{return !isSymbolExcluded(security->GetNumericSymbol());}//!m_useExclude || !isSymbolInExcludeSet(security->GetNumericSymbol());}
	bool SecBelongsByValues(const Security* security) const;
	bool SecBelongsByCalcValues(const Security* security) const;

	virtual bool SecurityPotentiallyBelongs(const Security* security) const;
	virtual unsigned char isPotentialFilterSame(const TakionFilter& filter) const override;//0 - same; 1 - to add; 2 - to remove; 3 - to add and remove
	virtual bool isFilterSame(const TakionFilter& filter) const override;
	virtual void Reset() override;
protected:
	unsigned int m_marketCategoryFilter;
	unsigned int m_testStockFilter;//1 - real; 2 - test; 3 - both
	unsigned int m_securityTypeFilter;
	unsigned int m_htbFilter;//1 - ETB; 2 - HTB available; 4 - htb available
	unsigned int m_tradingStateFilter;
	unsigned int m_circuitBreakerFilter;
	unsigned int m_nasdaqQuoteConditionFilter;
	unsigned int m_listedQuoteConditionFilter;
	TakionRangePositive<unsigned __int64> m_yesterdaysVolumeRange;
	TakionRangePositive<unsigned __int64> m_todaysVolumeRange;
	TakionRangePositive<unsigned __int64> m_todaysPxMhVolumeRange;
//	TakionRangePositive<unsigned int> m_volumeRateRange;
//	TakionRangePositive<Price> m_percentTVolByYVolRange;
//	TakionRangePositiveNegative<unsigned int, int> m_positionRange;

	TakionRangePositive<unsigned __int64> m_avgDailyVolumeRange;
	TakionRangePositive<Money> m_relativeVolumeRange;
	TakionRangePositive<Money> m_preMhVolRelRange;
	TakionRangePositive<Price> m_yesterdaysPriceRangeRange;
	TakionRangePositive<Price> m_yesterdaysPriceRangePercentRange;

	TakionRangePositiveNegative<unsigned int> m_imbalanceNyseRange;
	TakionRangePositiveNegative<unsigned int> m_imbalanceNyseRegRange;
	TakionRangePositiveNegative<unsigned int> m_imbalanceNsdqRange;
	TakionRangePositiveNegative<unsigned int> m_imbalanceArcaRange;
	TakionRangePositiveNegative<unsigned int> m_imbalanceExchRange;
	TakionRangePositiveNegative<Price> m_rateImbalanceRange;
	TakionRangePositiveNegative<Price> m_imbNyDeltaInfRange;
	TakionRangePositiveNegative<Price> m_imbExFarPriceDeltaRange;
	TakionRangePositiveNegative<Price> m_imbNqFarPriceDeltaRange;
	TakionRangePositiveNegative<Price> m_imbNqThruRange;
	TakionRangePositiveNegative<Money> m_imbExValueRange;
	TakionRangePositive<Price> m_imbExNearRange;
	TakionRangePositive<Price> m_imbExFarRange;
	TakionRangePositive<unsigned int> m_imbExMatchRange;
	TakionRangePositive<Money> m_imbExVolPercentRange;
	TakionRangePositive<Money> m_imbExYestVolPercentRange;
	TakionRangePositive<Price> m_deltaPvRange;
	TakionRangePositive<Price> m_rsiMhRange;
	TakionRangePositive<Price> m_rsiDaysRange;
	TakionRangePositive<Price> m_borrowPriceRange;
	TakionRangePositive<Price> m_pmiSpreadRange;
	TakionRangePositive<Price> m_todaysClosePriceRange;

	TakionRangePositiveNegative<Price> m_bidNetRange;
	TakionRangePositiveNegative<Price> m_askNetRange;

//Bid/Ask as % of Today's Close Price
	TakionRangePositiveNegative<Price> m_tBidNetRange;
	TakionRangePositiveNegative<Price> m_tAskNetRange;

	TakionRangePositiveNegative<Price> m_bidNetPercentRange;
	TakionRangePositiveNegative<Price> m_askNetPercentRange;

//Bid/Ask as % of Today's Close Price
	TakionRangePositiveNegative<Price> m_tBidNetPercentRange;
	TakionRangePositiveNegative<Price> m_tAskNetPercentRange;

	TakionRangePositiveNegative<SignedPrice> m_luldRange;
	TakionRangePositiveNegative<Money> m_luldPercentRange;

//RSI Minutes
	unsigned short m_rsiMhPriorPointCount;
	unsigned short m_rsiMhPeriodLength;
	unsigned short m_rsiMhPeriodCount;
	unsigned short m_rsiMhStartMinute;
	bool m_rsiMhCalculate;
	bool m_rsiMhTodayOnly;
	bool m_rsiMhPostMarket;
//RSI Days
	unsigned short m_rsiDaysPriorPointCount;
	unsigned short m_rsiDaysPeriodLength;
	unsigned short m_rsiDaysPeriodCount;
	unsigned short m_rsiDaysStartMinute;
	bool m_rsiDaysCalculate;
	bool m_rsiDaysPostMarket;
};

class TGUI_API TimeFrameFilter : public StockFilter
{
public:
	virtual void Copy(const TakionFilter& other) override;

	virtual bool isTimeFrameFilter() const override{return true;}
	void CopyMyFields(const TimeFrameFilter& other, unsigned int doNotCopyFlags);
	virtual void CopySymbolFilterOfOtherKind(const SymbolFilter& other, unsigned int doNotCopyFlags) override
	{
		if(other.isTimeFrameFilter())CopyMyFields((const TimeFrameFilter&)other, doNotCopyFlags);
		StockFilter::CopySymbolFilterOfOtherKind(other, doNotCopyFlags);
	}
	bool MyFieldsEqual(const TimeFrameFilter& other, unsigned int doNotCopyFlags) const;
	virtual bool isSymbolIntersectionEqual(const SymbolFilter& other, unsigned int doNotCopyFlags) const override
	{
		return StockFilter::isSymbolIntersectionEqual(other, doNotCopyFlags) && (!other.isTimeFrameFilter() || MyFieldsEqual((const TimeFrameFilter&)other, doNotCopyFlags));
	}
	virtual bool operator==(const TakionFilter& other) const override
	{
		return StockFilter::operator==(other) && MyFieldsEqual((const TimeFrameFilter&)other, 0);
	}

	virtual bool isFiltering() const override;
	virtual bool isEmpty() const override;

	TakionRangePositive<Price>& GetPriceRangeRange(){return m_priceRangeRange;}
	TakionRangePositiveNegative<Price>& GetNetChangeRange(){return m_netChangeRange;}
	TakionRangePositive<Price>& GetPriceRangePercentRange(){return m_priceRangePercentRange;}
	TakionRangePositiveNegative<Price>& GetNetChangePercentRange(){return m_netChangePercentRange;}
	TakionRangePositiveNegative<unsigned int>& GetHiLoCountRange(){return m_hiloCountRange;}
	TakionRangePositiveNegative<unsigned int>& GetTickCountRange(){return m_tickCountRange;}
	TakionRangePositive<unsigned int>& GetVolumeRateRange(){return m_volumeRateRange;}
	TakionRangePositive<Price>& GetVolumePercentRange(){return m_volumePercentRange;}
	TakionRangePositive<Price>& GetPercentTVolByYVolRange(){return m_percentTVolByYVolRange;}
	TakionRangePositiveNegative<unsigned int>& GetPositionRange(){return m_positionRange;}
	
	const TakionRangePositive<Price>& GetPriceRangeRange() const{return m_priceRangeRange;}
	const TakionRangePositiveNegative<Price>& GetNetChangeRange() const{return m_netChangeRange;}
	const TakionRangePositive<Price>& GetPriceRangePercentRange() const{return m_priceRangePercentRange;}
	const TakionRangePositiveNegative<Price>& GetNetChangePercentRange() const{return m_netChangePercentRange;}
	const TakionRangePositiveNegative<unsigned int>& GetHiLoCountRange() const{return m_hiloCountRange;}
	const TakionRangePositiveNegative<unsigned int>& GetTickCountRange() const{return m_tickCountRange;}
	const TakionRangePositive<unsigned int>& GetVolumeRateRange() const{return m_volumeRateRange;}
	const TakionRangePositive<Price>& GetVolumePercentRange() const{return m_volumePercentRange;}
	const TakionRangePositive<Price>& GetPercentTVolByYVolRange() const{return m_percentTVolByYVolRange;}
	const TakionRangePositiveNegative<unsigned int>& GetPositionRange() const{return m_positionRange;}

	static unsigned short GetValidTimeFrameMinutes(unsigned short timeFrameMinutes){return timeFrameMinutes > 720 ? 1440 : timeFrameMinutes > 390 ? 720 : timeFrameMinutes > 180 ? 390 : timeFrameMinutes < 2 ? 2 : timeFrameMinutes;}
	const unsigned short& GetTimeFrameMinutes() const{return m_timeFrameMinutes;}
	void SetTimeFrameMinutes(const unsigned short& timeFrameMinutes){m_timeFrameMinutes = GetValidTimeFrameMinutes(timeFrameMinutes);}

	static unsigned short GetValidMinutes(unsigned short timeFrameMinutes){return timeFrameMinutes > 180 ? 180 : timeFrameMinutes < 2 ? 2 : timeFrameMinutes;}
	const unsigned short& GetMinutes() const{return m_minutes;}
	void SetMinutes(const unsigned short& minutes){m_minutes = GetValidMinutes(minutes);}

	virtual void toString(std::string& str) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;

	virtual unsigned char isPotentialFilterSame(const TakionFilter& filter) const override;//0 - same; 1 - to add; 2 - to remove; 3 - to add and remove
	virtual bool isFilterSame(const TakionFilter& filter) const override;
	virtual bool SecurityBelongs(const SecurityChartRow* securityChartRow) const override;
	virtual void Reset() override;
	virtual void GetTimeFrameAsString(std::string& str, unsigned short msTimeFrame, bool timeFrameInMinutes) const override;
protected:
	TimeFrameFilter();
	unsigned short m_timeFrameMinutes;
	unsigned short m_minutes;
	TakionRangePositive<Price> m_priceRangeRange;
	TakionRangePositiveNegative<Price> m_netChangeRange;
	TakionRangePositive<Price> m_priceRangePercentRange;
	TakionRangePositiveNegative<Price> m_netChangePercentRange;
	TakionRangePositiveNegative<unsigned int> m_hiloCountRange;
	TakionRangePositiveNegative<unsigned int> m_tickCountRange;
	TakionRangePositive<unsigned int> m_volumeRateRange;
	TakionRangePositive<Price> m_volumePercentRange;
	TakionRangePositive<Price> m_percentTVolByYVolRange;
	TakionRangePositiveNegative<unsigned int> m_positionRange;
};

class TGUI_API MarketSorterFilter : public TimeFrameFilter//StockFilter
{
public:
	MarketSorterFilter():
		m_sortQuotesByActivity(true),
		m_sortPrintsByActivity(true)
	{}
	virtual bool isEmpty() const override
	{
		return TimeFrameFilter::isEmpty()
			&& m_sortQuotesByActivity
			&& m_sortPrintsByActivity
			;
	}
	virtual void Copy(const TakionFilter& other) override;

	virtual TakionFilter* CreateFilterCopy() const override;
	virtual unsigned char isA() const override{return FT_MARKET_SORTER;}
	virtual bool isMarketSorterFilter() const override{return true;}
	void CopyMyFields(const MarketSorterFilter& other, unsigned int doNotCopyFlags);
	virtual void CopySymbolFilterOfOtherKind(const SymbolFilter& other, unsigned int doNotCopyFlags) override
	{
		if(other.isMarketSorterFilter())CopyMyFields((const MarketSorterFilter&)other, doNotCopyFlags);
		TimeFrameFilter::CopySymbolFilterOfOtherKind(other, doNotCopyFlags);
	}
	bool MyFieldsEqual(const MarketSorterFilter& other, unsigned int doNotCopyFlags) const;
	virtual bool isSymbolIntersectionEqual(const SymbolFilter& other, unsigned int doNotCopyFlags) const override
	{
		return TimeFrameFilter::isSymbolIntersectionEqual(other, doNotCopyFlags) && (!other.isMarketSorterFilter() || MyFieldsEqual((const MarketSorterFilter&)other, doNotCopyFlags));
	}
	virtual bool operator==(const TakionFilter& other) const override
	{
		return TimeFrameFilter::operator==(other) && MyFieldsEqual((const MarketSorterFilter&)other, 0);
	}

	virtual void toString(std::string& str) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual bool SecurityBelongs(const SecurityChartRow* securityChartRow) const override;
	virtual bool SecurityPotentiallyBelongs(const Security* security) const override;
	virtual unsigned char isPotentialFilterSame(const TakionFilter& filter) const override;//0 - same; 1 - to add; 2 - to remove; 3 - to add and remove
	virtual bool isFilterSame(const TakionFilter& filter) const override;
	const bool& isSortQuotesByActivity() const{return m_sortQuotesByActivity;}
	void SetSortQuotesByActivity(bool byActivity){m_sortQuotesByActivity = byActivity;}
	const bool& isSortPrintsByActivity() const{return m_sortPrintsByActivity;}
	void SetSortPrintsByActivity(bool byActivity){m_sortPrintsByActivity = byActivity;}
	virtual void Reset() override
	{
		TimeFrameFilter::Reset();
		m_sortQuotesByActivity = true;
		m_sortPrintsByActivity = true;
	}
protected:
	bool m_sortQuotesByActivity;
	bool m_sortPrintsByActivity;
};

class TGUI_API IndexFilter : public PriceFilter//TimeFrameFilter
{
public:
	IndexFilter();
	virtual void Copy(const TakionFilter& other) override;

	virtual TakionFilter* CreateFilterCopy() const override;
	virtual unsigned char isA() const override{return FT_INDEX_SORTER;}
	virtual bool isIndexFilter() const override{return true;}
	void CopyMyFields(const IndexFilter& other, unsigned int doNotCopyFlags);
	virtual void CopySymbolFilterOfOtherKind(const SymbolFilter& other, unsigned int doNotCopyFlags) override
	{
		if(other.isIndexFilter())CopyMyFields((const IndexFilter&)other, doNotCopyFlags);
		PriceFilter::CopySymbolFilterOfOtherKind(other, doNotCopyFlags);
	}
	bool MyFieldsEqual(const IndexFilter& other, unsigned int doNotCopyFlags) const;
	virtual bool isSymbolIntersectionEqual(const SymbolFilter& other, unsigned int doNotCopyFlags) const override
	{
		return PriceFilter::isSymbolIntersectionEqual(other, doNotCopyFlags) && (!other.isIndexFilter() || MyFieldsEqual((const IndexFilter&)other, doNotCopyFlags));
	}
	virtual bool operator==(const TakionFilter& other) const override
	{
		return PriceFilter::operator==(other) && MyFieldsEqual((const IndexFilter&)other, 0);
	}

	virtual bool isFiltering() const override;
	virtual bool isEmpty() const override;

	TakionRangePositive<Price>& GetPriceRangeRange(){return m_priceRangeRange;}
	TakionRangePositiveNegative<Price>& GetNetChangeRange(){return m_netChangeRange;}
	TakionRangePositive<Price>& GetPriceRangePercentRange(){return m_priceRangePercentRange;}
	TakionRangePositiveNegative<Price>& GetNetChangePercentRange(){return m_netChangePercentRange;}
	TakionRangePositiveNegative<unsigned int>& GetHiLoCountRange(){return m_hiloCountRange;}
	TakionRangePositiveNegative<unsigned int>& GetTickCountRange(){return m_tickCountRange;}

	const TakionRangePositive<Price>& GetPriceRangeRange() const{return m_priceRangeRange;}
	const TakionRangePositiveNegative<Price>& GetNetChangeRange() const{return m_netChangeRange;}
	const TakionRangePositive<Price>& GetPriceRangePercentRange() const{return m_priceRangePercentRange;}
	const TakionRangePositiveNegative<Price>& GetNetChangePercentRange() const{return m_netChangePercentRange;}
	const TakionRangePositiveNegative<unsigned int>& GetHiLoCountRange() const{return m_hiloCountRange;}
	const TakionRangePositiveNegative<unsigned int>& GetTickCountRange() const{return m_tickCountRange;}

	static unsigned short GetValidTimeFrameMinutes(unsigned short timeFrameMinutes){return timeFrameMinutes > 720 ? 1440 : timeFrameMinutes > 390 ? 720 : timeFrameMinutes > 180 ? 390 : timeFrameMinutes < 2 ? 2 : timeFrameMinutes;}
	const unsigned short& GetTimeFrameMinutes() const{return m_timeFrameMinutes;}
	void SetTimeFrameMinutes(const unsigned short& timeFrameMinutes){m_timeFrameMinutes = GetValidTimeFrameMinutes(timeFrameMinutes);}

	static unsigned short GetValidMinutes(unsigned short timeFrameMinutes){return timeFrameMinutes > 180 ? 180 : timeFrameMinutes < 2 ? 2 : timeFrameMinutes;}
	const unsigned short& GetMinutes() const{return m_minutes;}
	void SetMinutes(const unsigned short& minutes){m_minutes = GetValidMinutes(minutes);}

	virtual void toString(std::string& str) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual bool IndexBelongs(const IndexChartRow* indexChartRow) const;
	virtual bool IndexPotentiallyBelongs(const Index* index) const;
	virtual unsigned char isPotentialFilterSame(const TakionFilter& filter) const override;//0 - same; 1 - to add; 2 - to remove; 3 - to add and remove
	virtual bool isFilterSame(const TakionFilter& filter) const override;
//	const bool& isHideAll() const{return m_hideAll;}
//	void SetHideAll(const bool& hideAll){m_hideAll = hideAll;}

	const unsigned int& GetCalcIndexFilter() const{return m_calcIndexFilter;}
	void SetCalcIndexFilter(const unsigned int& filter){m_calcIndexFilter = filter;}

	bool IndBelongsBySymbolInclude(const Index* index) const{return isSymbolIncluded(index->GetNumericSymbol());}//m_useInclude && m_includeSymbolSet.find(index->GetNumericSymbol()) != m_includeSymbolSetEnd;}
	bool IndBelongsBySymbolExclude(const Index* index) const{return !isSymbolExcluded(index->GetNumericSymbol());}//!m_useExclude || m_excludeSymbolSet.find(index->GetNumericSymbol()) == m_excludeSymbolSetEnd;}

	virtual void Reset() override;
protected:
	unsigned short m_timeFrameMinutes;
	unsigned short m_minutes;
	TakionRangePositive<Price> m_priceRangeRange;
	TakionRangePositiveNegative<Price> m_netChangeRange;
	TakionRangePositive<Price> m_priceRangePercentRange;
	TakionRangePositiveNegative<Price> m_netChangePercentRange;
	TakionRangePositiveNegative<unsigned int> m_hiloCountRange;
	TakionRangePositiveNegative<unsigned int> m_tickCountRange;
	unsigned int m_calcIndexFilter;//1 - real; 2 - calc; 3 - both
//	bool m_hideAll;
};

class TGUI_API SecurityScrollerFilter : public TimeFrameFilter//StockFilter
{
public:
	virtual void Copy(const TakionFilter& other) override;

	virtual bool isSecurityScrollerFilter() const override{return true;}
	void CopyMyFields(const SecurityScrollerFilter& other, unsigned int doNotCopyFlags);
	virtual void CopySymbolFilterOfOtherKind(const SymbolFilter& other, unsigned int doNotCopyFlags) override
	{
		if(other.isSecurityScrollerFilter())CopyMyFields((const SecurityScrollerFilter&)other, doNotCopyFlags);
		TimeFrameFilter::CopySymbolFilterOfOtherKind(other, doNotCopyFlags);
	}
	bool MyFieldsEqual(const SecurityScrollerFilter& other, unsigned int doNotCopyFlags) const;
	virtual bool isSymbolIntersectionEqual(const SymbolFilter& other, unsigned int doNotCopyFlags) const override
	{
		return TimeFrameFilter::isSymbolIntersectionEqual(other, doNotCopyFlags) && (!other.isSecurityScrollerFilter() || MyFieldsEqual((const SecurityScrollerFilter&)other, doNotCopyFlags));
	}
	virtual bool operator==(const TakionFilter& other) const override
	{
		return TimeFrameFilter::operator==(other) && MyFieldsEqual((const SecurityScrollerFilter&)other, 0);
	}

	virtual void toString(std::string& str) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual bool SecurityBelongs(const SecurityChartRow* securityChartRow) const override;
	virtual bool SecurityPotentiallyBelongs(const Security* security) const override;
	virtual unsigned char isPotentialFilterSame(const TakionFilter& filter) const override;//0 - same; 1 - to add; 2 - to remove; 3 - to add and remove
	virtual bool isFilterSame(const TakionFilter& filter) const override;
protected:
	SecurityScrollerFilter(){}
};


class TGUI_API AtomicPriceRange : public TakionRangePositive<Price>
{
public:
	AtomicPriceRange(const Price& minValue, const Price& maxValue, bool percent, const Price& atomicPrice, bool use = false):
		TakionRangePositive(minValue, maxValue, use, false, false),
		m_atomicPrice(atomicPrice),
		m_percent(percent)
	{
		UpdateAtomicPriceAsUInt();
	}
	AtomicPriceRange():TakionRangePositive(Price::priceZero, Price::priceZero, false, false, false), m_atomicPriceAsUInt(0), m_percent(false){}
//	virtual bool isValueIn(const T& value) const{return isPositiveValueIn(value);}
	virtual bool isEmpty() const override
	{
		return TakionRangePositive::isEmpty()
			&& m_atomicPrice.isZero()
			&& !m_percent
			;
	}
	const Price& GetAtomicPrice() const{return m_atomicPrice;}
	const unsigned int& GetAtomicPriceAsUInt() const{return m_atomicPriceAsUInt;}
	void SetAtomicPrice(const Price& price)
	{
		m_atomicPrice = price;
		UpdateAtomicPriceAsUInt();
	}
	bool isPercent() const{return m_percent;}
	void SetPercent(bool percent){m_percent = percent;}
	virtual bool operator==(const TakionRange& other) const
	{
		if(TakionRangePositive::operator==(other))
		{
			const AtomicPriceRange& aprOther = (const AtomicPriceRange&)other;
			return m_atomicPrice == aprOther.m_atomicPrice && m_percent == aprOther.m_percent;
		}
		return false;
	}
	virtual void toString(std::string& str) const override
	{
		TakionRangePositive::toString(str);
		TypeToString(m_atomicPrice, str);
		U_AppendBool(str, m_percent, settingDel);
	}
	virtual void fromString(const char*& cursor) override
	{
		TakionRangePositive::fromString(cursor);
		TypeFromString(m_atomicPrice, cursor);
		m_percent = U_ReadBoolToken(cursor, settingDel);
		UpdateAtomicPriceAsUInt();
	}
	static unsigned int CalculateAtomicPriceAsUInt(const Price& price)
	{
		return (price.GetDollars() * 100 + price.GetDollarFraction() / (Price::divider / 100));
	}
protected:
	Price m_atomicPrice;
	void UpdateAtomicPriceAsUInt()
	{
		m_atomicPriceAsUInt = CalculateAtomicPriceAsUInt(m_atomicPrice);
	}
	unsigned int m_atomicPriceAsUInt;
	bool m_percent;
};

class TGUI_API HiLoScrollerFilter : public SecurityScrollerFilter
{
public:
	HiLoScrollerFilter():
		m_useAtomicPrice(false),
		m_oddLotPrints(false),
		m_printJumpMode(false),
		m_outOfRangePercent(false),
		m_outOfRangeAtomicPriceAsUInt(0),
		m_atomicPriceVectorBegin(m_atomicPriceVector.begin()),
		m_atomicPriceVectorEnd(m_atomicPriceVector.end()),
		m_usedAtomicPriceVectorBegin(m_usedAtomicPriceVector.begin()),
		m_usedAtomicPriceVectorEnd(m_usedAtomicPriceVector.end())
	{}
	HiLoScrollerFilter(const HiLoScrollerFilter& other):
		SecurityScrollerFilter(other),
		m_useAtomicPrice(other.m_useAtomicPrice),
		m_oddLotPrints(other.m_oddLotPrints),
		m_printJumpMode(other.m_printJumpMode),
		m_outOfRangePercent(other.m_outOfRangePercent),
		m_outOfRangeAtomicPrice(other.m_outOfRangeAtomicPrice),
		m_outOfRangeAtomicPriceAsUInt(other.m_outOfRangeAtomicPriceAsUInt),
		m_atomicPriceVector(other.m_atomicPriceVector),
		m_atomicPriceVectorBegin(m_atomicPriceVector.begin()),
		m_atomicPriceVectorEnd(m_atomicPriceVector.end()),
		m_usedAtomicPriceVector(other.m_usedAtomicPriceVector),
		m_usedAtomicPriceVectorBegin(m_usedAtomicPriceVector.begin()),
		m_usedAtomicPriceVectorEnd(m_usedAtomicPriceVector.end())
	{}
	HiLoScrollerFilter& operator=(const HiLoScrollerFilter& other)
	{
		SecurityScrollerFilter::operator=(other);
		m_useAtomicPrice = other.m_useAtomicPrice;
		m_oddLotPrints = other.m_oddLotPrints;
		m_printJumpMode = other.m_printJumpMode;
		m_outOfRangePercent = other.m_outOfRangePercent;
		m_outOfRangeAtomicPrice = other.m_outOfRangeAtomicPrice;
		m_outOfRangeAtomicPriceAsUInt = other.m_outOfRangeAtomicPriceAsUInt;
		m_atomicPriceVector = other.m_atomicPriceVector;
		UpdateAtomicPriceIterators();
		m_usedAtomicPriceVector = other.m_usedAtomicPriceVector;
		UpdateUsedAtomicPriceIterators();
		return *this;
	}
	virtual bool isEmpty() const override
	{
		return SecurityScrollerFilter::isEmpty()
			&& !m_useAtomicPrice
			&& !m_oddLotPrints
			&& !m_printJumpMode
			&& !m_outOfRangePercent
			&& m_outOfRangeAtomicPrice.isZero()
			&& m_atomicPriceVector.empty()
			;
	}
	virtual void Copy(const TakionFilter& other) override;

	virtual TakionFilter* CreateFilterCopy() const override;
	virtual unsigned char isA() const override{return FT_HILO_SCROLLER;}
	virtual bool isHiLoScrollerFilter() const override{return true;}
	void CopyMyFields(const HiLoScrollerFilter& other, unsigned int doNotCopyFlags);
	virtual void CopySymbolFilterOfOtherKind(const SymbolFilter& other, unsigned int doNotCopyFlags) override
	{
		if(other.isHiLoScrollerFilter())CopyMyFields((const HiLoScrollerFilter&)other, doNotCopyFlags);
		SecurityScrollerFilter::CopySymbolFilterOfOtherKind(other, doNotCopyFlags);
	}
	bool MyFieldsEqual(const HiLoScrollerFilter& other, unsigned int doNotCopyFlags) const;
	virtual bool isSymbolIntersectionEqual(const SymbolFilter& other, unsigned int doNotCopyFlags) const override
	{
		return SecurityScrollerFilter::isSymbolIntersectionEqual(other, doNotCopyFlags) && (!other.isHiLoScrollerFilter() || MyFieldsEqual((const HiLoScrollerFilter&)other, doNotCopyFlags));
	}
	virtual bool operator==(const TakionFilter& other) const override
	{
		return SecurityScrollerFilter::operator==(other) && MyFieldsEqual((const HiLoScrollerFilter&)other, 0);
	}

	virtual void toString(std::string& str) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual bool SecurityBelongs(const SecurityChartRow* securityChartRow) const override;
	virtual bool SecurityPotentiallyBelongs(const Security* security) const override;
	virtual unsigned char isPotentialFilterSame(const TakionFilter& filter) const override;//0 - same; 1 - to add; 2 - to remove; 3 - to add and remove
	virtual bool isFilterSame(const TakionFilter& filter) const override;

	const bool& isUseAtomicPrice() const{return m_useAtomicPrice;}
	void SetUseAtomicPrice(const bool& use){m_useAtomicPrice = use;}

	const bool& isOddLotPrints() const{return m_oddLotPrints;}
	void SetOddLotPrints(const bool& oddLotPrints){m_oddLotPrints = oddLotPrints;}

	const bool& isPrintJumpMode() const{return m_printJumpMode;}
	void SetPrintJumpMode(const bool& printJumpMode){m_printJumpMode = printJumpMode;}

	const bool& isOutOfRangePecent() const{return m_outOfRangePercent;}
	void SetOutOfRangePecent(const bool& percent){m_outOfRangePercent = percent;}

	const Price& GetOutOfRangeAtomicPrice() const{return m_outOfRangeAtomicPrice;}
	void SetOutOfRangeAtomicPrice(const Price& price)
	{
		m_outOfRangeAtomicPrice = price;
		UpateOutOfRangeAtomicPriceAsUInt();
	}

	typedef std::vector<AtomicPriceRange> AtomicPriceVector;
	const AtomicPriceVector& GetAtomicPriceVector() const{return m_atomicPriceVector;}
	const AtomicPriceVector& GetUsedAtomicPriceVector() const{return m_usedAtomicPriceVector;}
	void ClearAtomicPrices()
	{
		m_atomicPriceVector.clear();
		UpdateAtomicPriceIterators();
		m_usedAtomicPriceVector.clear();
		UpdateUsedAtomicPriceIterators();
	}
	void AddAtomicPrice(const AtomicPriceRange& range)
	{
		m_atomicPriceVector.push_back(range);
		UpdateAtomicPriceIterators();
		if(range.isUse())
		{
			m_usedAtomicPriceVector.push_back(range);
			UpdateUsedAtomicPriceIterators();
		}
	}

	bool isAtomicPriceSame(const HiLoScrollerFilter& other) const;

	void CalculateAtomicPrice(const Price& stockPrice, Price& atomicPrice) const;
	const unsigned int& GetOutOfRangeAtomicPriceAsUInt() const{return m_outOfRangeAtomicPriceAsUInt;}
protected:
	bool m_useAtomicPrice;
	bool m_oddLotPrints;
	bool m_printJumpMode;
	bool m_outOfRangePercent;
	Price m_outOfRangeAtomicPrice;
	unsigned int m_outOfRangeAtomicPriceAsUInt;
	void UpateOutOfRangeAtomicPriceAsUInt()
	{
		m_outOfRangeAtomicPriceAsUInt = AtomicPriceRange::CalculateAtomicPriceAsUInt(m_outOfRangeAtomicPrice);
	}
	AtomicPriceVector m_atomicPriceVector;
	AtomicPriceVector::const_iterator m_atomicPriceVectorBegin;
	AtomicPriceVector::const_iterator m_atomicPriceVectorEnd;
	void UpdateAtomicPriceIterators()
	{
		m_atomicPriceVectorBegin = m_atomicPriceVector.begin();
		m_atomicPriceVectorEnd = m_atomicPriceVector.end();
	}

	AtomicPriceVector m_usedAtomicPriceVector;
	AtomicPriceVector::const_iterator m_usedAtomicPriceVectorBegin;
	AtomicPriceVector::const_iterator m_usedAtomicPriceVectorEnd;
	void UpdateUsedAtomicPriceIterators()
	{
		m_usedAtomicPriceVectorBegin = m_usedAtomicPriceVector.begin();
		m_usedAtomicPriceVectorEnd = m_usedAtomicPriceVector.end();
	}
};

class TGUI_API RangeUseCheckBox : public CheckBoxOwnerDraw
{
public:
	RangeUseCheckBox();
};

class TGUI_API RangeSignCheckBox : public CheckBoxOwnerDraw
{
public:
	RangeSignCheckBox();
};

class TGUI_API RangeGroupBase
{
public:
	virtual ~RangeGroupBase(){}
	bool isRangeBaseModified(const TakionUse& use) const
	{
		return use.isUse() == (m_CheckBox.GetCheck() == BST_UNCHECKED);
	}
	virtual bool isRangeEmpty() const
	{
		return m_CheckBox.GetCheck() == BST_UNCHECKED;
	}
	virtual void SetRangeEmpty()
	{
		m_CheckBox.SetCheck(BST_UNCHECKED);
	}
	void SetBaseUse(TakionUse& use) const
	{
		use.SetUse(m_CheckBox.GetCheck() == BST_CHECKED);
	}
	virtual bool SetBaseUseControl(const TakionUse& use)
	{
		if(m_CheckBox.m_hWnd && (m_CheckBox.GetCheck() == BST_CHECKED) != use.isUse())
		{
			m_CheckBox.SetCheck(use.isUse() ? BST_CHECKED : BST_UNCHECKED);
			m_CheckBox.Invalidate(FALSE);
			return true;
		}
		return false;
	}
	const unsigned short& GetIdGroup() const{return m_idGroup;}
	const unsigned short& GetIdCheckBox() const{return m_idCheckBox;}
	const unsigned short& GetIdSpinMin() const{return m_idSpinMin;}
	const unsigned short& GetIdSpinMax() const{return m_idSpinMax;}
	virtual unsigned short GetIdPositive() const{return 0;}
	virtual unsigned short GetIdNegative() const{return 0;}
	virtual CWnd& GetSpinWnd(bool minValue) = 0;
	virtual CWnd* GetPositiveNegativeCheckBox(bool positive){return NULL;}
	virtual void Show(unsigned int show)//SW_SHOW or SW_HIDE
	{
		m_GroupBox.ShowWindow(show);
		m_CheckBox.ShowWindow(show);
	}
	void InvalidateCheckBoxUse(){if(m_CheckBox.m_hWnd)m_CheckBox.Invalidate(FALSE);}
	bool isCheckBoxUseChecked() const{return m_CheckBox.m_hWnd && m_CheckBox.GetCheck() == BST_CHECKED;}
	virtual bool isUsed() const{return isCheckBoxUseChecked();}
	virtual void EnableToolTips(bool enable, CToolTipCtrl* externalToolTip)
	{
		m_CheckBox.EnableTooltips(enable, externalToolTip);
	}
	void SetToolTip(const char* const& toolTip)
	{
		m_CheckBox.SetTooltipText(toolTip);
	}
	void SetUseBoxColor(const COLORREF& color){m_CheckBox.SetBoxColor(color);}
	void SetUseBoxDeflation(const int& deflation){m_CheckBox.SetBoxDeflation(deflation);}
	void SetUseBoxColorAndDeflation(const COLORREF& color, const int& deflation){m_CheckBox.SetBoxColorAndDeflation(color, deflation);}
	virtual void SetBkColor(const COLORREF& color)
	{
		m_CheckBox.SetBackgroundColor(color);
	}

	CButton m_GroupBox;
	RangeUseCheckBox m_CheckBox;
protected:
	RangeGroupBase(const unsigned short& idGroup,
		const unsigned short& idCheckBox,
		const unsigned short& idSpinMin,
		const unsigned short& idSpinMax,
		const char* const& toolTip = NULL):
//		const COLORREF& disabledSpinColor = 0xFFFFFFFF);
		m_idGroup(idGroup),
		m_idCheckBox(idCheckBox),
		m_idSpinMin(idSpinMin),
		m_idSpinMax(idSpinMax)
//		m_disabledSpinColor(disabledSpinColor)
	{
		SetToolTip(toolTip);
//		if(0xFFFFFFFF == m_disabledSpinColor)m_disabledSpinColor = takionVisual->GetLightGrayColor();
	}
	unsigned short m_idGroup;
	unsigned short m_idCheckBox;
	unsigned short m_idSpinMin;
	unsigned short m_idSpinMax;

//	COLORREF m_disabledSpinColor;
};

template<class T>
class RangeGroup : public RangeGroupBase
{
public:
	typedef T RangeType;
	RangeGroup(const unsigned short& idGroup,
		const unsigned short& idCheckBox,
		const unsigned short& idSpinMin,
		const unsigned short& idSpinMax,
		const T& maxValue,
		const unsigned int& cellCount,
		const unsigned char& decDigits,
		const COLORREF& colorValid = RGB(255, 255, 255),
		const COLORREF& colorUsed = RGB(128, 255, 128),
		const COLORREF& colorInvalid = 0xFFFFFFFF,
		const char* const& toolTip = NULL,
		const bool& zeroValid = true,
		const COLORREF& borderColor = 0):
		RangeGroupBase(idGroup, idCheckBox, idSpinMin, idSpinMax, toolTip),
		m_SpinMin(maxValue, 0, 0, 1000, 3, TakionSpin::charComma, decDigits, TakionSpin::charDot, 1, true, true, false, borderColor),
		m_SpinMax(maxValue, 0, 0, 1000, 3, TakionSpin::charComma, decDigits, TakionSpin::charDot, 1, true, true, false, borderColor),
		m_colorValid(colorValid),
		m_colorUsed(colorUsed),
		m_bkColorSpin(colorValid),
		m_colorInvalid(colorInvalid),
		m_zeroValid(zeroValid),
		m_valid(true)
	{
		m_SpinMin.SetBkColorEnabled(m_colorValid);
		m_SpinMax.SetBkColorEnabled(m_colorValid);
		m_SpinMin.AddSpinCell(1, false);
		m_SpinMax.AddSpinCell(1, false);
		if(cellCount > 1)
		{
			m_SpinMin.AddSpinCell(100, false);
			m_SpinMax.AddSpinCell(100, false);
		}
		if(sizeof(RangeType) >= 4)
		{
			if(cellCount > 3)
			{
				m_SpinMin.AddSpinCell((RangeType)100000000, true);
				m_SpinMax.AddSpinCell((RangeType)100000000, true);
			}
		}
		if(cellCount > 2)
		{
//			m_SpinMin.AddSpinCell(100000, true);
//			m_SpinMax.AddSpinCell(100000, true);
			m_SpinMin.AddSpinCell(10000, true);
			m_SpinMax.AddSpinCell(10000, true);
		}
		switch(decDigits)
		{
			case 0:
			m_divider = 1;
			break;

			case 1:
			m_divider = 10;
			break;

			case 2:
			m_divider = 100;
			break;

			case 3:
			m_divider = 1000;
			break;

			default:
			m_divider = 10000;
			break;
		}
		m_priceMultiplier = Price::divider / m_divider;
		m_moneyMultiplier = Money::divider / m_divider;

		m_SpinMin.SetTooltipText("Min Value");
		m_SpinMax.SetTooltipText("Max Value (Zero means unlimited if Min Value > Zero");
	}
	void SetSpinToolTips(const char* const& minToolTip, const char* const& maxToolTip)
	{
		m_SpinMin.SetTooltipText(minToolTip);
		m_SpinMax.SetTooltipText(maxToolTi)p;
	}
	virtual void EnableToolTips(bool enable, CToolTipCtrl* externalToolTip) override
	{
		RangeGroupBase::EnableToolTips(enable, externalToolTip);
		m_SpinMin.EnableTooltips(enable, externalToolTip);
		m_SpinMax.EnableTooltips(enable, externalToolTip);
	}
	virtual bool isRangeEmpty() const override
	{
		return RangeGroupBase::isRangeEmpty() && !m_SpinMin.GetValue() && !m_SpinMax.GetValue();
	}
	virtual void SetRangeEmpty() override
	{
		RangeGroupBase::SetRangeEmpty();
		m_SpinMin.SetValue(0, false, true, false);
		m_SpinMax.SetValue(0, false, true, false);
//		UpdateRangeValid();
		UpdateUse();
	}
	void SetBkColorEnabled(const COLORREF& color)
	{
		m_SpinMin.SetBkColorEnabled(color);
		m_SpinMax.SetBkColorEnabled(color);
	}
	void SetBkColorDisabled(const COLORREF& color)
	{
		m_SpinMin.SetBkColorDisabled(color);
		m_SpinMax.SetBkColorDisabled(color);
	}
	void SetBorderColor(const COLORREF& color)
	{
		m_SpinMin.SetBorderColor(color);
		m_SpinMax.SetBorderColor(color);
	}

	void SetArrowColor(const COLORREF& color)
	{
		m_SpinMin.SetArrowColor(color);
		m_SpinMax.SetArrowColor(color);
	}

	void InvalidateSpins()
	{
		m_SpinMin.Invalidate(FALSE);
		m_SpinMax.Invalidate(FALSE);
	}
	void FillMoney(Money& money, const bool& minValue) const
	{
		const T& value = GetValue(minValue);
		const T dollars = value / m_divider;
		money.SetValue(dollars, (short)(m_moneyMultiplier * (value - m_divider * dollars)));
	}
	void FillPrice(Price& price, const bool& minValue) const
	{
		const T& value = GetValue(minValue);
		const T dollars = value / m_divider;
		price.SetValue((unsigned int)dollars, (unsigned int)(m_priceMultiplier * (value - m_divider * dollars)));
	}

	void FillPrice(SignedPrice& price, const bool& minValue) const
	{
		const T& value = GetValue(minValue);
		const T dollars = value / m_divider;
		price.SetValue(dollars, (m_priceMultiplier * (value - m_divider * dollars)));
	}

	const T& GetValue(const bool& minValue) const{return minValue ? m_SpinMin.GetValue() : m_SpinMax.GetValue();}

	bool isValueModified(const TakionRange<Money, Money>& range, const bool& minValue) const
	{
		Money money;
		FillMoney(money, minValue);
		return range.GetMinMax(minValue) != money;
	}

	bool isValueModified(const TakionRange<Price, Price>& range, const bool& minValue) const
	{
		Price money;
		FillPrice(money, minValue);
		return range.GetMinMax(minValue) != money;
	}

	bool isValueModified(const TakionRange<Price, SignedPrice>& range, const bool& minValue) const
	{
		Price money;
		FillPrice(money, minValue);
		return range.GetMinMax(minValue) != money;
	}

	bool isValueModified(const TakionRange<SignedPrice, SignedPrice>& range, const bool& minValue) const
	{
		Price money;
		FillPrice(money, minValue);
		return range.GetMinMax(minValue) != money;
	}

	bool isValueModified(const TakionRange<unsigned short>& range, const bool& minValue) const
	{
		return range.GetMinMax(minValue) != GetValue(minValue);
	}

	bool isValueModified(const TakionRange<unsigned short, short>& range, const bool& minValue) const
	{
		return range.GetMinMax(minValue) != GetValue(minValue);
	}

	bool isValueModified(const TakionRange<unsigned int>& range, const bool& minValue) const
	{
		return range.GetMinMax(minValue) != GetValue(minValue);
	}

	bool isValueModified(const TakionRange<unsigned int, int>& range, const bool& minValue) const
	{
		return range.GetMinMax(minValue) != GetValue(minValue);
	}

	bool isValueModified(const TakionRange<unsigned __int64>& range, const bool& minValue) const
	{
		return range.GetMinMax(minValue) != GetValue(minValue);
	}

	bool isRangeValid() const
	{
//		if(m_CheckBox.GetCheck() == BST_UNCHECKED)
		if(!isUsed())
		{
			return true;
		}
		const T& minValue = GetValue(true);
		const T& maxValue = GetValue(false);
//		return (minValue <= maxValue || EqualsZero(maxValue)) && (m_zeroValid || !EqualsZero(minValue) || !EqualsZero(maxValue));
		return (minValue <= maxValue || !maxValue) && (m_zeroValid || !!minValue || !!maxValue);
	}

	virtual bool SetBaseUseControl(const TakionUse& use)
	{
		bool ret = RangeGroupBase::SetBaseUseControl(use);
		if(ret)
		{
			m_bkColorSpin = use.isUse() ? m_colorUsed : m_colorValid;
			if(m_valid)
			{
				SetBkColorEnabled(m_bkColorSpin);
				InvalidateSpins();
			}
		}
		return ret;
	}
	virtual void UpdateUse()
	{
//		InvalidateCheckBoxUse();
		m_bkColorSpin = isUsed() == BST_CHECKED ? m_colorUsed : m_colorValid;
		if(!UpdateRangeValid())
		{
			if(m_valid)
			{
				SetBkColorEnabled(m_bkColorSpin);
				InvalidateSpins();
			}
		}
	}
	bool UpdateRangeValid()
	{
		if(m_valid != isRangeValid())
		{
			m_valid = !m_valid;
			if(m_colorInvalid != 0xFFFFFFFF)
			{
				SetBkColorEnabled(m_valid ? m_bkColorSpin : m_colorInvalid);
			}
			InvalidateSpins();
//			m_SpinMin.Invalidate(FALSE);
//			m_SpinMax.Invalidate(FALSE);
			return true;
		}
		return false;
	}

	const bool& isValid() const{return m_valid;}

	const bool& isZeroValid() const{return m_zeroValid;}
	bool isRangeModified(const TakionRange<Money, Money>& range) const
	{
		if(isRangeBaseModified(range))
		{
			return true;
		}
		Money money;
		FillMoney(money, true);
		if(range.GetMin() != money)
		{
			return true;
		}
		FillMoney(money, false);
		return range.GetMax() != money;
	}
	bool isRangeModified(const TakionRange<Price, Price>& range) const
	{
		if(isRangeBaseModified(range))
		{
			return true;
		}
		Price money;
		FillPrice(money, true);
		if(range.GetMin() != money)
		{
			return true;
		}
		FillPrice(money, false);
		return range.GetMax() != money;
	}
	bool isRangeModified(const TakionRange<Price, SignedPrice>& range) const
	{
		if(isRangeBaseModified(range))
		{
			return true;
		}
		Price money;
		FillPrice(money, true);
		if(range.GetMin() != money)
		{
			return true;
		}
		FillPrice(money, false);
		return range.GetMax() != money;
	}
	bool isRangeModified(const TakionRange<SignedPrice, SignedPrice>& range) const
	{
		if(isRangeBaseModified(range))
		{
			return true;
		}
		SignedPrice money;
		FillPrice(money, true);
		if(range.GetMin() != money)
		{
			return true;
		}
		FillPrice(money, false);
		return range.GetMax() != money;
	}
	bool isRangeModified(const TakionRange<unsigned short>& range) const
	{
		if(isRangeBaseModified(range))
		{
			return true;
		}
		return range.GetMin() != GetValue(true) || range.GetMax() != GetValue(false);
	}
	bool isRangeModified(const TakionRange<unsigned short, short>& range) const
	{
		if(isRangeBaseModified(range))
		{
			return true;
		}
		return range.GetMin() != GetValue(true) || range.GetMax() != GetValue(false);
	}

	bool isRangeModified(const TakionRange<unsigned int>& range) const
	{
		if(isRangeBaseModified(range))
		{
			return true;
		}
		return range.GetMin() != GetValue(true) || range.GetMax() != GetValue(false);
	}
	bool isRangeModified(const TakionRange<unsigned int, int>& range) const
	{
		if(isRangeBaseModified(range))
		{
			return true;
		}
		return range.GetMin() != GetValue(true) || range.GetMax() != GetValue(false);
	}

	bool isRangeModified(const TakionRange<unsigned __int64>& range) const
	{
		if(isRangeBaseModified(range))
		{
			return true;
		}
		return range.GetMin() != GetValue(true) || range.GetMax() != GetValue(false);
	}
	void SetRange(TakionRange<Money, Money>& range) const
	{
		SetBaseUse(range);
		Money money;
		FillMoney(money, true);
		range.SetMin(money);
		FillMoney(money, false);
		range.SetMax(money);
	}
	void SetRange(TakionRange<Price, Price>& range) const
	{
		SetBaseUse(range);
		Price money;
		FillPrice(money, true);
		range.SetMin(money);
		FillPrice(money, false);
		range.SetMax(money);
	}
	void SetRange(TakionRange<Price, SignedPrice>& range) const
	{
		SetBaseUse(range);
		Price money;
		FillPrice(money, true);
		range.SetMin(money);
		FillPrice(money, false);
		range.SetMax(money);
	}
	void SetRange(TakionRange<SignedPrice, SignedPrice>& range) const
	{
		SetBaseUse(range);
		SignedPrice money;
		FillPrice(money, true);
		range.SetMin(money);
		FillPrice(money, false);
		range.SetMax(money);
	}
	void SetRange(TakionRange<unsigned short>& range) const
	{
		SetBaseUse(range);
		range.SetMinMax(GetValue(true), GetValue(false));
	}
	void SetRange(TakionRange<unsigned short, short>& range) const
	{
		SetBaseUse(range);
		range.SetMinMax(GetValue(true), GetValue(false));
	}
	void SetRange(TakionRange<unsigned int>& range) const
	{
		SetBaseUse(range);
		range.SetMinMax(GetValue(true), GetValue(false));
	}
	void SetRange(TakionRange<unsigned int, int>& range) const
	{
		SetBaseUse(range);
		range.SetMinMax(GetValue(true), GetValue(false));
	}
	void SetRange(TakionRange<unsigned __int64>& range) const
	{
		SetBaseUse(range);
		range.SetMinMax(GetValue(true), GetValue(false));
	}

	void SetRangeControls(const TakionRange<Money, Money>& range)
	{
		SetBaseUseControl(range);
		m_SpinMin.SetValue((T)range.GetMin().GetDollars() * m_divider + range.GetMin().GetDollarFraction() / m_moneyMultiplier);
		m_SpinMax.SetValue((T)range.GetMax().GetDollars() * m_divider + range.GetMax().GetDollarFraction() / m_moneyMultiplier);
		UpdateRangeValid();
	}
	void SetRangeControls(const TakionRange<Price, Price>& range)
	{
		SetBaseUseControl(range);
		m_SpinMin.SetValue(range.GetMin().GetDollars() * m_divider + range.GetMin().GetDollarFraction() / m_priceMultiplier);
		m_SpinMax.SetValue(range.GetMax().GetDollars() * m_divider + range.GetMax().GetDollarFraction() / m_priceMultiplier);
		UpdateRangeValid();
	}
	void SetRangeControls(const TakionRange<Price, SignedPrice>& range)
	{
		SetBaseUseControl(range);
		m_SpinMin.SetValue(range.GetMin().GetDollars() * m_divider + range.GetMin().GetDollarFraction() / m_priceMultiplier);
		m_SpinMax.SetValue(range.GetMax().GetDollars() * m_divider + range.GetMax().GetDollarFraction() / m_priceMultiplier);
		UpdateRangeValid();
	}
	void SetRangeControls(const TakionRange<SignedPrice, SignedPrice>& range)
	{
		SetBaseUseControl(range);
		SignedPrice p(range.GetMin());
		if(p.isNegative())p.SetZero();
		m_SpinMin.SetValue(p.GetDollars() * m_divider + p.GetDollarFraction() / m_priceMultiplier);
		p = range.GetMax();
		if(p.isNegative())p.SetZero();
		m_SpinMax.SetValue(p.GetDollars() * m_divider + p.GetDollarFraction() / m_priceMultiplier);
		UpdateRangeValid();
	}
	void SetRangeControls(const TakionRange<unsigned short>& range)
	{
		SetBaseUseControl(range);
		m_SpinMin.SetValue(range.GetMin());
		m_SpinMax.SetValue(range.GetMax());
		UpdateRangeValid();
	}
	void SetRangeControls(const TakionRange<unsigned short, short>& range)
	{
		SetBaseUseControl(range);
		m_SpinMin.SetValue(range.GetMin());
		m_SpinMax.SetValue(range.GetMax());
		UpdateRangeValid();
	}
	void SetRangeControls(const TakionRange<unsigned int>& range)
	{
		SetBaseUseControl(range);
		m_SpinMin.SetValue(range.GetMin());
		m_SpinMax.SetValue(range.GetMax());
		UpdateRangeValid();
	}
	void SetRangeControls(const TakionRange<unsigned int, int>& range)
	{
		SetBaseUseControl(range);
		m_SpinMin.SetValue(range.GetMin());
		m_SpinMax.SetValue(range.GetMax());
		UpdateRangeValid();
	}
	void SetRangeControls(const TakionRange<unsigned __int64>& range)
	{
		SetBaseUseControl(range);
		m_SpinMin.SetValue((T)range.GetMin());
		m_SpinMax.SetValue((T)range.GetMax());
		UpdateRangeValid();
	}
	virtual CWnd& GetSpinWnd(bool minValue){return minValue ? m_SpinMin : m_SpinMax;}
	virtual void Show(unsigned int show) override//SW_SHOW or SW_HIDE
	{
		RangeGroupBase::Show(show);
		m_SpinMin.ShowWindow(show);
		m_SpinMax.ShowWindow(show);
	}
	UnsignedNumberTypeSpin<T> m_SpinMin;
	UnsignedNumberTypeSpin<T> m_SpinMax;
protected:
	T m_divider;
	T m_priceMultiplier;
	T m_moneyMultiplier;
	COLORREF m_colorValid;
	COLORREF m_colorUsed;
	COLORREF m_bkColorSpin;
	COLORREF m_colorInvalid;
	bool m_zeroValid;
	bool m_valid;
};

template<class T>
class RangeGroupPositiveNegative : public RangeGroup<T>
{
public:
	RangeGroupPositiveNegative(const unsigned short& idGroup,
		const unsigned short& idCheckBox,
		const unsigned short& idSpinMin,
		const unsigned short& idSpinMax,
		const unsigned short& idPositive,
		const unsigned short& idNegative,
		const T& maxValue,
		const unsigned int& cellCount,
		const unsigned char& decDigits,
		const COLORREF& colorValid = RGB(255, 255, 255),
		const COLORREF& colorUsed = RGB(128, 255, 128),
		COLORREF colorInvalid = 0xFFFFFFFF,
		const char* const& toolTip = NULL,
		const bool& zeroValid = true,
		const COLORREF& borderColor = 0):
		RangeGroup(idGroup,
			idCheckBox,
			idSpinMin,
			idSpinMax,
			maxValue,
			cellCount,
			decDigits,
			colorValid,
			colorUsed,
			colorInvalid,
			toolTip,
			zeroValid,
			borderColor),
		m_idPositive(idPositive),
		m_idNegative(idNegative)
	{
		SetPositiveNegativeToolTips("Filter in Positive Values", "Filter in Negative Values");
	}
	virtual bool isRangeEmpty() const override
	{
		return RangeGroup::isRangeEmpty() && m_CheckBoxPositive.GetCheck() == BST_CHECKED && m_CheckBoxNegative.GetCheck() == BST_CHECKED;
	}
	virtual void SetRangeEmpty()
	{
		RangeGroup::SetRangeEmpty();
		m_CheckBoxPositive.SetCheck(BST_CHECKED);
		m_CheckBoxNegative.SetCheck(BST_CHECKED);
	}
	virtual unsigned short GetIdPositive() const{return m_idPositive;}
	virtual unsigned short GetIdNegative() const{return m_idNegative;}
	void SetPositiveNegative(TakionUse& use) const
	{
		use.SetPositiveNegative((m_CheckBoxPositive.GetCheck() == BST_CHECKED ? 1 : 0) |  (m_CheckBoxNegative.GetCheck() == BST_CHECKED ? 2 : 0));
	}
	void SetPositiveNegativeControls(const TakionUse& use)
	{
		unsigned char positiveNegative = TakionUse::GetValidPositiveNegative(use.GetPositiveNegative());
		m_CheckBoxPositive.SetCheck(positiveNegative & TRPN_POSITIVE ? BST_CHECKED : BST_UNCHECKED);
		m_CheckBoxNegative.SetCheck(positiveNegative & TRPN_NEGATIVE ? BST_CHECKED : BST_UNCHECKED);
//		UpdateRangeValid();
	}
	virtual CWnd* GetPositiveNegativeCheckBox(bool positive){return positive ? &m_CheckBoxPositive : &m_CheckBoxNegative;}
	virtual void Show(unsigned int show) override//SW_SHOW or SW_HIDE
	{
		RangeGroup::Show(show);
		m_CheckBoxPositive.ShowWindow(show);
		m_CheckBoxNegative.ShowWindow(show);
	}
	virtual void EnableToolTips(bool enable, CToolTipCtrl* externalToolTip) override
	{
		RangeGroup::EnableToolTips(enable, externalToolTip);
		m_CheckBoxPositive.EnableTooltips(enable, externalToolTip);
		m_CheckBoxNegative.EnableTooltips(enable, externalToolTip);
	}
	void SetPositiveNegativeToolTips(const char* const& positiveToolTip, const char* const& negativeToolTip)
	{
		m_CheckBoxPositive.SetTooltipText(positiveToolTip);
		m_CheckBoxNegative.SetTooltipText(negativeToolTip);
	}
	virtual void SetBkColor(const COLORREF& color) override
	{
		RangeGroup::SetBkColor(color);
		m_CheckBoxPositive.SetBackgroundColor(color);
		m_CheckBoxNegative.SetBackgroundColor(color);
	}

	virtual void UpdateUse() override
	{
		RangeGroup::UpdateUse();
		const bool notUsed = !isUsed();
		m_CheckBoxPositive.SetInvalid(notUsed);
		m_CheckBoxNegative.SetInvalid(notUsed);
	}
	RangeSignCheckBox m_CheckBoxPositive;
	RangeSignCheckBox m_CheckBoxNegative;
	bool TogglePositive()
	{
		return ToggleCheckBox(m_CheckBoxPositive, m_CheckBoxNegative);
	}
	bool ToggleNegative()
	{
		return ToggleCheckBox(m_CheckBoxNegative, m_CheckBoxPositive);
	}
	bool isPositiveNegativeModified(const TakionUse& range) const
	{
		return range.GetPositiveNegative() != ((m_CheckBoxPositive.GetCheck() == BST_CHECKED ? 1 : 0) | (m_CheckBoxNegative.GetCheck() == BST_CHECKED ? 2 : 0));
	}
protected:
/*Worked for ButtonToolTip
	bool ToggleCheckBox(CButton& button, CButton& buttonOther)
	{
		if(button.GetCheck() == BST_CHECKED)
		{
			if(buttonOther.GetCheck() == BST_CHECKED)
			{
				button.SetCheck(BST_UNCHECKED);
				return true;
			}
		}
		else
		{
			button.SetCheck(BST_CHECKED);
			return true;
		}
		return false;
	}
*/
	bool ToggleCheckBox(RangeSignCheckBox& button, RangeSignCheckBox& buttonOther)
	{
		if(button.GetCheck() == BST_UNCHECKED)
		{
			if(buttonOther.GetCheck() == BST_UNCHECKED)
			{
				buttonOther.SetCheck(BST_CHECKED);
//				return true;
			}
		}
		return true;
//		return false;
	}
	unsigned short m_idPositive;
	unsigned short m_idNegative;
};

class TGUI_API NamedFilterItem
{
public:
	NamedFilterItem(SymbolFilter* const& symbolFilterOriginal, const std::string& name) :
		m_symbolFilterOriginal(symbolFilterOriginal),
		m_symbolFilterCopy((SymbolFilter*)symbolFilterOriginal->CreateFilterCopy()),
		m_nameOriginal(name),
		m_nameCopy(name)
	{}
	NamedFilterItem(const std::string& name, SymbolFilter* const& symbolFilterCopy) :
		m_symbolFilterOriginal(NULL),
		m_symbolFilterCopy(symbolFilterCopy),
//		m_nameOriginal(name),
		m_nameCopy(name)
	{}
	NamedFilterItem(const NamedFilterItem& other):
		m_symbolFilterOriginal(other.m_symbolFilterOriginal),
		m_symbolFilterCopy((SymbolFilter*)other.m_symbolFilterCopy->CreateFilterCopy()),
		m_nameOriginal(other.m_nameOriginal),
		m_nameCopy(other.m_nameCopy)
	{
	}
	~NamedFilterItem();
	NamedFilterItem& operator=(const NamedFilterItem& other);
	const SymbolFilter* const& GetFilterCopy() const{return m_symbolFilterCopy;}
	SymbolFilter* const& GetFilterCopy(){return m_symbolFilterCopy;}
	const SymbolFilter* const& GetFilterOriginal() const{return m_symbolFilterOriginal;}
	bool ResetFilterOriginal();//SymbolFilter* const& symbolFilterOriginal);
//	bool ResetFilterOriginal(SymbolFilter* const& symbolFilterOriginal, const std::string& name)
	bool ResetFilterOriginal(const std::string& name)
	{
		bool ret = ResetFilterOriginal();
		if(name != m_nameOriginal)
		{
			m_nameOriginal = name;
			ret = true;
		}
		if(name != m_nameCopy)
		{
			m_nameCopy = name;
			ret = true;
		}
		return ret;
	}
	bool isModified() const
	{
		return m_nameCopy != m_nameOriginal
			|| !m_symbolFilterOriginal
			|| m_symbolFilterOriginal->isA() != m_symbolFilterCopy->isA()
			|| !m_symbolFilterOriginal->isSymbolIntersectionEqual(*m_symbolFilterCopy, 1 << FDNC_SYMBOL);
	}
	const std::string& GetNameCopy() const{return m_nameCopy;}
	const std::string& GetNameOriginal() const{return m_nameOriginal;}
	void SetNameCopy(const std::string& newName){m_nameCopy = newName;}
	SymbolFilter* CreateFilterOriginal();
protected:
	SymbolFilter* m_symbolFilterOriginal;
	SymbolFilter* m_symbolFilterCopy;
	std::string m_nameOriginal;
	std::string m_nameCopy;
};

class TGUI_API ComboBoxNamedFilter : public ComboBoxOwnerDraw
{
friend class DialogSymbolFilter;
public:
	ComboBoxNamedFilter(DialogSymbolFilter* dialogParent);//DialogSymbolFilter* const& dialog, const SymbolFilter* const& filterSetInWindow):

	const SymbolFilter* const& GetFilterSetInWindow() const{return m_filterSetInWindow;}
	virtual void DestroyItem(const void* item) const override;
	virtual const char* GetItemName(const void* item) const override{return item ? ((const NamedFilterItem*)item)->GetNameCopy().c_str() : "";}
	virtual COLORREF GetSelectedBkColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override{return GetBkColor(lpDrawItemStruct);}
	virtual COLORREF GetBkColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override;
	virtual COLORREF GetStringColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override{return m_colorText;}// { return (lpDrawItemStruct->itemState & ODS_SELECTED) == 0 || m_invalid ? GetUnselectedStringColor(lpDrawItemStruct) : GetSysColor(COLOR_HIGHLIGHTTEXT); }
	virtual void GetDrawItemRect(const DRAWITEMSTRUCT* lpDrawItemStruct, CRect& drawItemRect) const override;
	virtual const CRect& GetToolTipRect() const override{return m_filtersModified ? m_nameRect : m_nameButtonRect;}
	virtual bool isToDestroyToolTipIfNoText() const override{return false;}

//	void SetDialog(DialogSymbolFilter* const& dialog);
	void SetWindowFilter(const SymbolFilter* filterSetInWindow);
	bool AddNamedFilter(const std::string& name);
	bool CopySelectedNamedFilter();
	bool PasteNameSelectedNamedFilter();
	bool RenameSelectedNamedFilter(const std::string& newName);
	bool CopyNameSelectedNamedFilter() const;
	bool PasteSelectedNamedFilter();
	bool RemoveSelectedNamedFilter();

	bool isModified() const;
	bool Reset();
	bool Apply();

	bool RemoveAllButFirstItem();

	void SetOwner(const bool& owner){m_owner = owner;}
protected:
	virtual void OnItemSelected() override;
	virtual void OnItemAdded(void* item, unsigned int at) override;
	virtual void BeforeItemDeleted(unsigned int at) override;
	virtual void AfterItemDeleted(unsigned int at, bool failed) override;
	virtual void BeforeItemsCleared() override;
	virtual void AfterItemsCleared() override;

	virtual void BeforeDestroy() override
	{
		ComboBoxOwnerDraw::BeforeDestroy();
		m_filtersModified = false;
		SetWindowFilter(NULL);
	}
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	DECLARE_MESSAGE_MAP()
	virtual void MouseLeft() override;

	virtual void SizeChanged(bool horizontalChange, bool verticalChange) override;
	virtual void ToolTipCreated() override;
	virtual void DrawPrefix(const DRAWITEMSTRUCT* lpDrawItemStruct, const CRect& r) override;
	virtual void DrawSuffix(const DRAWITEMSTRUCT* lpDrawItemStruct, const CRect& r) override;
//	virtual void DoDrawItem(const DRAWITEMSTRUCT* lpDrawItemStruct, const CRect& drawItemRect) override;
	virtual void AddMenuItems(CMenu& menu) override;
	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;

	bool SetFiltersModified(const bool modified);

	void UpdateButtonToolTip();

	DialogSymbolFilter* m_dialog;
	const SymbolFilter* m_filterSetInWindow;
	COLORREF m_colorIntersectionSame;
	COLORREF m_colorIntersectionDifferent;
	COLORREF m_colorSelectedInWindow;
	COLORREF m_colorText;
	COLORREF m_colorTextSameType;
	COLORREF m_colorModified;
	COLORREF m_buttonBkColor;
	COLORREF m_buttonBkColorLight;
	COLORREF m_buttonBkColorDark;
	CRect m_typeRect;//Shows Filter Type, like "ms" for MarketSorter
	CRect m_nameRect;
	CRect m_buttonRect;
	CRect m_nameButtonRect;//union of m_nameRect and m_buttonRect
	bool m_owner;
	bool m_notifyParent;
	bool m_filtersModified;
	bool m_insideButton;
	bool m_buttonPressed;
};

//#define FILTER_MARK_AFFECTED_FIELDS

class TGUI_API DialogSymbolFilter : public DialogFilter
{
friend class ComboBoxNamedFilter;
public:
	void Display(const TakionFilter& filter, TakionFrame* receipient, unsigned int code, CWnd* parent, int x, int y, int w, int h, bool show = true);
	virtual bool isFilterChanged() const override;
	virtual bool isFilterValid() const override;
	virtual bool isFilterEmpty() const override;
	virtual void SetFilterEmpty() override;
//	unsigned short GetTimeFrameMinutes() const;

	static const int topMost = 0;//3;
	static const int x0 = 5;
	static const int hgap = 4;
	static const int vgap = 0;//1;
	static const int vgroupgap = 6;
	static const int vtitlegroupgap = 10;
	static const int checkBoxHeight = 10;
	static const int staticHeight = 8;
	static const int spinHeight = 12;
	static const int groupHeight = checkBoxHeight + 2 * spinHeight + 4 * vgap + vgroupgap + 3;
	static const int groupWidth = 85;
	static const int controlWidth = groupWidth - hgap - hgap;
	static const int timeFrameWidth = 65;
	static const int timeFrameControlWidth = timeFrameWidth - hgap - hgap;

	void SetShowToolTips(bool showToolTips);
	bool UpdateGlobalToolTipsEnabled();

	virtual void UpdateFilterOfOtherKind(TakionFilter& other) const override
	{
		UpdateSymbolFilterOfOtherKind((SymbolFilter&)other);
	}
	void UpdateMyFields(SymbolFilter& other) const;// , unsigned int doNotCopyFlags);
	virtual void UpdateSymbolFilterOfOtherKind(SymbolFilter& other) const
	{
		UpdateMyFields(other);
	}
	virtual bool isFilterOfOtherKindIntersectionDifferent(const TakionFilter& other) const override
	{
		return isSymbolFilterOfOtherKindIntersectionDifferent((const SymbolFilter&)other, 0);
	}
	bool MyFieldsIntersectionDifferent(const SymbolFilter& other, unsigned int doNotCopyFlags) const;
	virtual bool isSymbolFilterOfOtherKindIntersectionDifferent(const SymbolFilter& other, unsigned int doNotCopyFlags) const
	{
		return MyFieldsIntersectionDifferent(other, doNotCopyFlags);
	}

	virtual void CopyFilterOfOtherKindToControls(const TakionFilter& filter) override
	{
		CopySymbolFilterOfOtherKindToControls((const SymbolFilter&)filter, 0);
	}
	void MyFieldsToControls(const SymbolFilter& other, unsigned int doNotCopyFlags);
	virtual void CopySymbolFilterOfOtherKindToControls(const SymbolFilter& filter, unsigned int doNotCopyFlags)
	{
		MyFieldsToControls(filter, doNotCopyFlags);
	}
	void PopulateControls(const SymbolFilter& filter, unsigned int doNotCopyFlags)
	{
		CopySymbolFilterOfOtherKindToControls(filter, doNotCopyFlags);
		EnableOkButton();
	}

	const std::string& GetEditNamedFilterName() const{return m_editNamedFilterName;}
	void SetEditNamedFilterName(const std::string& name);

	const COLORREF& GetEnabledColor() const{return m_enabledColor;}
	const COLORREF& GetEnabledTextColor() const{return m_enabledTextColor;}
	const COLORREF& GetDisabledColor() const{return m_disabledColor;}
	const COLORREF& GetInvalidColor() const{return m_invalidColor;}
	const COLORREF& GetCheckBoxColor() const{return m_checkBoxColor;}
	const COLORREF& GetPressedCheckColor() const{return m_pressedCheckColor;}

protected:
	DialogSymbolFilter(TakionMainWnd* mainWnd, int xSymbolOffset, int xSymbolHeight, bool toDestroyOnFocus = false, TakionFrame* receipient = NULL, CWnd* parent = NULL, LPCSTR caption = NULL, DWORD style = 0, DWORD exstendedStyle = 0, int x = 0, int y = 0, int w = 0, int h = 0,
		LPCSTR font = NULL, WORD fontSize = 8, bool executeCommands = true, bool closeOnCommandExecution = true);
	void DoAddSymbol(const char* symbol, bool checked);
	void DoRemoveSymbol(const char* symbol);
	int AddRangeComponent(int groupLeft, int groupTop, int groupWidth, const char* useCheckBoxName, const RangeGroupBase& groupBase, const char* positiveCheckBoxName = NULL, const char* negativeCheckBoxName = NULL, int additionalHeight = 0, int yOffset = 0);
	virtual void DoDataExchange(CDataExchange* pDX);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual BOOL OnInitDialog();
	virtual void BeforeShow();
	virtual void AfterClose() override;
	virtual void UpdateFilterValues();

//	virtual bool EnableToolTips(bool enable) override;
	virtual void ToolTipsEnabled(bool enable) override;
	virtual bool InitializeToolTips() override;

	DECLARE_MESSAGE_MAP()
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);

	afx_msg void OnCheckBoxToolTips();

	afx_msg void OnSymbolUseInclude();
	afx_msg void OnSymbolUseExclude();
	afx_msg void OnSelchangeSymbol();
	afx_msg LRESULT OnListBoxChecked(WPARAM w, LPARAM l);
//	afx_msg LRESULT OnListBoxRangeChecked(WPARAM w, LPARAM l);

	afx_msg LRESULT OnListBoxIncludeExclude(WPARAM w, LPARAM l);
	afx_msg LRESULT OnListBoxFind(WPARAM w, LPARAM l);
	afx_msg LRESULT OnListBoxRemove(WPARAM w, LPARAM l);
	afx_msg LRESULT OnListBoxClear(WPARAM w, LPARAM l);
	afx_msg LRESULT OnListBoxCopy(WPARAM w, LPARAM l);
	afx_msg LRESULT OnListBoxPaste(WPARAM w, LPARAM l);
	afx_msg LRESULT OnListBoxUnPaste(WPARAM w, LPARAM l);

//	afx_msg void OnSymbolUpdate();
	afx_msg void OnSymbolChange();
	afx_msg void OnSymbolFind();
	afx_msg void OnSymbolInclude();
	afx_msg void OnSymbolExclude();
	afx_msg void OnSymbolRemove();
	afx_msg void OnSymbolClear();
	afx_msg void OnSymbolCopy();
	afx_msg void OnSymbolPaste();
	afx_msg void OnSymbolUnPaste();

	afx_msg void OnSymbolUseFirstChars();
	afx_msg void OnSymbolUseNoFirstChars();
	afx_msg void OnSymbolUseChars();
	afx_msg void OnSymbolUseNoChars();
//	afx_msg void OnSymbolFirstCharsUpdate();
	afx_msg void OnSymbolFirstCharsChange();
//	afx_msg void OnSymbolNoFirstCharsUpdate();
	afx_msg void OnSymbolNoFirstCharsChange();
//	afx_msg void OnSymbolCharsUpdate();
	afx_msg void OnSymbolCharsChange();
//	afx_msg void OnSymbolNoCharsUpdate();
	afx_msg void OnSymbolNoCharsChange();

	afx_msg void OnSelchangeNamedFilter();
	afx_msg void OnEditNamedFilterNameChange();
	void NullifySelectedNamedFilter();

	void DoDataExchangeRange(RangeGroupBase& cg, CDataExchange* pDX);
	void EnableFindButton();
	void EnableAddSymbolButtons();
	void AddSymbol(bool checked);

	COLORREF m_enabledColor;
	COLORREF m_enabledTextColor;
	COLORREF m_disabledColor;
	COLORREF m_invalidColor;
	COLORREF m_checkBoxColor;
	COLORREF m_pressedCheckColor;

	ButtonToolTip m_CheckBoxToolTips;

	CheckBoxOwnerDraw m_CheckBoxSymbolInclude;
	CheckBoxOwnerDraw m_CheckBoxSymbolExclude;
	ValidEdit m_EditSymbol;
	ListBoxSymbolChecked m_ListBoxSymbol;
	CButton m_ButtonSymbolInclude;
	CButton m_ButtonSymbolExclude;
	CButton m_ButtonSymbolFind;
	CButton m_ButtonSymbolRemove;
	CButton m_ButtonSymbolClear;

	CButton m_GroupBoxSymbolChars;
	CheckBoxOwnerDraw m_CheckBoxFirstChars;
	CheckBoxOwnerDraw m_CheckBoxNoFirstChars;
	CheckBoxOwnerDraw m_CheckBoxChars;
	CheckBoxOwnerDraw m_CheckBoxNoChars;
	ValidEdit m_EditFirstChars;
	ValidEdit m_EditNoFirstChars;
	ValidEdit m_EditChars;
	ValidEdit m_EditNoChars;

	ComboBoxNamedFilter m_ComboBoxNamedFilter;
	ValidEdit m_EditNamedFilterName;

	virtual void DoEnableOkButton(bool enable) override;
	void NamedFilterSelected();
	void NamedFilterAdded(const NamedFilterItem* item, unsigned int at);
	void BeforeNamedFilterDeleted(unsigned int at);
	void BeforeNamedFiltersCleared();
//	void NamedFilterPasted(const SymbolFilter* filter);
	void NamedFiltersReset();
	void NamedFiltersApplied();

	virtual void NamedFilterSelChange(const SymbolFilter* oldFilter, const SymbolFilter* newFilter, COLORREF intersectionColor, CBrush* intersectionBrush, COLORREF regularColor, int intersectionDeflation, int regularDeflation);
	const SymbolFilter* m_selectedNamedFilter;
//	COLORREF m_namedFilterIntersectionColor;

	void UpdateListBoxSymbolColor(bool enable);
	
	std::string m_firstChars;
	std::string m_noFirstChars;
	std::string m_chars;
	std::string m_noChars;

	bool m_useFirstChars;
	bool m_useNoFirstChars;
	bool m_useChars;
	bool m_useNoChars;

//	typedef std::map<unsigned __int64, bool, lessUIntAsStr<unsigned __int64> > SymbolMap;
//	SymbolMap m_symbolMap;

	bool m_lastUsedSymbolInclude;

	std::string m_editNamedFilterName;
};

class TGUI_API DialogPriceFilter : public DialogSymbolFilter
{
public:
	void Display(const TakionFilter& filter, TakionFrame* receipient, unsigned int code, CWnd* parent, int x, int y, int w, int h, bool show = true);
	virtual bool isFilterChanged() const override;
	virtual bool isFilterValid() const override;
	virtual bool isFilterEmpty() const override;
	virtual void SetFilterEmpty() override;
//	unsigned short GetTimeFrameMinutes() const;

//	virtual BOOL PreTranslateMessage(MSG* pMsg);
	void UpdateMyFields(PriceFilter& other) const;// , unsigned int doNotCopyFlags);
	virtual void UpdateSymbolFilterOfOtherKind(SymbolFilter& other) const override
	{
		DialogSymbolFilter::UpdateSymbolFilterOfOtherKind(other);
		if(other.isPriceFilter())UpdateMyFields((PriceFilter&)other);
	}
	bool MyFieldsIntersectionDifferent(const PriceFilter& other, unsigned int doNotCopyFlags) const;
	virtual bool isSymbolFilterOfOtherKindIntersectionDifferent(const SymbolFilter& other, unsigned int doNotCopyFlags) const override
	{
		return DialogSymbolFilter::isSymbolFilterOfOtherKindIntersectionDifferent(other, doNotCopyFlags) || other.isPriceFilter() && MyFieldsIntersectionDifferent((const PriceFilter&)other, doNotCopyFlags);
	}

	void MyFieldsToControls(const PriceFilter& other, unsigned int doNotCopyFlags);
	virtual void CopySymbolFilterOfOtherKindToControls(const SymbolFilter& other, unsigned int doNotCopyFlags) override
	{
		DialogSymbolFilter::CopySymbolFilterOfOtherKindToControls(other, doNotCopyFlags);
		if(other.isPriceFilter())MyFieldsToControls((const PriceFilter&)other, doNotCopyFlags);
	}
protected:
	DialogPriceFilter(TakionMainWnd* mainWnd, int xPriceOffset, int priceTop, int xSymbolOffset, int xSymbolHeight, bool toDestroyOnFocus = false, TakionFrame* receipient = NULL, CWnd* parent = NULL, LPCSTR caption = NULL, DWORD style = 0, DWORD exstendedStyle = 0, int x = 0, int y = 0, int w = 0, int h = 0,
		LPCSTR font = NULL, WORD fontSize = 8, bool executeCommands = true, bool closeOnCommandExecution = true);
	virtual void DoDataExchange(CDataExchange* pDX);
	virtual BOOL OnInitDialog();
	virtual void BeforeShow() override;
	virtual void UpdateFilterValues() override;

//	virtual bool EnableToolTips(bool enable) override;
	virtual void ToolTipsEnabled(bool enable) override;

	virtual void NamedFilterSelChange(const SymbolFilter* oldFilter, const SymbolFilter* newFilter, COLORREF intersectionColor, CBrush* intersectionBrush, COLORREF regularColor, int intersectionDeflation, int regularDeflation) override;
	DECLARE_MESSAGE_MAP()
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnUsePrice();
	afx_msg void OnUseOpenPrice();
	afx_msg void OnUseDayNetChange();
	afx_msg void OnUseDayPriceRange();
	afx_msg void OnUseDayNetChangePercent();
	afx_msg void OnUseDayNetOpenChangePercent();
	afx_msg void OnUseDayPriceRangePercent();

	afx_msg void OnPositiveDayNetChange();
	afx_msg void OnNegativeDayNetChange();
	afx_msg void OnPositiveDayNetChangePercent();
	afx_msg void OnNegativeDayNetChangePercent();
	afx_msg void OnPositiveDayNetOpenChangePercent();
	afx_msg void OnNegativeDayNetOpenChangePercent();

	afx_msg LRESULT OnSpinChange(WPARAM spinId, LPARAM l);

	RangeGroup<unsigned int> m_price;
	RangeGroup<unsigned int> m_openPrice;
	RangeGroupPositiveNegative<unsigned int> m_dayNetChange;
	RangeGroup<unsigned int> m_dayPriceRange;
	RangeGroupPositiveNegative<unsigned int> m_dayNetChangePercent;
	RangeGroupPositiveNegative<unsigned int> m_dayNetOpenChangePercent;
	RangeGroup<unsigned int> m_dayPriceRangePercent;

	int m_secondColumnBottom;
};

class TGUI_API DialogStockFilter : public DialogPriceFilter
{
public:
	void Display(const TakionFilter& filter, TakionFrame* receipient, unsigned int code, CWnd* parent, int x, int y, int w, int h, bool show = true);
	virtual bool isFilterChanged() const override;
	virtual bool isFilterValid() const override;
	virtual bool isFilterEmpty() const override;
	virtual void SetFilterEmpty() override;
	static const char zeroChar;
	static const unsigned int securityTypeFilterAll;
	static const unsigned int nasdaqQuoteConditionFilterAll;
	static const unsigned int listedQuoteConditionFilterAll;

	void UpdateMyFields(StockFilter& other) const;
	virtual void UpdateSymbolFilterOfOtherKind(SymbolFilter& other) const override
	{
		DialogPriceFilter::UpdateSymbolFilterOfOtherKind(other);
		if(other.isStockFilter())UpdateMyFields((StockFilter&)other);
	}
	bool MyFieldsIntersectionDifferent(const StockFilter& other, unsigned int doNotCopyFlags) const;
	virtual bool isSymbolFilterOfOtherKindIntersectionDifferent(const SymbolFilter& other, unsigned int doNotCopyFlags) const override
	{
		return DialogPriceFilter::isSymbolFilterOfOtherKindIntersectionDifferent(other, doNotCopyFlags) || other.isStockFilter() && MyFieldsIntersectionDifferent((const StockFilter&)other, doNotCopyFlags);
	}

	void MyFieldsToControls(const StockFilter& other, unsigned int doNotCopyFlags);
	virtual void CopySymbolFilterOfOtherKindToControls(const SymbolFilter& other, unsigned int doNotCopyFlags) override
	{
		DialogPriceFilter::CopySymbolFilterOfOtherKindToControls(other, doNotCopyFlags);
		if(other.isStockFilter())MyFieldsToControls((const StockFilter&)other, doNotCopyFlags);
	}
protected:
	DialogStockFilter(TakionMainWnd* mainWnd,
		int xPriceOffset, int priceTop, int xSymbolOffset, int xSymbolHeight, bool useTimeFrame,
		bool toDestroyOnFocus = false, TakionFrame* receipient = NULL, CWnd* parent = NULL, LPCSTR caption = NULL, DWORD style = 0, DWORD exstendedStyle = 0, int x = 0, int y = 0, int w = 0, int h = 0,
		LPCSTR font = NULL, WORD fontSize = 8, bool executeCommands = true, bool closeOnCommandExecution = true);
	virtual void DoDataExchange(CDataExchange* pDX);
	virtual BOOL OnInitDialog();
	virtual void BeforeShow() override;
	virtual void UpdateFilterValues() override;
	
//	virtual bool EnableToolTips(bool enable) override;
	virtual void ToolTipsEnabled(bool enable) override;

//	virtual void Resize(bool widthChanged = true, bool heightChanged = true);
	virtual void NamedFilterSelChange(const SymbolFilter* oldFilter, const SymbolFilter* newFilter, COLORREF intersectionColor, CBrush* intersectionBrush, COLORREF regularColor, int intersectionDeflation, int regularDeflation) override;
	DECLARE_MESSAGE_MAP()
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnUseYesterdaysVolume();
	afx_msg void OnUseTodaysVolume();
	afx_msg void OnUseTodaysPxMhVolume();
	afx_msg void OnUseAvgDailyVolume();
	afx_msg void OnUseRelativeVolume();
	afx_msg void OnUsePreMhVolRel();
	afx_msg void OnUseYesterdaysPriceRange();
	afx_msg void OnUseYesterdaysPriceRangePercent();
	//	afx_msg void OnUsePositionSize();
//	afx_msg void OnUseVolumeRate();
//	afx_msg void OnUseTVolByYVol();
	afx_msg void OnUseImbalanceNyse();
	afx_msg void OnUseImbalanceNyseReg();
	afx_msg void OnUseImbalanceNsdq();
	afx_msg void OnUseImbalanceArca();
	afx_msg void OnUseImbalanceExch();
	afx_msg void OnUseRateImbalance();
	afx_msg void OnUseImbNyDeltaInf();
	afx_msg void OnUseImbExFarPriceDelta();
	afx_msg void OnUseImbNqFarPriceDelta();
	afx_msg void OnUseImbNqThru();
	afx_msg void OnUseImbExValue();
	afx_msg void OnUseImbExNear();
	afx_msg void OnUseImbExFar();
	afx_msg void OnUseImbExMatch();
	afx_msg void OnUseImbExVolPercent();
	afx_msg void OnUseImbExYestVolPercent();
	afx_msg void OnUseDeltaPv();
	afx_msg void OnUseRsiMh();
	afx_msg void OnUseRsiDays();
	afx_msg void OnUseBorrowPrice();
	afx_msg void OnUsePmiSpread();
	afx_msg void OnUseTodaysClosePrice();

	afx_msg void OnUseBidNet();
	afx_msg void OnUseAskNet();

	afx_msg void OnUseTBidNet();
	afx_msg void OnUseTAskNet();

	afx_msg void OnUseBidNetPercent();
	afx_msg void OnUseAskNetPercent();

	afx_msg void OnUseTBidNetPercent();
	afx_msg void OnUseTAskNetPercent();

	afx_msg void OnUseLuldDiff();
	afx_msg void OnPositiveLuldDiff();
	afx_msg void OnNegativeLuldDiff();

	afx_msg void OnUseLuldDiffPercent();
	afx_msg void OnPositiveLuldDiffPercent();
	afx_msg void OnNegativeLuldDiffPercent();

//	afx_msg void OnLongPosition();
//	afx_msg void OnShortPosition();

	afx_msg void OnPositiveImbalanceNyse();
	afx_msg void OnNegativeImbalanceNyse();
	afx_msg void OnPositiveImbalanceNyseReg();
	afx_msg void OnNegativeImbalanceNyseReg();
	afx_msg void OnPositiveImbalanceNsdq();
	afx_msg void OnNegativeImbalanceNsdq();
	afx_msg void OnPositiveImbalanceArca();
	afx_msg void OnNegativeImbalanceArca();
	afx_msg void OnPositiveImbalanceExch();
	afx_msg void OnNegativeImbalanceExch();
	afx_msg void OnPositiveRateImbalance();
	afx_msg void OnNegativeRateImbalance();
	afx_msg void OnPositiveImbNyDeltaInf();
	afx_msg void OnNegativeImbNyDeltaInf();
	afx_msg void OnPositiveImbExFarPriceDelta();
	afx_msg void OnNegativeImbExFarPriceDelta();
	afx_msg void OnPositiveImbNqFarPriceDelta();
	afx_msg void OnNegativeImbNqFarPriceDelta();
	afx_msg void OnPositiveImbNqThru();
	afx_msg void OnNegativeImbNqThru();
	afx_msg void OnPositiveImbExValue();
	afx_msg void OnNegativeImbExValue();

	afx_msg void OnPositiveBidNet();
	afx_msg void OnNegativeBidNet();
	afx_msg void OnPositiveAskNet();
	afx_msg void OnNegativeAskNet();

	afx_msg void OnPositiveTBidNet();
	afx_msg void OnNegativeTBidNet();
	afx_msg void OnPositiveTAskNet();
	afx_msg void OnNegativeTAskNet();

	afx_msg void OnPositiveBidNetPercent();
	afx_msg void OnNegativeBidNetPercent();
	afx_msg void OnPositiveAskNetPercent();
	afx_msg void OnNegativeAskNetPercent();

	afx_msg void OnPositiveTBidNetPercent();
	afx_msg void OnNegativeTBidNetPercent();
	afx_msg void OnPositiveTAskNetPercent();
	afx_msg void OnNegativeTAskNetPercent();

	afx_msg void OnRsiMhCalculate();
	afx_msg void OnRsiMhTodayOnly();
	afx_msg void OnRsiMhPostMarket();

	afx_msg void OnRsiDaysCalculate();
	afx_msg void OnRsiDaysPostMarket();

	afx_msg LRESULT OnSpinChange(WPARAM spinId, LPARAM l);
	afx_msg LRESULT OnListBoxChecked(WPARAM w, LPARAM l);

	CStatic m_StaticMarketCategory;
	ListBoxMarketCategory m_ListBoxMarketCategory;

	CStatic m_StaticTestOrReal;
	ListBoxFilterString<unsigned int> m_ListBoxTestOrReal;

	CStatic m_StaticSecurityType;
	ListBoxFilterString<unsigned int> m_ListBoxSecurityType;

	CStatic m_StaticHtb;
	ListBoxFilterString<unsigned int> m_ListBoxHtb;

	CStatic m_StaticTradingState;
	ListBoxFilterString<unsigned int> m_ListBoxTradingState;

	CStatic m_StaticCircuitBreaker;
	ListBoxFilterString<unsigned int> m_ListBoxCircuitBreaker;

	CStatic m_StaticNasdaqQc;
	ListBoxFilterString<unsigned int> m_ListBoxNasdaqQc;

	CStatic m_StaticListedQc;
	ListBoxFilterString<unsigned int> m_ListBoxListedQc;

	RangeGroup<unsigned int> m_yesterdaysVolume;
	RangeGroup<unsigned int> m_todaysVolume;
	RangeGroup<unsigned int> m_todaysPxMhVolume;
//	RangeGroup<unsigned int> m_volumeRate;
//	RangeGroup<unsigned int> m_percentTVolByYVol;
//	RangeGroupPositiveNegative<unsigned int> m_positionSize;
	RangeGroup<unsigned int> m_avgDailyVolume;
	RangeGroup<unsigned int> m_relativeVolume;
	RangeGroup<unsigned int> m_preMhVolRel;
	RangeGroup<unsigned int> m_yesterdaysPriceRange;
	RangeGroup<unsigned int> m_yesterdaysPriceRangePercent;

	RangeGroupPositiveNegative<unsigned int> m_imbalanceNyse;
	RangeGroupPositiveNegative<unsigned int> m_imbalanceNyseReg;
	RangeGroupPositiveNegative<unsigned int> m_imbalanceNsdq;
	RangeGroupPositiveNegative<unsigned int> m_imbalanceArca;
	RangeGroupPositiveNegative<unsigned int> m_imbalanceExch;
	RangeGroupPositiveNegative<unsigned int> m_rateImbalance;
	RangeGroupPositiveNegative<unsigned int> m_imbNyDeltaInf;
	RangeGroupPositiveNegative<unsigned int> m_imbExFarPriceDelta;
	RangeGroupPositiveNegative<unsigned int> m_imbNqFarPriceDelta;
	RangeGroupPositiveNegative<unsigned int> m_imbNqThru;
	RangeGroupPositiveNegative<unsigned __int64> m_imbExValue;

	RangeGroup<unsigned int> m_imbExNear;
	RangeGroup<unsigned int> m_imbExFar;

	RangeGroup<unsigned int> m_imbExMatch;
	RangeGroup<unsigned int> m_imbExVolPercent;
	RangeGroup<unsigned int> m_imbExYestVolPercent;

	RangeGroup<unsigned int> m_deltaPv;
	RangeGroup<unsigned int> m_borrowPrice;
	RangeGroup<unsigned int> m_pmiSpread;
	RangeGroup<unsigned int> m_todaysClosePrice;

	RangeGroupPositiveNegative<unsigned int> m_bidNet;
	RangeGroupPositiveNegative<unsigned int> m_askNet;

	RangeGroupPositiveNegative<unsigned int> m_tBidNet;
	RangeGroupPositiveNegative<unsigned int> m_tAskNet;

	RangeGroupPositiveNegative<unsigned int> m_bidNetPercent;
	RangeGroupPositiveNegative<unsigned int> m_askNetPercent;

	RangeGroupPositiveNegative<unsigned int> m_tBidNetPercent;
	RangeGroupPositiveNegative<unsigned int> m_tAskNetPercent;

	RangeGroup<unsigned int> m_rsiMh;
	RangeGroup<unsigned int> m_rsiDays;

	CButton m_GroupBoxRsiMhCalculation;
	CheckBoxOwnerDraw m_CheckBoxRsiMhCalculate;
	CheckBoxOwnerDraw m_CheckBoxRsiMhTodayOnly;
	CStatic m_StaticRsiMhPriorPointCount;
	UnsignedNumberTypeSpin<unsigned short> m_SpinRsiMhPriorPointCount;
	CStatic m_StaticRsiMhPeriodLength;
	UnsignedNumberTypeSpin<unsigned short> m_SpinRsiMhPeriodLength;
	CStatic m_StaticRsiMhPeriodCount;
	UnsignedNumberTypeSpin<unsigned short> m_SpinRsiMhPeriodCount;
	CStatic m_StaticRsiMhStartMinute;
	MinuteSpin m_SpinRsiMhStartMinute;
	CheckBoxOwnerDraw m_CheckBoxRsiMhPostMarket;
	bool m_calculateRsiMh;

	CButton m_GroupBoxRsiDaysCalculation;
	CheckBoxOwnerDraw m_CheckBoxRsiDaysCalculate;
	CStatic m_StaticRsiDaysPriorPointCount;
	UnsignedNumberTypeSpin<unsigned short> m_SpinRsiDaysPriorPointCount;
	CStatic m_StaticRsiDaysPeriodLength;
	UnsignedNumberTypeSpin<unsigned short> m_SpinRsiDaysPeriodLength;
	CStatic m_StaticRsiDaysPeriodCount;
	UnsignedNumberTypeSpin<unsigned short> m_SpinRsiDaysPeriodCount;
	CStatic m_StaticRsiDaysStartMinute;
	MinuteSpin m_SpinRsiDaysStartMinute;
	CheckBoxOwnerDraw m_CheckBoxRsiDaysPostMarket;
	bool m_calculateRsiDays;

	RangeGroupPositiveNegative<unsigned int> m_luldDiff;
	RangeGroupPositiveNegative<unsigned int> m_luldDiffPercent;

	int m_fourthColumnBottom;
	int m_fifthColumnBottom;
	int m_sixthColumnBottom;
	int m_seventhColumnBottom;
	int m_eighthColumnBottom;

	int m_timeFrameHeight;
	int m_leftMostColumnBottom;

	int m_leftMostColumnBottomPixel;
	int m_leftMostColumnLeftPixel;
	int m_leftMostColumnWidthPixel;
	int m_staticHeightPixel;

	int m_fifthColumnLeftPixel;
	int m_fifthColumnWidthPixel;
	int m_fifthColumnBottomPixel;

	unsigned int m_marketCategoryVisibleItemCount;
	unsigned int m_testVisibleItemCount;
	unsigned int m_securityTypeVisibleItemCount;
	unsigned int m_htbVisibleItemCount;
	unsigned int m_tradingStateVisibleItemCount;
	unsigned int m_quoteConditionVisibleItemCount;
};

class TGUI_API DialogStockPrintFilter : public DialogStockFilter
{
public:
	DialogStockPrintFilter(TakionMainWnd* mainWnd, bool toDestroyOnFocus = false, TakionFrame* receipient = NULL, CWnd* parent = NULL);

//	DialogStockPrintFilter(TakionMainWnd* mainWnd,
//		bool toDestroyOnFocus = false, TakionFrame* receipient = NULL, CWnd* parent = NULL, LPCSTR caption = NULL, DWORD style = 0, DWORD exstendedStyle = 0, int x = 0, int y = 0, int w = 0, int h = 0,
//		LPCSTR font = NULL, WORD fontSize = 8, bool executeCommands = true, bool closeOnCommandExecution = true);
	void Display(const TakionFilter& filter, TakionFrame* receipient, unsigned int code, CWnd* parent, int x, int y, int w, int h, bool show = true);
protected:
//	virtual bool EnableToolTips(bool enable) override;
	virtual void ToolTipsEnabled(bool enable) override;
};

class TGUI_API DialogTimeFrameFilter : public DialogStockFilter
{
public:
	void Display(const TakionFilter& filter, TakionTool* receipient, unsigned int code, CWnd* parent, int x, int y, int w, int h, bool show = true);
	virtual bool isFilterChanged() const override;
	virtual bool isFilterValid() const override;
	virtual bool isFilterEmpty() const override;
	virtual void SetFilterEmpty() override;
	unsigned short GetTimeFrameMinutes() const;

	void GetTimeFrameAsString(std::string& str) const;

	void UpdateMyFields(TimeFrameFilter& other) const;
	virtual void UpdateSymbolFilterOfOtherKind(SymbolFilter& other) const override
	{
		DialogStockFilter::UpdateSymbolFilterOfOtherKind(other);
		if(other.isTimeFrameFilter())UpdateMyFields((TimeFrameFilter&)other);
	}
	bool MyFieldsIntersectionDifferent(const TimeFrameFilter& other, unsigned int doNotCopyFlags) const;
	virtual bool isSymbolFilterOfOtherKindIntersectionDifferent(const SymbolFilter& other, unsigned int doNotCopyFlags) const override
	{
		return DialogStockFilter::isSymbolFilterOfOtherKindIntersectionDifferent(other, doNotCopyFlags) || other.isTimeFrameFilter() && MyFieldsIntersectionDifferent((const TimeFrameFilter&)other, doNotCopyFlags);
	}

	void MyFieldsToControls(const TimeFrameFilter& other, unsigned int doNotCopyFlags);
	virtual void CopySymbolFilterOfOtherKindToControls(const SymbolFilter& other, unsigned int doNotCopyFlags) override
	{
		DialogStockFilter::CopySymbolFilterOfOtherKindToControls(other, doNotCopyFlags);
		if(other.isTimeFrameFilter())MyFieldsToControls((const TimeFrameFilter&)other, doNotCopyFlags);
	}
protected:
	DialogTimeFrameFilter(TakionMainWnd* mainWnd,
//		int xHiLo, int yHiLo,
//		int xTick, int yTick,
//		int xPriceOffset, int priceTop, int xSymbolOffset, int symbolHeight,
		bool toDestroyOnFocus = false, TakionFrame* receipient = NULL, CWnd* parent = NULL, LPCSTR caption = NULL, DWORD style = 0, DWORD exstendedStyle = 0, int x = 0, int y = 0, int w = 0, int h = 0,
		LPCSTR font = NULL, WORD fontSize = 8, bool executeCommands = true, bool closeOnCommandExecution = true);
	virtual void DoDataExchange(CDataExchange* pDX);
	virtual BOOL OnInitDialog();
	virtual void BeforeShow() override;
	virtual void AfterClose() override;
	virtual void UpdateFilterValues() override;
	
//	virtual bool EnableToolTips(bool enable) override;
	virtual void ToolTipsEnabled(bool enable) override;

	void OnTimeFrame();
	virtual void NamedFilterSelChange(const SymbolFilter* oldFilter, const SymbolFilter* newFilter, COLORREF intersectionColor, CBrush* intersectionBrush, COLORREF regularColor, int intersectionDeflation, int regularDeflation) override;
	DECLARE_MESSAGE_MAP()
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnTimeFrameDay();
	afx_msg void OnTimeFrameFrom1stPrint();
	afx_msg void OnTimeFrameMarketHours();
	afx_msg void OnTimeFrameMinutes();

	afx_msg void OnUseVolumeRate();
	afx_msg void OnUseVolumePercent();
	afx_msg void OnUseTVolByYVol();

	afx_msg void OnUsePositionSize();
	afx_msg void OnLongPosition();
	afx_msg void OnShortPosition();

	afx_msg void OnUsePriceRange();
	afx_msg void OnUseNetChange();

	afx_msg void OnUsePriceRangePercent();
	afx_msg void OnUseNetChangePercent();

	afx_msg void OnPositiveNetChange();
	afx_msg void OnNegativeNetChange();

	afx_msg void OnPositiveNetChangePercent();
	afx_msg void OnNegativeNetChangePercent();

	afx_msg void OnUseHiLoCount();
	afx_msg void OnPositiveHiLo();
	afx_msg void OnNegativeHiLo();

	afx_msg void OnUseTickCount();
	afx_msg void OnPositiveTick();
	afx_msg void OnNegativeTick();

	afx_msg LRESULT OnSpinChange(WPARAM spinId, LPARAM l);

	CButton m_GroupTimeFrame;
	RadioGroup m_RadioGroupTimeFrame;
	RadioOwnerDraw m_RadioTimeFrameDay;
	RadioOwnerDraw m_RadioTimeFrameFrom1stPrint;
	RadioOwnerDraw m_RadioTimeFrameMarketHours;
	RadioOwnerDraw m_RadioTimeFrameMinutes;

	UnsignedNumberTypeSpin<unsigned int> m_SpinTimeFrame;

	RangeGroup<unsigned int> m_priceRange;
	RangeGroupPositiveNegative<unsigned int> m_netChange;
	RangeGroup<unsigned int> m_priceRangePercent;
	RangeGroupPositiveNegative<unsigned int> m_netChangePercent;

	RangeGroup<unsigned int> m_volumeRate;
	RangeGroup<unsigned int> m_volumePercent;
	RangeGroup<unsigned int> m_percentTVolByYVol;
	RangeGroupPositiveNegative<unsigned int> m_positionSize;
	
	RangeGroupPositiveNegative<unsigned int> m_hiloCount;
	RangeGroupPositiveNegative<unsigned int> m_tickCount;
//	int m_timeFrameHeight;
//	int m_leftMostColumnBottom;

	int m_thirdColumnBottom;

	TakionTool* m_takionTool;
};

class TGUI_API BaseDialogMarketSorterFilter : public DialogTimeFrameFilter
{
public:
	enum TakionMarketSorterFilterDialogIds
	{
		sortQuotesGroupId = 1400,
		sortQuotesActivityId,
		sortQuotesGoodBadId,
		sortPrintsGroupId,
		sortPrintsActivityId,
		sortPrintsGoodBadId,

		marketSorterFilterCount
	};

//	BaseDialogMarketSorterFilter(TakionMainWnd* mainWnd, bool toDestroyOnFocus = false, TakionFrame* receipient = NULL, CWnd* parent = NULL);
	void Display(const TakionFilter& filter, TakionTool* receipient, unsigned int code, CWnd* parent, int x, int y);
	virtual bool isFilterChanged() const override;
	virtual bool isFilterValid() const override;
	virtual bool isFilterEmpty() const override;
	virtual void SetFilterEmpty() override;

	void UpdateMyFields(MarketSorterFilter& other) const;
	virtual void UpdateSymbolFilterOfOtherKind(SymbolFilter& other) const override
	{
		DialogTimeFrameFilter::UpdateSymbolFilterOfOtherKind(other);
		if(other.isMarketSorterFilter())UpdateMyFields((MarketSorterFilter&)other);
	}
	bool MyFieldsIntersectionDifferent(const MarketSorterFilter& other, unsigned int doNotCopyFlags) const;
	virtual bool isSymbolFilterOfOtherKindIntersectionDifferent(const SymbolFilter& other, unsigned int doNotCopyFlags) const override
	{
		return DialogTimeFrameFilter::isSymbolFilterOfOtherKindIntersectionDifferent(other, doNotCopyFlags) || other.isMarketSorterFilter() && MyFieldsIntersectionDifferent((const MarketSorterFilter&)other, doNotCopyFlags);
	}

	void MyFieldsToControls(const MarketSorterFilter& other, unsigned int doNotCopyFlags);
	virtual void CopySymbolFilterOfOtherKindToControls(const SymbolFilter& other, unsigned int doNotCopyFlags) override
	{
		DialogTimeFrameFilter::CopySymbolFilterOfOtherKindToControls(other, doNotCopyFlags);
		if(other.isMarketSorterFilter())MyFieldsToControls((const MarketSorterFilter&)other, doNotCopyFlags);
	}
protected:
	BaseDialogMarketSorterFilter(TakionMainWnd* mainWnd,
//		int xHiLo, int yHiLo,
//		int xTick, int yTick,
//		int xPriceOffset, int priceTop, int xSymbolOffset, int symbolHeight,
		bool toDestroyOnFocus = false, TakionFrame* receipient = NULL, CWnd* parent = NULL,
		LPCSTR caption = NULL, DWORD style = 0, DWORD exstendedStyle = 0, int x = 0, int y = 0, int w = 0, int h = 0,
		LPCSTR font = NULL, WORD fontSize = 8, bool executeCommands = true, bool closeOnCommandExecution = true);
	virtual void DoDataExchange(CDataExchange* pDX);
//	virtual void Apply();
	virtual BOOL OnInitDialog();
//	virtual void Resize(bool widthChanged = true, bool heightChanged = true);
//	virtual void FinishDialog(int result);
	virtual void BeforeShow() override;
//	virtual void Resize(bool widthChanged = true, bool heightChanged = true);
//	virtual void EnableOkButton();
	virtual void UpdateFilterValues() override;

//	virtual bool EnableToolTips(bool enable) override;
	virtual void ToolTipsEnabled(bool enable) override;

	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnSortQuotesActivity();
	afx_msg void OnSortQuotesGoodBad();
	afx_msg void OnSortPrintsActivity();
	afx_msg void OnSortPrintsGoodBad();

	virtual void NamedFilterSelChange(const SymbolFilter* oldFilter, const SymbolFilter* newFilter, COLORREF intersectionColor, CBrush* intersectionBrush, COLORREF regularColor, int intersectionDeflation, int regularDeflation) override;
	DECLARE_MESSAGE_MAP()

	void OnSortQuotes();
	void OnSortPrints();

	CButton m_GroupQuotes;
	RadioGroup m_RadioGroupQuotes;
	RadioOwnerDraw m_RadioQuotesActivity;
	RadioOwnerDraw m_RadioQuotesGoodBad;

	CButton m_GroupPrints;
	RadioGroup m_RadioGroupPrints;
	RadioOwnerDraw m_RadioPrintsActivity;
	RadioOwnerDraw m_RadioPrintsGoodBad;
};

class TGUI_API DialogMarketSorterFilter : public BaseDialogMarketSorterFilter//DialogStockFilter
{
public:
	DialogMarketSorterFilter(TakionMainWnd* mainWnd, bool toDestroyOnFocus = false, TakionFrame* receipient = NULL, CWnd* parent = NULL);
//protected:
//	virtual void AfterClose() override;
};

class TGUI_API DialogIndexSorterFilter : public DialogPriceFilter//DialogTimeFrameFilter
{
public:
	DialogIndexSorterFilter(TakionMainWnd* mainWnd, bool toDestroyOnFocus = false, TakionFrame* receipient = NULL, CWnd* parent = NULL);
	void Display(const TakionFilter& filter, TakionFrame* receipient, unsigned int code, CWnd* parent, int x, int y);
	virtual bool isFilterChanged() const override;
	virtual bool isFilterValid() const override;
	virtual bool isFilterEmpty() const override;
	virtual void SetFilterEmpty() override;
	unsigned short GetTimeFrameMinutes() const;

	void UpdateMyFields(IndexFilter& other) const;
	virtual void UpdateSymbolFilterOfOtherKind(SymbolFilter& other) const override
	{
		DialogPriceFilter::UpdateSymbolFilterOfOtherKind(other);
		if(other.isIndexFilter())UpdateMyFields((IndexFilter&)other);
	}
	bool MyFieldsIntersectionDifferent(const IndexFilter& other, unsigned int doNotCopyFlags) const;
	virtual bool isSymbolFilterOfOtherKindIntersectionDifferent(const SymbolFilter& other, unsigned int doNotCopyFlags) const override
	{
		return DialogPriceFilter::isSymbolFilterOfOtherKindIntersectionDifferent(other, doNotCopyFlags) || other.isIndexFilter() && MyFieldsIntersectionDifferent((const IndexFilter&)other, doNotCopyFlags);
	}

	void MyFieldsToControls(const IndexFilter& other, unsigned int doNotCopyFlags);
	virtual void CopySymbolFilterOfOtherKindToControls(const SymbolFilter& other, unsigned int doNotCopyFlags) override
	{
		DialogPriceFilter::CopySymbolFilterOfOtherKindToControls(other, doNotCopyFlags);
		if(other.isIndexFilter())MyFieldsToControls((const IndexFilter&)other, doNotCopyFlags);
	}
protected:
	virtual void DoDataExchange(CDataExchange* pDX);
//	virtual void Apply();
	virtual BOOL OnInitDialog();
//	virtual void Resize(bool widthChanged = true, bool heightChanged = true);
//	virtual void FinishDialog(int result);
	virtual void BeforeShow() override;
//	virtual void EnableOkButton();
	virtual void UpdateFilterValues() override;

//	virtual bool EnableToolTips(bool enable) override;
	virtual void ToolTipsEnabled(bool enable) override;

//	afx_msg void OnHideAll();
	afx_msg LRESULT OnListBoxChecked(WPARAM w, LPARAM l);

	virtual void NamedFilterSelChange(const SymbolFilter* oldFilter, const SymbolFilter* newFilter, COLORREF intersectionColor, CBrush* intersectionBrush, COLORREF regularColor, int intersectionDeflation, int regularDeflation) override;
	DECLARE_MESSAGE_MAP()

//	CButton m_CheckBoxHideAll;

	CStatic m_StaticCalcOrReal;
	ListBoxFilterString<unsigned int> m_ListBoxCalcOrReal;

//	virtual void DoDataExchange(CDataExchange* pDX);
//	virtual BOOL OnInitDialog();
//	virtual void BeforeShow();
	void OnTimeFrame();
//	DECLARE_MESSAGE_MAP()
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnTimeFrameDay();
	afx_msg void OnTimeFrameFrom1stPrint();
	afx_msg void OnTimeFrameMarketHours();
	afx_msg void OnTimeFrameMinutes();

	afx_msg void OnUsePriceRange();
	afx_msg void OnUseNetChange();

	afx_msg void OnUsePriceRangePercent();
	afx_msg void OnUseNetChangePercent();

	afx_msg void OnPositiveNetChange();
	afx_msg void OnNegativeNetChange();

	afx_msg void OnPositiveNetChangePercent();
	afx_msg void OnNegativeNetChangePercent();

	afx_msg void OnUseHiLoCount();
	afx_msg void OnPositiveHiLo();
	afx_msg void OnNegativeHiLo();

	afx_msg void OnUseTickCount();
	afx_msg void OnPositiveTick();
	afx_msg void OnNegativeTick();

	afx_msg LRESULT OnSpinChange(WPARAM spinId, LPARAM l);

//	CButton m_GroupTimeFrame;
	RadioGroup m_RadioGroupTimeFrame;
	RadioOwnerDraw m_RadioTimeFrameDay;
	RadioOwnerDraw m_RadioTimeFrameFrom1stPrint;
	RadioOwnerDraw m_RadioTimeFrameMarketHours;
	RadioOwnerDraw m_RadioTimeFrameMinutes;

	UnsignedNumberTypeSpin<unsigned int> m_SpinTimeFrame;

	RangeGroup<unsigned int> m_priceRange;
	RangeGroupPositiveNegative<unsigned int> m_netChange;
	RangeGroup<unsigned int> m_priceRangePercent;
	RangeGroupPositiveNegative<unsigned int> m_netChangePercent;
	RangeGroupPositiveNegative<unsigned int> m_hiloCount;
	RangeGroupPositiveNegative<unsigned int> m_tickCount;

	int m_thirdColumnBottom;

	int m_timeFrameHeight;
	int m_leftMostColumnBottom;
};

class TGUI_API DialogSecurityScrollerFilter : public DialogTimeFrameFilter//DialogStockFilter
{
public:
	DialogSecurityScrollerFilter(TakionMainWnd* mainWnd, bool toDestroyOnFocus, TakionFrame* receipient, CWnd* parent, int x, int y, int w, int h);//, bool show = true);
	void Display(const TakionFilter& filter, TakionTool* receipient, unsigned int code, CWnd* parent, int x, int y);
	virtual bool isFilterChanged() const override;
	virtual bool isFilterValid() const override;
	virtual bool isFilterEmpty() const override;
	virtual void SetFilterEmpty() override;

	void UpdateMyFields(SecurityScrollerFilter& other) const;
	virtual void UpdateSymbolFilterOfOtherKind(SymbolFilter& other) const override
	{
		DialogTimeFrameFilter::UpdateSymbolFilterOfOtherKind(other);
		if(other.isSecurityScrollerFilter())UpdateMyFields((SecurityScrollerFilter&)other);
	}
	bool MyFieldsIntersectionDifferent(const SecurityScrollerFilter& other, unsigned int doNotCopyFlags) const;
	virtual bool isSymbolFilterOfOtherKindIntersectionDifferent(const SymbolFilter& other, unsigned int doNotCopyFlags) const override
	{
		return DialogTimeFrameFilter::isSymbolFilterOfOtherKindIntersectionDifferent(other, doNotCopyFlags) || other.isSecurityScrollerFilter() && MyFieldsIntersectionDifferent((const SecurityScrollerFilter&)other, doNotCopyFlags);
	}

	void MyFieldsToControls(const SecurityScrollerFilter& other, unsigned int doNotCopyFlags);
	virtual void CopySymbolFilterOfOtherKindToControls(const SymbolFilter& other, unsigned int doNotCopyFlags) override
	{
		DialogTimeFrameFilter::CopySymbolFilterOfOtherKindToControls(other, doNotCopyFlags);
		if(other.isSecurityScrollerFilter())MyFieldsToControls((const SecurityScrollerFilter&)other, doNotCopyFlags);
	}
protected:
	virtual void DoDataExchange(CDataExchange* pDX);
	virtual BOOL OnInitDialog();
	virtual void BeforeShow() override;
	virtual void UpdateFilterValues() override;

//	virtual bool EnableToolTips(bool enable) override;
	virtual void ToolTipsEnabled(bool enable) override;

	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	DECLARE_MESSAGE_MAP()
	virtual void NamedFilterSelChange(const SymbolFilter* oldFilter, const SymbolFilter* newFilter, COLORREF intersectionColor, CBrush* intersectionBrush, COLORREF regularColor, int intersectionDeflation, int regularDeflation) override;
};

class TGUI_API ListBoxAtomicPrice : public ListBoxOwnerDraw
{
friend class DialogHiLoScrollerFilter;
public:
	ListBoxAtomicPrice(DialogHiLoScrollerFilter* dlg, bool draggable = true, const char* const& tooltipText = NULL):
		ListBoxOwnerDraw(0, true, true, draggable, tooltipText),
		m_dlg(dlg),
		m_rangeWidth(0),
		m_fromRight(0),
		m_toRight(0),
		m_useAtomicPrice(false)
	{
		m_selectable = false;
		m_checkable = 1;
		m_checkOnDoubleClick = false;
	}
	virtual bool isItemChecked(const void* item) const override{return ((const AtomicPriceRange*)item)->isUse();}
	virtual void DestroyItem(const void* item) const override;
	virtual void* CloneItem(const void* item) const override;
	virtual CBrush* GetBkBrush() const override
	{
		return m_useAtomicPrice ? NULL : GetGrayBrush();
	}
	virtual COLORREF GetBkColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override
	{
		return m_useAtomicPrice ? ListBoxOwnerDraw::GetBkColor(lpDrawItemStruct) : GetBkGrayColor();
	}
	const bool& isUseAtomicPrice() const{return m_useAtomicPrice;}
	void SetUseAtomicPrice(const bool& useAtomicPrice)
	{
		if(useAtomicPrice != m_useAtomicPrice)
		{
			m_useAtomicPrice = useAtomicPrice;
			Invalidate(TRUE);
		}
	}
	virtual bool HasItemToolTips() const override{return false;}
	virtual int GetCheckInvalidateWidth() const override{return m_useAtomicPrice ? m_rangeWidth : 0;}
protected:
	virtual void SetItemChecked(void* item, unsigned int i, bool checked) override{((AtomicPriceRange*)item)->SetUse(checked);}
	virtual void DoDrawItem(const DRAWITEMSTRUCT* lpDrawItemStruct, const CRect& drawItemRect) override;

	virtual void AddMenuItems(CMenu& menu) override;
	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;

	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;

//	virtual bool CanAddItem() const{return true;}
	virtual int AddItemOnMenuCommand(int before) override;
//	virtual bool CanFindItem() const override{return m_itemCount > 0;}
	virtual int FindItemOnMenuCommand() override;
//	virtual bool CanRemoveSelectedItem() const{return GetCurSel() >= 0;}
//	virtual bool CanClearItems() const{return m_itemCount > 0;}
	virtual bool RemoveSelectedItemOnMenuCommand(int sel) override;//{DeleteString(sel); return true;}
	virtual bool ClearItemsOnMenuCommand() override;//{return ClearItemsWithRedraw();}

	virtual void DoCreateColumnToolTips() override;
	virtual void UpdateColumnToolTipsHorizontalBounds() override;

	void CalculateBorders()
	{
		const int totalWidth = m_listBoxWidth - m_itemHeight;
		const int atomicPriceWidth = totalWidth >> 2;
		m_rangeWidth = (totalWidth - atomicPriceWidth) >> 1;
		m_fromRight = m_itemHeight + m_rangeWidth;
		m_toRight = m_fromRight + m_rangeWidth;
	}
	virtual void ListBoxCreated() override
	{
		ListBoxOwnerDraw::ListBoxCreated();
		CalculateBorders();
	}
	virtual void SizeChanged(bool horizontalChange, bool verticalChange) override
	{
		ListBoxOwnerDraw::SizeChanged(horizontalChange, verticalChange);
		if(horizontalChange)
		{
			CalculateBorders();
		}
	}

	DialogHiLoScrollerFilter* m_dlg;

	int m_rangeWidth;
	int m_fromRight;
	int m_toRight;

	bool m_useAtomicPrice;
};

class TGUI_API DialogHiLoScrollerFilter : public DialogSecurityScrollerFilter
{
friend class ListBoxAtomicPrice;
public:
	DialogHiLoScrollerFilter(TakionMainWnd* mainWnd, bool toDestroyOnFocus = false, TakionFrame* receipient = NULL, CWnd* parent = NULL);
	void Display(const TakionFilter& filter, TakionTool* receipient, unsigned int code, CWnd* parent, int x, int y);
	virtual bool isFilterChanged() const override;
	virtual bool isFilterValid() const override;
	virtual bool isFilterEmpty() const override;
	virtual void SetFilterEmpty() override;
	const bool& isUseAtomic() const{return m_useAtomic;}
	const bool& isOddLotPrints() const{return m_oddLotPrints;}
	const bool& isUsePrintJumpMode() const{return m_printJumpMode;}

	void GetAtomicRangeFrom(Price& from) const;
	void GetAtomicRangeTo(Price& to) const;
	void GetAtomicRange(Price& from, Price& to) const;

	void UpdateMyFields(HiLoScrollerFilter& other) const;
	virtual void UpdateSymbolFilterOfOtherKind(SymbolFilter& other) const override
	{
		DialogSecurityScrollerFilter::UpdateSymbolFilterOfOtherKind(other);
		if(other.isHiLoScrollerFilter())UpdateMyFields((HiLoScrollerFilter&)other);
	}
	bool MyFieldsIntersectionDifferent(const HiLoScrollerFilter& other, unsigned int doNotCopyFlags) const;
	virtual bool isSymbolFilterOfOtherKindIntersectionDifferent(const SymbolFilter& other, unsigned int doNotCopyFlags) const override
	{
		return DialogSecurityScrollerFilter::isSymbolFilterOfOtherKindIntersectionDifferent(other, doNotCopyFlags) || other.isHiLoScrollerFilter() && MyFieldsIntersectionDifferent((const HiLoScrollerFilter&)other, doNotCopyFlags);
	}

	void MyFieldsToControls(const HiLoScrollerFilter& other, unsigned int doNotCopyFlags);
	virtual void CopySymbolFilterOfOtherKindToControls(const SymbolFilter& other, unsigned int doNotCopyFlags) override
	{
		DialogSecurityScrollerFilter::CopySymbolFilterOfOtherKindToControls(other, doNotCopyFlags);
		if(other.isHiLoScrollerFilter())MyFieldsToControls((const HiLoScrollerFilter&)other, doNotCopyFlags);
	}
protected:
	virtual void DoDataExchange(CDataExchange* pDX);
	virtual BOOL OnInitDialog();
	virtual void BeforeShow() override;
	virtual void FinishDialog(int result) override;
	virtual void UpdateFilterValues() override;
	
//	virtual bool EnableToolTips(bool enable) override;
	virtual void ToolTipsEnabled(bool enable) override;

	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnAtomicUse();
	afx_msg void OnOddLotPrints();
	afx_msg void OnPrintJumpMode();
	afx_msg void OnAtomicDefaultPercent();
	afx_msg void OnDblClkAtomicPrice();
//	afx_msg void OnAtomicRangeAdd();
//	afx_msg void OnAtomicRangeRemove();
//	afx_msg void OnAtomicRangeClear();
	afx_msg LRESULT OnSpinChange(WPARAM spinId, LPARAM l);
	afx_msg LRESULT OnListBoxChecked(WPARAM w, LPARAM l);
	afx_msg LRESULT OnListBoxItemMoved(WPARAM w, LPARAM l);

	DECLARE_MESSAGE_MAP()
	virtual void NamedFilterSelChange(const SymbolFilter* oldFilter, const SymbolFilter* newFilter, COLORREF intersectionColor, CBrush* intersectionBrush, COLORREF regularColor, int intersectionDeflation, int regularDeflation) override;

	CheckBoxOwnerDraw m_CheckBoxUseAtomic;
	CheckBoxOwnerDraw m_CheckBoxOddLotPrints;
	CheckBoxOwnerDraw m_CheckBoxPrintJumpMode;
	CheckBoxOwnerDraw m_CheckBoxDefaultPercent;
	CStatic m_StaticAtomicOutOfRange;
	UnsignedNumberTypeSpin<unsigned int> m_SpinAtomicOutOfRange;
	UnsignedNumberTypeSpin<unsigned int> m_SpinAtomicRangeMin;
	UnsignedNumberTypeSpin<unsigned int> m_SpinAtomicRangeMax;
	UnsignedNumberTypeSpin<unsigned int> m_SpinAtomicPrice;

	CheckBoxOwnerDraw m_CheckBoxPercent;

//	CButton m_ButtonAtomicAdd;
//	CButton m_ButtonAtomicRemove;
//	CButton m_ButtonAtomicClear;

	ListBoxAtomicPrice m_ListBoxAtomicPrice;

	void EnableButtonsOnAtomicPriceRangeChange();

	void AtomicRangeAdd(int before);
	void AtomicRangeRemove(int sel);
	void AtomicRangeClear();

	void UpdateAtomicColors();
	bool m_useAtomic;
	bool m_oddLotPrints;
	bool m_printJumpMode;
};

class TGUI_API TakionSettingAbout : public TakionSettingAboutBase//TakionSettingPageBase
{
public:
	TakionSettingAbout(TakionMainWnd* mainWnd, TakionSettingTabDialog* parentTab, const char* releaseNotesLink);
protected:
	virtual void FillProperties();
};

class TGUI_API TakionLayoutFileDialog : public TakionCheckBoxFileDialog
{
public:
	TakionLayoutFileDialog(TakionMainWnd* mainWnd, bool open, const char* fileName, bool createLbFlags, bool noValidate, CWnd* parent);
//	unsigned int GetFlags() const;
	virtual const char* GetNameFlag(unsigned int i, unsigned char& flag) const;
protected:
//	virtual BOOL OnInitDialog() override;
//	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) override;
//	TakionFileDialogCheckBoxParentWnd* m_layoutParent;
};

class TGUI_API TakionPosCostFileDialog : public TakionCheckBoxFileDialog
{
public:
	TakionPosCostFileDialog(TakionMainWnd* mainWnd, bool open, const char* fileName, bool createLbFlags, CWnd* parent);
//	unsigned int GetFlags() const;
	virtual const char* GetNameFlag(unsigned int i, unsigned char& flag) const;
protected:
//	virtual BOOL OnInitDialog() override;
//	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) override;
//	TakionFileDialogCheckBoxParentWnd* m_layoutParent;
};

enum CopyDataIds
{
	CDI_STARTUP = 0,
	CDI_SHUTDOWN,
	CDI_SYMBOL,
	CDI_MMBOX_ADDED,
	CDI_MMBOX_REMOVED,

	CDI_COUNT
};

class TGUI_API ListBoxLink : public ListBoxOwnerDraw
{
public:
	ListBoxLink();//int itemHeight = 0, bool rbuttonSelection = false, bool rbuttonMenu = false, bool draggable = false);
	virtual void DestroyItem(const void* item) const override;
	virtual void* CloneItem(const void* item) const override;
	virtual int Compare(const void* item1, const void* item2) const override;
//	virtual void ItemToString(const void* item, std::string& itemStr) const{itemStr = ((const StringUInt*)item)->GetNameStr();}
//	virtual const char* GetItemName(const void* item) const{return ((const StringUInt*)item)->GetName();}
//	virtual bool SpinItem(unsigned int at, bool increment, unsigned int value, bool leftSideSpin, unsigned char ordinalSpin);
	virtual COLORREF GetSelectedBkColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override;
	virtual bool isItemChecked(const void* item) const override;
	static const int gap = 1;

	int GetCheckUnderMouse() const{return m_checkUnderMouse;}
	unsigned char GetUseUnderMouse() const{return m_useUnderMouse;}
	void SetCheckUnderMouse(int i, unsigned char use);
	void SetCheckAndInvalidate(unsigned int i, unsigned char use, bool notify);
	void InvalidateCheckBox(unsigned int i, unsigned char use);
	bool SetItemAtCheckChecked(unsigned int i, unsigned char use);
	void ToggleCheckAndInvalidate(unsigned int i, unsigned char use);
	bool ToggleCheckAt(unsigned int i, unsigned char use);
	void ToggleCurrentUnderMouse();
//	virtual bool isPointForRButtonMenuOk(UINT nFlags, CPoint point) const;

protected:
	virtual void SetItemChecked(void* item, unsigned int i, bool checked) override;
	virtual void DoDrawItem(const DRAWITEMSTRUCT* lpDrawItemStruct, const CRect& drawItemRect) override;
	virtual void AddMenuItems(CMenu& menu) override;
//	virtual void Resize(int cx, int cy) override;
	virtual void SizeChanged(bool horizontalChange, bool verticalChange) override;
//	virtual void ListBoxCreated();
	virtual void MouseLeft() override;

	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);

	DECLARE_MESSAGE_MAP()

	COLORREF m_colorNotFound;
	COLORREF m_colorConnected;
	COLORREF m_colorDisconnected;

	int m_checkBoxSendSymbolLeft;
	int m_checkBoxSendSymbolRight;
	unsigned char m_useUnderMouse;
	unsigned char m_usePressed;
	int m_checkUnderMouse;
	int m_checkPressed;
};

class TGUI_API TakionSettingPassword : public TakionSettingPageBase
{
public:
	TakionSettingPassword(TakionMainWnd* mainWnd, TakionSettingTabDialog* parentTab, const char* label, const char* iniPath, const char* iniSection, const char* iniNewsSection, const char* traderId, const char* password, const char* newsPassword, bool noConnection);
	virtual HWND GetFirstTabControl() const{return m_EditPassword.m_hWnd;}
	virtual void UpdateControls();
//	virtual void UpdateSettings();
	void SetTraderIdAndPassword(const char* traderId, const char* password, const char* newsPassword, bool noConnection);
	bool isChanged() const;
	bool isNewsChanged() const;
protected:
	void UpdateStatus();
	void UpdateWarningText();
	void UpdateNewsStatus();
	void UpdateNewsWarningText();

	CButton m_CheckBoxUseIp;
	CStatic m_StaticStatus;
	EditNoContext m_EditPassword;
	CButton m_ButtonSave;
	CButton m_ButtonRemove;
	CStatic m_StaticWarning;
	virtual BOOL OnInitDialog();
	virtual void DoDataExchange(CDataExchange* pDX);
	afx_msg void OnUseIp();
	afx_msg void OnChangePassword();
	afx_msg void OnSave();
	afx_msg void OnRemove();
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	DECLARE_MESSAGE_MAP()

	CButton m_CheckBoxNewsUseIp;
	CStatic m_StaticNewsStatus;
	EditNoContext m_EditNewsPassword;
	CButton m_ButtonNewsSave;
	CButton m_ButtonNewsRemove;
	CStatic m_StaticNewsWarning;
	afx_msg void OnNewsUseIp();
	afx_msg void OnChangeNewsPassword();
	afx_msg void OnNewsSave();
	afx_msg void OnNewsRemove();

//	virtual void Resize(bool widthChanged = true, bool heightChanged = true);

	std::string m_myPassword;
	std::string m_password;
	std::string m_savedPasswordDecrypted;
	bool m_savedPasswordValid;
	bool m_noConnection;
	bool m_savedUseIp;
	bool m_useIp;
	StringIniValue m_savedPassword;

	std::string m_myNewsPassword;
	std::string m_newsPassword;
	std::string m_savedNewsPasswordDecrypted;
	bool m_savedNewsPasswordValid;
	bool m_savedNewsUseIp;
	bool m_newsUseIp;
	StringIniValue m_savedNewsPassword;

	int m_buttonWidth;
	int m_buttonHeight;
	int m_staticHeight;
	int m_gapVertical;
	int m_gapHorizontal;
};

class TGUI_API TakionSettingLink : public TakionSettingPageBase
{
public:
	TakionSettingLink(TakionMainWnd* mainWnd, TakionSettingTabDialog* parentTab);
	virtual HWND GetFirstTabControl() const{return m_ListBoxLink.m_hWnd;}
	virtual void UpdateSettings();
	void LinkChanged(bool connected, HWND hwnd);
	void NullifyLink(const char* className, const char* title);
protected:
	ListBoxLink m_ListBoxLink;
	CStatic m_StaticClassName;
	CStatic m_StaticTitle;
	EditNoContext m_EditClassName;
	EditNoContext m_EditTitle;
	CButton m_ButtonAdd;
	CButton m_ButtonRemove;
	CButton m_ButtonClear;
	CButton m_ButtonFind;
	CButton m_ButtonPaste;
	virtual BOOL OnInitDialog();
	virtual void DoDataExchange(CDataExchange* pDX);
	afx_msg void OnDblClkLink();
	afx_msg void OnSelchangeLink();
	afx_msg void OnChangeClassName();
	afx_msg void OnChangeTitle();
	afx_msg void OnAdd();
	afx_msg void OnRemove();
	afx_msg void OnClear();
	afx_msg void OnFind();
	afx_msg void OnPaste();
//	afx_msg LRESULT OnListBoxChecked(WPARAM w, LPARAM l);
//	afx_msg LRESULT OnListBoxRangeChecked(WPARAM w, LPARAM l);
	DECLARE_MESSAGE_MAP()

	virtual void Resize(bool widthChanged = true, bool heightChanged = true);
	void EnableAddButton();
	void EnableClearButton();
	void EnableRemoveButton();

	int m_buttonWidth;
	int m_buttonHeight;
	int m_staticHeight;
	int m_gapVertical;
	int m_gapHorizontal;
};

//#define EXT_LINK_USE_DBL_CLK_TO_ERASE

#ifdef EXT_LINK_USE_DBL_CLK_TO_ERASE
enum ExtLinkSimulateDoubleClick : unsigned char
{
	ELSDC_THINKORSWIM,

	ELSDC_Count
};
#endif

class TGUI_API TakionSettingExtLink : public TakionSettingPageBase
{
public:
	TakionSettingExtLink(TakionMainWnd* mainWnd, TakionSettingTabDialog* parentTab);
	virtual HWND GetFirstTabControl() const override{return m_SpinAdvancedGetMillisecond.m_hWnd;}
	virtual void UpdateSettings() override;
#ifdef EXT_LINK_USE_DBL_CLK_TO_ERASE
	HWND GetMainWindowToLink(HWND entryHwnd) const;
#endif
protected:
	CButton m_GroupAdvancedGet;
	TimeSpin m_SpinAdvancedGetMillisecond;
	CStatic m_StaticAdvancedGetMillisecond;
	CButton m_CheckBoxForceSendSymbol;

	virtual BOOL OnInitDialog();
	virtual void DoDataExchange(CDataExchange* pDX);
	
#ifdef EXT_LINK_USE_DBL_CLK_TO_ERASE
	CButton m_GroupSimulateDoubleClick;
	ComboBoxString m_ComboBoxSimulateDoubleClick;

	virtual void OnMouseForcedReleaseCapture() override;
	afx_msg void OnSelchangeSimulateDoubleClick();
	afx_msg LRESULT OnNcHitTest(CPoint point);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
//	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
#endif

	afx_msg LRESULT OnSpinChange(WPARAM spinId, LPARAM l);
	DECLARE_MESSAGE_MAP()

	int m_buttonWidth;
	int m_buttonHeight;
	int m_staticHeight;
	int m_gapVertical;
	int m_gapHorizontal;

#ifdef EXT_LINK_USE_DBL_CLK_TO_ERASE
	virtual void DoPaint(const RECT& rcPaint, CDC& dc) override;
	virtual void MouseLeft() override;

	CRect m_rectSimulateDoubleClick;

	CPoint m_extLinkPointSimulateDoubleClick[ELSDC_Count];

	COLORREF m_colorActive;
	COLORREF m_colorActiveLight;
	COLORREF m_colorActiveDark;
	COLORREF m_colorInactive;
	COLORREF m_colorInactiveLight;
	COLORREF m_colorInactiveDark;

	void DoSetClientDragCursor(HCURSOR cursor);
	void SetClientDragCursor(UINT nFlags, CPoint point);

	bool m_inRectSimulateDoubleClick;
	unsigned char m_extLinkSimulateDoubleClick;
	unsigned char m_draggingClientStatus;//0 - not dragging, 1 - mouse button down, waiting for it to move by some value, 2 - dragging
	int m_dragClientInitialX;
	int m_dragClientInitialY;
	HCURSOR m_draggingCursor;
	HWND m_draggingClientOver;
	HWND m_draggingParentOver;
	HWND m_goalWindow;
#endif
};

class TGUI_API ListBoxAccelerator : public ListBoxOwnerDraw
{
public:
	ListBoxAccelerator();//int itemHeight = 0, bool rbuttonSelection = false, bool rbuttonMenu = false, bool draggable = false);
	virtual void DestroyItem(const void* item) const override;
	virtual void* CloneItem(const void* item) const override;
	virtual int Compare(const void* item1, const void* item2) const override;
	virtual const char* GetItemName(const void* item) const override;
//	virtual COLORREF GetSelectedBkColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const;
//	virtual bool isItemChecked(const void* item) const;
//	virtual void SetItemChecked(void* item, bool checked);
protected:
	virtual void DoDrawItem(const DRAWITEMSTRUCT* lpDrawItemStruct, const CRect& drawItemRect) override;
//	virtual void AddMenuItems(CMenu& menu);
	COLORREF m_colorFound;
//	COLORREF m_colorConnected;
//	COLORREF m_colorDisconnected;
};

class TGUI_API TakionSettingAccelerator : public TakionSettingPageBase
{
public:
	TakionSettingAccelerator(TakionMainWnd* mainWnd, TakionSettingTabDialog* parentTab);
	virtual HWND GetFirstTabControl() const{return m_ListBoxAccelerator.m_hWnd;}
	virtual void UpdateSettings();
protected:
	ListBoxAccelerator m_ListBoxAccelerator;
//	CStatic m_StaticAccelerator;
//	CStatic m_StaticSymbol;
	ValidEdit m_EditAccelerator;
	ValidEdit m_EditSymbol;
	CButton m_ButtonFindAccelerator;
	CButton m_ButtonFindSymbol;
	CButton m_ButtonAdd;
	CButton m_ButtonRemove;
	CButton m_ButtonClear;
	CButton m_ButtonPaste;
	virtual BOOL OnInitDialog();
	virtual void DoDataExchange(CDataExchange* pDX);
	afx_msg void OnDblClkAccelerator();
	afx_msg void OnSelchangeAccelerator();
	afx_msg void OnChangeAccelerator();
//	afx_msg void OnUpdateAccelerator();
	afx_msg void OnChangeSymbol();
//	afx_msg void OnUpdateSymbol();
	afx_msg void OnAdd();
	afx_msg void OnRemove();
	afx_msg void OnClear();
	afx_msg void OnFindAccelerator();
	afx_msg void OnFindSymbol();
	afx_msg void OnPaste();
//	afx_msg LRESULT OnListBoxChecked(WPARAM w, LPARAM l);
//	afx_msg LRESULT OnListBoxRangeChecked(WPARAM w, LPARAM l);
	DECLARE_MESSAGE_MAP()

//	virtual void Resize(bool widthChanged = true, bool heightChanged = true);
	void EnableAddButton();
	void EnableClearButton();
	void EnableRemoveButton();

	int m_buttonWidth;
	int m_buttonHeight;
	int m_staticHeight;
	int m_editHeight;
	int m_gapVertical;
	int m_gapHorizontal;
};

class TGUI_API ListBoxNamedValue : public ListBoxOwnerDraw
{
public:
	ListBoxNamedValue(bool draggable = false):ListBoxOwnerDraw(0, true, false, draggable){}
	virtual int Compare(const void* item1, const void* item2) const override;
	virtual void ItemToString(const void* item, std::string& itemStr) const override;
	virtual const char* GetItemName(const void* item) const override;
protected:
	virtual void DoDrawItem(const DRAWITEMSTRUCT* lpDrawItemStruct, const CRect& drawItemRect) override;
	virtual bool GetToolTipInfo(unsigned int ordinal, const void* item, std::string& tooltipText, int& left, int& right) const override;
};

class TGUI_API TakionSettingNamedValue : public TakionSettingPickItems
{
protected:
	TakionSettingNamedValue(TakionMainWnd* mainWnd, TakionSettingTabDialog* parentTab, const char* label, int lbWidth, int hOffset, bool tooltips, bool removeByDragging);//, int height = defaultHeight);

	ListBoxNamedValue m_ListBoxValuesAll;
	ListBoxNamedValue m_ListBoxValuesSelected;
};

class TGUI_API ListBoxTitleLine : public ListBoxOrdinal
{
public:
	ListBoxTitleLine():ListBoxOrdinal(0, true, true, true){}
//	virtual const char* GetItemName(const void* item) const;
protected:
	virtual void DestroyItem(const void* item) const override;
	virtual void AddMenuItems(CMenu& menu) override;
	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;
};

class TGUI_API TakionSettingSecurityTitle : public TakionSettingNamedValue
{
public:
	virtual void UpdateSettings();
	virtual bool ClearItems();
protected:
	TakionSettingSecurityTitle(TakionMainWnd* mainWnd,
		TakionSettingTabDialog* parentTab,
		TakionConfig::StringVectorVector& valuesSetting,
		BoolSetting& alignSetting,
		const char* label,
		int lbWidth,
		int hOffset,
		bool tooltips,
		bool removeByDragging);

//	virtual void Entering() override;
	virtual void ToolTipsEnabled(bool enable) override;

	virtual void DoApplyInitInfo() override;
	virtual BOOL OnInitDialog();
	virtual void DoDataExchange(CDataExchange* pDX);
	virtual void LBItemDraggedAndDropped(unsigned int ctrlId, unsigned short from, unsigned short to) override;// unsigned int itemOrdinal);
	virtual void LBDragDropDone(unsigned int ctrlId, int itemOrdinalOld, int itemOrdinalNew) override;
	virtual void LBDragDropAbort(unsigned int ctrlId, int itemOrdinal) override;
	afx_msg void OnSelchangeLine();
	afx_msg LRESULT OnTitleLinesAdded(WPARAM w, LPARAM l);
	afx_msg LRESULT OnTitleLinesRemoved(WPARAM w, LPARAM l);
	afx_msg LRESULT OnTitleLineMove(WPARAM w, LPARAM l);
	afx_msg LRESULT OnRSelChange(WPARAM ctrlId, LPARAM itemNumber);
//	afx_msg void OnAlign();
	DECLARE_MESSAGE_MAP()
	void UpdateCurrentLine();
//	void UpdateSelection(int sel);
	void DoSelchangeLine(int sel);
	virtual void UpdateTitleValueCollection(){}
	virtual void UpdateAlignTitleValues(){}
	TakionConfig::StringVectorVector& m_valuesSetting;
	BoolSetting& m_alignSetting;
	ListBoxTitleLine m_ListBoxTitleLine;
	ButtonToolTip m_CheckBoxAlign;
	int m_currentLineSelection;
	void* m_currentItemSelection;
	bool m_currentLineModified;
};

class TGUI_API TakionSettingSearchCommands : public TakionSettingPageBase
{
public:
	enum TakionSettingSearchCommandsIds
	{
		commandListBoxId = 10000,

		searchEditId,
		searchButtonId,
		findCommandButtonId,

		searchCommandIdsCount
	};

	bool SearchCommands();
	virtual HWND GetFirstTabControl() const;
protected:
	TakionSettingSearchCommands(TakionMainWnd* mainWnd,
		TakionSettingTabDialog* parentTab,
		const char* label,
		int listBoxWidth,
		bool listBoxesInTheMiddle);

	virtual BOOL OnInitDialog() override;

//	virtual void Entering() override;
	virtual void ToolTipsEnabled(bool enable) override;

	virtual void DoApplyInitInfo() override;
	virtual void SelectCorrespondingKey(){}
	virtual void SelectCorrespondingCommand(){}
	virtual bool CheckCommandCategory(const CommandCategory commandCategory){return false;}
	virtual bool CheckKeyModifiers(const Key& key){return false;}

	virtual void SettingPageDestroyed() override;

	virtual void DoDataExchange(CDataExchange* pDX);
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	virtual void AfterSearchCommands(){}

	unsigned char ProcessKeyInSearch(MSG* pMsg);

//	CommandListBox m_ListBoxCommand;
	MappableCommandListBox m_ListBoxCommand;
	EditNoContext m_EditSearch;
	CButton m_ButtonSearch;

	CButton m_ButtonFindCommand;

	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnSelchangeCommand();
	afx_msg void OnSearchChange();
	afx_msg void OnSearch();
	afx_msg void OnFindCommand();
	afx_msg LRESULT OnRSelChange(WPARAM ctrlId, LPARAM itemNumber);
	DECLARE_MESSAGE_MAP()

	virtual void CommandSelected(){}

	int m_checkHeight;
	int m_buttonHeight;
	int m_editHeight;

	CString m_searchStr;
	bool m_searchDone;

	ResizeControl* m_commandResize;
};


class TGUI_API TakionSettingCommands : public TakionSettingSearchCommands
{
public:
	enum TakionSettingCommandsIds
	{
		keyListBoxId = searchCommandIdsCount,

		checkBoxMappedOnTopKeys,
		checkBoxMappedOnTopCommands,

		commandIdsCount
	};

	virtual ~TakionSettingCommands();
	virtual void UpdateSettings() override;
//	virtual void UpdateControls();

//	bool SearchCommands();
//	virtual HWND GetFirstTabControl();
	const KeyCommandPair* UpdateCommandToMap();
	const KeyCommandPair* UpdateKeyToMap();

#if (_MSC_VER > 1600)
	typedef std::unordered_map<Command*, KeyCommandPair*> CommandList;
	typedef std::unordered_map<Key, KeyCommandPair*, TakionHashValue<Key> > KeyList;
#else
	typedef std::hash_map<Command*, KeyCommandPair*> CommandList;
	typedef std::hash_map<Key, KeyCommandPair*> KeyList;
#endif
	KeyCommandPair* FindKey(const Key& key);
	const KeyCommandPair* FindKey(const Key& key) const;
	virtual KeyCommandPair* FindKeyThrough(const Key& key, int& found);

	KeyCommandPair* FindCommand(const Command* command);
	const KeyCommandPair* FindCommand(const Command* command) const;
	virtual void CommandAdded(Command* command);
	virtual void CommandRemoved(Command* command);
	virtual void BeforeCommandRenamed(Command* c, KeyCommandPair*& keyPair, KeyCommandPair*& keySelected, KeyCommandPair*& commandPair, KeyCommandPair*& commandSelected);
	virtual void CommandRenamed(Command* command, KeyCommandPair* keyPair, KeyCommandPair* keySelected, KeyCommandPair* commandPair, KeyCommandPair* commandSelected);
	virtual void CommandMapped(const Key& key, Command* command);
	virtual void CommandUnmapped(const Key& key, Command* command);
protected:
	TakionSettingCommands(TakionMainWnd* mainWnd,
		TakionSettingTabDialog* parentTab,
		const char* label,
		KeyCommandMapping& keyCommandMapping,
		TakionConfig::StringStringMappingSetting& keyCommandMappingSetting,
		BoolSetting& mappedOnTopKeysSetting,
		BoolSetting& mappedOnTopCommandsSetting,
		unsigned char maxCategory,
		unsigned int commandFilter,
		int listBoxWidth,
		bool listBoxesInTheMiddle);
	void DestroyKeys();
	KeyList& GetKeyList(const Key& key);
	const KeyList& GetKeyList(const Key& key) const;

	int SelectKeyInCommandList(const Key& key);

//	virtual void Entering() override;
	virtual void ToolTipsEnabled(bool enable) override;

	virtual void CommandSelected();
	void KeySelected();

	virtual void AfterSearchCommands() override;

	virtual void SelectCorrespondingKey() override;
	virtual void SelectCorrespondingCommand() override;

	KeyCommandMapping& m_keyCommandMapping;
	TakionConfig::StringStringMappingSetting& m_keyCommandMappingSetting;
	BoolSetting& m_mappedOnTopKeysSetting;
	BoolSetting& m_mappedOnTopCommandsSetting;

	MappableKeyListBox m_ListBoxKey;
//	KeyListBox m_ListBoxKey;

	ButtonToolTip m_CheckBoxMappedOnTopKeys;
	ButtonToolTip m_CheckBoxMappedOnTopCommands;

	virtual void Resize(bool widthChanged = true, bool heightChanged = true) override;
	virtual void SettingPageDestroyed() override;
	virtual BOOL PreTranslateMessage(MSG* pMsg) override;
	virtual BOOL OnInitDialog() override;
	virtual void DoDataExchange(CDataExchange* pDX) override;
	afx_msg void OnSelchangeKey();
	afx_msg void OnDblclkCommand();
	afx_msg void OnDblclkKey();

	afx_msg void OnMappedOnTopKeys();
	afx_msg void OnMappedOnTopCommands();

	afx_msg LRESULT OnMapCommand(WPARAM index, LPARAM id);
	afx_msg LRESULT OnRSelChange(WPARAM ctrlId, LPARAM itemNumber);
	DECLARE_MESSAGE_MAP()

	void DoMap(const Key& key, Command* commandToMap, int commandItemIndex, int keyItemIndex);
	void DoUnmap(int commandItemIndex, int keyItemIndex, bool ui);

	bool m_mappingModified;
	Key m_lastKeyPressed;

	unsigned char m_maxCategory;
	unsigned int m_commandFilter;
	unsigned int m_potentialCommandFilter;
	unsigned short m_keyFilter;

//	int m_leftControlsX;
//	int m_rightControlsX;

	ResizeControl* m_keyResize;

	CommandList* m_commandCategoryList;
	KeyList m_keyCategoryList[SC_COUNT][KLC_COUNT][KC_COUNT];
};

class TGUI_API TakionSettingModifierCommands : public TakionSettingCommands
{
public:
	virtual void UpdateSettings();
	virtual KeyCommandPair* FindKeyThrough(const Key& key, int& found);
protected:
	TakionSettingModifierCommands(TakionMainWnd* mainWnd, TakionSettingTabDialog* parentTab, const char* label, KeyCommandMapping& keyCommandMapping, TakionConfig::StringStringMappingSetting& keyCommandMappingSetting, BoolSetting& mappedOnTopKeysSetting, BoolSetting& mappedOnTopCommandsSetting, unsigned char maxCategory, unsigned int commandFilter, UShortSetting& keyFilterSetting, UIntSetting& fallThroughKeysSetting, int rightTopOffset);
	bool DoCheckKeyCategory(CButton& button, const KeyCategory kc);
	bool DoCheckKeyLockCategory(CButton& button, const KeyLockCategory klc);
	bool DoCheckSideCategory(CButton& button, const SideCategory sc);
	virtual bool CheckKeyModifiers(const Key& key) override;

//	virtual void Entering() override;
	virtual void ToolTipsEnabled(bool enable) override;

	virtual BOOL OnInitDialog() override;
	virtual void DoDataExchange(CDataExchange* pDX) override;
//	virtual void Resize(bool widthChanged = true, bool heightChanged = true);
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnModifierNone();
	afx_msg void OnModifierShift();
	afx_msg void OnModifierCtrl();
	afx_msg void OnModifierAlt();
	afx_msg void OnModifierShiftCtrl();
	afx_msg void OnModifierShiftAlt();
	afx_msg void OnModifierCtrlAlt();
	afx_msg void OnModifierShiftCtrlAlt();

	afx_msg void OnLockNone();
	afx_msg void OnLockCaps();
	afx_msg void OnLockNum();
	afx_msg void OnLockCapsNum();

	afx_msg void OnSideLeft();
	afx_msg void OnSideRight();

	afx_msg LRESULT OnListBoxChecked(WPARAM w, LPARAM l);
	afx_msg LRESULT OnListBoxItemMoved(WPARAM w, LPARAM l);
	DECLARE_MESSAGE_MAP()

	void OnKeyCategoryFilter(CButton& button, KeyCategory kc);
	void OnKeyLockCategoryFilter(CButton& button, KeyLockCategory kc);
	void OnKeySideCategoryFilter(CButton& button, SideCategory kc);

	UShortSetting& m_keyFilterSetting;
	UIntSetting& m_fallThroughKeysSetting;

	ButtonToolTip m_CheckBoxModifierNone;
	ButtonToolTip m_CheckBoxModifierShift;
	ButtonToolTip m_CheckBoxModifierCtrl;
	ButtonToolTip m_CheckBoxModifierAlt;
	ButtonToolTip m_CheckBoxModifierShiftCtrl;
	ButtonToolTip m_CheckBoxModifierShiftAlt;
	ButtonToolTip m_CheckBoxModifierCtrlAlt;
	ButtonToolTip m_CheckBoxModifierShiftCtrlAlt;

	ButtonToolTip m_CheckBoxLockNone;
	ButtonToolTip m_CheckBoxLockCaps;
	ButtonToolTip m_CheckBoxLockNum;
	ButtonToolTip m_CheckBoxLockCapsNum;

	ButtonToolTip m_CheckBoxSideLeft;
	ButtonToolTip m_CheckBoxSideRight;

	CStatic m_StaticKeyFallThrough;
	ListBoxKeyFallThrough m_ListBoxKeyFallThrough;
/*
	typedef std::list<CWnd*> WinList;
	WinList m_leftControls;
	WinList m_rightControls;
*/
	COLORREF m_lockColor;
	COLORREF m_sideColor;

	bool m_numChecked;
	bool m_capsChecked;
	bool m_rightChecked;
	bool UpdateFallThroughKeys();
	unsigned int m_fallThroughKeys;
	unsigned short m_originalKeyFilter;

	int m_rightOffset;// = 371;
	int m_rightWidth;// = 41;

//	VerticalResizeControlBelowControlFromMiddleLeft
};

class TGUI_API TakionSettingMainCommands : public TakionSettingModifierCommands
{
public:
	TakionSettingMainCommands(TakionMainWnd* mainWnd, TakionSettingTabDialog* parentTab);
	virtual void UpdateSettings();
//	virtual KeyCommandPair* FindKeyThrough(const Key& key, int& found);
protected:
	bool DoCheckCommandCategory(CButton& button, const CommandCategory cc);
	virtual bool CheckCommandCategory(const CommandCategory commandCategory) override;

//	virtual void Entering() override;
	virtual void ToolTipsEnabled(bool enable) override;

	virtual BOOL OnInitDialog() override;
	virtual void DoDataExchange(CDataExchange* pDX);
//	virtual void Resize(bool widthChanged = true, bool heightChanged = true);
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnCcAggregate();
	afx_msg void OnCcTrade();
	afx_msg void OnCcCancel();
	afx_msg void OnCcTierSize();
	afx_msg void OnCcNavigate();
	afx_msg void OnCcSetting();
	afx_msg void OnCcEmail();
	DECLARE_MESSAGE_MAP()

	void OnCommandFilter(CButton& button, const CommandCategory cc);

	ButtonToolTip m_CheckBoxCcAggregate;
	ButtonToolTip m_CheckBoxCcTrade;
	ButtonToolTip m_CheckBoxCcCancel;
	ButtonToolTip m_CheckBoxCcTierSize;
	ButtonToolTip m_CheckBoxCcNavigate;
	ButtonToolTip m_CheckBoxCcSetting;
	ButtonToolTip m_CheckBoxCcEmail;
};

class TGUI_API TakionSettingMainDialog : public TakionSettingTopDialog
{
friend class TakionMainWnd;
public:
	TakionSettingMainDialog(TakionMainWnd* mainWnd, int width, int height, const char* title = NULL, COLORREF titleColor = RGB(0, 0, 128), int topOffset = 0, bool showTime = false, COLORREF selectedBkColor = RGB(196, 196, 255), COLORREF alarmBkColor = RGB(255, 0, 0));
//	virtual int GetRightMargin() const;
	void AddAllTabs();
//	virtual void Apply();
	TakionSettingCommands* GetTakionSettingCommands(){return m_takionSettingCommands;}
	TakionSettingLink* GetTakionSettingLink(){return m_takionSettingLink;}
	virtual std::string GetHelpUrl() const override;
//	virtual TakionSettingTabDialog* GetMainTabDialog(){return this;}
//	virtual void OnOK();
	virtual bool isInitializedFromFile() const override;
	virtual void GetPosRect(CRect& r) override;
	virtual bool ExtractIsAlwaysOnTop() const override;
	virtual bool isLeafRButtonMenuOk() const override{return true;}
	virtual bool isLeafNcRButtonMenuOk() const override{return true;}
//For handling Views
	const int& GetLocationX() const{return m_locationX;}
	const int& GetLocationY() const{return m_locationY;}
	const bool& isLocationInitializedFromFile() const{return m_locationInitializedFromFile;}
	const bool& isLocationOnTop() const{return m_locationOnTop;}
protected:
	virtual void DisplayPageMenu(TakionSettingPageBase* leaf, const CPoint& point) override;
	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;
	virtual void SaveAlwaysOnTop(bool onTop);

	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;
/*
	CButton m_ButtonOk;
	CButton m_ButtonApply;
	CButton m_CheckBoxOnTop;
	CButton m_ButtonCancel;
	CButton m_ButtonHelp;
*/
//	virtual BOOL OnInitDialog();
//	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void FinishDialog(int result);

//	virtual void DoDataExchange(CDataExchange* pDX);
//    virtual void DoPaint(const RECT& rcPaint, CDC& dc);

//	afx_msg void OnOnTop();
//	DECLARE_MESSAGE_MAP()

//	CRect m_dividerRect;
//	COLORREF m_dividerColor;

	TakionSettingCommands* m_takionSettingCommands;
	TakionSettingLink* m_takionSettingLink;

//For handling Views
	int m_locationX;
	int m_locationY;
	bool m_locationInitializedFromFile;
	bool m_locationOnTop;
};

class TGUI_API TakionTool : public TakionResizableWnd
{
friend class ToolSet;
friend class TakionMainWnd;
friend class SecurityTitleCollection;
public:
	virtual ~TakionTool();
	virtual bool CreateTakionWnd(const CRect* rect, bool adjustToScreen);
	virtual const Account* GetCurrentAccount() const;
	virtual bool isTimeFrameInMinutes() const{return true;}
	virtual unsigned short GetTimeFrameInSeconds() const{return 0;}

	static const unsigned int graphicsCaseAdd =
#ifdef SECONDARY_ROWS
		1;
#else
		0;
#endif

	virtual void SetToDrawLine(unsigned char drawType){}
	virtual void ClearDrawType(unsigned char drawType, unsigned char historical){}//1 historical, 2 today, 3 both

	virtual bool ShowOrderDialog(CustomDialogOrderCommand* command){return true;}
	virtual const Price& GetEcnBid() const{return Price::priceZero;}
	virtual const Price& GetEcnAsk() const{return Price::priceZero;}
	const Price& GetEcnQuote(const bool& bid) const{return bid ? GetEcnBid() : GetEcnAsk();}
	virtual const Quote* GetFirstQuote(bool bid) const{return NULL;}
	virtual unsigned int GetBorrowSize() const{return 0;}
	virtual unsigned int GetTierSize() const{return 0;}

	static const unsigned int roundLot;// = 100
	virtual const unsigned int& GetStockRoundLot() const{return roundLot;}

	virtual const Price& GetLevel1Bid() const{return Price::priceZero;}
	virtual const Price& GetLevel1Ask() const{return Price::priceZero;}
	virtual const Price& GetLevel2Bid() const{return Price::priceZero;}
	virtual const Price& GetLevel2Ask() const{return Price::priceZero;}
//	virtual const Price& GetLevel1Quote(bool side) const{return Price::priceZero;}
//	virtual const Price& GetLevel2Quote(bool side) const{return Price::priceZero;}
	virtual const Price& GetImbExNear() const{return Price::priceZero;}
	const Price& GetLevel1Quote(const bool& bid) const{return bid ? GetLevel1Bid() : GetLevel1Ask();}
	const Price& GetLevel2Quote(const bool& bid) const{return bid ? GetLevel2Bid() : GetLevel2Ask();}

	virtual const Price& GetLuldLow() const{return Price::priceZero;}
	virtual const Price& GetLuldHigh() const{return Price::priceZero;}
	const Price& GetLuld(const bool& bid) const{return bid ? GetLuldLow() : GetLuldHigh();}

	virtual int GetPositionSize() const{return 0;}
	virtual bool isDialogOrderBarVisible() const{return false;}
	virtual bool HasPrints() const{return false;}
	virtual bool isBasket() const{return false;}
	virtual bool GetOrderModuleLimitPriceOffset(SignedPrice& offset) const{return false;}
	virtual bool GetOrderModuleLimitPrice(Price& price) const{return false;}

	virtual void ExpandSelectedRows(const bool expand){}
	virtual void ExpandAllRows(const bool expand){}
	virtual void ToggleExpandedSelectedRow(){}

	virtual void RemoveSelectedStocks(){}
	virtual void RemoveActiveStock(){}

	virtual void CancelSelectedOrder(){}
	virtual bool CancelSelectedAlert(){return false;}
	virtual void ExecuteSelectedOrderInSimulation(){}

	typedef CMap<unsigned __int64, const unsigned __int64&, unsigned char, const unsigned char&> StockBasketMap;
	virtual bool FillCommandToolBasketSymbols(StockBasketMap& stockBasketMap) const{return false;}

	virtual const StockBasketMap* GetCommandToolBasketSymbolsPtr() const{return NULL;}
//	virtual void SetCommandToolBasketSymbols(const StockBasketMap& stockBasketMap){}
	virtual void SetCommandToolStockBasketMap(const StockBasketMap* stockBasketMap){}
	
	virtual void StockAddedToCommandToolBasket(const unsigned __int64& symbol){}
	virtual void StockRemovedFromCommandToolBasket(const unsigned __int64& symbol){}
	virtual void StocksClearedFromCommandToolBasket(){}

	int GetTitleBottom() const{return m_titleResizor.GetRect().top - m_clientRect.top;}
	virtual CMenu* GetSysMenu() const;
	virtual const char* GetSettingsTabPath(const CPoint& point) const override;
	virtual unsigned int GetWorkspace() const{return m_workspace;}
	void SetWorkspace(unsigned int workspace){m_workspace = workspace;}
	static const unsigned int maxWorkspace = 100;
	virtual unsigned int GetLayer() const{return m_workspace >= maxWorkspace ? m_workspace - maxWorkspace : 0xFFFFFFFF;}
	const bool& isPinned() const{return m_pinned;}
	void SetPinned(bool pinned);

	const bool& isOnTop() const{return m_onTop;}
	void SetOnTop(bool onTop, bool refresh);

	void UpdateLocation(const CRect& rect)
	{
		m_frameRect = rect;
		if(m_hWnd)
		{
			::SetWindowPos(m_hWnd, NULL, m_frameRect.left, m_frameRect.top, m_frameRect.Width(), m_frameRect.Height(), SWP_NOZORDER|SWP_NOCOPYBITS);
		}
	}

	const bool& isVisible() const{return m_visible;}

	virtual bool isHidden() const{return m_hidden;}

	virtual void PropagateTempTierSize(unsigned int tierSize){}

	virtual bool CanLinkToSpecificExternalWindow(HWND externalWindow, const LinkExternal* linkExternal) const{return false;}

	virtual bool isSaveableToLayout() const{return !m_extensionTool;}
	virtual void OnSecurityDoubleClicked(const std::string& symbol){}
#ifndef TAKION_NO_OPTIONS
	virtual bool isOptionView() const{return false;}
	virtual void OnOptionDoubleClicked(const Security* option){}
	virtual void SetStockOptionByParams(const unsigned __int64& numericSymbol, const OptionKey& optionKey, unsigned char basket, bool force){}
	virtual void SetStockOption(const Security* security, unsigned char basket, bool force){}
	virtual unsigned int GetContractSize() const{return 1;}
#endif

	static bool YesNoBelongs(const unsigned int& filter, const bool& yes)
	{
		return (filter & (1 << (yes ? YNM_YES : YNM_NO))) != 0;
	}
/*
	void SetUnderlierMarketSorterConnected(bool connected);
	void SetUnderlierMarketSorterLoaded(bool loaded);
*/
	virtual void UpdateTitleLabelGraphics(const Graphics* graphics);
	virtual void UpdateTitleValueGraphics(const Graphics* graphics);

	virtual bool isCommandToolDefaultExternalLink() const{return false;}
	virtual unsigned __int64 GetExternalLinkMask() const{return 0;}
	virtual const char* GetStringSymbolPtr(unsigned char& basket) const{basket = EST_STOCK; return NULL;}
	virtual bool GetLastSecuritySymbol(std::string& symbol) const{return false;}
	virtual void GetAdditionalTitleInfo(std::string& text) const{}
	virtual void AppendWindowMenuInfo(std::string& menuText) const{}
//	virtual Security* GetSecurity(){return NULL;}
	virtual const Security* GetSecurity() const{return NULL;}
	virtual const Position* GetPosition() const{return NULL;}
#ifndef TAKION_NO_OPTIONS
	virtual const Security* GetUnderlierSecurity() const{return NULL;}
#endif
	virtual void SetOneEcnBookQuoteFilter(unsigned int filter, bool on){}
	virtual void ToggleOneEcnBookQuoteFilter(unsigned int filter){}

	virtual void CloseOrderBoxIfDisplayed(){}
	virtual bool GetCommandToolObjects(bool& basket, std::string& symbol, const Security*& security, const Account*& account, const Position*& position) const
	{
		basket = false;
		symbol.clear();
		security = NULL;
		account = NULL;
		position = NULL;
		return false;
	}

	virtual bool AreAllRowsSelected() const{return false;}
	virtual void SelectAllRows(bool forceMultisel){}
	virtual bool UnselectAllRows(bool repaint){return false;}
	void ToggleSelectAllRows()
	{
		if(AreAllRowsSelected())UnselectAllRows(true);
		else SelectAllRows(true);
	}

	void IncludeActiveSecurity();
	void ExcludeActiveSecurity();
	void UnIncludeActiveSecurity();
	void UnExcludeActiveSecurity();

	void AddActiveSecurityToBasket();
	void RemoveActiveSecurityFromBasket();

	virtual bool CharStartsEnteringSymbol(unsigned char key, unsigned char modifier) const{return false;}

	virtual void IncludeSecurity(const Security* security){}
	virtual void ExcludeSecurity(const Security* security){}
	virtual void UnIncludeSecurity(const Security* security){}
	virtual void UnExcludeSecurity(const Security* security){}

	virtual void AddSecurityToBasket(const Security* security){}
	virtual void RemoveSecurityFromBasket(const Security* security){}

	virtual void ScrollLine(bool up, unsigned char modifier){}
	virtual void ScrollPage(bool up, unsigned char modifier){}
	virtual void ScrollToExtreme(bool up, unsigned char modifier){}
	virtual void ScrollHorizontally(bool left, unsigned char modifier){}
	virtual void CopySelection() const{}

	virtual const void* GetGraphicsTabInitInfo(const CPoint& point) const override;
	virtual bool isFontMenu(const CPoint& point) const{return true;}
	virtual bool isColorMenu(const CPoint& point) const{return true;}
	virtual bool HasMaxFontSize(const CPoint& point) const{return false;}
	virtual bool GetCurrentFontParams(std::string& title, FontDescription& fontDescription, FontDescription& fontDescriptionCustom, bool& custom, unsigned int& id) const override;
	virtual void SetCustomFont(const FontDescription& fontDescription, bool custom, unsigned int id) override;
	virtual void SetCustomColors(const Graphics* graphics, GraphicsColorCollection* colorCollection, const COLORREF* colors, unsigned short colorCount, bool custom, const FilterStringAsNumberArray& title) override;//, const FilterStringAsNumberArray& title, unsigned int colorId) override;

	virtual bool UpdateSecurityTitleValueGraphicsColorsCustom(const GraphicsColorCollection* colorCollection);
	virtual bool UpdateSecurityTitleValueGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL);

	virtual bool UpdateSecurityTitleLabelGraphicsColorsCustom(const GraphicsColorCollection* colorCollection);
	virtual bool UpdateSecurityTitleLabelGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL);

	void UpdateTitleValueCollection();
	void UpdateAlignTitleValues();

	void UpdateSecurityTitleValueAndLabelColors();

	bool isToolCopyCompatible() const;
	bool PasteFromCopy();//restore from string TakionMainWnd::m_toolCopy
	virtual void toString(std::string& str, unsigned int contentModifier) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual void fromScratch() override;
	virtual const char* GetToolId() const = 0;
	virtual const char* GetWindowName() const override{return GetToolId();}
	virtual bool isTool() const override{return true;}
	virtual const unsigned int& GetToolOrdinal() const override{return m_ordinal;}
	const bool& isActiveTool() const{return m_activeTool;}
	void SetActiveTool(bool active);
	const bool& isActiveCommandTool() const{return m_activeCommandTool;}
	void SetActiveCommandTool(bool active);
	const bool& isDefaultCommandTool() const{return m_defaultCommandTool;}
	void SetDefaultCommandTool(bool defaultCommandTool);
	const bool& isMaximized() const{return m_maximized;}
	virtual void DragWindow(int x, int y);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
//	virtual bool ProcessKeyDown(unsigned char key, unsigned char modifier, bool repeat){return false;}
	virtual const CRect& GetNormalRect() const{return m_maximized ? m_restoreRect : m_frameRect;}
	void RepaintTitle() const{if(m_hWnd)::InvalidateRect(m_hWnd, &m_titleRect, FALSE);}

	virtual void CurrentAccountChanged(const Account* currentAccount);
	virtual void CurrentAccountLoaded(){}
	virtual void CurrentAccountConstraintsLoaded();
	virtual void AccountLoaded(const Account* account){}
	virtual void AllAccountsLoaded(){}
	virtual void LoggedToExecutor(){}

	virtual void AccountDeleted(const Account* account){}
	virtual void AllAccountsDeleted(){}
	virtual void NewAccount(const Account* account){}
	virtual void RepaintDefaultOnlyTradingAllowed(){}

	virtual void ConnectionDisconnected(unsigned int ipAddress, unsigned short port, unsigned int ipBindAddress, unsigned short bindPort, unsigned char connectionType, const char* connectionName){}
	virtual void ConnectionConnected(unsigned int ipAddress, unsigned short port, unsigned int ipBindAddress, unsigned short bindPort, unsigned char connectionType, const char* connectionName){}
	virtual void ConnectionLogged(unsigned int connectionType){}

	virtual bool isCommandTool() const{return false;}
	virtual void PrependLinkMenuItems(CMenu& popupMenu){}
	virtual TakionTool* Clone() const = 0;
	void GetCloneRect(CRect& rect) const
	{
		rect.left = m_frameRect.left + m_clientRect.left + m_titleHeight;
		rect.top = m_frameRect.top + m_clientRect.top;// + m_titleHeight;
		rect.right = rect.left + m_frameRect.Width();
		rect.bottom = rect.top + m_frameRect.Height();
	}
	virtual void GetEntryPoint(CPoint& point) const
	{
		point.x = m_frameRect.left + m_borderWidth;
		point.y = m_frameRect.top + m_borderWidth;
	}
	virtual int GetInitialWidth() const;
	virtual int GetInitialHeight() const;

	virtual void UpdateShowTooltips();

//	virtual unsigned int GetCommandToolOrdinal() const{return 0xFFFFFFFF;}
	virtual bool isTabbable() const{return false;}
//	virtual void SetCommandToolOrdinal(unsigned int ordinal){}
	virtual void DecrementCommandToolOrdinal(){}
	void DecrementCommandToolLinkedOrdinal();
	virtual void AddToSpecificToolCollection(){}
	virtual void UpdateGraphics();

	virtual void UpdateTitleGraphics(const Graphics* graphics);
	bool UpdateTitleGraphicsFont(const Graphics* graphics);

	virtual bool UpdateTitleGraphicsColorsCustom(const GraphicsColorCollection* colorCollection);
	virtual bool UpdateTitleGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL);

	virtual void UpdateBorderGraphics(const Graphics* graphics);

	bool UpdateBorderGraphicsColorsCustom(const GraphicsColorCollection* colorCollection);
	bool UpdateBorderGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL);

	virtual std::string GetTitleGraphicsName() const{return std::string("Title");}

	COLORREF GetLightColorActive() const{return m_lightColorActive;}
	COLORREF GetDarkColorActive() const{return m_darkColorActive;}

	virtual void DoMaximize();

	virtual void ExecuteDebuggingCommand(){}//For debuggingOnly

	virtual void EstablishAllExternalLinks(bool force){}
	virtual bool ExternalLinkEstablished(LinkExternal* link){return true;}

	virtual void SetEquityNumericSymbol(const unsigned __int64& symbol, unsigned char basket, bool force, bool addToStockChain){SetEquitySymbol((const char*)&symbol, basket, force, addToStockChain);}
	virtual void SetEquitySymbol(const char* symbol, unsigned char basket, bool force, bool addToStockChain){}

	virtual bool isRemoved() const{return m_removed;}

	virtual bool CanDragClient(UINT nFlags, CPoint point) const;
	virtual bool CanLink() const{return false;}
	virtual void AddLinkedWnd(TakionTool* tool){}
	virtual void RemoveLinkedWnd(TakionTool* tool){}

	virtual bool CanLinkToOtherTakion() const{return CanLink();}

	const bool& isLinked() const{return m_linked;}
	const TakionTool* GetCommandToolLinked() const{return m_commandToolLinked;}
	const unsigned int& GetCommandToolLinkedOrdinal() const{return m_commandToolLinkedOrdinal;}
	void SetLinked(bool linked, TakionTool* mm);
//	unsigned char GetDraggingClientStatus() const{return m_draggingClientStatus;}//0 - not dragging, 1 - mouse button down, waiting for it to move by some value, 2 - dragging
	void ToggleLinked(TakionTool* mm);
	virtual void OnUnlink(){}
	const CBitmap* GetBitmap() const{return m_bitmap;}

	virtual void CommandRemoved(Command* command)
	{
		if(m_symbolToActiveCommandWindowCommand == command)m_symbolToActiveCommandWindowCommand = NULL;
		if(m_activateWindowCommand == command)m_activateWindowCommand = NULL;
	}

	ActivateWindowCommand* GetActivateWindowCommand(){return m_activateWindowCommand;}
	void SetActivateWindowCommand(ActivateWindowCommand* command){m_activateWindowCommand = command;}

	virtual bool HasLastSymbolCommands() const{return false;}
	SymbolToActiveCommandWindowCommand* GetSymbolToActiveCommandWindowCommand(){return m_symbolToActiveCommandWindowCommand;}
	void SetSymbolToActiveCommandWindowCommand(SymbolToActiveCommandWindowCommand* command){m_symbolToActiveCommandWindowCommand = command;}

	virtual bool isIncludeStockActive() const{return false;}
	virtual void SetIncludeStockActive(bool active){}

	virtual bool isExcludeStockActive() const{return false;}
	virtual void SetExcludeStockActive(bool active){}
	virtual int GetTitleMaxBottom(){return m_clientRect.bottom;}

	virtual unsigned char GetEsignalLinkGroup() const{return 0;}
	virtual unsigned char GetBloombergLinkGroup() const{return 0;}
	virtual bool SetQuotePage(unsigned int page, bool updateQuotes){return false;}
	virtual bool IncrementQuotePage(bool decrement, unsigned int count = 1){return false;}
//	virtual bool PasteBasketFromClipboard(){return false;}
	virtual bool PasteStocksFromClipboard(bool replace){return false;}
	virtual void CopySelectedStocksToClipboard() const{}
	virtual void CopyAllStocksToClipboard() const{}
	virtual void CreateNewBasketTradingWindow() const{}

	virtual void CopyRowsToClipboard(bool selected) const{}

	virtual void SelectPositionRows(unsigned int filter){}//PositionStatus

	virtual bool CanClearSymbols() const{return false;}
	virtual void ClearSymbols(){}

	virtual bool CanShowTime() const{return false;}
	virtual bool isShowTime() const{return false;}
	virtual void ToggleShowTime(){}

	virtual bool CanShowPrefixOnly() const{return false;}
	virtual bool isShowPrefixOnly() const{return false;}
	virtual void TogglePrefixOnly(){}

	virtual bool CanShowRowCount() const{return false;}
	virtual bool isShowRowCount() const{return false;}
	virtual void ToggleRowCount(){}

	virtual bool CanShowTotalCount() const{return false;}
	virtual bool isShowTotalCount() const{return false;}
	virtual void ToggleTotalCount(){}

	virtual void UnuseUnselectedColumns(){}
#ifdef SECONDARY_ROWS
	virtual void UnuseUnselectedSecondaryColumns(){}
#endif
	virtual void OnKeyMenu(){}
	virtual void AltKeyDown(bool up){}

	unsigned int GetNextMenuId() const;
	const bool& isExtensionTool() const{return m_extensionTool;}
	virtual void ClearConfig();

	const unsigned char& GetLinkGroup() const{return m_linkGroup;}//For Other Takion sending a symbol to this Takion
	void SetLinkGroup(unsigned char linkGroup);

	void InvalidateTopRect() const{if(m_hWnd)::InvalidateRect(m_hWnd, &m_topRect, FALSE);}
	const int& GetTopHeight() const{return m_topHeight;}
	const CRect& GetTopRect() const{return m_topRect;}
	virtual bool isAffectedByOddLotPrints() const{return false;}
	virtual bool isUseOddLotPrints() const{return m_useOddLotPrints;}
	void SetUseOddLotPrints(bool useOddLotPrints)
	{
		if(isAffectedByOddLotPrints() && m_useOddLotPrints != useOddLotPrints)
		{
			m_useOddLotPrints = useOddLotPrints;
			UseOddLotPrintsChanged();
		}
	}

	enum InventoryAction : unsigned char
	{
		IA_REMOVE,
		IA_UNUSE,
		IA_USE,
		IA_POSITION,//Inventory equal to the current position size

		IA_Count
	};
	const InventoryMode& GetInventoryMode() const{return m_inventoryMode;}//0-non inventory; 1-inventory; 2 - default (same as in the main bar
	const bool& isInventoryView() const{return m_inventoryView;}
	virtual bool hasInventoryView() const{return false;}
	virtual bool AddToToolCollection() override;
	virtual const void* GetSettingsTabInitInfo(const CPoint& point) const;

	virtual void SecurityNoteAdded(const unsigned __int64& symbol, const std::string& note){}
	virtual void SecurityNoteRemoved(const unsigned __int64& symbol){}
	virtual void SecurityNotesCleared(){}
	virtual void SecurityNotesClearDone(){}
	virtual void SecurityNotesReplaced(const std::map<unsigned __int64, std::string, lessUIntAsStr<unsigned __int64> >& newNotes, bool clearOld){}
	virtual void SecurityNotesReplacementDone(){}

	void ToggleInventoryMode(const bool& reverse);

	virtual void ExternalManualLinkRemoved(LinkExternal* link){}

	virtual void UpdateColorsCustom(const GraphicsColorCollection* colorCollection);
//	virtual unsigned int GetGraphicsColorCollectionCount() const{return 2;}
	virtual const Graphics* GetGraphicsAt(unsigned int graphicsOrdinal) const;

	typedef std::map<FilterStringAsNumberArray, GraphicsColorCollection*> GraphicsColorMap;
	const GraphicsColorCollection* FindGraphicsColorCollection(const FilterStringAsNumberArray& name) const
	{
		GraphicsColorMap::const_iterator found = m_graphicsColorMap.find(name);
		return found == m_graphicsColorMapEnd ? NULL : found->second;
	}

	GraphicsColorCollection* FindGraphicsColorCollection(const FilterStringAsNumberArray& name)
	{
		GraphicsColorMap::iterator found = m_graphicsColorMap.find(name);
		return found == m_graphicsColorMapEnd ? NULL : found->second;
	}

	const GraphicsColorCollection* FindGraphicsColorCollection(const std::string& name) const
	{
		return FindGraphicsColorCollection(FilterStringAsNumberArray(name));
	}

	GraphicsColorCollection* FindGraphicsColorCollection(const std::string& name)
	{
		return FindGraphicsColorCollection(FilterStringAsNumberArray(name));
	}

	const char* GetGraphicsName(unsigned int graphicsOrdinal) const
	{
		const Graphics* graphics = GetGraphicsAt(graphicsOrdinal);
		return graphics ? graphics->GetName() : NULL;
	}
	unsigned int GetGraphicsColorCount(const unsigned int& graphicsOrdinal) const
	{
		const Graphics* graphics = GetGraphicsAt(graphicsOrdinal);
		return graphics ? graphics->GetColorCount() : 0;
//		return graphicsOrdinal < m_graphicsColorCollectionCount ? m_graphicsColorCollection[graphicsOrdinal].GetCount() : 0;
	}
	const NamedColor* GetGraphicsNamedColorAt(unsigned int graphicsOrdinal, unsigned int at) const
	{
		const Graphics* graphics = GetGraphicsAt(graphicsOrdinal);
		return graphics ? graphics->GetColor(at) : NULL;
	}
	const char* GetGraphicsColorNameAt(unsigned int graphicsOrdinal, unsigned int at) const
	{
		const NamedColor* namedColor = GetGraphicsNamedColorAt(graphicsOrdinal, at);
		return namedColor ? namedColor->GetName() : NULL;
	}
	const COLORREF* GetGraphicsColorAt(const unsigned int& graphicsOrdinal, const unsigned int& at) const
	{
		const NamedColor* namedColor = GetGraphicsNamedColorAt(graphicsOrdinal, at);
		return namedColor ? &namedColor->GetColor() : NULL;
//		return graphicsOrdinal < m_graphicsColorCollectionCount ? m_graphicsColorCollection[graphicsOrdinal].GetColorAt(at) : NULL;
	}
//used in ToolMarketMaker
	typedef StrAsNumberArray<size_t, 24 / sizeof(size_t)> NamedValueId;
	typedef std::vector<NamedValueId> NamedValueIdVector;
	typedef std::vector<NamedValueIdVector> NamedValueIdVectorVector;

	virtual bool isClipChildren() const{return false;}

	virtual void BeforeDestroy() override;

	virtual bool HasNamedFiltering() const{return false;}
	virtual void NamedFilterAdded(SymbolFilter* filter, const std::string& name){}
	virtual void NamedFilterChanged(SymbolFilter* filter){}
	virtual void NamedFilterRenamed(SymbolFilter* filter, const std::string& name){}
	virtual void NamedFilterDeleted(SymbolFilter* filter){}
	virtual void AllNamedFiltersDeleted(){}
	virtual void RefreshNamedFilters(){}
protected:
	TakionTool(const CBitmap* bitmap,
		unsigned int workspace,
		bool pinned = false,
		int minVisibleSize = 15,
		int minWidth = 100,
		int maxWidth = 0,
		int minHeight = 50,
		int maxHeight = 0,
		int minBorderWidth = 2,
		int maxBorderWidth = 2,
		const char* className = "TakionTool",
		int minTitleHeight = 0,
		int maxTitleHeight = 15,
		int titleHeight = 15);
//		bool visible);

	virtual void ToolAdded(){}
	virtual void ActiveToolAppActivated(bool activated);
	virtual void ActiveToolMainWndActivated(bool activated){}

	virtual void AfterCloning() override;
	virtual void AfterPasting() override{ToolAdded();}

	virtual void SetFrameRect(const CRect& rect) override
	{
		bool removed = RemoveFromVisibleTools();
		m_restoreRect = m_frameRect = rect;
		if(m_maximized)
		{
			SetMaximizedRect();
		}
		if(removed)
		{
			AddToVisibleTools();
		}
	}

	void SetMarketSorterConnected(bool connected);
	void SetMarketSorterLoaded(bool loaded);

	virtual void OnLinkChanged(){}

	virtual void UseOddLotPrintsChanged(){}
	bool SetHidden(bool hidden);
	virtual void OnHidden(){}
	virtual void NextDayStarted(){}
	virtual void SystemTimeChanged(unsigned int prevMillisecond, unsigned int currentMillisecond, unsigned int prevDate, unsigned int todaysDate){}
//	virtual void ClearConfig(){Unlink();}

	virtual void WriteInitialLayoutInfoToString(std::string& str, unsigned int contentModifier) const{}
	virtual void ReadInitialLayoutInfoFromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier){}

	virtual void OnMouseForcedReleaseCapture() override;

	virtual void LinkToSpecificExternalWindowSet(LinkExternal* link){}
	virtual void AddManualExternalLink(LinkExternal* link){}

	void UpdateCaptionRect(bool invalidateTitleResizor);

	void UpdateLink();
	void UpdateCommandToolLink();
	void DoSetLinked(bool linked, TakionTool* mm);
	virtual void Unlink();

	virtual void ScrollOnTitleResize(int scrollAmount);

//	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) override;
	virtual bool ProcessKeyDown(unsigned char key, unsigned char modifier, bool repeat, TakionFrame* fromWindow) override;

	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;

//	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
//	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
//	afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnNcLButtonDblClk(UINT nHitTest, CPoint point);
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu);
	afx_msg LRESULT OnCanLinkRequest(WPARAM wparam, LPARAM error);
	afx_msg LRESULT OnMakeActive(WPARAM nState, LPARAM lParam);
	DECLARE_MESSAGE_MAP()

	virtual void AddMenuItems(CMenu& menu) override;
	virtual void PostAddMenuItems(CMenu& menu) override;
	virtual void AddInventoryMenuItems(CMenu& popupMenu);

	virtual void AddRowPropertiesMenuItems(CMenu& popupMenu);
	virtual void PostAddRowPropertiesMenuItems(CMenu& popupMenu);

	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;

	virtual bool ResizeMouseArea(const CPoint& point, bool locked) override;
	virtual unsigned char UpdateResizeCursor(const CPoint& point, bool locked) override;

	virtual void MouseLeft() override;
	virtual bool ClientSetCursor() override;
	virtual void ToolShown(){}
	virtual void DoPaint(const RECT& rcPaint, CDC& dc);
	virtual void DoSize(UINT nType, int cx, int cy, int oldX, int oldY);
	virtual void OnSuccessfulCreate();
	virtual void UpdateTitleRects();
	virtual void DoPaintTitle(const RECT& interRect, CDC& dc);
	virtual void DoPaintClient(const RECT& interRect, CDC& dc);
	virtual void DoActivate(UINT state, bool minimized) override;//, CWnd* pWndOther) override;
//	virtual bool ClientSetCursor(){return false;}
	virtual void OnSetActiveTool(){}
	virtual void OnSetActiveCommandTool(){}
	virtual void OnSetDefaultCommandTool(){}

//	virtual void DoRestore();

	virtual void SizeHorizontal(int cx, int cy, int oldX, int oldY);
	virtual void SizeVertical(int cx, int cy, int oldX, int oldY);
	virtual bool ResizeBorder(int borderWidth);

	virtual bool RemoveFromVisibleTools();
	virtual void AddToVisibleTools();

	virtual void ActiveStockChosen(const char* symbol){}
	bool AddActiveStockMenuItem(CMenu& menu, bool separatorBefore, bool separatorAfter);

	void SetMaximizedRect();

	int m_minTitleHeight;
	int m_maxTitleHeight;
	int m_titleHeight;

	int m_minBorderWidth;
	int m_maxBorderWidth;

	int m_activeStockMenuWidth;

	VerticalResizor m_titleResizor;

	virtual void OnTitleResize();

	virtual void OnTopResized(){}
	virtual void OnTopResizing(int scrollAmount){}
	void CreateTopResizor(int height, int width, int cursorOffsetTop, int cursorOffsetBottom, COLORREF color);
	void DestroyTopResizor();
	bool UpdateTopResizor(int& prevTop, int& prevHeight);
	void UpdateTopResizorAndCollection(bool horizontalChanged);
	int m_topMinHeight;
//	int m_topMaxHeight;
	int m_topHeight;
	CRect m_topRect;
	VerticalResizor* m_topResizor;

	void CreateSecurityTitleCollection(const TakionConfig::StringVectorVector& values);
	void DestroySecurityTitleCollection();
	void OnSecurityRefreshed();
	void OnSecurityLevel1Updated();
	void OnSecurityLevel2Updated();
	void OnPositionUpdated();
	void OnSecurityInvalid(const unsigned __int64& symbol);
	void OnSecurityDeleted(const Security* seurity);
	SecurityTitleCollection* m_securityTitleCollection;

	virtual void OnLevel1Updated(){}
	virtual void OnLevel2Updated(){}

	COLORREF m_lightColorActive;
	COLORREF m_darkColorActive;

	unsigned int m_workspace;
	bool m_pinned;
	bool m_visible;
	bool m_onTop;

	bool m_hidden;

	bool m_useOddLotPrints;

	bool m_activeTool;
	bool m_activeCommandTool;
	bool m_defaultCommandTool;

	CRect m_restoreRect;
	bool m_maximized;

	unsigned int m_ordinal;

	bool m_removed;

	bool m_linked;

	bool m_extensionTool;

	unsigned char m_linkGroup;//For Other Takion sending a symbol to this Takion

	TakionTool* m_commandToolLinked;
	unsigned int m_commandToolLinkedOrdinal;

	virtual void ClientBeginsDragging(){}
	void SetClientDragCursor(UINT nFlags, CPoint point);
	void DoSetClientDragCursor(HCURSOR cursor);
	unsigned char m_draggingClientStatus;//0 - not dragging, 1 - mouse button down, waiting for it to move by some value, 2 - dragging
	int m_dragClientInitialX;
	int m_dragClientInitialY;
	HWND m_draggingClientOver;
	HWND m_draggingTakionClientOver;
	HWND m_linkExternalClientOver;
	LinkExternal* m_linkExternalOver;

	HCURSOR m_draggingCursor;
	const CBitmap* m_bitmap;
	SymbolToActiveCommandWindowCommand* m_symbolToActiveCommandWindowCommand;
	ActivateWindowCommand* m_activateWindowCommand;

	void AddInventoryModeMenuItems(CMenu& popupMenu);
	virtual void UpdateInventoryView(){}
	void SetInventoryMode(const InventoryMode inventoryMode);

	InventoryMode m_inventoryMode;//0-IM_NON_INVENTORY; 1-IM_INVENTORY; 2 - IM_DEFAULT (same as in the main bar)
	bool m_inventoryView;

private:
	void SetInventoryView(const bool inventoryView);

	void CreateGraphicsColorCollection();
	void ClearGraphicsColorMap();
	GraphicsColorMap m_graphicsColorMap;
	GraphicsColorMap::const_iterator m_graphicsColorMapEnd;
//	GraphicsColorCollection* m_graphicsColorCollection;
//	unsigned int m_graphicsColorCollectionCount;
};

class TGUI_API ListBoxTakionTool : public ListBoxFit
{
friend class DialogListTakionTool;
public:
	ListBoxTakionTool(DialogList* parentDlg, bool rbuttonSelection = true, bool rbuttonMenu = true, bool draggable = false, bool useBoldItem = true);
	virtual const char* GetItemName(const void* item) const override;
	virtual int Compare(const void* item1, const void* item2) const override;
//	virtual void GetDrawItemRectOffsets(int& left, int& right, int itemHeight = 0) const;
	virtual void GetDrawItemRect(const DRAWITEMSTRUCT* lpDrawItemStruct, CRect& drawItemRect) const override;
	virtual COLORREF GetStringColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override;
	virtual COLORREF GetSelectedBkColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override;
	virtual COLORREF GetBkColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override;
	const COLORREF& GetColorVisible() const{return m_colorVisible;}
	const COLORREF& GetColorHidden() const{return m_colorHidden;}
	virtual void GetItemText(const void* item, std::string& text) const override
	{
//		text = GetItemName(item);
		const TakionTool* tool = (const TakionTool*)item;
		text = tool->GetToolId();
		tool->AppendWindowMenuInfo(text);
	}
	TakionTool* GetSelectedTool()
	{
		int sel = GetCurSel();
		return sel >= 0 ? (TakionTool*)GetItemDataPtr(sel) : NULL;
	}
	const TakionTool* GetSelectedTool() const
	{
		int sel = GetCurSel();
		return sel >= 0 ? (const TakionTool*)GetItemDataPtr(sel) : NULL;
	}
	void ActivateSelectedTool(const bool& corner = false);
	void CornerSelectedTool(const bool& activate = true);
	void CopySelectedTool() const;
	void PinSelectedTool();
	void SetSelectedToolOnTop();
	void LockSelectedTool();
	void SelectedToolShowTime();
	void SelectedToolPrefixOnly();
	void SelectedToolRowCount();
	void SelectedToolTotalCount();
	void HideSelectedTool();
	void MaximizeSelectedTool();
	void CloseSelectedTool();

	void PretendNotDisplayed() const
	{
		if(m_parentDlg)m_parentDlg->PretendNotDisplayed();//Prevents the dialog box from getting closed on Deactivate (Loss of Focus)
	}
	void UnpretendNotDisplayed() const
	{
		if(m_parentDlg)m_parentDlg->UnpretendNotDisplayed();
	}
	void SetActive()
	{
		if(m_parentDlg)
		{
			if(m_parentDlg->m_hWnd)::SetActiveWindow(m_parentDlg->m_hWnd);
		}
		else if(m_hWnd)
		{
			::SetFocus(m_hWnd);
		}
	}
	void UpdateBoldItem(bool resize);
protected:
	virtual void DoDrawItem(const DRAWITEMSTRUCT* lpDrawItemStruct, const CRect& drawItemRect) override;
	virtual void OnItemAdded(void* item, unsigned int at, bool checked) override;
	virtual void BeforeItemDeleted(unsigned int at, bool checked) override;
	virtual void AfterItemsCleared() override;
	virtual void AfterItemDeleted(unsigned int at, bool failed, bool checked) override;
	void UpdateDimensions();

	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;
	virtual void AddMenuItems(CMenu& menu) override;
	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;

//	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
//	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
//	DECLARE_MESSAGE_MAP()

	DialogList* m_parentDlg;
	COLORREF m_colorVisible;
	COLORREF m_colorHidden;
};

class TGUI_API DialogListTakionTool : public DialogList
{
public:
	DialogListTakionTool(TakionMainWnd* mainWnd, CWnd* parent, unsigned int maxVisibleItemtCount);//, bool sortAlphabetically);//, bool ownItems);// = 0, CWnd* receipient = NULL);
	const TakionTool* GetToolAt(int i) const;
	const TakionTool* GetSelectedTool() const;
	void Display(unsigned int code,
		bool rightButton,
		bool sortAlphabetically,
		const void* item,
		CWnd* parent,
		int x,
		int y,
		int w,
		int h,
		bool fastSelection,
		unsigned int maxVisibleItemCount = 0,
		CWnd* receipient = NULL,
		COLORREF bkColor = 0xFFFFFFFF,
		COLORREF selectionBkColor = 0xFFFFFFFF,
		COLORREF textColor = 0xFFFFFFFF,
		COLORREF selectionTextColor = 0xFFFFFFFF);
//	void* FindItemByName(const char* name) const;
//	int FindItemIndexByName(const char* name) const{return m_ListBoxAccount.FindItemByName(name);}

//	virtual bool NullItemOk() const{return true;}
	const int& GetListBoxItemWidth() const{return m_ListBoxTakionTool.GetMaxWidth();}
	const bool& isSortAlphabetically() const{return m_sortAlphabetically;}
//	void SetSortAlphabetically(const bool& sortAlphabetically){m_sortAlphabetically = sortAlphabetically;}
	virtual bool UpdateFrameRight() override;
	virtual void ItemDeleted(unsigned int at) override
	{
		if((unsigned int)m_ListBoxTakionTool.GetItemBold() == at)
		{
			m_item = NULL;
			m_ListBoxTakionTool.SetItemBold(-1);
		}
	}
	virtual bool CanShow() const override{return m_ListBoxTakionTool.GetItemCount() > 0;}
protected:
	virtual BOOL OnInitDialog();
	virtual void BeforeShow() override;
	virtual void FinishDialog(int result) override;
	virtual void Resize(bool widthChanged = true, bool heightChanged = true) override;

	virtual void BeforeCurrentItemSet(const void* itemToBeCurrent, unsigned char resize) override;
//	virtual void OnDisplay();
	ListBoxTakionTool m_ListBoxTakionTool;
	bool m_sortAlphabetically;
//	afx_msg void OnSelchangeItem();
//	DECLARE_MESSAGE_MAP()
};

////
class TGUI_API DialogPickNamedValue : public DialogPickItems
{
public:
	static bool AreVectorsSame(const TakionTool::NamedValueIdVector& valueVector, const TakionTool::NamedValueIdVector& valueVectorOther)
	{
		return U_SetsEqual(valueVector, valueVectorOther);
	}
protected:
	DialogPickNamedValue(MainMessageLoopWnd* mainWnd,
		int lbWidth, int hOffset, bool tooltips, bool removeByDragging, bool pickToSorted = false,
		bool toDestroyOnFocus = false,
		TakionFrame* receipient = NULL,
		CWnd* parent = NULL,
		const char* checkBoxCustomToolTip = NULL,
		const char* buttonDefaultToolTip = NULL):
		DialogPickItems(mainWnd,
			&m_ListBoxValuesAll,
			&m_ListBoxValuesSelected,
			lbWidth,
			hOffset,
			tooltips,
			removeByDragging,
			pickToSorted,
			toDestroyOnFocus,
			receipient,
			parent,
			checkBoxCustomToolTip,
			buttonDefaultToolTip),
		m_ListBoxValuesSelected(true)
	{
		m_ListBoxValuesSelected.AssignCursor(m_visualBase->GetCursorThrow());
		m_ListBoxValuesAll.AssignCursor(m_visualBase->GetCursorCopy());
	}

	ListBoxNamedValue m_ListBoxValuesAll;
	ListBoxNamedValue m_ListBoxValuesSelected;
};


class TGUI_API DialogPickNamedValueLevel1 : public DialogPickNamedValue
{
public:
	void FillVectorFromListBoxTo(TakionTool::NamedValueIdVector& valueVector) const;
	virtual void UpdateCurrentValueVector(unsigned int ctrlId, int itemOrdinalOld, int itemOrdinalNew) override;
	virtual TakionTool::NamedValueIdVector* GetValueVector(){return NULL;}
protected:
	DialogPickNamedValueLevel1(TakionMainWnd* mainWnd,
		int lbWidth, int hOffset, bool tooltips, bool removeByDragging, bool pickToSorted = false,
		bool toDestroyOnFocus = false,
		TakionFrame* receipient = NULL,
		CWnd* parent = NULL,
		const char* checkBoxCustomToolTip = NULL,
		const char* buttonDefaultToolTip = NULL);
	void FillListBoxToFromVector(const TakionTool::NamedValueIdVector& valueVector);
	virtual void DoFillListBoxFrom() override;
};

class TGUI_API DialogPickItemsLevel1 : public DialogPickNamedValueLevel1
{
public:
	DialogPickItemsLevel1(TakionMainWnd* mainWnd,
		int lbWidth, int hOffset, bool tooltips, bool removeByDragging, bool pickToSorted = false,
		bool toDestroyOnFocus = false,
		TakionFrame* receipient = NULL,
		CWnd* parent = NULL,
		const char* checkBoxCustomToolTip = NULL,
		const char* buttonDefaultToolTip = NULL);
	virtual bool isDefaultChanged() const override{return !AreVectorsSame(m_currentCustom ? m_customLevel1Tokens : m_defaultLevel1Tokens, m_defaultLevel1TokensOriginal);}
	virtual bool CheckModifiedCustom() const{return !AreVectorsSame(m_customLevel1Tokens, m_customLevel1TokensOriginal);}
	virtual bool CheckModifiedDefault() const{return !AreVectorsSame(m_defaultLevel1Tokens, m_defaultLevel1TokensOriginal);}
	virtual unsigned int GetApplyMessageId() const{return WM_USER + 202;}
	virtual TakionTool::NamedValueIdVector* GetValueVector() override{return m_currentCustom ? &m_customLevel1Tokens : &m_defaultLevel1Tokens;}

	const TakionTool::NamedValueIdVector& GetCustomLevel1Tokens() const{return m_customLevel1Tokens;}
	const TakionTool::NamedValueIdVector& GetDefaultLevel1Tokens() const{return m_defaultLevel1Tokens;}

	void Display(TakionFrame* receipient, unsigned int code, CWnd* parent, int x, int y, int w, int h, const TakionTool::NamedValueIdVector& customLevel1Tokens, const TakionTool::NamedValueIdVector& defaultLevel1Tokens, bool custom);
protected:
	virtual void ClearCustomValues() override{m_customLevel1Tokens.clear();}
	virtual void ClearDefaultValues() override{m_defaultLevel1Tokens.clear();}
	virtual void ResetCustomValues() override{m_customLevel1Tokens = m_customLevel1TokensOriginal;}
	virtual void ResetDefaultValues() override{m_defaultLevel1Tokens = m_defaultLevel1TokensOriginal;}
	virtual void ApplyCustomValues() override{m_customLevel1TokensOriginal = m_customLevel1Tokens;}
	virtual void ApplyDefaultValues() override{m_defaultLevel1TokensOriginal = m_defaultLevel1Tokens;}

	virtual void MakeDefaultCustomValues() override{m_customLevel1Tokens = m_defaultLevel1TokensOriginal;}

	virtual BOOL OnInitDialog() override;
	virtual void FinishDialog(int result) override;
	virtual void DoFillListBoxTo() override;

	TakionTool::NamedValueIdVector m_customLevel1Tokens;
	TakionTool::NamedValueIdVector m_defaultLevel1Tokens;

	TakionTool::NamedValueIdVector m_customLevel1TokensOriginal;
	TakionTool::NamedValueIdVector m_defaultLevel1TokensOriginal;
};

class TGUI_API DialogPickItemsTitle : public DialogPickNamedValueLevel1
{
public:
	enum DialogPickIds
	{
		alignCheckBoxId = DialogPickItems::dialogPickIdsCount,
		staticLinesId,
		listBoxLinesId,

		dialogPickTitleIdsCount
	};
	DialogPickItemsTitle(TakionMainWnd* mainWnd,
		int lbWidth, int hOffset, bool tooltips, bool removeByDragging, bool pickToSorted = false,
		bool toDestroyOnFocus = false,
		TakionFrame* receipient = NULL,
		CWnd* parent = NULL,
		const char* checkBoxCustomToolTip = NULL,
		const char* buttonDefaultToolTip = NULL);
	virtual int GetAdditionalLbWidth() const{return m_lbLineWidth + m_gapH;}
	virtual bool ShouldRefillOnDefault() const override
	{
		const unsigned int ordinal = m_currentCustom ? m_ordinalCustom : m_ordinalDefault;
		const unsigned int size = (unsigned int)m_defaultTitleTokensOriginal.size();
		if(ordinal < size)
		{
			const TakionTool::NamedValueIdVector* valueVector = GetValueVectorConst();
			if(valueVector)
			{
				return !AreVectorsSame(*valueVector, m_defaultTitleTokensOriginal[ordinal]);
			}
		}
		return true;
	}
	virtual bool isDefaultChanged() const override{return !AreVectorsOfVectorsSame(m_currentCustom ? m_customTitleTokens : m_defaultTitleTokens, m_defaultTitleTokensOriginal);}
	static bool AreVectorsOfVectorsSame(const TakionTool::NamedValueIdVectorVector& vectorOfVectors, const TakionTool::NamedValueIdVectorVector& vectorOfVectorOthers)
	{
		if(vectorOfVectors.size() == vectorOfVectorOthers.size())
		{
			for(TakionTool::NamedValueIdVectorVector::const_iterator it = vectorOfVectors.cbegin(), itend = vectorOfVectors.cend(),
				itOther = vectorOfVectorOthers.cbegin(), itOtherEnd = vectorOfVectorOthers.cend();
				it != itend && itOther != itOtherEnd;
				++it, ++itOther)
			{
				if(!AreVectorsSame(*it, *itOther))
				{
					return false;
				}
			}
			return true;
		}
		return false;
	}
	virtual bool CheckModifiedCustom() const
	{
		return !AreVectorsOfVectorsSame(m_customTitleTokens, m_customTitleTokensOriginal);
	}
	virtual bool CheckModifiedDefault() const
	{
		return !AreVectorsOfVectorsSame(m_defaultTitleTokens, m_defaultTitleTokensOriginal);
	}
	virtual bool isAdditionalChanged() const override{return m_customAlign != m_customAlignOriginal || m_defaultAlign != m_defaultAlignOriginal;}

	virtual unsigned int GetApplyMessageId() const{return WM_USER + 203;}
	virtual TakionTool::NamedValueIdVector* GetValueVector() override
	{
		return m_currentCustom ?
			m_ordinalCustom < (unsigned int)m_customTitleTokens.size() ? &m_customTitleTokens[m_ordinalCustom] : NULL:
			m_ordinalDefault < (unsigned int)m_defaultTitleTokens.size() ? &m_defaultTitleTokens[m_ordinalDefault] : NULL;
	}
	const TakionTool::NamedValueIdVector* GetValueVectorConst() const
	{
		return m_currentCustom ?
			m_ordinalCustom < (unsigned int)m_customTitleTokens.size() ? &m_customTitleTokens[m_ordinalCustom] : NULL:
			m_ordinalDefault < (unsigned int)m_defaultTitleTokens.size() ? &m_defaultTitleTokens[m_ordinalDefault] : NULL;
	}
	const TakionTool::NamedValueIdVectorVector& GetCustomTitleTokens() const{return m_customTitleTokens;}
	const TakionTool::NamedValueIdVectorVector& GetDefaultTitleTokens() const{return m_defaultTitleTokens;}

	const TakionTool::NamedValueIdVectorVector& GetTitleTokens() const{return m_currentCustom ? m_customTitleTokens : m_defaultTitleTokens;}
	TakionTool::NamedValueIdVectorVector& GetTitleTokens(){return m_currentCustom ? m_customTitleTokens : m_defaultTitleTokens;}

	const bool& isCustomAlign() const{return m_customAlign;}
	const bool& isDefaultAlign() const{return m_defaultAlign;}
	const bool& isAlign() const{return m_currentCustom ? m_customAlign : m_defaultAlign;}

	void Display(TakionFrame* receipient, unsigned int code, CWnd* parent, int x, int y, int w, int h, const TakionTool::NamedValueIdVectorVector& customTitleTokens, const TakionTool::NamedValueIdVectorVector& defaultTitleTokens, bool customAlign, bool defaultAlign, bool custom, int selectLine);
protected:
	virtual void UpdateCurrentValueVector(unsigned int ctrlId, int itemOrdinalOld, int itemOrdinalNew) override;
	virtual void ClearCustomValues(){if(m_ordinalCustom < (unsigned int)m_customTitleTokens.size())m_customTitleTokens[m_ordinalCustom].clear();}
	virtual void ClearDefaultValues(){if(m_ordinalDefault < (unsigned int)m_defaultTitleTokens.size())m_defaultTitleTokens[m_ordinalDefault].clear();}
	virtual void ResetCustomValues(){m_customTitleTokens = m_customTitleTokensOriginal; AdjustNumberOfLines();}
	virtual void ResetDefaultValues(){m_defaultTitleTokens = m_defaultTitleTokensOriginal; AdjustNumberOfLines();}
	virtual void ApplyCustomValues(){m_customTitleTokensOriginal = m_customTitleTokens;}
	virtual void ApplyDefaultValues(){m_defaultTitleTokensOriginal = m_defaultTitleTokens;}
	virtual void MakeDefaultCustomValues() override{m_customTitleTokens = m_defaultTitleTokensOriginal; AdjustNumberOfLines();}

	virtual void ToolTipsEnabled(bool enable) override;
	virtual void Resize(bool widthChanged = true, bool heightChanged = true) override;

	virtual BOOL OnInitDialog() override;

	virtual bool DoReset() override;
	virtual void DoApply() override;
	virtual void FinishDialog(int result) override;
	virtual void DoDefault() override;
	virtual void CustomModified() override;
	virtual void DoFillListBoxTo() override;

	virtual void DoDataExchange(CDataExchange* pDX) override;

	afx_msg void OnAlign();
	afx_msg void OnSelchangeLine();
	afx_msg LRESULT OnTitleLinesAdded(WPARAM w, LPARAM l);
	afx_msg LRESULT OnTitleLinesRemoved(WPARAM w, LPARAM l);
	afx_msg LRESULT OnRSelChange(WPARAM ctrlId, LPARAM itemNumber);

	DECLARE_MESSAGE_MAP()

	ListBoxTitleLine m_ListBoxTitleLine;
	CStatic m_StaticLines;
	ButtonToolTip m_CheckBoxAlign;

	unsigned int m_ordinalCustom;
	unsigned int m_ordinalDefault;

	void AdjustNumberOfLines(int selectLine = -1);
	void DoSelchangeLine(unsigned int uintSel);

	TakionTool::NamedValueIdVectorVector m_customTitleTokens;
	TakionTool::NamedValueIdVectorVector m_defaultTitleTokens;

	TakionTool::NamedValueIdVectorVector m_customTitleTokensOriginal;
	TakionTool::NamedValueIdVectorVector m_defaultTitleTokensOriginal;

	bool m_customAlign;
	bool m_defaultAlign;

	bool m_customAlignOriginal;
	bool m_defaultAlignOriginal;

	int m_lbLineTop;
	int m_lbLineWidth;
};
////



class TGUI_API ListBoxView : public ListBoxFit
{
friend class DialogListView;
public:
	ListBoxView(DialogListView* parentDlg, bool rbuttonSelection = true, bool rbuttonMenu = true, bool draggable = false, bool useBoldItem = true);
	virtual const char* GetItemName(const void* item) const override;
//	virtual int Compare(const void* item1, const void* item2) const override;
	virtual COLORREF GetStringColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override;
	virtual COLORREF GetSelectedBkColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override;
/*
	virtual void GetDrawItemRect(const DRAWITEMSTRUCT* lpDrawItemStruct, CRect& drawItemRect) const override;
	virtual COLORREF GetBkColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override;
*/
	virtual void GetSelectionItemRect(const DRAWITEMSTRUCT* lpDrawItemStruct, CRect& drawItemRect) const override;
//	virtual void GetItemText(const void* item, std::string& text) const override;

	static const COLORREF colorDefaultView;
	static const COLORREF colorNewView;
	static const COLORREF colorInitialView;
	static const COLORREF colorView;

	int AddItem(const char* newName, const char* oldName);
	int AddItem(const std::string& newName, const std::string& oldName);
	void PretendNotDisplayed() const;//Prevents the parent dialog box from getting closed on Deactivate (Loss of Focus)
	void UnpretendNotDisplayed() const;
	void SetActive();

	virtual bool CanAddItem() const override;
	virtual bool CanRemoveSelectedItem() const override;
	virtual bool CanClearItems() const override;
	virtual bool CanFindItem() const;

	bool SetOwner(const bool& owner)
	{
		if(owner != m_owner)
		{
			m_owner = owner;
			return true;
		}
		return false;
	}

	bool ViewSelectedItem() const;
	bool SaveAsText() const;
	bool SaveAsSelectedItem() const;

	void ExtractInitialView(){m_initialView.ExtractValue();}
	void SaveInitialView(std::string* error = NULL){m_initialView.SaveValueAndUpdateInitialValue(error);}
	bool isInitialViewModified() const{return m_initialView.isModified();}
	const std::string& GetInitialView() const{return m_initialView.GetValue();}
	void SetInitialView(const std::string& initialViewName);
	void ResetInitialView();
protected:
	virtual int FindItemOnMenuCommand() override;
	virtual int AddItemOnMenuCommand(int before) override;
	virtual bool RemoveSelectedItemOnMenuCommand(int sel) override;
	virtual bool ClearItemsOnMenuCommand() override;

	virtual void DoDrawItem(const DRAWITEMSTRUCT* lpDrawItemStruct, const CRect& drawItemRect) override;
	virtual void DestroyItem(const void* item) const override;
	virtual void OnItemAdded(void* item, unsigned int at, bool checked) override;
	virtual void BeforeItemDeleted(unsigned int at, bool checked) override;
	virtual void AfterItemsCleared() override;
	virtual void AfterItemDeleted(unsigned int at, bool failed, bool checked) override;
	void UpdateDimensions();

	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;
	virtual void AddMenuItems(CMenu& menu) override;
	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;

	DialogListView* m_parentDlg;
	std::string m_defaultName;
	StringIniValue m_initialView;
	bool m_owner;
};



class TGUI_API DialogListView : public DialogListEditOkCancel
{
public:
	DialogListView(TakionMainWnd* mainWnd, CWnd* parent, unsigned int maxVisibleItemtCount);//, bool sortAlphabetically);//, bool ownItems);// = 0, CWnd* receipient = NULL);
//	const TakionTool* GetToolAt(int i) const;
//	const TakionTool* GetSelectedTool() const;
	void* FindItemByName(const char* name) const;
	void Display(unsigned int code,
		bool rightButton,
		const void* item,
		CWnd* parent,
		int x, int y, int w, int h,
		bool fastSelection,
		unsigned int maxVisibleItemCount = 0,
		CWnd* receipient = NULL,
		COLORREF bkColor = 0xFFFFFFFF,
		COLORREF selectionBkColor = 0xFFFFFFFF,
		COLORREF textColor = 0xFFFFFFFF,
		COLORREF selectionTextColor = 0xFFFFFFFF,
		const char* title = NULL);

//	virtual void GetItemTextToPopulateEdit(const void* item, std::string& itemStr) const override;

	virtual bool ResetContent() override;
	const int& GetListBoxItemWidth() const{return m_ListBoxView.GetMaxWidth();}
	virtual bool UpdateFrameRight() override;
//	virtual bool UpdateFrameBottom() override;
	virtual bool isOkButtonEnabled() const override;
	virtual void Apply() override;
	void Reset();
//	virtual bool CanShow() const override{return m_ListBoxView.GetItemCount() > 0;}
	void UpdateViews();
	void InvalidateApplyButton() const{if(m_ButtonApply.m_hWnd)::InvalidateRect(m_ButtonApply.m_hWnd, NULL, TRUE);}
	void InvalidateResetButton() const{if(m_ButtonReset.m_hWnd)::InvalidateRect(m_ButtonReset.m_hWnd, NULL, TRUE);}
protected:
	virtual BOOL OnInitDialog();
	virtual void BeforeShow() override;
	virtual void BeforeDestroy() override;
	virtual void FinishDialog(int result) override;
	virtual void ItemSelected() override;
	virtual void ItemDoubleClicked() override;
	virtual void ItemSelectedWithRightClick(unsigned int itemOrdinal) override;
	virtual void Resize(bool widthChanged = true, bool heightChanged = true) override;
	virtual void OnResizeToFrame() override;

	virtual void BeforeCurrentItemSet(const void* itemToBeCurrent, unsigned char resize) override;
//	virtual void OnDisplay();
	virtual void DoDataExchange(CDataExchange* pDX);
	afx_msg void OnReset();
	DECLARE_MESSAGE_MAP()

	virtual void OkButtonEnabled(bool enabled) override;

	void ResetViews();

	ListBoxView m_ListBoxView;

	CButton m_ButtonApply;
	CButton m_ButtonReset;

	CRect m_rectApply;
	CRect m_rectReset;

	int m_applyResetButtonWidth;


//	StringStringItem m_selectedItem;
};

class TGUI_API SecurityCollection// : public Observer
{
friend class TakionTool;
public:
	virtual ~SecurityCollection(){DestroyToolTip();}
//	virtual void Paint(CDC& dc, const RECT& interRect) = 0;
	const Account* GetCurrentAccount() const;//{return m_account ? m_account : m_takionTool->GetMainWnd()->GetCurrentAccount();}
	void UpdateSecurityLevel1();
	void UpdateSecurityLevel2();
	virtual void UpdatePosition(){}
	void OnSecurityRefreshed()
	{
		UpdateSecurityLevel1();
		UpdateSecurityLevel2();
		UpdatePosition();
	}
	void OnSecurityInvalid(const unsigned __int64& symbol);
	void OnSecurityDeleted(const Security* security);

//	Security* GetSecurity(){return m_security;}
//	Account* GetAccount(){return m_account;}
//	Position* GetPosition(){return m_position;}

	const Security* const& GetSecurity() const{return m_security;}
	const Account* const& GetAccount() const{return m_account;}
	const Position* const& GetPosition() const{return m_position;}

	void SetSecurity(const Security* security);
	void SetAccount(const Account* account);
	void SetPosition(const Position* position);

	virtual void UpdateTitleValueGraphics(const Graphics* graphics, const GraphicsColorCollection* colorCollection);

	virtual bool UpdateSecurityTitleValueGraphicsColorsCustom(const GraphicsColorCollection* colorCollection);
	virtual void UpdateSecurityTitleValueGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection);//, const GraphicsColorCollection* colorCollection = NULL);

//	virtual
	bool UpdateSecurityTitleLabelGraphicsColorsCustom(const GraphicsColorCollection* colorCollection);
//	virtual
	void UpdateSecurityTitleLabelGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection);

	COLORREF GetBkColor() const{return m_marketSorterConnected ? m_marketSorterLoaded ? m_bgColor : m_bgColorNotLoaded : m_bgColorDisconnected;}
	void SetMarketSorterConnected(bool connected);
	void SetMarketSorterLoaded(bool loaded);
	bool isMarketSorterConnected() const{return m_marketSorterConnected;}
	bool isMarketSorterLoaded() const{return m_marketSorterLoaded;}

	bool NeedToolTip() const;
	void SetShowTooltips(const bool show);
	bool isShowTooltips() const{return m_showTooltips;}
	void UpdateShowTooltips();
protected:
	SecurityCollection(TakionTool* takionTool, const TakionConfig::StringVectorVector& values);
	
	virtual void UpdateLabelColor(const COLORREF& color){}
	virtual void UpdateLabelInventoryColor(const COLORREF& color){}

	virtual void DoUpdateSecurityLevel1(){}
	virtual void DoUpdateSecurityLevel2(){}
	virtual void CurrentAccountChanged(const Account* account){}
	virtual void OnSecuritySet()
	{
		UpdateSecurityLevel1();
		UpdateSecurityLevel2();
		UpdatePosition();
	}
	virtual void OnPositionSet()
	{
	}
	TakionTool* m_takionTool;
	const TakionConfig::StringVectorVector& m_values;
	const Security* m_security;
	const Account* m_account;
	const Position* m_position;

	COLORREF m_bgColor;
	COLORREF m_bgColorDisconnected;
	COLORREF m_bgColorNotLoaded;

	bool m_marketSorterConnected;
	bool m_marketSorterLoaded;

	virtual void OnToolSuccessfulCreate();
	void DestroyToolTip();
	bool CreateToolTip();
	void RelayToolTipEvent(MSG* pMsg);
	void UpdateToolTips();
	CToolTipCtrl* m_toolTip;
	unsigned int m_tooltipCount;
	bool m_showTooltips;
//	unsigned char m_tooltipFilter;

	virtual void DoCreateToolTips(){}
	void DoDestroyToolTips();
	static const unsigned int tipsStartId;// = 2000;
};

class TGUI_API SecurityTitleCollection : public SecurityCollection
{
friend class TakionTool;
public:
	SecurityTitleCollection(TakionTool* takionTool, const TakionConfig::StringVectorVector& values);
	virtual ~SecurityTitleCollection();
	typedef std::set<unsigned int> UIntSet;

	void Paint(CDC& dc, const RECT& interRect);

	void CurrentAccountConstraintsLoaded();
	virtual void CurrentAccountChanged(const Account* account);
//	virtual void UpdateSecurityLevel1();
//	virtual void UpdateSecurityLevel2();
	virtual void UpdatePosition();

	const bool& isAlign() const{return m_align;}
	void SetAlign(const bool& align)
	{
		if(align != m_align)
		{
			m_align = align;
			UpdateAlignTitleValues();
		}
	}
	void AlignTitleValues();

	void UpdateTitleLabelGraphics(const Graphics* graphics, const GraphicsColorCollection* colorCollection);
	virtual void UpdateTitleValueGraphics(const Graphics* graphics, const GraphicsColorCollection* colorCollection) override;
	void UpdateTitleValueCollection();
	void SetDecDigitsTitle(unsigned char decDigits);
	const unsigned char& GetDecDigitsTitle() const{return m_decDigitsTitle;}
	void SetTruncateTitle(bool truncate);
	const bool& isTruncateTitle() const{return m_truncateTitle;}
	void SetShowTitleSizeInShares(const bool sizeInShares);
	const bool& isShowTitleSizeInShares() const{return m_titleSizeInShares;}
	
	virtual bool UpdateSecurityTitleValueGraphicsColorsCustom(const GraphicsColorCollection* colorCollection) override;
	virtual void UpdateSecurityTitleValueGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection) override;//, const GraphicsColorCollection* colorCollection = NULL);

//	virtual bool UpdateSecurityTitleLabelGraphicsColorsCustom(const GraphicsColorCollection* colorCollection) override;
//	virtual void UpdateSecurityTitleLabelGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection) override;

	void UpdateTitleLabelMetrics();
	void UpdateTitleValueMetrics(short direction, bool fontChanged);
	bool UpdateTitleValueHeight(short direction, bool fontChanged, bool lineCountChanged);
	void UpdateTitleCollectionWidth();

	void toString(std::string& str, unsigned int contentModifier) const;
	void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier);

	void SetCustomFont(const FontDescription& fontDescription, bool custom, unsigned int id);
	void GetCurrentFontParams(std::string& title, FontDescription& fontDescription, FontDescription& fontDescriptionCustom, bool& custom, unsigned int& id) const;

	void SetCustomFontTitleValue(const FontDescription& fontDescription, bool custom);

	void SetCustomFontTitleLabel(const FontDescription& fontDescription, bool custom);

//	void SetCustomColors(const Graphics* graphics, GraphicsColorCollection* colorCollection, const COLORREF* colors, unsigned short colorCount, bool custom, const FilterStringAsNumberArray& title);//, const FilterStringAsNumberArray& title, unsigned int colorId);

	typedef std::vector<NamedValueCollectionHorizontal*> NvchVector;
	const NvchVector& GetTitleValueCollection() const{return m_titleValueCollection;}
protected:
	virtual void UpdateLabelColor(const COLORREF& color) override;
	virtual void UpdateLabelInventoryColor(const COLORREF& color) override;

	static void UpdateTitleItemColors(const Graphics* graphics, NamedValueCollectionHorizontal* nvch, unsigned int i);
	static void UpdateTitleItemColorsCustom(const GraphicsColorCollection* colorCollection, NamedValueCollectionHorizontal* nvch, unsigned int i);

//	void UpdateSecurityTitleValueAndLabelColors(const Graphics* graphicsLabel, const Graphics* graphicsValue);
//	void UpdateSecurityTitleValueAndLabelColorsCustom(const GraphicsColorCollection* colorCollectionLabel, const GraphicsColorCollection* colorCollectionValue);

	void UpdateTitleValueRect(bool horizontalChanged, int prevTop, int prevHeight);
	virtual void OnSecuritySet();
	virtual void OnPositionSet();
	virtual void DoUpdateSecurityLevel1();
	virtual void DoUpdateSecurityLevel2();

	void UpdateTitleLabelOffset();
	void SetFontTitleLabel(const FontDescription& fontDescription);//, bool fontChanged);
	FontDescription m_fontDescriptionTitleLabel;
	FontDescription m_fontDescriptionTitleLabelCustom;
	CFont* m_fontTitleLabel;
	bool m_fontTitleLabelCustom;

	bool SetFontTitleValue(const FontDescription& fontDescription, bool fontChanged);
	FontDescription m_fontDescriptionTitleValue;
	FontDescription m_fontDescriptionTitleValueCustom;
	CFont* m_fontTitleValue;
	bool m_fontTitleValueCustom;

	UIntSet m_titleFontSet;
	UIntSet::const_iterator m_titleFontSetBegin;
	UIntSet::const_iterator m_titleFontSetEnd;
	unsigned int m_fontTitleValueSize;
	unsigned char m_titleLabelHorizontalSpacing;
	unsigned char m_titleLabelVerticalSpacing;
	unsigned char m_titleValueHorizontalSpacing;
	unsigned char m_titleValueVerticalSpacing;
	unsigned char m_decDigitsTitle;
	bool m_truncateTitle;
	bool m_titleSizeInShares;
	int m_minTitleValueHeight;
	int m_maxTitleValueHeight;
	int m_titleValueHeight;
	int m_titleValueTotalHeight;
	void UpdateTitleValues(NamedValueCollectionHorizontal* nvch, const TakionConfig::StringVector& values);
	void ArrangeTitleValues();
	void UpdateTitleValues(ValueType valueType);

	NvchVector m_titleValueCollection;
	void DestroyTitleValueCollection();

	int CalculateExtraLevel1Width(unsigned char spacing, int height) const;
	int CalculateExtraLevel1Height(unsigned char spacing, int height) const;
	void UpdateAlignTitleValues();
	bool m_align;

	virtual void DoCreateToolTips();
};

class TGUI_API TakionTitleTool : public TakionTool
{
public:
	virtual ~TakionTitleTool();
	const char* GetTitle() const{return m_title.c_str();}
	const std::string& GetTitleStr() const{return m_title;}
/*
	void SetTitle(const char* title)
	{
		if(strcmp(m_title.c_str(), title))
		{
			m_title = title;
			RepaintTitle();
		}
	}
*/
	virtual void SetPrefix(const char* prefix);

	virtual void toString(std::string& str, unsigned int contentModifier) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual void fromScratch() override;

	virtual void UpdateTitleGraphics(const Graphics* graphics) override;
	int CalculateExtraTitleHeight(unsigned char spacing, int height) const;
	int CalculateExtraTitleWidth(unsigned char spacing, int height) const;

	const std::string& GetPrefix() const{return m_prefix;}
	virtual bool CanHavePrefix() const{return false;}

	virtual void AppendWindowMenuInfo(std::string& menuText) const override
	{
		TakionTool::AppendWindowMenuInfo(menuText);
		if(!m_prefix.empty())
		{
			menuText += " - ";
			menuText += m_prefix;
		}
	}

	virtual bool CanShowTime() const override{return true;}
	virtual bool isShowTime() const override{return m_showTime;}
	void SetShowTime(bool showTime);
	virtual void ToggleShowTime() override{SetShowTime(!m_showTime);}

	virtual bool CanShowPrefixOnly() const override{return CanHavePrefix();}

	virtual bool isShowPrefixOnly() const override{return m_showPrefixOnly;}
	void SetPrefixOnly(bool showPrefixOnly);
	virtual void TogglePrefixOnly() override{SetPrefixOnly(!m_showPrefixOnly);}

	virtual bool isShowRowCount() const override{return m_showRowCount;}
	void SetShowRowCount(bool showRowCount);
	virtual void ToggleRowCount() override{SetShowRowCount(!m_showRowCount);}

	virtual bool isShowTotalCount() const override{return m_showTotalCount;}
	void SetShowTotalCount(bool showTotalCount);
	virtual void ToggleTotalCount() override{SetShowTotalCount(!m_showTotalCount);}

	void InvalidateHourRect1() const{::InvalidateRect(m_hWnd, &m_hourRect1, FALSE);}
	void InvalidateHourRect2() const{::InvalidateRect(m_hWnd, &m_hourRect2, FALSE);}
	void InvalidateMinuteRect1() const{::InvalidateRect(m_hWnd, &m_minuteRect1, FALSE);}
	void InvalidateMinuteRect2() const{::InvalidateRect(m_hWnd, &m_minuteRect2, FALSE);}
	void InvalidateSecondRect1() const{::InvalidateRect(m_hWnd, &m_secondRect1, FALSE);}
	void InvalidateSecondRect2() const{::InvalidateRect(m_hWnd, &m_secondRect2, FALSE);}
	void InvalidateSecondRect() const{::InvalidateRect(m_hWnd, &m_secondRect, FALSE);}
	virtual int GetHourRectLeft() const{return m_borderWidth;}

	void InvalidatePrefixOnlyRect() const{if(m_hWnd)::InvalidateRect(m_hWnd, &m_prefixOnlyRect, FALSE);}
protected:
	TakionTitleTool(const CBitmap* bitmap,
		unsigned int workspace,
		bool pinned = false,
		int minVisibleSize = 15,
//		int minWidth = 100,
		int minWidth = 20,
		int maxWidth = 0,
//		int minHeight = 50,
		int minHeight = 20,
		int maxHeight = 0,
		int minBorderWidth = 2,
		int maxBorderWidth = 2,
		const char* className = "TakionTool",
		int minTitleHeight = 0,
		int maxTitleHeight = 15,
		int titleHeight = 15);
	void UpdateTitleMetrics();

	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;

	virtual void DoUpdateTitle()
	{
		m_title = GetToolId();
//		AppendWindowMenuInfo(m_title);
		GetAdditionalTitleInfo(m_title);
	}
	void UpdateTitle()
	{
		DoUpdateTitle();
		RepaintTitle();
	}

//	DECLARE_MESSAGE_MAP()
//	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
//	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);

	virtual void TitleFontChanged() override;

	virtual void PrefixChanging(const char* from) const{}

	virtual void OnTimeRectUpdated();

	virtual void UpdateTitleRects();
	virtual void SizeHorizontal(int cx, int cy, int oldX, int oldY) override;
	virtual void DoPaintTitle(const RECT& interRect, CDC& dc) override;
	virtual void OnSuccessfulCreate() override;
	virtual void OnTitleResize() override;
	virtual void BeforeDestroy() override;
	void DoPaintTitleText(const RECT& textRect, const RECT& interRect, CDC& dc);
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;
	virtual void PostAddMenuItems(CMenu& menu) override;
	virtual void AcceptText(const char* text, unsigned int code) override;
	std::string m_title;
	std::string m_prefix;
	int m_titleTextHeight;
	int m_titleOffsetX;
	int m_titleOffsetY;
	unsigned char m_titleHorizontalSpacing;
	unsigned char m_titleVerticalSpacing;

	CRect m_titleTextRect;

	bool m_showTime;
	bool m_showPrefixOnly;
	bool m_showRowCount;
	bool m_showTotalCount;
	CRect m_timeRect;
	CRect m_hourRect1;
	CRect m_hourRect2;
	CRect m_timeColonRect1;
	CRect m_minuteRect1;
	CRect m_minuteRect2;
	CRect m_timeColonRect2;
	CRect m_secondRect1;
	CRect m_secondRect2;
	CRect m_secondRect;
	CRect m_prefixOnlyRect;
	int m_timeHeight;
	int m_timeTokenWidth;
	int m_timeSeparatorWidth;
	void UpdateTimeRectWidth();
	void CalculateTimeRectHeight();
	void CalculateTimeRectWidth();
	void AdjustTimeRectWidth();
};

//template<class Comp = std::less<TakionTool*> >
//class ToolCollection : public PtrCollection<TakionTool, Comp>
template<class PtrSetType = std::set<TakionTool*, std::less<TakionTool*> > >
class ToolCollection : public PtrCollection<TakionTool, PtrSetType>
{
public:
	ToolCollection():m_activeTool(NULL),m_activeCommandTool(NULL){}
//	ToolCollection(const ToolCollection& other):PtrCollection(other),m_activeTool(NULL),m_activeCommandTool(NULL){}
	void DestroyTools()
	{
		PtrSet copy(m_ptrs);
		Clear();
		for(PtrSet::iterator it = copy.begin(), itend = copy.end(); it != itend; ++it)
		{
			(*it)->DestroyWindow();
		}
		m_activeCommandTool = NULL;
		m_activeTool = NULL;
	}

	void AdjustFrameRect()
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->AdjustFrameRect();
		}
	}
	void UpdateSystemRects()
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->UpdateSystemRects();
		}
	}
	void MoveTools(int deltaX, int deltaY)
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->DragWindow(deltaX, deltaY);
		}
	}
	void AccountDeleted(const Account* account)
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->AccountDeleted(account);
		}
	}
	void ConnectionDisconnected(unsigned int ipAddress, unsigned short port, unsigned int ipBindAddress, unsigned short bindPort, unsigned char connectionType, const char* connectionName)
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->ConnectionDisconnected(ipAddress, port, ipBindAddress, bindPort, connectionType, connectionName);
		}
	}
	void ConnectionConnected(unsigned int ipAddress, unsigned short port, unsigned int ipBindAddress, unsigned short bindPort, unsigned char connectionType, const char* connectionName)
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->ConnectionConnected(ipAddress, port, ipBindAddress, bindPort, connectionType, connectionName);
		}
	}

	void ConnectionLogged(unsigned int connectionType)
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->ConnectionLogged(connectionType);
		}
	}

	void RepaintDefaultOnlyTradingAllowed()
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->RepaintDefaultOnlyTradingAllowed();
		}
	}

	void NewAccount(const Account* account)
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->NewAccount(account);
		}
	}
	void DeleteAllAccounts()
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->AllAccountsDeleted();
		}
	}
	void CurrentAccountChanged(const Account* account)
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->CurrentAccountChanged(account);
		}
	}
	void NamedFilterAdded(SymbolFilter* filter, const std::string& name)
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->NamedFilterAdded(filter, name);
		}
	}
	void NamedFilterChanged(SymbolFilter* filter)
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->NamedFilterChanged(filter);
		}
	}
	void NamedFilterRenamed(SymbolFilter* filter, const std::string& name)
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->NamedFilterRenamed(filter, name);
		}
	}
	void NamedFilterDeleted(SymbolFilter* filter)
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->NamedFilterDeleted(filter);
		}
	}
	void AllNamedFiltersDeleted()
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->AllNamedFiltersDeleted();
		}
	}
	void RefreshNamedFilters()
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->RefreshNamedFilters();
		}
	}

	void UpdateTitleGraphics(const Graphics* graphics)
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->UpdateTitleGraphics(graphics);
		}
	}
	void UpdateBorderGraphics(const Graphics* graphics)
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->UpdateBorderGraphics(graphics);
		}
	}
	void GetMinLeftTop(int& minLeft, int& minTop)
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
	//				(*it)->SetWindowPos(NULL, m_screenRect.left, m_screenRect.top, 0, 0, SWP_NOSIZE|SWP_NOACTIVATE|SWP_NOZORDER);
			const CRect& frameRect = (*it)->GetFrameRect();
			if(minLeft > frameRect.left)
			{
				minLeft = frameRect.left;
			}
			if(minTop > frameRect.top)
			{
				minTop = frameRect.top;
			}
		}
	}
	void AdjustFrameRect(int diffX, int diffY)
	{
		TakionTool* tool;
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			tool = *it;
			const CRect& frameRect = tool->GetFrameRect();
			tool->SetWindowPos(NULL, frameRect.left + diffX, frameRect.top + diffY, 0, 0, SWP_NOSIZE|SWP_NOACTIVATE|SWP_NOZORDER);
			tool->AdjustFrameRect();
		}
	}
	void Corner()
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
//				(*it)->SetWindowPos(NULL, m_screenRect.left, m_screenRect.top, 0, 0, SWP_NOSIZE|SWP_NOACTIVATE|SWP_NOZORDER);
			(*it)->Corner();
		}
	}
	void EstablishAllExternalLinks(bool force)
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->EstablishAllExternalLinks(force);
		}
	}
	void ExternalLinkEstablished(LinkExternal* link)
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->ExternalLinkEstablished(link);
		}
	}
	void CurrentAccountConstraintsLoaded()
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->CurrentAccountConstraintsLoaded();
		}
	}
	void CurrentAccountLoaded()
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->CurrentAccountLoaded();
		}
	}
	void AccountLoaded(const Account* account)
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->AccountLoaded(account);
		}
	}
	void AllAccountsLoaded()
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->AllAccountsLoaded();
		}
	}

	void LoggedToExecutor()
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->LoggedToExecutor();
		}
	}

	void SecurityNoteAdded(const unsigned __int64& symbol, const std::string& note)
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->SecurityNoteAdded(symbol, note);
		}
	}

	void SecurityNoteRemoved(const unsigned __int64& symbol)
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->SecurityNoteRemoved(symbol);
		}
	}

	void SecurityNotesCleared()
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->SecurityNotesCleared();
		}
	}

	void SecurityNotesClearDone()
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->SecurityNotesClearDone();
		}
	}

	void SecurityNotesReplaced(const std::map<unsigned __int64, std::string, lessUIntAsStr<unsigned __int64> >& newNotes, bool clearOld)
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->SecurityNotesReplaced(newNotes, clearOld);
		}
	}

	void SecurityNotesReplacementDone()
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->SecurityNotesReplacementDone();
		}
	}

	void UpdateShowTooltips()
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->UpdateShowTooltips();
		}
	}

	void ShowTools(int show)
	{
		TakionTool* tool;
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			tool = *it;
			if(!tool->isHidden() && !tool->isPinned())
			{
				tool->ShowWindow(show);
			}
		}
	}
	void HideToolsExceptWorkspace(unsigned int workspace, bool keepPinned)
	{
		TakionTool* tool;
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd;)
		{
			tool = *it;
			if(tool->GetWorkspace() == workspace || keepPinned && tool->isPinned())
			{
				++it;
			}
			else
			{
				it = m_ptrs.erase(it);
				UpdateIterators();
				tool->ShowWindow(SW_HIDE);
			}
		}
	}
	void ToggleShowTools()
	{
		bool someToolsNotHidden = false;
		TakionTool* tool;
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			tool = *it;
			if(!tool->isHidden())
			{
				if(tool->isVisible())
				{
					ShowTools(SW_HIDE);
					return;
				}
				someToolsNotHidden = true;
			}
		}
		if(someToolsNotHidden)
		{
			ShowTools(SW_SHOWNA);
		}
	}
	void EnableTools(BOOL enable)
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->EnableWindow(enable);
		}
	}
	TakionTool* Extract()
	{
		if(m_itBegin != m_itEnd)
		{
			TakionTool* tool = *m_itBegin;
			m_ptrs.erase(m_itBegin);
			UpdateIterators();
			return tool;
		}
		return NULL;
	}
	TakionTool* GetFirst()
	{
		return m_itBegin == m_itEnd ? NULL : *m_itBegin;
	}
	void SetActiveTool(TakionTool* tool)
	{
//		if(!tool || m_ptrs.find(tool) != m_ptrs.end())
//		{
			m_activeTool = tool;
//		}
	}
	TakionTool* GetActiveTool(){return m_activeTool;}
	void SetActiveCommandTool(TakionTool* tool)
	{
		if(!tool || tool->isCommandTool())// && m_ptrs.find(tool) != m_ptrs.end())
		{
			m_activeCommandTool = tool;
		}
	}
	TakionTool* GetActiveCommandTool(){return m_activeCommandTool;}
protected:
	virtual void BeforeObjectRemoved(TakionTool* tool)
	{
		if(tool == m_activeTool)
		{
			m_activeTool = NULL;
		}
		if(tool == m_activeCommandTool)
		{
			m_activeCommandTool = NULL;
		}
	}
	virtual void BeforeObjectsCleared()
	{
		m_activeTool = NULL;
		m_activeCommandTool = NULL;
	}
	TakionTool* m_activeTool;
	TakionTool* m_activeCommandTool;
	ToolCollection(const ToolCollection& other):PtrCollection(other),m_activeTool(NULL),m_activeCommandTool(NULL){}
private:
	ToolCollection& operator=(const ToolCollection& other){return *this;}
};

class TGUI_API ToolSet : public ToolCollection<
#if (_MSC_VER > 1600)
	std::unordered_set<TakionTool*>
#else
	std::hash_set<TakionTool*>
#endif
	>
{
friend class ToolPool;
//public:
private:
//	ToolSet(const ToolSet& other):ToolCollection(other){}
	ToolSet& operator=(const ToolSet& other){return *this;}
	void SetToolsRemoved()
	{
		for(PtrSet::iterator it = m_itBegin; it != m_itEnd; ++it)
		{
			(*it)->m_removed = true;
		}
	}
};

class TGUI_API ToolPool
{
public:
	~ToolPool();
#if (_MSC_VER > 1600)
	typedef std::unordered_map<std::string, ToolSet> PoolMap;
#else
	typedef std::hash_map<std::string, ToolSet> PoolMap;
#endif
	void Insert(TakionTool* tool);
	TakionTool* GetTool(const std::string& id);
	void DestroyTools();
protected:
	PoolMap m_poolMap;
};

//from <functional> line 148
struct lessRect : public std::binary_function<RECT, RECT, bool>
{
	bool operator()(const RECT& r1, const RECT& r2) const
	{
		return r1.top < r2.top ? true:
			r1.top > r2.top ? false:
			r1.left < r2.left ? true:
			r1.left > r2.left ? false:
			r1.bottom > r2.bottom ? true:
			r1.bottom < r2.bottom ? false:
			r1.right > r2.right;
	}
};
/*
struct lessToolCommand : public std::binary_function<TakionTool*, TakionTool*, bool>
{
	bool operator()(const TakionTool* const& t1, const TakionTool* const& t2) const
	{
		return t1->isCommandTool() && !t2->isCommandTool();
	}
};
*/
struct lessTool : public std::binary_function<TakionTool*, TakionTool*, bool>
{
	bool operator()(const TakionTool* const& t1, const TakionTool* const& t2) const
	{
		if(t1->isCommandTool() == t2->isCommandTool())
		{
			if(t1->isCommandTool())
			{
				return t1->GetCommandToolOrdinal() < t2->GetCommandToolOrdinal();
			}
			else
			{
				const CRect& r1 = t1->GetNormalRect();
				const CRect& r2 = t2->GetNormalRect();
				return r1.top < r2.top ? true:
					r1.top > r2.top ? false:
					r1.left < r2.left ? true:
					r1.left > r2.left ? false:
					r1.bottom > r2.bottom ? true:
					r1.bottom < r2.bottom ? false:
					r1.right > r2.right ? true:
					r1.right < r2.right ? false:
					t1->GetToolOrdinal() < t2->GetToolOrdinal();
			}
		}
		else
		{
			return t1->isCommandTool();
		}
	}
};

struct lessAlphabeticalTool : public std::binary_function<TakionTool*, TakionTool*, bool>
{
	bool operator()(const TakionTool* const& t1, const TakionTool* const& t2) const
	{
		if(t1->isCommandTool() == t2->isCommandTool())
		{
			if(t1->isCommandTool())
			{
				return t1->GetCommandToolOrdinal() < t2->GetCommandToolOrdinal();
			}
			else
			{
				int ret = strcmp(t1->GetToolId(), t2->GetToolId());
				return ret < 0 || !ret && t1->GetToolOrdinal() < t2->GetToolOrdinal();
			}
		}
		else
		{
			return t1->isCommandTool();
		}
	}
};

const char* const toolAccountId = "Account";
const char* const toolPositionId = "Position";
const char* const toolOrderId = "Order";
/*
#ifdef SECONDARY_ROWS
const char* const toolAccountSecondaryId = "Account-Position";
const char* const toolPositionSecondaryId = "Position-Order";
const char* const toolOrderSecondaryId = "Order-Execution";
#endif
*/
const char* const toolExecutionId = "Execution";
const char* const toolClearingFirmId = "ClearingFirm";
const char* const toolPositionManagerId = "PosMan";
const char* const toolMarketSorterId = "MarketSorter";
const char* const toolIndexSorterId = "IndexSorter";
const char* const toolHiLoScrollerId = "HiLoScroller";
#ifndef TAKION_NO_OPTIONS
const char* const toolOptionId = "Option";
const char* const toolOptionChainId = "OptionChain";
#endif
#ifdef FIRM_VALUES
const char* const toolFirmPositionId = "FirmPosition";
#endif
const char* const toolExtensionId = "Extension";
const char* const toolPrintId = "Print";
const char* const toolHistoricalPrintId = "HistoricalPrint";
const char* const toolNewsHeadlineId = "NewsHeadline";
const char* const toolNewsContentsId = "NewsContents";
const char* const toolAlertId = "Alert";
const char* const toolHtmlViewerId = "HtmlViewer";
const char* const toolDataMonitorId = "DataMonitor";

enum DragTimerDirection : unsigned char
{
	CDTD_NONE,
	CDTD_RIGHT,
	CDTD_LEFT
};

class TGUI_API SimpleTextWnd : public TakionTitleTool
{
public:
	virtual ~SimpleTextWnd(){DestroyUrlList();}
	bool SetText(const std::string& text, const char* title);
	virtual void toString(std::string& str, unsigned int contentModifier) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual void fromScratch() override;
	virtual void UpdateGraphics() override;

	virtual void UpdateTextGraphics(const Graphics* graphics);
	virtual const Graphics* GetGraphicsAt(unsigned int graphicsOrdinal) const override;
	virtual bool UpdateTextGraphicsColorsCustom(const GraphicsColorCollection* colorCollection);
	virtual bool UpdateTextGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL);
	virtual void UpdateColorsCustom(const GraphicsColorCollection* colorCollection) override;

	virtual bool GetCurrentFontParams(std::string& title, FontDescription& fontDescription, FontDescription& fontDescriptionCustom, bool& custom, unsigned int& id) const override;
	virtual void SetCustomFont(const FontDescription& fontDescription, bool custom, unsigned int id) override;
	virtual void SetCustomColors(const Graphics* graphics, GraphicsColorCollection* colorCollection, const COLORREF* colors, unsigned short colorCount, bool custom, const FilterStringAsNumberArray& title) override;//, const FilterStringAsNumberArray& title, unsigned int colorId) override;
	void SetFont(const FontDescription& fontDescription);
	int CalculateExtraHeight(unsigned char spacing, int height) const;
	int CalculateExtraWidth(unsigned char spacing, int height) const;
	virtual size_t GetRowFirstVisibleOrd() const{return m_verticalScrollInfo.nPos;}
	virtual int GetScrollHorizontalOffset() const;

	virtual void ScrollLine(bool up, unsigned char modifier) override;
	virtual void ScrollPage(bool up, unsigned char modifier) override;
	virtual void ScrollToExtreme(bool up, unsigned char modifier) override;
	virtual void ScrollHorizontally(bool left, unsigned char modifier) override;
	virtual void CopySelection() const override;

	void ScrollWindowAndSelection(int lines);
	void SetFirstVisibleRow(unsigned int ord);//, bool selectedSame);
	void SetLastVisibleRow(unsigned int ord);//, bool selectedSame)
	void SetUseVerticalScroll(bool use);

	bool GetRowsRect(size_t from, size_t to, CRect& rect) const;
	bool GetRowRect(size_t ord, CRect& rect) const;
	void InvalidateRow(size_t ord);
	typedef std::vector<std::string> StringVector;
	const std::string& GetText() const{return m_text;}
	const StringVector& GetLines() const{return m_lines;}
	const StringVector& GetWordBrokenLines() const{return m_wordBrokenLines;}

	bool GetFirstSelectedLine(std::string& line) const;
	bool GetSelectionAsOneLine(std::string& line) const;
	bool VisitSelectedUrl() const;
	bool GetLineSelectionVector(StringVector& strings) const;

	typedef std::vector<unsigned int> UIntVector;

	int GetLineAtPoint(const CPoint& point) const;//returns -1 if not on a line
	int GetLineAndPosAtPoint(const CPoint& point, unsigned int& atX, unsigned int& atPos) const;//returns -1 if not on a line
//	const bool& hasFocus() const{return m_hasFocus;}
	bool isSelection() const{return m_xSelectionStart != m_xSelectionEnd || m_lineSelectionStart != m_lineSelectionEnd;}

	void SetHighlightURLs(bool highlight);
	void SetDblClkVisitURL(bool dblClkVisitURL);
	void SetHighlightFilterTokens(bool highlight);
	void SetHighlightFilteredIn(bool highlight);

	unsigned int GetNextMenuId() const;

	void TokenExpressionAdded(const TokenExpressionCollection* const expression);
	void TokenExpressionRemoved(const TokenExpressionCollection* const expression);
	void TokenExpressionChanged(const TokenExpressionCollection* const expression);
	bool SetTokenExpression(const TokenExpressionCollection* const expression);
	bool SetTokenExpressionByName(const char* name);

	virtual const char* GetSettingsTabPath(const CPoint& point) const override;
	virtual const void* GetSettingsTabInitInfo(const CPoint& point) const override;

//	void GetTextTokenData(unsigned int selectionStart, unsigned int selectionEnd) const;
//	virtual COLORREF GetBkColor() const override{return m_contentsFilteredIn ? m_filteredInColor : m_bkColor;}
	virtual COLORREF GetBkColor() const override{return m_contentsFilteredIn ? m_filteredInColor : m_backgroundColor;}

protected:
	SimpleTextWnd(const CBitmap* bitmap,
		unsigned int workspace,
		bool pinned = false,
		int minVisibleSize = 15,
//		int minWidth = 100,
		int minWidth = 20,
		int maxWidth = 0,
//		int minHeight = 50,
		int minHeight = 20,
		int maxHeight = 0,
		int minBorderWidth = 2,
		int maxBorderWidth = 2,
		const char* className = "TakionTool",
		int minTitleHeight = 0,
		int maxTitleHeight = 15,
		int titleHeight = 15);

	virtual void PreSuccessfulCreate() override;
	virtual void OnSuccessfulCreate() override;
	virtual void BeforeDestroy() override;
	virtual void DoPaintClient(const RECT& interRect, CDC& dc) override;
//	virtual void BeforeDestroy();
	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;

//	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
//	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
//	afx_msg void OnMButtonDown(UINT nFlags, CPoint point);
//	afx_msg void OnSetFocus(CWnd* pOldWnd);
//	afx_msg void OnKillFocus(CWnd* pNewWnd);

	afx_msg void OnVScroll(UINT nCode, UINT nPos, CScrollBar* pScrollBar);
//	afx_msg void OnHScroll(UINT nCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	DECLARE_MESSAGE_MAP()

	virtual void MouseLeft() override;
	virtual bool ClientSetCursor() override;
	virtual void ScrollOnTitleResize(int scrollAmount) override;

	void UpdateRowCount(int oldWidth = 0);
//	void UpdateHorizontalScroll();
	void UpdateVerticalScroll();

	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;
	virtual void AddMenuItems(CMenu& menu) override;
//	virtual void AddRowPropertiesMenuItems(CMenu& popupMenu);
//	virtual void ToolShown(){}
//	virtual void DoPaint(const RECT& rcPaint, CDC& dc);
	virtual void DoSize(UINT nType, int cx, int cy, int oldX, int oldY) override;
	virtual void SizeHorizontal(int cx, int cy, int oldX, int oldY) override;
	virtual void SizeVertical(int cx, int cy, int oldX, int oldY) override;
	virtual void OnTitleResize() override;
	virtual void UpdateTitleRects() override;
	virtual bool ResizeBorder(int borderWidth) override;
	virtual void DoActivate(UINT state, bool minimized) override;//, CWnd* pWndOther) override;

	void OnSizeHorizontal();

	void UpdateMetrics();

	void UpdateTextRectHeight();
	void UpdateRowsFit();
//	void DoUpdateClipRgn();

	void ClearSelection();
	
	std::string m_text;
	std::string m_textAsOneLine;
	StringVector m_lines;
	StringVector m_wordBrokenLines;
	StringVector::const_iterator m_linesBegin;
	StringVector::const_iterator m_linesEnd;
	StringVector::const_iterator m_wordBrokenLinesBegin;
	StringVector::const_iterator m_wordBrokenLinesEnd;

	UIntVector m_wordBrokenLengths;
	UIntVector::const_iterator m_wordBrokenLengthsBegin;
	UIntVector::const_iterator m_wordBrokenLengthsEnd;

	unsigned int m_maxTextWidth;
	unsigned int m_maxTextBreakWidth;
	unsigned int m_spaceWidth;
	unsigned int m_tabWidth;
	unsigned int m_lineFeedWidth;
/*
	CScrollBar m_horizontalScrollBar;
	SCROLLINFO m_horizontalScrollInfo;
	bool m_useHorizontalScroll;
	bool m_horizontalScrollVisible;
	int m_horizontalScrollSize;
*/
	CScrollBar m_verticalScrollBar;
	SCROLLINFO m_verticalScrollInfo;
	bool m_useVerticalScroll;
	bool m_verticalScrollVisible;
	int m_verticalScrollSize;

	short m_accumulatedWheel;

	COLORREF m_textColor;
	COLORREF m_selectionColor;
	COLORREF m_textSelectionColor;
	CRect m_textRect;
//	CRgn m_clipRgn;
	unsigned int m_textRectHeight;
	unsigned int m_rowsFit;
	bool m_rowsFitPartial;
	unsigned int m_rowCount;
	unsigned int m_textHeight;
	unsigned int m_rowHeight;
	int m_rowOffsetX;
	int m_rowOffsetY;
	unsigned char m_horizontalSpacing;
	unsigned char m_verticalSpacing;
	FontDescription m_fontDescription;
	FontDescription m_fontDescriptionCustom;
	CFont* m_font;
	bool m_fontCustom;

//	void SetMouseFocus();
	void BuildCaret();
	void UpdateCaretPosition();
	void ShowCaret();
	void HideCaret();
	void DestroyCaret();
	void BringCaretToView(bool toUpdatePosition);
	bool m_caretShown;
//	bool m_hasFocus;
	int m_caretWidth;

	unsigned int FindCharPosInLine(const unsigned int& x, const std::string& text, unsigned int& atX) const
	{
		HGDIOBJ oldFont = SelectObject(m_dc, *m_font);
		unsigned int atPos = U_FindCharPosInLine(m_dc, x, text, atX);
		SelectObject(m_dc, oldFont);
		return atPos;
	}
	void UpdateSelectionEnd(const unsigned int& x)
	{
		m_charSelectionEnd = FindCharPosInLine(x, m_wordBrokenLines[m_lineSelectionEnd], m_xSelectionEnd);
	}

	int m_linePressed;
	unsigned int m_xPressed;
	unsigned int m_charPressed;

	unsigned int m_lineSelectionStart;
	unsigned int m_xSelectionInitial;
	unsigned int m_xSelectionStart;
	unsigned int m_charSelectionStart;

	unsigned int m_lineSelectionEnd;
	unsigned int m_xSelectionEnd;
	unsigned int m_charSelectionEnd;

	void UpdateSelectionStartAndLength();
	void UpdateSelectionData();
	unsigned int m_selectionStart;
	unsigned int m_selectionEnd;

	void SetVerticalTimer(const CPoint& point);
	bool CanScrollRowBottom() const;
	void SetRowDragTimer(DragTimerDirection direction);
	DragTimerDirection m_rowDragTimerDirection;
	unsigned int m_rowDragTimerMillisecond;
	void UpdateRowDragTimerDelayFactor(unsigned int distance);
	unsigned int m_rowDragTimerCount;
	unsigned int m_rowDragTimerDelayFactorMax;
	unsigned int m_rowDragTimerDelayFactor;
	unsigned int m_rowDragTimerDelayDistance;

	void UpdateURLs();

	typedef std::list<std::string*> StringPtrList;

	typedef std::multimap<unsigned int, CRect> RectMap;

	class UrlRect : public CRect
	{
	public:
		UrlRect(const std::string* const& url, const int& left = 0, const int& top = 0, const int& right = 0, const int& bottom = 0):
			CRect(left, top, right, bottom),
			m_url(url)
		{}
		UrlRect():CRect(0, 0, 0, 0), m_url(NULL){}

		const std::string* const& GetUrl() const{return m_url;}
		void SetUrl(const std::string* const& url){m_url = url;}
		void Clear(){left = top = right = bottom = 0; m_url = NULL;}
	protected:
		const std::string* m_url;
	};
	typedef std::multimap<unsigned int, UrlRect> UrlRectMap;

	void DestroyUrlList();
	StringPtrList m_urlList;
	UrlRectMap m_urlRects;
	UrlRectMap::const_iterator m_urlRectsBegin;
	UrlRectMap::const_iterator m_urlRectsEnd;
	void UpdateInUrl(const CPoint& point);
	void SetInUrl(const bool inUrl);
	bool VisitUrlUnderMouse() const;
	bool DoVisitUrlUnderMouse() const;
	COLORREF m_highlightURLsColor;
	UrlRect m_rectUrlUnderMouse;
	UrlRect m_rectUrlPressed;
	bool m_inUrl;
	bool m_highlightURLs;
	bool m_dblClkVisitURL;

	virtual void DoUpdateTitle() override;
	std::string m_titleString;

//TextFiltering
	void ClearTextFilter();
	void ClearTextFilterInfo();

	void OnSetTokenExpression();
	const TokenExpressionCollection* m_textFilter;
	std::string m_textFilterName;

	bool UpdateFilterTokens();
	bool UpdateFilteredIn();

	void AdjustRects(int scrollAmount);

	void AddTokens(unsigned int selectionStart, unsigned int selectionEnd, RectMap& rects) const;

	typedef std::map<std::string, bool> StringBoolMap;//bool - WHole WOrd

	StringBoolMap m_highlightTokenCiMap;
	StringBoolMap::const_iterator m_highlightTokenCiMapBegin;
	StringBoolMap::const_iterator m_highlightTokenCiMapEnd;

	StringBoolMap m_highlightTokenCsMap;
	StringBoolMap::const_iterator m_highlightTokenCsMapBegin;
	StringBoolMap::const_iterator m_highlightTokenCsMapEnd;

	RectMap m_filterTokens;
	RectMap::const_iterator m_filterTokensBegin;
	RectMap::const_iterator m_filterTokensEnd;

	COLORREF m_highlightFilterTokensColor;
	COLORREF m_filteredInColor;
	bool m_highlightFilterTokens;
	bool m_highlightFilteredIn;

	bool m_contentsFilteredIn;
//
//	void AddDoubleClickActionMenuItems(CMenu& menu);
	HCURSOR m_cursorFinger;
	HCURSOR m_cursorFingerTransparent;
	HCURSOR m_beamCursor;
private:
//	SimpleTextWnd::SimpleTextWnd(const SimpleTextWnd& other):TakionTitleTool(other){}
	SimpleTextWnd& operator=(const SimpleTextWnd& other){return *this;}
};

class TGUI_API NewsContentsWnd : public SimpleTextWnd
{
public:
	NewsContentsWnd(const CBitmap* bitmap, unsigned int workspace, bool pinned = false);
	virtual COLORREF GetBkColor() const override{return m_newsConnected ? m_error ? m_colorError : SimpleTextWnd::GetBkColor() : m_colorDisconnected;}
	virtual const char* GetToolId() const override{return toolNewsContentsId;}
	virtual void toString(std::string& str, unsigned int contentModifier) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual void fromScratch() override;
	virtual void AddToSpecificToolCollection() override;

	virtual bool CanHavePrefix() const override{return true;}

	virtual void UpdateTextGraphics(const Graphics* graphics) override;
	virtual bool UpdateTextGraphicsColorsCustom(const GraphicsColorCollection* colorCollection) override;
	virtual bool UpdateTextGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL) override;

	virtual TakionTool* Clone() const override;
	void MakeTemplate();
	bool SetText(const std::string& text, const char* title, const bool error);
	bool isNewsConnected() const{return m_newsConnected;}
	bool isError() const{return m_error;}
	const COLORREF& GetColorNotLoaded() const{return m_colorNotLoaded;}
	const COLORREF& GetColorDisconnected() const{return m_colorDisconnected;}
	const COLORREF& GetColorError() const{return m_colorError;}
protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;
	virtual void AddMenuItems(CMenu& menu) override;
	virtual void PostAddMenuItems(CMenu& menu) override;

	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;
//	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
//	DECLARE_MESSAGE_MAP()

//	void SetNewsLoaded();
	void SetNewsConnected(bool connected);
	virtual void BeforeDestroy() override;
	COLORREF m_colorNotLoaded;
	COLORREF m_colorDisconnected;
	COLORREF m_colorError;
	bool m_newsConnected;
	bool m_error;
};

class TGUI_API EditMnemonic : public EditSelection
{
public:
	EditMnemonic(const char* tooltipText = NULL, CToolTipCtrl* externalToolTip = NULL);
};


enum SortDirection : unsigned char
{
	SD_NOT_SORTED,
	SD_ASCENDING,
	SD_DESCENDING
};

class TGUI_API Column
{
public:
	Column(const char* name,
		unsigned short id,
		int defaultWidth,
		unsigned short ordinal,
		UINT defaultHorizontalJustification,
		bool sortable,
		bool defaultSortAscending,
		const char* tooltip,
		bool use,
		bool globalUse,
		bool createsCell,
		unsigned char useTick,
		unsigned char followable,
		bool alwaysUsed,
		bool paintText,
		bool useDefaultColor);
	DECLARE_NED_NEW
	const std::string& GetNameStr() const{return m_name;}
	const char* GetName() const{return m_name.c_str();}
	const std::string& GetTooltipStr() const{return m_tooltip;}
	const char* GetTooltip() const{return m_tooltip.c_str();}
	void SetTooltip(const char* const& tooltip){m_tooltip = tooltip;}
	const unsigned short& GetId() const{return m_id;}
	const bool& isSortable() const{return m_sortable;}
	void SetSortable(const bool& sortable){m_sortable = sortable;}
	const bool& isDefaultSortAscending() const{return m_defaultSortAscending;}
	void SetDefaultSortAscending(const bool& ascending){m_defaultSortAscending = ascending;}
	const bool& isAscending() const{return m_ascending;}
	void SetAscending(const bool& ascending){m_ascending = ascending;}
	void ToggleAscending(){m_ascending = !m_ascending;}
	const unsigned short& GetSecondarySort() const{return m_secondarySort;}
	void SetSecondarySort(const unsigned short& secondarySort){m_secondarySort = secondarySort;}
	void IncrementSecondarySort(){++m_secondarySort;}
	void DecrementSecondarySort(){if(m_secondarySort > 1)--m_secondarySort;}
	void SetDefaultWidth(const int& width){m_defaultWidth = width;}
	const int& GetDefaultWidth() const{return m_defaultWidth;}
	void SetTextWidth(const int& width){m_textWidth = width;}
	const int& GetTextWidth() const{return m_textWidth;}
	const unsigned short& GetColumnOrdinal() const{return m_ordinal;}
	void SetColumnOrdinal(const unsigned short& ordinal){m_ordinal = ordinal;}
	void IncrementOrdinal(){++m_ordinal;}
	void DecrementOrdinal(){--m_ordinal;}
//	static const unsigned int minVisibleWidth = 2;
//	bool isVisible() const{return m_textWidth >= minVisibleWidth;}
	const unsigned char& GetAlignment() const{return m_alignment;}
	void SetAlignment(const unsigned char& alignment){m_alignment = alignment;}
	const bool& isAlwaysUsed() const{return m_alwaysUsed;}
	const bool& isGlobalUse() const{return m_globalUse;}
	void SetGlobalUse(const bool& globalUse){m_globalUse = globalUse;}
	const bool& isUse() const{return m_use;}
	void SetUse(const bool& use){m_use = use;}
	bool isToCreateCell() const{return m_use && m_globalUse && m_createsCell || m_alwaysUsed;}
	const bool& CreatesCell() const{return m_createsCell;}
	bool isCreateCellModifiable() const{return m_createsCell && !m_alwaysUsed;}
	const unsigned char& GetUseTick() const{return m_useTick;}
	const unsigned char& GetFollowable() const{return m_followable;}//0 - no; 1 - can follow; 2 - can be followed
	const bool& Follows() const{return m_follows;}
	void SetFollows(const bool& follows){m_follows = follows;}
	const bool& isPaintText() const{return m_paintText;}
	void SetPaintText(const bool& paintText){m_paintText = paintText;}
	const bool& isUseDefaultColor() const{return m_useDefaultColor;}
	void SetUseDefaultColor(const bool& useDefaultColor){m_useDefaultColor = useDefaultColor;}
	const UINT& GetDefaultHorizontalJustification() const{return m_defaultHorizontalJustification;}
	void SetDefaultHorizontalJustification(const UINT& defaultHorizontalJustification){m_defaultHorizontalJustification = defaultHorizontalJustification;}
	UINT GetHorizontalJustification() const
	{
		return m_alignment ? m_alignment - 1 : m_defaultHorizontalJustification;
/*
		switch(m_alignment)
		{
			case 0:
			return m_defaultHorizontalJustification;

			case 1:
			return DT_LEFT;

			case 2:
			return DT_CENTER;

			default:
			return DT_RIGHT;
		}
*/
	}
protected:
	std::string m_name;
	unsigned short m_id;
	bool m_sortable;
	bool m_defaultSortAscending;
	int m_defaultWidth;
	int m_textWidth;
	UINT m_defaultHorizontalJustification;
	unsigned short m_ordinal;
	unsigned short m_secondarySort;
	unsigned char m_alignment;
	unsigned char m_useTick;
	bool m_ascending;
	bool m_alwaysUsed;
	bool m_globalUse;
	bool m_use;
	bool m_createsCell;
	unsigned char m_followable;//0 - no; 1 - can follow; 2 - can be followed
	bool m_follows;
	bool m_paintText;
	bool m_useDefaultColor;
	std::string m_tooltip;
};

//class RowWindow;

//#define USE_TICK

class TGUI_API RowValue
{
public:
	static const bool yesValue;//true
	static const bool noValue;//false
	virtual ~RowValue(){}
	virtual bool CanBeNegative() const{return true;}
	virtual short CompareValueToZero() const{return 0;}
	virtual bool isValueZero() const{return true;}
	virtual bool isObjectValueZero() const{return true;}
#ifdef USE_TICK
	virtual short CompareTickToZero() const{return 0;}
#endif
	virtual bool UpdateValue() = 0;
	virtual void InitValue(){}
//	virtual void InitializeValue(){}
	virtual bool isValueChanged() const{return false;}
	virtual void toString(std::string& text) const = 0;
	virtual short Compare(const RowValue& other) const = 0;
	virtual short CompareAhead(const RowValue& other) const = 0;
	virtual bool isValueEmpty() const{return false;}
	virtual bool isObjectValueEmpty() const{return false;}
	virtual void NullifyTick()
	{
#ifndef USE_TICK
		m_tickIndicator = '\0';
#endif
	}
	virtual void NullifyLastDiff() const{}
//	virtual UINT GetHorizontalJustification() const{return DT_RIGHT;}

//	bool isPaintText() const{return m_paintText;}
//	void SetPaintText(bool paintText){m_paintText = paintText;}

	virtual bool Add(const RowValue& other){return false;}
	virtual bool Subtract(const RowValue& other){return false;}
	virtual bool Adjust(const RowValue& other){return false;}
	virtual void Reset(){}
	virtual unsigned int GetCount() const{return 0;}

	void SetId(unsigned short id){m_id = id;}
	unsigned short GetId() const{return m_id;}
//	bool isUseDefaultColor() const{return m_useDefaultColor;}
//	void SetUseDefaultColor(bool useDefaultColor){m_useDefaultColor = useDefaultColor;}
//	bool isUseTick() const{return m_useTick;}
//	void SetUseTick(bool useTick){m_useTick = useTick;}
	bool isUseNeutralColor() const{return m_useNeutralColor;}
	void SetUseNeutralColor(bool useNeutralColor){m_useNeutralColor = useNeutralColor;}

	virtual unsigned int GetTickMillisecond() const{return 0;}

	virtual const char* GetStringValue() const{return NULL;}
	virtual unsigned int GetUIntValue() const{return 0;}
	virtual unsigned __int64 GetUInt64Value() const{return 0;}
	virtual int GetIntValue() const{return 0;}
	virtual Price GetPriceValue() const{return Price::priceZero;}
	virtual SignedPrice GetSignedPriceValue() const{return SignedPrice::signedPriceZero;}

	virtual void SetPosition(const PositionData* position){}
	static const bool boolValueFalse = false;
	static const bool boolValueTrue = true;
//	const RowWindow* GetRowWindow() const{return m_rowWindow;}
	virtual const bool* isComma() const{return NULL;}
	virtual void SetComma(const bool* comma){}
	virtual const unsigned char* GetDecDigits() const{return NULL;}
	virtual void SetDecDigits(const unsigned char* decDigits){}
	virtual const bool* isTruncate() const{return NULL;}
	virtual void SetTruncate(const bool* truncate){}
	bool isInitialized() const{return m_initialized;}
#ifndef USE_TICK
	const char& GetTickIndicator() const{return m_tickIndicator;}
#endif

	static bool DivideMoneyByPrice(Money& value, const Price& price)
	{
		unsigned __int64 dollars = (price * 10000).GetDollars();
		if(dollars)
		{
			value.SetValue((value.GetDollars() * 10000 + value.GetDollarFraction()) * 100, 0);
//			value *= 1000000;
			value /= dollars;
			return true;
		}
		else
		{
			dollars = (price * 1000000).GetDollars();
			if(dollars)
			{
				value.SetValue((value.GetDollars() * 10000 + value.GetDollarFraction()) * 10000, 0);
//				value *= 100000000;
				value /= dollars;
				return true;
			}
		}
		return false;
	}
	static bool DivideMoneyBySignedPrice(Money& value, const SignedPrice& price)
	{
		__int64 dollars = (price * 10000).GetDollars();
		if(dollars)
		{
			value.SetValue((value.GetDollars() * 10000 + value.GetDollarFraction()) * 100, 0);
//			value *= 1000000;
			value /= dollars;
			return true;
		}
		else
		{
			dollars = (price * 1000000).GetDollars();
			if(dollars)
			{
				value.SetValue((value.GetDollars() * 10000 + value.GetDollarFraction()) * 10000, 0);
//				value *= 100000000;
				value /= dollars;
				return true;
			}
		}
		return false;
	}
	static bool DivideMoneyByMoney(Money& value, const Money& denominator)
	{
		return value.DivideByMoney(denominator);
/*
		if(denominator.isZero())
		{
			value.SetZero();
			return false;
		}
		else
		{
			value.SetValue(value.GetDollars() * 10000 + value.GetDollarFraction(), 0);
			value /= denominator.GetDollars() * 10000 + denominator.GetDollarFraction();
			return true;
		}
*/
	}
	static bool DivideMoneyByMoneyPercent(Money& value, const Money& denominator)
	{
		return value.DivideByMoneyPercent(denominator);
/*
		if(denominator.isZero())
		{
			value.SetZero();
			return false;
		}
		else
		{
			value.SetValue((value.GetDollars() * 10000 + value.GetDollarFraction()) * 100, 0);
			value /= denominator.GetDollars() * 10000 + denominator.GetDollarFraction();
			return true;
		}
*/
	}

//	static const int zeroDiff;
	virtual int GetLastIntDiff() const{return 0;}//zeroDiff;}
	virtual unsigned int GetTrueCount() const{return 0;}
protected:
	RowValue(bool useEmptyValue, bool useNeutralColor, bool useTick = true):
		m_id(0xFFFF),
//		m_useDefaultColor(false),
		m_useNeutralColor(useNeutralColor),
//		m_useTick(useTick),
//		m_paintText(true),
		m_useEmptyValue(useEmptyValue),
#ifndef USE_TICK
		m_tickIndicator('\0'),
#endif
		m_initialized(false){}
//	const RowWindow* m_rowWindow;
	unsigned short m_id;
//	bool m_useDefaultColor;
	bool m_useNeutralColor;
//	bool m_useTick;
//	bool m_paintText;
	bool m_useEmptyValue;
#ifndef USE_TICK
	char m_tickIndicator;
#endif
	bool m_initialized;
//Can be a problem if somehow the drawing is done using multithreading. Should not be the case.
	static char num[44];
};

template<class V>
class TypedRowValue : public RowValue
{
public:
//	static const V zeroValue = zero;
	typedef V ValueType;
//	typename typedef std::make_signed<ValueType>::type SignedValueType;

//	virtual UINT GetHorizontalJustification() const{return DT_LEFT;}
	virtual short CompareValue(const ValueType& other) const{return m_value < other ? -1 : other < m_value ? 1 : 0;}
	virtual short Compare(const RowValue& other) const override{return CompareValue(((const TypedRowValue&)other).m_value);}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(GetObjectValue());}

	virtual const ValueType& GetObjectValue() const{return m_value;}
	virtual bool isValueChanged() const override{return m_value != GetObjectValue();}

	const ValueType& GetValue() const{return m_value;}
	virtual bool SetValue(const ValueType& value)// in future we can add the time when the change happened
	{
		if(m_value != value)
		{
			if(!m_initialized)
			{
				m_initialized = true;
			}
			m_value = value;
			return true;
		}
		return false;
	}
	virtual bool UpdateValue() override{return SetValue(GetObjectValue());}
	virtual void InitValue() override
	{
		InitializeValue();
//		if(m_value != m_emptyValue)m_initialized = true;
		if(!isValueZero())m_initialized = true;
	}
//	bool CheckValueEmpty() const{return m_useEmptyValue && !CompareValueToZero();}
//	virtual bool isValueEmpty() const{return CheckValueEmpty();}
	virtual bool isValueEmpty() const override{return m_useEmptyValue && isValueZero();}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && isObjectValueZero();}//GetObjectValue() == m_emptyValue;}
protected:
	TypedRowValue(const ValueType& value, bool useEmptyValue = false, bool useNeutralColor = false, bool useTick = true):RowValue(useEmptyValue, useNeutralColor, useTick), m_value(value){}
//	TypedRowValue(const V& value, bool useEmptyValue = false, bool useNeutralColor = false, bool useTick = true):RowValue(useEmptyValue, useNeutralColor, useTick), m_value(value), m_emptyValue(value),m_initialized(false){}
//	TypedRowValue(const V& value, const V& emptyValue, bool useEmptyValue = false, bool useNeutralColor = false, bool useTick = true):RowValue(useEmptyValue, useNeutralColor, useTick), m_value(value), m_emptyValue(emptyValue), m_useEmptyValue(useEmptyValue),m_initialized(false){}
	virtual void InitializeValue(){m_value = GetObjectValue();}
	ValueType m_value;
//	V m_emptyValue;
//	bool m_useEmptyValue;
//	bool m_initialized;
};

template<class V>
class EmptyTypedRowValue : public TypedRowValue<V>
{
public:
	EmptyTypedRowValue(const ValueType& value, bool useEmptyValue = true, bool useNeutralColor = true, bool useTick = false):TypedRowValue(value, useEmptyValue, useNeutralColor, useTick){}
	virtual bool isValueChanged() const override{return false;}

	virtual bool SetValue(const ValueType& value) override{return false;}
	virtual bool UpdateValue() override{return false;}

	virtual void InitValue() override{}
	virtual bool isValueEmpty() const override{return m_useEmptyValue;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue;}
	virtual bool isValueZero() const override{return true;}
	virtual bool isObjectValueZero() const override{return true;}
	virtual bool CanBeNegative() const override{return false;}
	virtual short CompareValueToZero() const override{return 0;}
	virtual void toString(std::string& text) const override{}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue(){}
};

class TGUI_API CharPtrRowValue : public TypedRowValue<const char*>
{
public:
	CharPtrRowValue(bool caseInsensitive = false):TypedRowValue("", false, false, false), m_caseInsensitive(caseInsensitive){}
	virtual void toString(std::string& text) const override{text += m_value;}
//	virtual short CompareValue(const char* const& other) const override{int ret = m_caseInsensitive ? _strcmpi(m_value, other) : strcmp(m_value, other); return ret < 0 ? -1 : ret > 0 ? 1 : 0;}
	virtual short CompareValue(const ValueType& other) const override{const int ret = m_caseInsensitive ? _strcmpi(m_value, other) : strcmp(m_value, other); return ret < 0 ? -1 : ret > 0 ? 1 : 0;}
	virtual bool isValueChanged() const override{return strcmp(m_value, GetObjectValue()) != 0;}
//	virtual bool isValueEmpty() const{return m_useEmptyValue && strcmp(m_value, m_emptyValue) == 0;}
//	virtual bool isObjectValueEmpty() const{return m_useEmptyValue && strcmp(GetObjectValue(), m_emptyValue) == 0;}
	virtual short CompareValueToZero() const override{return !*m_value ? 0 : 1;}
	virtual bool isValueZero() const override{return !*m_value;}
	virtual bool isObjectValueZero() const override{return !*GetObjectValue();}
	virtual bool CanBeNegative() const override{return false;}
	DECLARE_NED_NEW
protected:
	bool m_caseInsensitive;
};

class TGUI_API AccountIdRowValue : public TypedRowValue<AccountId>
{
public:
	AccountIdRowValue():TypedRowValue(AccountId(), false, false, false){}
	virtual void toString(std::string& text) const override{text += m_value.GetId();}
	virtual short CompareValue(const ValueType& other) const override{const char ret = m_value.CompareAsStrings(other); return ret < 0 ? -1 : ret > 0 ? 1 : 0;}
//	virtual bool isValueChanged() const override{return strcmp(m_value, GetObjectValue()) != 0;}
	virtual short CompareValueToZero() const override{return !m_value ? 0 : 1;}
	virtual bool isValueZero() const override{return !m_value;}
	virtual bool isObjectValueZero() const override{return !GetObjectValue();}
	virtual bool CanBeNegative() const override{return false;}
	DECLARE_NED_NEW
protected:
	bool m_caseInsensitive;
};

template<class V>//, class D = V>
class TypedNumericRowValue : public TypedRowValue<V>
{
public:
	typename typedef std::make_signed<ValueType>::type SignedValueType;

//	static const ValueType zero;
//	virtual UINT GetHorizontalJustification() const{return DT_RIGHT;}
//	virtual short CompareToZero(const SignedValueType& value) const{return 0;}

	virtual short CompareToZero(const SignedValueType& value) const{return value > 0 ? 1 : value < 0 ? -1 : 0;}
	virtual short CompareValueToZero() const override{return m_value > 0 ? 1 : m_value < 0 ? -1 : 0;}
	virtual bool isValueZero() const override{return !m_value;}
	virtual bool isObjectValueZero() const override{return !GetObjectValue();}

	const SignedValueType& GetLastDiff() const{return m_lastDiff;}
	virtual bool SetValue(const ValueType& value) override
	{
		CalculateTick(value, m_lastDiff);
		if(m_value != value)
		{
			if(m_initialized)
			{
#ifdef USE_TICK
				m_tick = m_lastDiff;
				if(m_tick)m_tickMillisecond = TL_GetCurrentMillisecond();
#else
				m_tickIndicator = (char)CompareToZero(m_lastDiff);
				if(m_tickIndicator)m_tickMillisecond = TL_GetCurrentMillisecond();
#endif
			}
			else
			{
				m_initialized = true;
			}
			m_value = value;
			return true;
		}
		return false;
	}

	virtual void NullifyTick() override
	{
#ifdef USE_TICK
		m_tick -= m_tick;
#else
		m_tickIndicator = '\0';
#endif
		m_tickMillisecond = 0;
	}
	virtual void NullifyLastDiff() const override{m_lastDiff -= m_lastDiff;}

	virtual unsigned int GetTickMillisecond() const override{return m_tickMillisecond;}

#ifdef USE_TICK
	const SignedValueType& GetTick() const{return m_tick;}
	short CompareTickToZero() const{return CompareToZero(m_tick);}
#endif
	virtual bool Add(const RowValue& other) override{return SetValue(m_value + ((const TypedNumericRowValue&)other).m_value);}
	virtual bool Subtract(const RowValue& other) override{return SetValue(m_value - ((const TypedNumericRowValue&)other).m_value);}
	virtual bool Adjust(const RowValue& other) override
	{
//		return SetValue(m_value + ((const TypedNumericRowValue&)other).m_lastDiff);
		const SignedValueType& lastDiff = ((const TypedNumericRowValue&)other).m_lastDiff;
		return CompareToZero(lastDiff) && SetValue(m_value + lastDiff);
	}
	virtual void Reset() override{m_value -= m_value;}
protected:
	TypedNumericRowValue(const ValueType& value, bool useEmptyValue = false, bool useNeutralColor = false, bool useTick = true):
		TypedRowValue(value, useEmptyValue, useNeutralColor, useTick),
		m_lastDiff(value - value),
#ifdef USE_TICK
		m_tick(m_lastDiff),
#endif
		m_tickMillisecond(0)
	{}
	virtual void CalculateTick(const ValueType& newValue, SignedValueType& tick){tick = newValue - m_value;}
	mutable SignedValueType m_lastDiff;
#ifdef USE_TICK
	SignedValueType m_tick;
#endif
	unsigned int m_tickMillisecond;
};

template<class V>//unsigned type
class TypedAbsRowValue : public TypedRowValue<V>
{
public:
	typename typedef std::make_signed<ValueType>::type SignedValueType;
	virtual bool CanBeNegative() const override{return false;}
	virtual short CompareValueToZero() const override{return !m_value ? 0 : 1;}

	virtual short CompareAhead(const RowValue& other) const override
	{
		const SignedValueType& signedValue = GetObjectSignedValue();
		return -((const TypedRowValue&)other).CompareValue((ValueType)(signedValue < 0 ? -signedValue : signedValue));
	}

	virtual bool isValueChanged() const override
	{
		const SignedValueType& signedValue = GetObjectSignedValue();
		return m_value != (ValueType)(signedValue < 0 ? -signedValue : signedValue);
	}

	virtual bool UpdateValue() override
	{
		const SignedValueType& signedValue = GetObjectSignedValue();
		return SetValue((ValueType)(signedValue < 0 ? -signedValue : signedValue));
	}

	virtual short CompareToZero(const SignedValueType& value) const{return value > 0 ? 1 : value < 0 ? -1 : 0;}
	virtual bool isValueZero() const override{return !m_value;}
	virtual bool isObjectValueZero() const override{return !GetObjectSignedValue();}

	virtual const SignedValueType& GetObjectSignedValue() const = 0;// {return m_value; }
protected:
	TypedAbsRowValue(const ValueType& value, const bool& useEmptyValue = false, const bool& useTick = true):
		TypedRowValue(value, useEmptyValue, true, useTick)
	{}
	virtual void InitializeValue() override
	{
		const SignedValueType& signedValue = GetObjectSignedValue();
		m_value = (ValueType)(signedValue < 0 ? -signedValue : signedValue);
	}
};

template<class V>//, class D = V>
class TypedNumericAbsRowValue : public TypedAbsRowValue<V>
{
public:
	const SignedValueType& GetLastDiff() const{return m_lastDiff;}
	virtual bool SetValue(const ValueType& value) override
	{
		CalculateTick(value, m_lastDiff);
		if(m_value != value)
		{
			if(m_initialized)
			{
#ifdef USE_TICK
				m_tick = m_lastDiff;
				if(m_tick)m_tickMillisecond = TL_GetCurrentMillisecond();
#else
				m_tickIndicator = (char)CompareToZero(m_lastDiff);
				if(m_tickIndicator)m_tickMillisecond = TL_GetCurrentMillisecond();
#endif
			}
			else
			{
				m_initialized = true;
			}
			m_value = value;
			return true;
		}
		return false;
	}

	virtual void NullifyTick() override
	{
#ifdef USE_TICK
		m_tick -= m_tick;
#else
		m_tickIndicator = '\0';
#endif
		m_tickMillisecond = 0;
	}
	virtual void NullifyLastDiff() const override{m_lastDiff -= m_lastDiff;}

	virtual unsigned int GetTickMillisecond() const override{return m_tickMillisecond;}

#ifdef USE_TICK
	const SignedValueType& GetTick() const{return m_tick;}
	short CompareTickToZero() const{return CompareToZero(m_tick);}
#endif
	virtual bool Add(const RowValue& other) override{return SetValue(m_value + ((const TypedNumericAbsRowValue&)other).m_value);}
	virtual bool Subtract(const RowValue& other) override{return SetValue(m_value - ((const TypedNumericAbsRowValue&)other).m_value);}
	virtual bool Adjust(const RowValue& other) override
	{
		const SignedValueType& lastDiff = ((const TypedNumericAbsRowValue&)other).m_lastDiff;
		switch(CompareToZero(lastDiff))
		{
			case 1:
			return SetValue(m_value + (ValueType)lastDiff);

			case -1:
			return SetValue(m_value - (ValueType)-lastDiff);
		}
		return false;
	}
	virtual void Reset() override{m_value -= m_value;}
protected:
	TypedNumericAbsRowValue(const ValueType& value, bool useEmptyValue = false, bool useTick = true):
		TypedAbsRowValue(value, useEmptyValue, useTick),
		m_lastDiff(value - value),
#ifdef USE_TICK
		m_tick(m_lastDiff),
#endif
		m_tickMillisecond(0)
	{}
//	virtual void CalculateTick(const ValueType& newValue, SignedValueType& tick){tick = newValue - m_value;}
	virtual void CalculateTick(const ValueType& newValue, SignedValueType& tick)
	{
		tick = newValue > m_value ? newValue - m_value : -(SignedValueType)(m_value - newValue);
	}
	mutable SignedValueType m_lastDiff;
#ifdef USE_TICK
	SignedValueType m_tick;
#endif
	unsigned int m_tickMillisecond;
};

template<class V>
class CommaAbsRowValue : public TypedNumericAbsRowValue<V>
{
public:
	virtual const bool* isComma() const override{return m_comma;}
	virtual void SetComma(const bool* comma) override{m_comma = comma;}
//	virtual unsigned int GetUIntValue() const override{return m_value;}
protected:
	CommaAbsRowValue(const bool* comma, const ValueType& value, bool useEmptyValue = true, bool useTick = true):
		TypedNumericAbsRowValue(value, useEmptyValue, useTick),
		m_comma(comma)
	{}
	const bool* m_comma;
};

template<class V>
class TGUI_API UnsignedNumberAbsRowValue : public CommaAbsRowValue<V>
{
public:
	static const ValueType zero;// = 0;
//	static const ValueType one;
	UnsignedNumberAbsRowValue(const bool* comma, bool useEmptyValue = true, bool useTick = true):
		CommaAbsRowValue(comma, zero, useEmptyValue, useTick)
	{}
	virtual void toString(std::string& text) const{if(!isValueEmpty())text += U_UIntToStrWithCommas(m_value, num, sizeof(num));}
//	virtual unsigned int GetUIntValue() const override{return m_value;}
	DECLARE_NED_NEW
};

class TGUI_API UIntAbsRowValue : public UnsignedNumberAbsRowValue<unsigned int>
{
public:
	UIntAbsRowValue(const bool* comma, bool useEmptyValue = true, bool useTick = true):
		UnsignedNumberAbsRowValue(comma, useEmptyValue, useTick)
	{}
	virtual unsigned int GetUIntValue() const override{return m_value;}
	DECLARE_NED_NEW
};

template<class V>
class TGUI_API TypedSignedIntegerRowValue : public TypedNumericRowValue<V>
{
/*
public:
//	static const ValueType zero;// = 0;
	virtual short CompareToZero(const SignedValueType& value) const{return value > 0 ? 1 : value < 0 ? -1 : 0;}
	virtual short CompareValueToZero() const{return m_value > 0 ? 1 : m_value < 0 ? -1 : 0;}
	virtual bool isValueZero() const{return !m_value;}
	virtual bool isObjectValueZero() const{return !GetObjectValue();}
*/
protected:
//	TypedSignedIntegerRowValue(const ValueType& value, bool useEmptyValue = false, bool useNeutralColor = false, bool useTick = true):TypedNumericRowValue(value, useEmptyValue, useNeutralColor, useTick){}
	TypedSignedIntegerRowValue(const ValueType& value, bool useEmptyValue, bool useNeutralColor, bool useTick):TypedNumericRowValue(value, useEmptyValue, useNeutralColor, useTick){}
};

template<class V>
class CommaRowValue : public TypedNumericRowValue<V>
{
public:
	virtual const bool* isComma() const override{return m_comma;}
	virtual void SetComma(const bool* comma) override{m_comma = comma;}
protected:
	CommaRowValue(const bool* comma, const ValueType& value, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):TypedNumericRowValue(value, useEmptyValue, useNeutralColor, useTick), m_comma(comma){}
//	CommaRowValue(const bool* comma, const ValueType& value, const ValueType& emptyValue, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):TypedNumericRowValue(value, emptyValue, useEmptyValue, useNeutralColor, useTick), m_comma(comma){}
	const bool* m_comma;
};

template<class V>
class CommaSignedIntegerRowValue : public CommaRowValue<V>
{
/*
public:
	virtual short CompareToZero(const SignedValueType& value) const{return value > 0 ? 1 : value < 0 ? -1 : 0;}
	virtual short CompareValueToZero() const{return m_value > 0 ? 1 : m_value < 0 ? -1 : 0;}
	virtual bool isValueZero() const{return !m_value;}
	virtual bool isObjectValueZero() const{return !GetObjectValue();}
*/
protected:
	CommaSignedIntegerRowValue(const bool* comma, const ValueType& value, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):CommaRowValue(comma, value, useEmptyValue, useNeutralColor, useTick){}
};

template<class V>
class DecRowValue : public CommaRowValue<V>
{
public:
	virtual const unsigned char* GetDecDigits() const{return m_decDigits;}
	virtual void SetDecDigits(const unsigned char* decDigits){m_decDigits = decDigits;}
	virtual const bool* isTruncate() const{return m_truncate;}
	virtual void SetTruncate(const bool* truncate){m_truncate = truncate;}
protected:
	DecRowValue(const bool* comma, const unsigned char* decDigits, const bool* truncate, const ValueType& value, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):CommaRowValue(comma, value, useEmptyValue, useNeutralColor, useTick), m_decDigits(decDigits), m_truncate(truncate){}
//	DecRowValue(const bool* comma, const unsigned int* decDigits, const bool* truncate, const ValueType& value, const ValueType& emptyValue, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):CommaRowValue(comma, value, emptyValue, useEmptyValue, useNeutralColor, useTick), m_decDigits(decDigits), m_truncate(truncate){}
	const unsigned char* m_decDigits;
	const bool* m_truncate;
//	static const bool m_removeTrailingZeros = false;
};

template<class V>//, class D>
class TypedUnsignedRowValue : public TypedNumericRowValue<V>//, D>
{
public:
	virtual bool CanBeNegative() const override{return false;}
	virtual short CompareValueToZero() const override{return !m_value ? 0 : 1;}
	virtual bool Adjust(const RowValue& other) override
	{
		const SignedValueType& lastDiff = ((const TypedUnsignedRowValue&)other).m_lastDiff;
		switch(CompareToZero(lastDiff))
		{
			case 1:
			return SetValue(m_value + (ValueType)lastDiff);

			case -1:
			return SetValue(m_value - (ValueType)-lastDiff);
		}
		return false;
	}
protected:
	virtual void CalculateTick(const ValueType& newValue, SignedValueType& tick) override
	{
		tick = newValue > m_value ? newValue - m_value : -(SignedValueType)(m_value - newValue);
	}
	TypedUnsignedRowValue(const ValueType& value, bool useEmptyValue, bool useTick):TypedNumericRowValue(value, useEmptyValue, true, useTick){}
};

template<class V>//, class D>
class CommaUnsignedRowValue : public TypedUnsignedRowValue<V>//, D>
{
public:
	virtual const bool* isComma() const override{return m_comma;}
	virtual void SetComma(const bool* comma) override{m_comma = comma;}
//	virtual void toString(std::string& text) const{if(!isValueEmpty())text += U_UnsignedNumberToStrWithCommasNoDecDigits(m_value, num, sizeof(num), *m_comma);}
protected:
	CommaUnsignedRowValue(const bool* comma, const ValueType& value, bool useEmptyValue = true, bool useTick = true):TypedUnsignedRowValue(value, useEmptyValue, useTick), m_comma(comma){}
	const bool* m_comma;
};
/*
template<class V>//, class D>
class CommaUnsignedIntegerRowValue : public CommaUnsignedRowValue<V>//, typename std::make_signed<V>::type>//D>
{
//public:
//	virtual short CompareToZero(const SignedValueType& value) const{return value > 0 ? 1 : value < 0 ? -1 : 0;}
//	virtual short CompareValueToZero() const{return m_value ? 1 : 0;}
//	virtual bool isValueZero() const{return !m_value;}
//	virtual bool isObjectValueZero() const{return !GetObjectValue();}
protected:
	CommaUnsignedIntegerRowValue(const bool* comma, const ValueType& value, bool useEmptyValue = true, bool useTick = true):CommaUnsignedRowValue(comma, value, useEmptyValue, useTick){}
};
*/
template<class V>//, class D>
class DecUnsignedRowValue : public CommaUnsignedRowValue<V>//, D>
{
public:
	virtual const unsigned char* GetDecDigits() const{return m_decDigits;}
	virtual void SetDecDigits(const unsigned char* decDigits){m_decDigits = decDigits;}
	virtual const bool* isTruncate() const{return m_truncate;}
	virtual void SetTruncate(const bool* truncate){m_truncate = truncate;}
protected:
	DecUnsignedRowValue(const bool* comma, const unsigned char* decDigits, const bool* truncate, const ValueType& value, bool useEmptyValue = true, bool useTick = true):CommaUnsignedRowValue(comma, value, useEmptyValue, useTick), m_decDigits(decDigits), m_truncate(truncate){}
	const unsigned char* m_decDigits;
	const bool* m_truncate;
};

template<class V>
class MonetaryRowValue : public DecRowValue<V>
{
protected:
	MonetaryRowValue(const bool* comma, const unsigned char* decDigits, const bool* truncate, const ValueType& value, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = false):DecRowValue(comma, decDigits, truncate, value, useEmptyValue, useNeutralColor, useTick){}
/*
	virtual short CompareToZero(const SignedValueType& value) const{return value.isPositive() ? 1 : value.isNegative() ? -1 : 0;}
	virtual short CompareValueToZero() const{return m_value.isPositive() ? 1 : m_value.isNegative() ? -1 : 0;}
	virtual bool isValueZero() const{return m_value.isZero();}
	virtual bool isObjectValueZero() const{return GetObjectValue().isZero();}
*/
};

class TGUI_API SignedPriceRowValue : public MonetaryRowValue<SignedPrice>
{
public:
	static const ValueType zero;
	SignedPriceRowValue(const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = false):MonetaryRowValue(comma, decDigits, truncate, zero, useEmptyValue, useTick, useNeutralColor){}
	SignedPriceRowValue(const ValueType& value, const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = false):MonetaryRowValue(comma, decDigits, truncate, value, useEmptyValue, useTick, useNeutralColor){}
	virtual void toString(std::string& text) const{if(!isValueEmpty())U_SignedPriceToStr(text, m_value, *m_decDigits, '\0', *m_comma, '\0', *m_truncate);}
	DECLARE_NED_NEW
};

class TGUI_API MoneyRowValue : public MonetaryRowValue<Money>
{
public:
	static const SignedValueType zero;
	MoneyRowValue(const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):MonetaryRowValue(comma, decDigits, truncate, zero, useEmptyValue, useTick, useNeutralColor){}
	MoneyRowValue(const ValueType& value, const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):MonetaryRowValue(comma, decDigits, truncate, value, useEmptyValue, useTick, useNeutralColor){}
	virtual void toString(std::string& text) const{if(!isValueEmpty())U_MoneyToStr(text, m_value, *m_decDigits, '\0', *m_comma, '\0', *m_truncate);}
	DECLARE_NED_NEW
};

template<class V>//, class D>
class MonetaryUnsignedRowValue : public DecUnsignedRowValue<V>//, D>
{
protected:
	MonetaryUnsignedRowValue(const bool* comma, const unsigned char* decDigits, const bool* truncate, const ValueType& value, bool useEmptyValue = false, bool useTick = true):DecUnsignedRowValue(comma, decDigits, truncate, value, useEmptyValue, useTick){}
	virtual bool CanBeNegative() const{return false;}
/*
	virtual short CompareToZero(const SignedValueType& value) const{return value.isPositive() ? 1 : value.isNegative() ? -1 : 0;}
	virtual short CompareValueToZero() const{return m_value.isPositive() ? 1 : 0;}
	virtual bool isValueZero() const{return m_value.isZero();}
	virtual bool isObjectValueZero() const{return GetObjectValue().isZero();}
*/
};

class TGUI_API PriceRowValue : public MonetaryUnsignedRowValue<Price>//, SignedPrice>
{
public:
	static const ValueType zero;
	PriceRowValue(const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useTick = true):MonetaryUnsignedRowValue(comma, decDigits, truncate, zero, useEmptyValue, useTick){}
	PriceRowValue(const ValueType& value, const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useTick = true):MonetaryUnsignedRowValue(comma, decDigits, truncate, value, useEmptyValue, useTick){}
	virtual void toString(std::string& text) const{if(!isValueEmpty())U_PriceToStr(text, m_value, *m_decDigits, 0, *m_comma, '\0', *m_truncate);}
	virtual Price GetPriceValue() const{return m_value;}
	DECLARE_NED_NEW
};

class TGUI_API UIntRowValueNoComma : public TypedUnsignedRowValue<unsigned int>//, int>
{
public:
	static const ValueType zero;// = 0;
	UIntRowValueNoComma(bool useEmptyValue = true, bool useTick = true):TypedUnsignedRowValue(zero, useEmptyValue, useTick){}
	UIntRowValueNoComma(const ValueType& value, bool useEmptyValue = true, bool useTick = true):TypedUnsignedRowValue(value, useEmptyValue, useTick){}
	virtual unsigned int GetUIntValue() const override{return m_value;}
	virtual void toString(std::string& text) const override{if(!isValueEmpty())text += U_UnsignedNumberToStrNoDecDigits(m_value, num, sizeof(num));}
	DECLARE_NED_NEW
};

template<class V>
class TGUI_API CommaUnsignedNumberRowValue : public CommaUnsignedRowValue<V>
{
public:
	virtual void toString(std::string& text) const{if(!isValueEmpty())text += U_UnsignedNumberToStrWithCommasNoDecDigits(m_value, num, sizeof(num), *m_comma);}
protected:
	CommaUnsignedNumberRowValue(const bool* comma, const ValueType& value, bool useEmptyValue = true, bool useTick = true):CommaUnsignedRowValue(comma, value, useEmptyValue, useTick) {}
};

class TGUI_API UIntRowValue : public CommaUnsignedNumberRowValue<unsigned int>//, int>
{
public:
	static const ValueType zero;// = 0;
	static const ValueType one;
	UIntRowValue(const bool* comma, bool useEmptyValue = true, bool useTick = true):CommaUnsignedNumberRowValue(comma, zero, useEmptyValue, useTick){}
	UIntRowValue(const ValueType& value, const bool* comma, bool useEmptyValue = true, bool useTick = true):CommaUnsignedNumberRowValue(comma, value, useEmptyValue, useTick){}
//	virtual void toString(std::string& text) const{if(!isValueEmpty())text += U_UnsignedNumberToStrWithCommasNoDecDigits(m_value, num, sizeof(num), *m_comma);}
	virtual unsigned int GetUIntValue() const override{return m_value;}
	DECLARE_NED_NEW
};

class TGUI_API CompactPriceRowValue : public UIntRowValue
{
public:
	CompactPriceRowValue(const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useTick = true):UIntRowValue(comma, useEmptyValue, useTick), m_decDigits(decDigits), m_truncate(truncate){}
	CompactPriceRowValue(const ValueType& value, const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useTick = true):UIntRowValue(value, comma, useEmptyValue, useTick), m_decDigits(decDigits), m_truncate(truncate){}
	virtual void toString(std::string& text) const;//{if(!isValueEmpty())TU_CompactPriceToStr(text, m_value, m_decDigits, true, '\0', m_removeTrailingZeros);}
	virtual Price GetPriceValue() const{return Price(m_value);}
	virtual const unsigned char* GetDecDigits() const{return m_decDigits;}
	virtual void SetDecDigits(const unsigned char* decDigits){m_decDigits = decDigits;}
	virtual const bool* isTruncate() const{return m_truncate;}
	virtual void SetTruncate(const bool* truncate){m_truncate = truncate;}
	DECLARE_NED_NEW
protected:
	const unsigned char* m_decDigits;
	const bool *m_truncate;
//	static const bool m_removeTrailingZeros = false;
};
/*
class TGUI_API PriceAsUIntRowValue : public UIntRowValue
{
public:
	PriceAsUIntRowValue(const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useTick = true):UIntRowValue(comma, useEmptyValue, useTick), m_decDigits(decDigits), m_truncate(truncate){}
	PriceAsUIntRowValue(const ValueType& value, const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useTick = true):UIntRowValue(value, comma, useEmptyValue, useTick), m_decDigits(decDigits), m_truncate(truncate){}
	virtual void toString(std::string& text) const;//{if(!isValueEmpty())TU_PriceToStr(text, Price(m_value), m_decDigits);}
	virtual Price GetPriceValue() const{return Price(m_value);}
	virtual const unsigned char* GetDecDigits() const{return m_decDigits;}
	virtual void SetDecDigits(const unsigned char* decDigits){m_decDigits = decDigits;}
	virtual const bool* isTruncate() const{return m_truncate;}
	virtual void SetTruncate(const bool* truncate){m_truncate = truncate;}
	DECLARE_NED_NEW
protected:
	const unsigned char* m_decDigits;
	const bool *m_truncate;
//	static const bool m_removeTrailingZeros = false;
};
*/

class TGUI_API UIntRowValueWithCount : public UIntRowValue
{
public:
	UIntRowValueWithCount(const bool* comma, bool useEmptyValue = true, bool useTick = true):UIntRowValue(comma, useEmptyValue, useTick),m_count(0){}
	virtual unsigned int GetCount() const{return m_count;}
	virtual bool Add(const RowValue& other);
	virtual bool Subtract(const RowValue& other);
	virtual void Reset(){m_value = m_count = 0;}
	virtual bool Adjust(const RowValue& other);
	DECLARE_NED_NEW
protected:
	unsigned int m_count;
};

class TGUI_API SizeRowValue : public UIntRowValue
{
public:
	SizeRowValue(const bool* comma, const bool* sizeInShares, unsigned int roundLot, bool useEmptyValue = true, bool useTick = true):UIntRowValue(comma, useEmptyValue, useTick), m_sizeInShares(sizeInShares), m_roundLot(roundLot){}
	SizeRowValue(const bool* comma, const bool* sizeInShares, unsigned int roundLot, const unsigned int& value, bool useEmptyValue = true, bool useTick = true):UIntRowValue(value, comma, useEmptyValue, useTick), m_sizeInShares(sizeInShares), m_roundLot(roundLot){}
	virtual void toString(std::string& text) const;//{if(!isValueEmpty())text += U_UIntToStrWithCommas(m_sizeInShares || !m_roundLot ? m_value : m_value / m_roundLot, num, sizeof(num));}
	DECLARE_NED_NEW
protected:
	const bool* m_sizeInShares;
	unsigned int m_roundLot;
};

class TGUI_API SplitRowValue : public UIntRowValueNoComma
{
public:
	SplitRowValue(bool useEmptyValue = true, bool useTick = true):UIntRowValueNoComma(useEmptyValue, useTick),m_numerator(0),m_denomenator(0){}
	virtual short CompareValueToZero() const{return m_numerator == m_denomenator ? 0 : 1;}
//	virtual bool isValueZero() const{return !m_value;}
//	virtual bool isObjectValueZero() const{return !GetObjectValue();}
	virtual void toString(std::string& text) const;
	virtual short CompareValue(const ValueType& other) const
	{
		return CompareToSplit(other >> 16, other & 0xFFFF);
	}
	virtual bool SetValue(const ValueType& value);
	short CompareToSplit(unsigned short numerator, unsigned short denomenator) const;
	short CalculateTickAsDouble(unsigned short numerator, unsigned short denomenator) const;
	DECLARE_NED_NEW
protected:
	virtual void CalculateTick(const ValueType& newValue, SignedValueType& tick) override
	{
		tick = CompareToSplit(newValue >> 16, newValue & 0xFFFF);
	}
	unsigned short m_numerator;
	unsigned short m_denomenator;
};

class TGUI_API UInt64RowValue : public CommaUnsignedNumberRowValue<unsigned __int64>//, __int64>
{
public:
	static const ValueType zero;
	UInt64RowValue(const bool* comma, bool useEmptyValue = true, bool useTick = true):CommaUnsignedNumberRowValue(comma, zero, useEmptyValue, useTick){}
	UInt64RowValue(const ValueType& value, const bool* comma, bool useEmptyValue = true, bool useTick = true):CommaUnsignedNumberRowValue(comma, value, useEmptyValue, useTick){}
//	virtual void toString(std::string& text) const;//{if(!isValueEmpty())text += U_UInt64ToStrWithCommas(m_value, num, sizeof(num));}
	virtual unsigned __int64 GetUInt64Value() const{return m_value;}
	DECLARE_NED_NEW
};

class TGUI_API UInt64RowValueNoComma : public TypedUnsignedRowValue<unsigned __int64>//, __int64>
{
public:
	static const ValueType zero;
	UInt64RowValueNoComma(bool useEmptyValue = true, bool useTick = true):TypedUnsignedRowValue(zero, useEmptyValue, useTick){}
	UInt64RowValueNoComma(const ValueType& value, bool useEmptyValue = true, bool useTick = true):TypedUnsignedRowValue(value, useEmptyValue, useTick){}
	virtual void toString(std::string& text) const;//{if(!isValueEmpty())text += U_UIntToStrWithCommas(m_value, num, sizeof(num));}
	virtual unsigned __int64 GetUInt64Value() const{return m_value;}
	DECLARE_NED_NEW
};

class TGUI_API VersionRowValue : public UInt64RowValueNoComma
{
public:
	VersionRowValue(bool useEmptyValue = true, bool useTick = false):UInt64RowValueNoComma(useEmptyValue, useTick){}
	VersionRowValue(const ValueType& value, bool useEmptyValue = true, bool useTick = false):UInt64RowValueNoComma(value, useEmptyValue, useTick){}
	virtual void toString(std::string& text) const;//{if(!isValueEmpty())U_VersionNumToStr(m_value, text);}
	DECLARE_NED_NEW
};

class TGUI_API PriceAsUInt64RowValue : public UInt64RowValue
{
public:
	PriceAsUInt64RowValue(const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useTick = true):UInt64RowValue(comma, useEmptyValue, useTick), m_decDigits(decDigits), m_truncate(truncate){}
	PriceAsUInt64RowValue(const ValueType& value, const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useTick = true):UInt64RowValue(value, comma, useEmptyValue, useTick), m_decDigits(decDigits), m_truncate(truncate){}
	virtual void toString(std::string& text) const;//{if(!isValueEmpty())TU_PriceToStr(text, Price(m_value), m_decDigits);}
	virtual Price GetPriceValue() const{return Price(m_value);}
	virtual const unsigned char* GetDecDigits() const{return m_decDigits;}
	virtual void SetDecDigits(const unsigned char* decDigits){m_decDigits = decDigits;}
	virtual const bool* isTruncate() const{return m_truncate;}
	virtual void SetTruncate(const bool* truncate){m_truncate = truncate;}
	DECLARE_NED_NEW
protected:
	const unsigned char* m_decDigits;
	const bool *m_truncate;
//	static const bool m_removeTrailingZeros = false;
};

class TGUI_API UShortRowValue : public TypedUnsignedRowValue<unsigned short>//, short>
{
public:
	static const ValueType zero;
	UShortRowValue(bool useEmptyValue = true, bool useTick = true):TypedUnsignedRowValue(zero, useEmptyValue, useTick){}
	UShortRowValue(const ValueType& value, bool useEmptyValue = true, bool useTick = true):TypedUnsignedRowValue(value, useEmptyValue, useTick){}
	virtual void toString(std::string& text) const;//{if(!isValueEmpty())text += U_UShortToStr(m_value, num, sizeof(num));}
	DECLARE_NED_NEW
};

class TGUI_API ShortRowValue : public TypedSignedIntegerRowValue<short>
{
public:
	static const ValueType zero;
	ShortRowValue(bool useEmptyValue = false, bool useTick = true):TypedSignedIntegerRowValue(zero, useEmptyValue, false, useTick){}
	ShortRowValue(const ValueType& value, bool useEmptyValue = false, bool useTick = true):TypedSignedIntegerRowValue(value, useEmptyValue, false, useTick){}
	virtual void toString(std::string& text) const override;//{if(!isValueEmpty())text += U_ShortToStr(m_value, num, sizeof(num));}
	DECLARE_NED_NEW
};

class TGUI_API TimeRowValue : public UIntRowValueNoComma
{
public:
	TimeRowValue(const bool* showMilliseconds, bool useEmptyValue = true, bool useTick = true):UIntRowValueNoComma(useEmptyValue, useTick), m_showMilliseconds(showMilliseconds){}
	TimeRowValue(const ValueType& value, const bool* showMilliseconds, bool useEmptyValue = true, bool useTick = true):UIntRowValueNoComma(value, useEmptyValue, useTick), m_showMilliseconds(showMilliseconds){}
	virtual void toString(std::string& text) const override{if(!isValueEmpty())U_AppendMillisecond(text, m_value, *m_showMilliseconds);}
	DECLARE_NED_NEW
protected:
	const bool* m_showMilliseconds;
};

class TGUI_API IpRowValue : public UIntRowValueNoComma
{
public:
	IpRowValue(bool useEmptyValue = true):UIntRowValueNoComma(useEmptyValue, false){}
	IpRowValue(const ValueType& value, bool useEmptyValue = true):UIntRowValueNoComma(value, useEmptyValue, false){}
	virtual void toString(std::string& text) const;//{if(!isValueEmpty())U_AppendMillisecond(text, m_value, m_showMilliseconds);}
	DECLARE_NED_NEW
};

class TGUI_API DateRowValue : public UIntRowValueNoComma
{
public:
	DateRowValue(bool useEmptyValue = true, bool useTick = false):UIntRowValueNoComma(useEmptyValue, useTick){}
	DateRowValue(const ValueType& value, bool useEmptyValue = true, bool useTick = false):UIntRowValueNoComma(value, useEmptyValue, useTick){}
	virtual void toString(std::string& text) const;//{if(!isValueEmpty())TL_DateNumToStr(m_value, text);}
	DECLARE_NED_NEW
};

class TGUI_API ThreeCharDateRowValue : public UIntRowValueNoComma
{
public:
	ThreeCharDateRowValue(bool useEmptyValue = true, bool useTick = false):UIntRowValueNoComma(useEmptyValue, useTick){}
	ThreeCharDateRowValue(const ValueType& value, bool useEmptyValue = true, bool useTick = false):UIntRowValueNoComma(value, useEmptyValue, useTick){}
	virtual void toString(std::string& text) const;//{if(!isValueEmpty())TL_DateNumToStr(m_value, text);}
	DECLARE_NED_NEW
};

class TGUI_API FullYearDateRowValue : public UIntRowValueNoComma
{
public:
	FullYearDateRowValue(bool useEmptyValue = true, bool useTick = false):UIntRowValueNoComma(useEmptyValue, useTick){}
	FullYearDateRowValue(const ValueType& value, bool useEmptyValue = true, bool useTick = false):UIntRowValueNoComma(value, useEmptyValue, useTick){}
	virtual void toString(std::string& text) const;//{if(!isValueEmpty())TL_DateNumToStr(m_value, text);}
	DECLARE_NED_NEW
};

class TGUI_API DateTimeRowValue : public UInt64RowValueNoComma
{
public:
	DateTimeRowValue(const bool* showMilliseconds, bool useEmptyValue = true, bool useTick = false):UInt64RowValueNoComma(useEmptyValue, useTick), m_showMilliseconds(showMilliseconds){}
	DateTimeRowValue(const ValueType& value, const bool* showMilliseconds, bool useEmptyValue = true, bool useTick = false):UInt64RowValueNoComma(value, useEmptyValue, useTick), m_showMilliseconds(showMilliseconds){}
	virtual void toString(std::string& text) const;//{if(!isValueEmpty())TL_DateNumToStr(m_value, text);}
	DECLARE_NED_NEW
protected:
	const bool* m_showMilliseconds;
};

template<class V>
class TGUI_API TypedUnsignedIntegerAsStrRowValue : public TypedUnsignedRowValue<V>
{
public:
//	TypedUnsignedIntegerAsStrRowValue(const bool& useEmptyValue = true):TypedUnsignedRowValue(0, useEmptyValue, false){}
	TypedUnsignedIntegerAsStrRowValue(const ValueType& value = 0, const bool& useEmptyValue = true):TypedUnsignedRowValue(value, useEmptyValue, false){}
	virtual void toString(std::string& text) const
	{
		if(!isValueZero())
		{
			U_AppendUnsignedNumberAsString(text, m_value);
/*
			const char* cursor = (const char*)&m_value;
			char c;
			for(unsigned int i = 0; i < sizeof(m_value); ++i, ++cursor)
			{
				c = *cursor;
				if(c)
				{
					text += c;
				}
				else
				{
					break;
				}
			}
*/
		}
	}
	virtual short CompareValue(const ValueType& other) const{return U_CompareUIntAsString(m_value, other);}
//	virtual UINT GetHorizontalJustification() const{return DT_LEFT;}
	DECLARE_NED_NEW
};

class TGUI_API UIntAsStrRowValue : public TypedUnsignedIntegerAsStrRowValue<unsigned int>
{
public:
	static const ValueType zero;
//	UIntAsStrRowValue(const bool& useEmptyValue = true):TypedUnsignedIntegerAsStrRowValue(useEmptyValue){}
	UIntAsStrRowValue(const ValueType& value = 0, const bool& useEmptyValue = true):
		TypedUnsignedIntegerAsStrRowValue(value, useEmptyValue)
	{}

	virtual unsigned int GetUIntValue() const override{return m_value;}
	DECLARE_NED_NEW
};

class TGUI_API UShortAsStrRowValue : public TypedUnsignedIntegerAsStrRowValue<unsigned short>
{
public:
	static const ValueType zero;
//	UShortAsStrRowValue(const bool& useEmptyValue = true):TypedUnsignedIntegerAsStrRowValue(useEmptyValue){}
	UShortAsStrRowValue(const ValueType& value = 0, const bool& useEmptyValue = true):TypedUnsignedIntegerAsStrRowValue(value, useEmptyValue){}
	DECLARE_NED_NEW
};

class TGUI_API UInt64AsStrRowValue : public TypedUnsignedIntegerAsStrRowValue<unsigned __int64>
{
public:
	static const ValueType zero;
//	UInt64AsStrRowValue(const bool& useEmptyValue = true):TypedUnsignedIntegerAsStrRowValue(useEmptyValue){}
	UInt64AsStrRowValue(const ValueType& value = 0, const bool& useEmptyValue = true):TypedUnsignedIntegerAsStrRowValue(value, useEmptyValue){}
	virtual unsigned __int64 GetUInt64Value() const{return m_value;}
	DECLARE_NED_NEW
};

class TGUI_API IntRowValueNoComma : public TypedSignedIntegerRowValue<int>
{
public:
	static const ValueType zero;
	static const ValueType one;
	static const ValueType minusOne;
	IntRowValueNoComma(bool useEmptyValue = false, bool useTick = true):TypedSignedIntegerRowValue(zero, useEmptyValue, false, useTick){}
	IntRowValueNoComma(const ValueType& value, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = false):TypedSignedIntegerRowValue(value, useEmptyValue, useNeutralColor, useTick){}//{m_value = value;}
	virtual void toString(std::string& text) const;//{if(!isValueEmpty())text += U_IntToStrWithCommas(m_value, num, sizeof(num));}
	virtual int GetIntValue() const{return m_value;}
	DECLARE_NED_NEW
};

class TGUI_API IntRowValue : public CommaSignedIntegerRowValue<int>
{
public:
	static const ValueType zero;
	static const ValueType one;
	static const ValueType minusOne;
	IntRowValue(const bool* comma, bool useEmptyValue = false, bool useTick = true):CommaSignedIntegerRowValue(comma, zero, useEmptyValue, false, useTick){}
	IntRowValue(const ValueType& value, const bool* comma, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = false):CommaSignedIntegerRowValue(comma, value, useEmptyValue, useNeutralColor, useTick){}//{m_value = value;}
	virtual void toString(std::string& text) const;//{if(!isValueEmpty())text += U_IntToStrWithCommas(m_value, num, sizeof(num));}
	virtual int GetIntValue() const{return m_value;}
	DECLARE_NED_NEW
};

class TGUI_API IntSignRowValue : public IntRowValueNoComma
{
public:
	IntSignRowValue(bool useEmptyValue = false, bool useTick = true):IntRowValueNoComma(useEmptyValue, useTick){}
	IntSignRowValue(const ValueType& value, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = false):IntRowValueNoComma(value > 0 ? 1 : value < 0 ? -1 : 0, useEmptyValue, useTick, useNeutralColor){}
	virtual void toString(std::string& text) const;//{if(!isValueEmpty())text += U_IntToStrWithCommas(m_value, num, sizeof(num));}
	virtual int GetIntValue() const{return m_value;}
	DECLARE_NED_NEW
};

class TGUI_API CompactSignedPriceRowValue : public IntRowValue
{
public:
	CompactSignedPriceRowValue(const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useTick = true):IntRowValue(comma, useEmptyValue, useTick), m_decDigits(decDigits), m_truncate(truncate){}
	CompactSignedPriceRowValue(const ValueType& value, const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useTick = true):IntRowValue(value, comma, useEmptyValue, useTick), m_decDigits(decDigits), m_truncate(truncate){}
	virtual void toString(std::string& text) const;//{if(!isValueEmpty())TU_CompactPriceToStr(text, m_value, m_decDigits, true, '\0', m_removeTrailingZeros);}
	virtual SignedPrice GetSignedPriceValue() const{return SignedPrice(m_value);}
	virtual const unsigned char* GetDecDigits() const{return m_decDigits;}
	virtual void SetDecDigits(const unsigned char* decDigits){m_decDigits = decDigits;}
	virtual const bool* isTruncate() const{return m_truncate;}
	virtual void SetTruncate(const bool* truncate){m_truncate = truncate;}
	DECLARE_NED_NEW
protected:
	const unsigned char* m_decDigits;
	const bool *m_truncate;
//	static const bool m_removeTrailingZeros = false;
};
/*Use CompactSignedPriceRowValue
class TGUI_API SignedPriceAsIntRowValue : public IntRowValue
{
public:
	SignedPriceAsIntRowValue(const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useTick = true):IntRowValue(comma, useEmptyValue, useTick), m_decDigits(decDigits), m_truncate(truncate){}
	SignedPriceAsIntRowValue(const ValueType& value, const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useTick = true):IntRowValue(value, comma, useEmptyValue, useTick), m_decDigits(decDigits), m_truncate(truncate){}
	virtual void toString(std::string& text) const;//{if(!isValueEmpty())TU_PriceToStr(text, Price(m_value), m_decDigits);}
	virtual SignedPrice GetSignedPriceValue() const{return SignedPrice(m_value);}
	virtual const unsigned char* GetDecDigits() const{return m_decDigits;}
	virtual void SetDecDigits(const unsigned char* decDigits){m_decDigits = decDigits;}
	virtual const bool* isTruncate() const{return m_truncate;}
	virtual void SetTruncate(const bool* truncate){m_truncate = truncate;}
	DECLARE_NED_NEW
protected:
	const unsigned char* m_decDigits;
	const bool *m_truncate;
};
*/
class TGUI_API Int64RowValueNoComma : public TypedSignedIntegerRowValue<__int64>
{
public:
	static const ValueType zero;
	Int64RowValueNoComma(bool useEmptyValue = false, bool useTick = true):TypedSignedIntegerRowValue(zero, useEmptyValue, false, useTick){}
	Int64RowValueNoComma(const ValueType& value, bool useEmptyValue = false, bool useTick = true):TypedSignedIntegerRowValue(value, useEmptyValue, false, useTick){}
	virtual void toString(std::string& text) const;//{if(!isValueEmpty())text += U_Int64ToStrWithCommas(m_value, num, sizeof(num));}
	DECLARE_NED_NEW
};

class TGUI_API Int64RowValue : public CommaSignedIntegerRowValue<__int64>
{
public:
	static const ValueType zero;
	Int64RowValue(const bool* comma, bool useEmptyValue = false, bool useTick = true):CommaSignedIntegerRowValue(comma, zero, useEmptyValue, false, useTick){}
	Int64RowValue(const ValueType& value, const bool* comma, bool useEmptyValue = false, bool useTick = true):CommaSignedIntegerRowValue(comma, value, useEmptyValue, false, useTick){}
	virtual void toString(std::string& text) const;//{if(!isValueEmpty())text += U_Int64ToStrWithCommas(m_value, num, sizeof(num));}
	DECLARE_NED_NEW
};

class TGUI_API StringRowValue : public TypedRowValue<std::string>
{
public:
//	StringRowValue(UINT horizontalJustification = DT_LEFT):TypedRowValue(std::string(), false),m_horizontalJustification(horizontalJustification){}
	StringRowValue():TypedRowValue(std::string(), false){}
//	StringRowValue(const ValueType& value, UINT horizontalJustification = DT_LEFT):TypedRowValue(value, false),m_horizontalJustification(horizontalJustification){}//{m_value = value;}
	StringRowValue(const ValueType& value):TypedRowValue(value, false){}//{m_value = value;}
	virtual void toString(std::string& text) const;//{text += m_value;}
	virtual bool CanBeNegative() const{return false;}
//	virtual UINT GetHorizontalJustification() const{return m_horizontalJustification;}
	virtual const char* GetStringValue() const{return m_value.c_str();}

	virtual short CompareValueToZero() const{return !m_value.length() ? 0 : 1;}
	virtual short CompareToZero(const ValueType& value) const{return !value.length() ? 0 : 1;}
	virtual bool isValueZero() const{return !m_value.length();}
	virtual bool isObjectValueZero() const{return GetObjectValue().empty();}
	DECLARE_NED_NEW
protected:
	UINT m_horizontalJustification;
};

class TGUI_API CharRowValue : public TypedSignedIntegerRowValue<char>
{
public:
	static const ValueType zero;
	CharRowValue(const ValueType& value = '\0',
		const bool& useEmptyValue = false,
		const bool& useNeutralColor = false,
		const bool& useTick = false,
		const char& invalidReplacement = '\0'):
		TypedSignedIntegerRowValue(value, useEmptyValue, useNeutralColor, useTick),
		m_invalidReplacement(invalidReplacement)
	{}
	virtual void toString(std::string& text) const override
	{
		if(!isValueEmpty())U_AppendPrintableCharIfValid(text, m_value, m_invalidReplacement);
	}
	virtual bool CanBeNegative() const override{return false;}
	virtual bool SetValue(const ValueType& value) override
	{
		if(m_value != value)
		{
			if(!m_initialized)m_initialized = true;
			m_value = value;
			return true;
		}
		return false;
	}
	DECLARE_NED_NEW
protected:
	char m_invalidReplacement;
};

class TGUI_API CharRowValueWithEmpty : public CharRowValue
{
public:
	CharRowValueWithEmpty(const ValueType& emptyValue, const ValueType& value = '\0', bool useNeutralColor = false):CharRowValue(value, true, useNeutralColor, false), m_emptyValue(emptyValue){}
	virtual bool isValueZero() const{return m_value == m_emptyValue;}
	virtual bool isObjectValueZero() const{return m_emptyValue == GetObjectValue();}
	DECLARE_NED_NEW
protected:
	ValueType m_emptyValue;
};

class TGUI_API BoolUnknownAsCharRowValue : public CharRowValue
{
public:
	BoolUnknownAsCharRowValue(const ValueType& value = '\0', bool useEmptyValue = false, bool useNeutralColor = false):
		CharRowValue(value, useEmptyValue, useNeutralColor, false){}
	virtual void toString(std::string& text) const//{if(m_value >= ' ' && (!m_useEmptyValue || m_value != m_emptyValue))text += m_value;}
	{
		if(m_value > 0)text += 'Y';
		else if(m_value < 0)text += 'N';
	}
	DECLARE_NED_NEW
protected:
};

class TGUI_API TwoCharRowValue : public UShortRowValue
{
public:
	TwoCharRowValue():UShortRowValue(true, false){}
	TwoCharRowValue(const char& value1, const char& value2):UShortRowValue(true, false){m_value = ((unsigned short)value2 << 8) | value1;}
	virtual void toString(std::string& text) const;
//	virtual UINT GetHorizontalJustification() const{return DT_CENTER;}
	DECLARE_NED_NEW
};

class TGUI_API CharAsIntRowValue : public CharRowValue
{
public:
	CharAsIntRowValue(const ValueType& value = '\0', bool useEmptyValue = false, bool useNeutralColor = false, bool useTick = false):CharRowValue(value, useEmptyValue, useNeutralColor, useTick){}
//	CharAsIntRowValue(const ValueType& value, const ValueType& emptyValue, bool useEmptyValue = false, bool useNeutralColor = false, bool useTick = false):CharRowValue(value, emptyValue, useEmptyValue, useNeutralColor, useTick){}
	virtual void toString(std::string& text) const{if(!isValueEmpty())text += U_CharAsIntToStr(m_value, num, sizeof(num));}
//	virtual UINT GetHorizontalJustification() const{return DT_RIGHT;}
//	virtual short CompareToZero(const char& value) const{return value > '\0' ? 1 : value < '\0' ? -1 : 0;}
	virtual bool CanBeNegative() const{return true;}
	DECLARE_NED_NEW
};

class TGUI_API IntAsChar3RowValueRef : public CharRowValue
{
public:
	IntAsChar3RowValueRef(const int& ref, const ValueType& valuePositive, const ValueType& valueNegative, const ValueType& valueNeutral, const ValueType& emptyValue = '\0', bool useEmptyValue = false, bool useNeutralColor = false);

	virtual const ValueType& GetObjectValue() const;
	DECLARE_NED_NEW
	virtual int GetIntValue() const{return m_intValueRef;}
	virtual bool CanBeNegative() const{return true;}
protected:
	ValueType m_valuePositive;
	ValueType m_valueNegative;
	ValueType m_valueNeutral;
	const int& m_intValueRef;
};

class TGUI_API UCharRowValue : public TypedUnsignedRowValue<unsigned char>//, char>
{
public:
	static const ValueType zero;
	UCharRowValue(bool useEmptyValue = true, bool useTick = false):TypedUnsignedRowValue(zero, useEmptyValue, useTick){}
	UCharRowValue(const ValueType& value, bool useEmptyValue = true, bool useTick = false):TypedUnsignedRowValue(value, useEmptyValue, useTick){}
	virtual void toString(std::string& text) const override//{if(!isValueEmpty())text += U_UCharToStr(m_value, num, sizeof(num));}
	{
		if(!isValueEmpty())text += U_UnsignedNumberToStrNoDecDigits(m_value, num, sizeof(num));
	}
	DECLARE_NED_NEW
};

class TGUI_API UCharCountableRowValue : public UCharRowValue
{
public:
	UCharCountableRowValue(bool useEmptyValue = true, bool useTick = false):UCharRowValue(useEmptyValue, useTick){}
	UCharCountableRowValue(const ValueType& value, bool useEmptyValue = true, bool useTick = false):UCharRowValue(value, useEmptyValue, useTick){}
//	virtual void toString(std::string& text) const;//{if(!isValueEmpty())text += U_UCharToStr(m_value, num, sizeof(num));}
	virtual void CalculateTick(const ValueType& newValue, SignedValueType& tick) override
	{
		tick = !newValue ? !m_value ? 0 : -1 :
			!m_value ? 1 : 0;
	}
	DECLARE_NED_NEW
};

class TGUI_API UCharAsCharRowValue : public UCharRowValue
{
public:
	UCharAsCharRowValue(const bool& useEmptyValue = true, const bool& useTick = false, const char& invalidReplacement = '\0'):
		UCharRowValue(useEmptyValue, useTick),
		m_invalidReplacement(invalidReplacement)
	{}
	UCharAsCharRowValue(const ValueType& value, bool useEmptyValue = true, bool useTick = false, const char& invalidReplacement = '\0'):
		UCharRowValue(value, useEmptyValue, useTick),
		m_invalidReplacement(invalidReplacement)
	{}
	virtual void toString(std::string& text) const//{if(!isValueEmpty())text += U_UCharToStr(m_value, num, sizeof(num));}
	{
		if(!isValueEmpty())U_AppendPrintableCharIfValid(text, m_value, '\0', m_invalidReplacement);
	}
	virtual bool SetValue(const ValueType& value) override
	{
		if(m_value != value)
		{
			if(!m_initialized)m_initialized = true;
			m_value = value;
			return true;
		}
		return false;
	}
	DECLARE_NED_NEW
protected:
	char m_invalidReplacement;
};

class TGUI_API UCharAsBoolRowValue : public UCharRowValue
{
public:
	UCharAsBoolRowValue(char trueValue = 'Y', char falseValue = '\0'):UCharRowValue(false, false), m_trueValue(trueValue), m_falseValue(falseValue){}
	UCharAsBoolRowValue(const ValueType& value, char trueValue = 'Y', char falseValue = '\0'):UCharRowValue(value, false, false), m_trueValue(trueValue), m_falseValue(falseValue){}
	virtual void toString(std::string& text) const{U_AppendPrintableCharIfValid(text, m_value ? m_trueValue : m_falseValue);}
//	virtual UINT GetHorizontalJustification() const{return DT_CENTER;}
	DECLARE_NED_NEW
protected:
	char m_trueValue;
	char m_falseValue;
};
/*
class TGUI_API BoolAsUCharRowValue : public UCharRowValue
{
public:
	BoolAsUCharRowValue(char trueValue = 'Y', char falseValue = '\0'):UCharRowValue(false, false), m_trueValue(trueValue), m_falseValue(falseValue){}
	BoolAsUCharRowValue(const bool& value, char trueValue = 'Y', char falseValue = '\0'):UCharRowValue(value ? 1 : 0, false, false), m_trueValue(trueValue), m_falseValue(falseValue){}
	virtual void toString(std::string& text) const;//{if(m_value){if(m_trueValue)text += m_trueValue;}else if(m_falseValue)text += m_falseValue;}
//	virtual bool isObjectValueZero() const{return !GetObjectValue();}
	DECLARE_NED_NEW
protected:
	char m_trueValue;
	char m_falseValue;
};
*/
template<class V>//, class D>
class TGUI_API FlagRowValue : public TypedUnsignedRowValue<V>//, D>
{
public:
	FlagRowValue(const ValueType& value, const ValueType& flag, char trueValue = 'Y', char falseValue = '\0', bool useEmptyValue = true, bool useTick = false):TypedUnsignedRowValue(value, useEmptyValue, useTick), m_flag(flag), m_trueValue(trueValue), m_falseValue(falseValue){}

	virtual short CompareToZero(const ValueType& value) const{return (value & m_flag) ? 1 : 0;}
	virtual short CompareValueToZero() const{return (m_value & m_flag) ? 1 : 0;}
	virtual bool isValueZero() const{return !(m_value & m_flag);}
	virtual bool isObjectValueZero() const{return !(GetObjectValue() & m_flag);}
//	virtual UINT GetHorizontalJustification() const{return DT_CENTER;}
	virtual void toString(std::string& text) const{if(m_value & m_flag){if(m_trueValue)text += m_trueValue;}else if(m_falseValue)text += m_falseValue;}
//	static const int zeroDiff;
//	virtual const int& GetLastDiff() const{return zeroDiff;}

	virtual void CalculateTick(const ValueType& newValue, SignedValueType& tick) override
	{
		const bool yes = (m_value & m_flag) != 0;
		const bool newYes = (newValue & m_flag) != 0;
		tick = yes == newYes ? 0 : yes ? -1 : 1;
	}
	virtual int GetLastIntDiff() const override{return (int)m_lastDiff;}
	virtual unsigned int GetTrueCount() const override{return (m_value & m_flag) ? 1 : 0;}
	virtual void NullifyLastDiff() const override{m_lastDiff = 0;}

	virtual short CompareValue(const ValueType& other) const
	{
		const bool yes = (m_value & m_flag) != 0;
		const bool yesOther = (other & m_flag) != 0;
		return yes == yesOther ? 0:
			yes ? 1 : -1;
//		tick = yes == newYes ? 0 : yes ? -1 : 1;
//		return m_value < other ? -1 : other < m_value ? 1 : 0;
	}
	DECLARE_NED_NEW
protected:
	ValueType m_flag;
	char m_trueValue;
	char m_falseValue;
};

class TGUI_API BoolRowValue : public TypedRowValue<bool>
{
public:
	static const ValueType zero;
	BoolRowValue(char trueValue = 'Y', char falseValue = '\0'):TypedRowValue(false, false, false, false), m_trueValue(trueValue), m_falseValue(falseValue){}
	BoolRowValue(const ValueType& value, char trueValue = 'Y', char falseValue = '\0'):TypedRowValue(value, false, false, false), m_trueValue(trueValue), m_falseValue(falseValue){}
	virtual void toString(std::string& text) const override
	{
		if(m_value)
		{
			if(m_trueValue)text += m_trueValue;
		}
		else if(m_falseValue)text += m_falseValue;
	}
//	virtual UINT GetHorizontalJustification() const{return DT_CENTER;}
	virtual bool CanBeNegative() const override{return false;}
	virtual short CompareValueToZero() const override{return m_value ? 1 : 0;}
	virtual bool isValueZero() const override{return !m_value;}
	virtual bool isObjectValueZero() const override{return !GetObjectValue();}
	virtual void Reset() override{m_value = false;}
//	static const int zeroDiff;
//	virtual const int& GetLastDiff() const{return zeroDiff;}
/*
	virtual void CalculateTick(const ValueType& newValue, SignedValueType& tick)
	{
		tick = m_value == newValue ? 0 : m_value ? -1 : 1;
	}
*/
	DECLARE_NED_NEW
protected:
	char m_trueValue;
	char m_falseValue;
};
////

class TGUI_API BoolRowValueCountable : public BoolRowValue
{
public:
	BoolRowValueCountable(char trueValue = 'Y', char falseValue = '\0'):BoolRowValue(trueValue, falseValue), m_lastDiff(0){}
	BoolRowValueCountable(const ValueType& value, char trueValue = 'Y', char falseValue = '\0'):BoolRowValue(value, trueValue, falseValue), m_lastDiff(0){}
	virtual int GetLastIntDiff() const override{return m_lastDiff;}
	virtual unsigned int GetTrueCount() const override{return m_value ? 1 : 0;}
	virtual bool SetValue(const ValueType& value) override
	{
		if(m_value != value)
		{
			UpdateLastDiffByNewValue(value);
			if(m_initialized)
			{
#ifdef USE_TICK
				m_tick = m_lastDiff;
#else
				m_tickIndicator = m_lastDiff;
#endif
//				m_tickMillisecond = TL_GetCurrentMillisecond();
			}
			else
			{
				m_initialized = true;
			}
			m_value = value;
			return true;
		}
		else
		{
			m_lastDiff = 0;
		}
		return false;
	}
	virtual void NullifyLastDiff() const override{m_lastDiff = 0;}
	DECLARE_NED_NEW
protected:
	virtual void UpdateLastDiffByNewValue(const ValueType& value){m_lastDiff = value ? 1 : -1;}
	mutable int m_lastDiff;
};

class TGUI_API BoolRowValueCountableOpposite : public BoolRowValueCountable
{
public:
	BoolRowValueCountableOpposite(char trueValue = '\0', char falseValue = 'N'):BoolRowValueCountable(true, trueValue, falseValue){}
	BoolRowValueCountableOpposite(const ValueType& value, char trueValue = '\0', char falseValue = 'N'):BoolRowValueCountable(value, trueValue, falseValue){}
	virtual unsigned int GetTrueCount() const override{return m_value ? 0 : 1;}
	virtual bool isValueZero() const override{return m_value;}
	virtual bool isObjectValueZero() const override{return GetObjectValue();}
	virtual void Reset() override{m_value = true;}
protected:
	virtual void UpdateLastDiffByNewValue(const ValueType& value){m_lastDiff = value ? -1 : 1;}
};

class TGUI_API BoolRowValueCount : public UIntRowValue
{
public:
	BoolRowValueCount(const bool* comma, bool useEmptyValue = true, bool useTick = true):UIntRowValue(comma, useEmptyValue, useTick){}
	BoolRowValueCount(const ValueType& value, const bool* comma, bool useEmptyValue = true, bool useTick = true):UIntRowValue(value, comma, useEmptyValue, useTick){}
//	virtual bool Add(const RowValue& other) override{return ((const BoolRowValue&)other).GetValue() && SetValue(m_value + 1);}
	virtual bool Add(const RowValue& other) override{return SetValue(m_value + other.GetTrueCount());}
//	virtual bool Subtract(const RowValue& other) override{return ((const BoolRowValue&)other).GetValue() && SetValue(m_value - 1);}
	virtual bool Subtract(const RowValue& other) override{return SetValue(m_value - other.GetTrueCount());}
	virtual bool Adjust(const RowValue& other) override
	{
//		const BoolRowValue& boolValue = (const BoolRowValue&)other;
//		const int lastDiff = boolValue.GetLastDiff();
		const int lastDiff = other.GetLastIntDiff();
		other.NullifyLastDiff();
		return lastDiff && SetValue(lastDiff > 0 ? m_value + 1 : m_value - 1);
	}
	DECLARE_NED_NEW
};

class TGUI_API UCharAsBoolCopyRowValue : public UCharAsBoolRowValue
{
public:
	UCharAsBoolCopyRowValue(char trueValue = 'Y', char falseValue = '\0'):UCharAsBoolRowValue(trueValue, falseValue){m_copy = m_value;}
	UCharAsBoolCopyRowValue(const ValueType& value, char trueValue = 'Y', char falseValue = '\0'):UCharAsBoolRowValue(value, trueValue, falseValue){m_copy = m_value;}
	virtual const ValueType& GetObjectValue() const override{return m_copy;}
	DECLARE_NED_NEW
//	bool SetCopyValue(const ValueType& value)
	bool SetCopyValue(const bool& value)
	{
		if(value == !m_copy)
		{
			m_copy = value ? 1 : 0;
			return true;
		}
		return false;
	}
protected:
	ValueType m_copy;
};

class TGUI_API UCharCopyRowValue : public UCharRowValue
{
public:
	UCharCopyRowValue(const bool& useEmptyValue = false):UCharRowValue(useEmptyValue, false){m_copy = m_value;}
	UCharCopyRowValue(const ValueType& value, const bool& useEmptyValue = false):UCharRowValue(value, useEmptyValue, false){m_copy = m_value;}
	virtual const ValueType& GetObjectValue() const override{return m_copy;}
	DECLARE_NED_NEW
	bool SetCopyValue(const ValueType& value)
	{
		if(value != m_copy)
		{
			m_copy = value;
			return true;
		}
		return false;
	}
protected:
	ValueType m_copy;
};

class TGUI_API UntradebleRowValue : public UCharCopyRowValue
{
public:
	UntradebleRowValue(const bool& useEmptyValue = false):UCharCopyRowValue(useEmptyValue){}
	UntradebleRowValue(const ValueType& value, const bool& useEmptyValue = false):UCharCopyRowValue(value, useEmptyValue){}
	DECLARE_NED_NEW
	virtual void toString(std::string& text) const override
	{
		switch(m_value)
		{
			case US_TRADEABLE:
			break;

			case US_UNTRADEABLE_FULL:
			text += "No";
			break;

			case US_UNTRADEABLE_PARTIAL://Can trade within borrowed size
			text += "Part";
			break;

			default:
			text += "ERR";
			break;
		}
	}
};

class TGUI_API BoolRowValueRef : public BoolRowValue
{
public:
	BoolRowValueRef(const ValueType& ref, char trueValue = 'Y', char falseValue = '\0'):BoolRowValue(ref, trueValue, falseValue),m_valueRef(ref){}
	virtual const ValueType& GetObjectValue() const override{return m_valueRef;}
	DECLARE_NED_NEW
protected:
	const ValueType& m_valueRef;
};

class TGUI_API ShortRowValueRef : public ShortRowValue
{
public:
	ShortRowValueRef(const ValueType& ref, bool useEmptyValue = true, bool useTick = true):ShortRowValue(ref, useEmptyValue, useTick),m_valueRef(ref){}
	virtual const ValueType& GetObjectValue() const override{return m_valueRef;}
	DECLARE_NED_NEW
protected:
	const ValueType& m_valueRef;
};

class TGUI_API UShortRowValueRef : public UShortRowValue
{
public:
	UShortRowValueRef(const ValueType& ref, bool useEmptyValue = true, bool useTick = true):UShortRowValue(ref, useEmptyValue, useTick),m_valueRef(ref){}
	virtual const ValueType& GetObjectValue() const override{return m_valueRef;}
	DECLARE_NED_NEW
protected:
	const ValueType& m_valueRef;
};

class TGUI_API UShortRowValueRefMinute : public UShortRowValueRef
{
public:
	UShortRowValueRefMinute(const ValueType& ref, bool useEmptyValue = true, bool useTick = true):UShortRowValueRef(ref, useEmptyValue, useTick){}
	virtual void toString(std::string& text) const override{if(!isValueEmpty())U_AppendMinute(text, m_value);}
//	virtual bool UpdateValue() override{return SetValue(GetObjectValue());}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_value = GetObjectValue();
	}
};

class TGUI_API IntRowValueRef : public IntRowValue
{
public:
	IntRowValueRef(const ValueType& ref, const bool* comma, bool useEmptyValue = true, bool useTick = false, bool useNeutralColor = false):IntRowValue(ref, comma, useEmptyValue, useTick, useNeutralColor),m_valueRef(ref){}
	virtual const ValueType& GetObjectValue() const override{return m_valueRef;}
	DECLARE_NED_NEW
	virtual int GetIntValue() const override{return m_valueRef;}
protected:
	const ValueType& m_valueRef;
};

class TGUI_API IntRowValueRefNoComma : public IntRowValueNoComma
{
public:
	IntRowValueRefNoComma(const ValueType& ref, bool useEmptyValue = true, bool useTick = false, bool useNeutralColor = false):IntRowValueNoComma(ref, useEmptyValue, useTick, useNeutralColor),m_valueRef(ref){}
	virtual const ValueType& GetObjectValue() const override{return m_valueRef;}
	DECLARE_NED_NEW
	virtual int GetIntValue() const override{return m_valueRef;}
protected:
	const ValueType& m_valueRef;
};

class TGUI_API UIntRowValueRef : public UIntRowValue
{
public:
	UIntRowValueRef(const ValueType& ref, const bool* comma, bool useEmptyValue = true, bool useTick = true):UIntRowValue(ref, comma, useEmptyValue, useTick),m_valueRef(ref){}
	virtual const ValueType& GetObjectValue() const override{return m_valueRef;}
	DECLARE_NED_NEW
protected:
	const ValueType& m_valueRef;
};

class TGUI_API UIntRowValueRefNoComma : public UIntRowValueNoComma
{
public:
	UIntRowValueRefNoComma(const ValueType& ref, bool useEmptyValue = true, bool useTick = true):UIntRowValueNoComma(ref, useEmptyValue, useTick),m_valueRef(ref){}
	virtual const ValueType& GetObjectValue() const override{return m_valueRef;}
	DECLARE_NED_NEW
protected:
	const ValueType& m_valueRef;
};

class TGUI_API UInt64RowValueRef : public UInt64RowValue
{
public:
	UInt64RowValueRef(const ValueType& ref, const bool* comma, bool useEmptyValue = true, bool useTick = true):
		UInt64RowValue(ref, comma, useEmptyValue, useTick),m_valueRef(ref){}
	virtual const ValueType& GetObjectValue() const override{return m_valueRef;}
	DECLARE_NED_NEW
protected:
	const ValueType& m_valueRef;
};

class TGUI_API StringRowValueRef : public StringRowValue
{
public:
	StringRowValueRef(const ValueType& ref):StringRowValue(ref), m_valueRef(ref){}
	virtual const ValueType& GetObjectValue() const override{return m_valueRef;}
	DECLARE_NED_NEW
protected:
	const ValueType& m_valueRef;
};

class TGUI_API PriceRowValueRef : public PriceRowValue
{
public:
	PriceRowValueRef(const ValueType& ref, const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useTick = true):
		PriceRowValue(ref, comma, decDigits, truncate, useEmptyValue, useTick),m_valueRef(ref){}
	virtual const ValueType& GetObjectValue() const override{return m_valueRef;}
	virtual Price GetPriceValue() const override{return m_valueRef;}
	DECLARE_NED_NEW
protected:
	const ValueType& m_valueRef;
};

class TGUI_API PriceRowValueRefZeroValue : public PriceRowValueRef
{
public:
	PriceRowValueRefZeroValue(const ValueType& ref, const ValueType& emptyValue, const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useTick = true):
		PriceRowValueRef(ref, comma, decDigits, truncate, true, useTick),m_emptyValue(emptyValue){}
	virtual bool isValueZero() const override{return m_value == m_emptyValue;}
	virtual bool isObjectValueZero() const override{return GetObjectValue() == m_emptyValue;}
	DECLARE_NED_NEW
protected:
	ValueType m_emptyValue;
};

class TGUI_API CompactPriceRowValueRef : public CompactPriceRowValue
{
public:
	CompactPriceRowValueRef(const ValueType& ref, const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useTick = true):
		CompactPriceRowValue(ref, comma, decDigits, truncate, useEmptyValue, useTick),m_valueRef(ref){}
	virtual const ValueType& GetObjectValue() const override{return m_valueRef;}
	virtual Price GetPriceValue() const override{return Price(m_valueRef);}
	DECLARE_NED_NEW
protected:
	const ValueType& m_valueRef;
};

class TGUI_API CompactSignedPriceRowValueRef : public CompactSignedPriceRowValue
{
public:
	CompactSignedPriceRowValueRef(const ValueType& ref, const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useTick = true):
		CompactSignedPriceRowValue(ref, comma, decDigits, truncate, useEmptyValue, useTick),m_valueRef(ref){}
	virtual const ValueType& GetObjectValue() const override{return m_valueRef;}
	virtual SignedPrice GetSignedPriceValue() const override{return SignedPrice(m_valueRef);}
	DECLARE_NED_NEW
protected:
	const ValueType& m_valueRef;
};

class TGUI_API SignedPriceRowValueRef : public SignedPriceRowValue
{
public:
	SignedPriceRowValueRef(const ValueType& ref, const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		SignedPriceRowValue(ref, comma, decDigits, truncate, useEmptyValue, useTick, useNeutralColor),m_valueRef(ref){}
	virtual const ValueType& GetObjectValue() const override{return m_valueRef;}
	DECLARE_NED_NEW
protected:
	const ValueType& m_valueRef;
};

class TGUI_API MoneyRowValueRef : public MoneyRowValue
{
public:
	MoneyRowValueRef(const ValueType& ref, const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useTick = true):
		MoneyRowValue(ref, comma, decDigits, truncate, useEmptyValue, false, useTick),
		m_valueRef(ref)
	{}
	virtual const ValueType& GetObjectValue() const override{return m_valueRef;}
	DECLARE_NED_NEW
protected:
	const ValueType& m_valueRef;
};

class TGUI_API MoneyRowValueAverage64Ref : public MoneyRowValue
{
public:
	MoneyRowValueAverage64Ref(const ValueType& moneyRef, const unsigned __int64& volumeRef, const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = true):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_volumeRef(volumeRef),
		m_moneyRef(moneyRef)
	{}

	Money CalculateValue() const{return m_volumeRef && !m_moneyRef.isZero() ? m_moneyRef / m_volumeRef : Money::moneyZero;}
	Money DeriveValue() const{return m_volume && !m_money.isZero() ? m_money / m_volume : Money::moneyZero;}
	virtual bool isValueChanged() const override{return m_volume != m_volumeRef || m_money != m_moneyRef;}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_volume = m_volumeRef;
		m_money = m_moneyRef;
		return SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return !m_volumeRef || m_moneyRef.isZero();}
	virtual bool isValueZero() const override{return !m_volume || m_money.isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_volume = m_volumeRef;
		m_money = m_moneyRef;
		m_value = DeriveValue();
	}
	const unsigned __int64& m_volumeRef;
	const Money& m_moneyRef;
	unsigned __int64 m_volume;
	Money m_money;
};
////
class TGUI_API ClearingFirmTimeRowValue : public TimeRowValue
{
public:
	typedef const ValueType& (ClearingFirm::*UIntFunction)() const;
	ClearingFirmTimeRowValue(const ClearingFirm* clearingFirm, const bool* showMilliseconds, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = false):
		TimeRowValue(showMilliseconds, useEmptyValue, useTick),
		m_clearingFirm(clearingFirm),
		m_uintFunction(uintFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_clearingFirm->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	const ClearingFirm* m_clearingFirm;
	UIntFunction m_uintFunction;
};

class TGUI_API ClearingFirmBoolRowValueCountable : public BoolRowValueCountable
{
public:
	typedef const ValueType& (ClearingFirm::*BoolFunction)() const;
	ClearingFirmBoolRowValueCountable(const ClearingFirm* const& clearingFirm, BoolFunction boolFunction, const char& trueValue = 'Y', const char& falseValue = '\0'):
		BoolRowValueCountable(trueValue, falseValue),
		m_clearingFirm(clearingFirm),
		m_boolFunction(boolFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_clearingFirm->*m_boolFunction)();}
	DECLARE_NED_NEW
protected:
	const ClearingFirm* m_clearingFirm;
	BoolFunction m_boolFunction;
};

class TGUI_API ClearingFirmMoneyRowValue : public MoneyRowValue
{
public:
	typedef const ValueType& (ClearingFirm::*MoneyFunction)() const;
	ClearingFirmMoneyRowValue(const ClearingFirm* clearingFirm,
		const bool* comma,
		const unsigned char* decDigits,
		const bool* truncate,
		MoneyFunction moneyFunction,
		bool useEmptyValue = true,
		bool useNeutralColor = false,
		bool useTick = true):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_clearingFirm(clearingFirm),
		m_moneyFunction(moneyFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_clearingFirm->*m_moneyFunction)();}
	DECLARE_NED_NEW
protected:
	const ClearingFirm* m_clearingFirm;
	MoneyFunction m_moneyFunction;
};

class TGUI_API ClearingFirmMoneyVRowValue : public MoneyRowValue
{
public:
	typedef ValueType (ClearingFirm::*MoneyFunction)() const;
	ClearingFirmMoneyVRowValue(const ClearingFirm* clearingFirm,
		const bool* comma,
		const unsigned char* decDigits,
		const bool* truncate,
		MoneyFunction moneyFunction,
		bool useEmptyValue = true,
		bool useNeutralColor = false,
		bool useTick = true):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_clearingFirm(clearingFirm),
		m_moneyFunction(moneyFunction)
		{}
//	virtual const unsigned int& GetObjectValue() const override{return (m_account->*m_uintFunction)();}
	virtual bool isValueChanged() const override{return m_value != (m_clearingFirm->*m_moneyFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_clearingFirm->*m_moneyFunction)());}
	virtual bool UpdateValue() override{return SetValue((m_clearingFirm->*m_moneyFunction)());}
	virtual bool isObjectValueZero() const override{return !(m_clearingFirm->*m_moneyFunction)();}
//	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_clearingFirm->*m_moneyFunction)();}
	const ClearingFirm* m_clearingFirm;
	MoneyFunction m_moneyFunction;
};

class TGUI_API ClearingFirmMoneyConditionalRowValue : public ClearingFirmMoneyRowValue
{
public:
	ClearingFirmMoneyConditionalRowValue(const ClearingFirm* clearingFirm, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, const bool& useValue, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true) :
		ClearingFirmMoneyRowValue(clearingFirm, comma, decDigits, truncate, moneyFunction, useEmptyValue, useNeutralColor, useTick),
		m_useValue(useValue){}
//if !m_useValue then show zero
	virtual const ValueType& GetObjectValue() const override{return m_useValue ? (m_clearingFirm->*m_moneyFunction)() : Money::moneyZero;}
	DECLARE_NED_NEW
protected:
	const bool& m_useValue;
};

class TGUI_API ClearingFirmUIntVRowValue : public UIntRowValue
{
public:
	typedef ValueType (ClearingFirm::*UIntFunction)() const;
	ClearingFirmUIntVRowValue(const ClearingFirm* clearingFirm, const bool* comma, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true):
		UIntRowValue(comma, useEmptyValue, useTick),
		m_clearingFirm(clearingFirm),
		m_uintFunction(uintFunction){}
//	virtual const unsigned int& GetObjectValue() const override{return (m_account->*m_uintFunction)();}
	virtual bool isValueChanged() const override{return m_value != (m_clearingFirm->*m_uintFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_clearingFirm->*m_uintFunction)());}
	virtual bool UpdateValue() override{return SetValue((m_clearingFirm->*m_uintFunction)());}
//	virtual bool isObjectValueEmpty() const;//{return m_useEmptyValue && (m_account->*m_uintFunction)() == m_emptyValue;}
	virtual bool isObjectValueZero() const override{return !(m_clearingFirm->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_clearingFirm->*m_uintFunction)();}
	const ClearingFirm* m_clearingFirm;
	UIntFunction m_uintFunction;
};

////
class TGUI_API AccountStringRowValue : public StringRowValue
{
public:
	typedef const ValueType& (Account::*StringFunction)() const;
	AccountStringRowValue(const Account* account, StringFunction stringFunction):m_account(account),m_stringFunction(stringFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_account->*m_stringFunction)();}
	DECLARE_NED_NEW
protected:
	const Account* m_account;
	StringFunction m_stringFunction;
};

class TGUI_API AccountUIntAsStrRowValue : public UIntAsStrRowValue
{
public:
	typedef const ValueType& (Account::*UIntFunction)() const;
	AccountUIntAsStrRowValue(const Account* const& account, UIntFunction uintFunction, const bool& useEmptyValue = true):
		UIntAsStrRowValue(zero, useEmptyValue),
		m_account(account),
		m_uintFunction(uintFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_account->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	const Account* m_account;
	UIntFunction m_uintFunction;
};

class TGUI_API AccountAccountIdRowValue : public AccountIdRowValue
{
public:
	typedef const ValueType& (Account::*AccountIdFunction)() const;
	AccountAccountIdRowValue(const Account* const& account, AccountIdFunction accountIdFunction)://, const bool& useEmptyValue = true) :
//		AccountIdRowValue(),
		m_account(account),
		m_accountIdFunction(accountIdFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_account->*m_accountIdFunction)();}
	DECLARE_NED_NEW
protected:
	const Account* m_account;
	AccountIdFunction m_accountIdFunction;
};

class TGUI_API AccountBoolRowValue : public BoolRowValue
{
public:
	typedef const ValueType& (Account::*BoolFunction)() const;
	AccountBoolRowValue(const Account* account, BoolFunction boolFunction, char trueValue = 'Y', char falseValue = '\0'):
		BoolRowValue(trueValue, falseValue), m_account(account),m_boolFunction(boolFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_account->*m_boolFunction)();}
	DECLARE_NED_NEW
protected:
	const Account* m_account;
	BoolFunction m_boolFunction;
};

class TGUI_API AccountBoolRowValueCountable : public BoolRowValueCountable
{
public:
	typedef const ValueType& (Account::*BoolFunction)() const;
	AccountBoolRowValueCountable(const Account* const& account, BoolFunction boolFunction, const char& trueValue = 'Y', const char& falseValue = '\0'):
		BoolRowValueCountable(trueValue, falseValue),
		m_account(account),
		m_boolFunction(boolFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_account->*m_boolFunction)();}
	DECLARE_NED_NEW
protected:
	const Account* m_account;
	BoolFunction m_boolFunction;
};

class TGUI_API AccountUCharAsBoolRowValue : public UCharAsBoolRowValue
{
public:
	typedef const ValueType& (Account::*UCharFunction)() const;
	AccountUCharAsBoolRowValue(const Account* account, UCharFunction ucharFunction, char trueValue = 'Y', char falseValue = '\0'):
		UCharAsBoolRowValue(trueValue, falseValue), m_account(account),m_ucharFunction(ucharFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_account->*m_ucharFunction)();}
	DECLARE_NED_NEW
protected:
	const Account* m_account;
	UCharFunction m_ucharFunction;
};

class TGUI_API AccountBoolAsUCharRowValue : public UCharAsBoolRowValue
{
public:
	typedef const bool& (Account::*BoolFunction)() const;
	AccountBoolAsUCharRowValue(const Account* account, BoolFunction boolFunction, char trueValue = 'Y', char falseValue = '\0'):
		UCharAsBoolRowValue(trueValue, falseValue), m_account(account),m_boolFunction(boolFunction){}

	virtual bool isValueChanged() const override{return m_value != ((m_account->*m_boolFunction)() ? 1 : 0);}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_account->*m_boolFunction)() ? 1 : 0);}
	virtual bool UpdateValue() override{return SetValue((m_account->*m_boolFunction)() ? 1 : 0);}
	virtual bool isObjectValueZero() const override{return !(m_account->*m_boolFunction)();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_account->*m_boolFunction)() ? 1 : 0;}
	const Account* m_account;
	BoolFunction m_boolFunction;
};

class TGUI_API AccountBoolAsUCharVRowValue : public UCharAsBoolRowValue
{
public:
	typedef bool (Account::*BoolFunction)() const;
	AccountBoolAsUCharVRowValue(const Account* account, BoolFunction boolFunction, char trueValue = 'Y', char falseValue = '\0'):
		UCharAsBoolRowValue(trueValue, falseValue), m_account(account),m_boolFunction(boolFunction){}

	virtual bool isValueChanged() const override{return m_value != ((m_account->*m_boolFunction)() ? 1 : 0);}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_account->*m_boolFunction)() ? 1 : 0);}
	virtual bool UpdateValue() override{return SetValue((m_account->*m_boolFunction)() ? 1 : 0);}
	virtual bool isObjectValueZero() const override{return !(m_account->*m_boolFunction)();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_account->*m_boolFunction)() ? 1 : 0;}
	const Account* m_account;
	BoolFunction m_boolFunction;
};

class TGUI_API AccountBoolAsUCharReversedVRowValue : public UCharAsBoolRowValue
{
public:
	typedef bool (Account::*BoolFunction)() const;
	AccountBoolAsUCharReversedVRowValue(const Account* account, BoolFunction boolFunction, char trueValue = 'Y', char falseValue = '\0'):
		UCharAsBoolRowValue(trueValue, falseValue), m_account(account),m_boolFunction(boolFunction){}

	virtual bool isValueChanged() const override{return m_value != ((m_account->*m_boolFunction)() ? 0 : 1);}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_account->*m_boolFunction)() ? 0 : 1);}
	virtual bool UpdateValue() override{return SetValue((m_account->*m_boolFunction)() ? 0 : 1);}
	virtual bool isObjectValueZero() const override{return (m_account->*m_boolFunction)();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_account->*m_boolFunction)() ? 0 : 1;}
	const Account* m_account;
	BoolFunction m_boolFunction;
};

class TGUI_API AccountUCharAsBoolVRowValue : public UCharAsBoolRowValue
{
public:
	typedef ValueType (Account::*UCharFunction)() const;
	AccountUCharAsBoolVRowValue(const Account* account, UCharFunction ucharFunction, char trueValue = 'Y', char falseValue = '\0'):
		UCharAsBoolRowValue(trueValue, falseValue), m_account(account),m_ucharFunction(ucharFunction){}
	virtual bool isValueChanged() const override{return m_value != ((m_account->*m_ucharFunction)() ? 1 : 0);}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_account->*m_ucharFunction)() ? 1 : 0);}
	virtual bool UpdateValue() override{return SetValue((m_account->*m_ucharFunction)() ? 1 : 0);}
	virtual bool isObjectValueZero() const override{return !(m_account->*m_ucharFunction)();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_account->*m_ucharFunction)() ? 1 : 0;}
	const Account* m_account;
	UCharFunction m_ucharFunction;
};

class TGUI_API AccountCharRowValue : public CharRowValue
{
public:
	typedef const ValueType& (Account::*CharFunction)() const;
	AccountCharRowValue(const Account* account, CharFunction charFunction, const ValueType& value = '\0', bool useEmptyValue = false, bool useNeutralColor = false, bool useTick = false):
		CharRowValue(value, useEmptyValue, useNeutralColor, useTick),m_account(account),m_charFunction(charFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_account->*m_charFunction)();}
	DECLARE_NED_NEW
protected:
	const Account* m_account;
	CharFunction m_charFunction;
};

class TGUI_API AccountIntRowValue : public IntRowValue
{
public:
	typedef const ValueType& (Account::*IntFunction)() const;
	AccountIntRowValue(const Account* account, const bool* comma, IntFunction intFunction, bool useEmptyValue = false, bool useTick = true):
		IntRowValue(comma, useEmptyValue, useTick), m_account(account),m_intFunction(intFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_account->*m_intFunction)();}
	DECLARE_NED_NEW
protected:
	const Account* m_account;
	IntFunction m_intFunction;
};

class TGUI_API AccountUIntRowValue : public UIntRowValue
{
public:
	typedef const ValueType& (Account::*UIntFunction)() const;
	AccountUIntRowValue(const Account* account, const bool* comma, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true):
		UIntRowValue(comma, useEmptyValue, useTick), m_account(account),m_uintFunction(uintFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_account->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	const Account* m_account;
	UIntFunction m_uintFunction;
};

class TGUI_API AccountUIntRowValueNoComma : public UIntRowValueNoComma
{
public:
	typedef const ValueType& (Account::*UIntFunction)() const;
	AccountUIntRowValueNoComma(const Account* account, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = false):
		UIntRowValueNoComma(useEmptyValue, useTick), m_account(account), m_uintFunction(uintFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_account->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	const Account* m_account;
	UIntFunction m_uintFunction;
};

class TGUI_API AccountUIntInventoryRowValue : public UIntRowValue
{
public:
	typedef const ValueType& (Account::*UIntFunction)(const bool& inventoryView) const;
	AccountUIntInventoryRowValue(const Account* account, const bool& inventoryView, const bool* comma, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true):
		UIntRowValue(comma, useEmptyValue, useTick),
		m_account(account),
		m_uintFunction(uintFunction),
		m_inventoryView(inventoryView){}
	virtual const ValueType& GetObjectValue() const override{return (m_account->*m_uintFunction)(m_inventoryView);}
	DECLARE_NED_NEW
protected:
	const Account* m_account;
	UIntFunction m_uintFunction;
	const bool& m_inventoryView;
};

#ifndef TAKION_NO_OPTIONS
class TGUI_API AccountOptionVenueRowValue : public AccountUIntRowValue
{
public:
	AccountOptionVenueRowValue(const Account* account, const bool* comma, bool useEmptyValue = true):
		AccountUIntRowValue(account, comma, &Account::GetOptionVenue, useEmptyValue, false){}
	virtual void toString(std::string& text) const override
	{
		switch(m_value)
		{
//			case OV_NITE:
//			text += "NITE";
//			break;

			case OV_APEX:
			text += "APEX";
			break;

			case OV_DASH:
			text += "DASH";
			break;
		}
	}
	DECLARE_NED_NEW
};
#endif

class TGUI_API AccountLocateVenueRowValue : public AccountUIntRowValue
{
public:
	AccountLocateVenueRowValue(const Account* account, const bool* comma, bool useEmptyValue = true):
		AccountUIntRowValue(account, comma, &Account::GetLocateVenue, useEmptyValue, false){}
	virtual void toString(std::string& text) const override
	{
		switch(m_value)
		{
			case LV_QSTK:
			text += "QSTK";
			break;

			case LV_BROADRIDGE:
			text += "BDRG";
			break;
		}
	}
	DECLARE_NED_NEW
};

class TGUI_API AccountPriceRowValue : public PriceRowValue
{
public:
	typedef const ValueType& (Account::*PriceFunction)() const;
	AccountPriceRowValue(const Account* account,
		const bool* comma,
		const unsigned char* decDigits,
		const bool* truncate,
		PriceFunction priceFunction,
		bool useEmptyValue = true,
		bool useTick = true):
		PriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick), m_account(account),m_priceFunction(priceFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_account->*m_priceFunction)();}
	DECLARE_NED_NEW
protected:
	const Account* m_account;
	PriceFunction m_priceFunction;
};

class TGUI_API AccountPriceVRowValue : public PriceRowValue
{
public:
	typedef ValueType (Account::*PriceFunction)() const;
	AccountPriceVRowValue(const Account* const& account,
		const bool* comma,
		const unsigned char* decDigits,
		const bool* truncate,
		PriceFunction priceFunction,
		bool useEmptyValue = true,
		bool useTick = true):
		PriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_account(account),
		m_priceFunction(priceFunction)
		{}
//	virtual const unsigned int& GetObjectValue() const override{return (m_account->*m_uintFunction)();}
	virtual bool isValueChanged() const override{return m_value != (m_account->*m_priceFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_account->*m_priceFunction)());}
	virtual bool UpdateValue() override{return SetValue((m_account->*m_priceFunction)());}
//	virtual bool isObjectValueEmpty() const;//{return m_useEmptyValue && (m_account->*m_uintFunction)() == m_emptyValue;}
	virtual bool isObjectValueZero() const override{return !(m_account->*m_priceFunction)();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_account->*m_priceFunction)();}
	const Account* m_account;
	PriceFunction m_priceFunction;
};

class TGUI_API AccountCompactPriceRowValue : public CompactPriceRowValue
{
public:
	typedef const ValueType& (Account::*PriceFunction)() const;
	AccountCompactPriceRowValue(const Account* account, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true):
		CompactPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_account(account),
		m_priceFunction(priceFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_account->*m_priceFunction)();}
	DECLARE_NED_NEW
protected:
	const Account* m_account;
	PriceFunction m_priceFunction;
};

class TGUI_API AccountMoneyVRowValue : public MoneyRowValue
{
public:
	typedef ValueType (Account::*MoneyFunction)() const;
	AccountMoneyVRowValue(const Account* const& account,
		const bool* comma,
		const unsigned char* decDigits,
		const bool* truncate,
		MoneyFunction moneyFunction,
		bool useEmptyValue = true,
		bool useNeutralColor = false,
		bool useTick = true):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_account(account),
		m_moneyFunction(moneyFunction)
		{}
//	virtual const unsigned int& GetObjectValue() const override{return (m_account->*m_uintFunction)();}
	virtual bool isValueChanged() const override{return m_value != (m_account->*m_moneyFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_account->*m_moneyFunction)());}
	virtual bool UpdateValue() override{return SetValue((m_account->*m_moneyFunction)());}
//	virtual bool isObjectValueEmpty() const;//{return m_useEmptyValue && (m_account->*m_uintFunction)() == m_emptyValue;}
	virtual bool isObjectValueZero() const override{return !(m_account->*m_moneyFunction)();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_account->*m_moneyFunction)();}
	const Account* m_account;
	MoneyFunction m_moneyFunction;
};

class TGUI_API AccountMoneyPositiveVRowValue : public AccountMoneyVRowValue
{
public:
	AccountMoneyPositiveVRowValue(const Account* account, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		AccountMoneyVRowValue(account, comma, decDigits, truncate, moneyFunction, useEmptyValue, useNeutralColor, useTick)
		{}
	virtual bool CanBeNegative() const override{return false;}
	DECLARE_NED_NEW
};

class TGUI_API AccountMoneyInventoryVRowValue : public MoneyRowValue
{
public:
	typedef ValueType (Account::*MoneyFunction)(const bool& inventoryView) const;
	AccountMoneyInventoryVRowValue(const Account* account, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true) :
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_account(account),
		m_moneyFunction(moneyFunction),
		m_inventoryView(inventoryView)
	{}
	virtual bool isValueChanged() const override{return m_value != (m_account->*m_moneyFunction)(m_inventoryView);}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_account->*m_moneyFunction)(m_inventoryView));}
	virtual bool UpdateValue() override{return SetValue((m_account->*m_moneyFunction)(m_inventoryView));}
	virtual bool isObjectValueZero() const override{return !(m_account->*m_moneyFunction)(m_inventoryView);}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_account->*m_moneyFunction)(m_inventoryView);}
	const Account* m_account;
	MoneyFunction m_moneyFunction;
	const bool& m_inventoryView;
};

class TGUI_API AccountMoneyInventoryPositiveVRowValue : public AccountMoneyInventoryVRowValue
{
public:
	AccountMoneyInventoryPositiveVRowValue(const Account* account, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		AccountMoneyInventoryVRowValue(account, inventoryView, comma, decDigits, truncate, moneyFunction, useEmptyValue, useNeutralColor, useTick)
		{}
	virtual bool CanBeNegative() const override{return false;}
	DECLARE_NED_NEW
};

class TGUI_API AccountMoneyInventoryVRowValue2 : public AccountMoneyInventoryVRowValue
{
public:
	AccountMoneyInventoryVRowValue2(const Account* account, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, MoneyFunction moneyFunction2, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		AccountMoneyInventoryVRowValue(account, inventoryView, comma, decDigits, truncate, moneyFunction, useEmptyValue, useNeutralColor, useTick),
		m_moneyFunction2(moneyFunction2)
	{
	}
	virtual bool isValueChanged() const override{return m_value != (m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView);}
//	virtual const Money& GetObjectValue() const override{return (m_account->*m_moneyFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView));}
	virtual bool UpdateValue() override{return SetValue((m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView));}
	virtual bool isObjectValueZero() const override{return ((m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView)).isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView);}
	MoneyFunction m_moneyFunction2;
};

class TGUI_API AccountMoneyInventoryVRowValue3 : public AccountMoneyInventoryVRowValue2
{
public:
	AccountMoneyInventoryVRowValue3(const Account* account, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, MoneyFunction moneyFunction2, MoneyFunction moneyFunction3, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		AccountMoneyInventoryVRowValue2(account, inventoryView, comma, decDigits, truncate, moneyFunction, moneyFunction2, useEmptyValue, useNeutralColor, useTick),
		m_moneyFunction3(moneyFunction3)
	{
	}
	virtual bool isValueChanged() const override{return m_value != (m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) + (m_account->*m_moneyFunction3)(m_inventoryView);}
//	virtual const Money& GetObjectValue() const override{return (m_account->*m_moneyFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) + (m_account->*m_moneyFunction3)(m_inventoryView));}
	virtual bool UpdateValue() override{return SetValue((m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) + (m_account->*m_moneyFunction3)(m_inventoryView));}
	virtual bool isObjectValueZero() const override{return ((m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) + (m_account->*m_moneyFunction3)(m_inventoryView)).isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) + (m_account->*m_moneyFunction3)(m_inventoryView);}
	MoneyFunction m_moneyFunction3;
};

class TGUI_API AccountMoneyInventoryVRowValue3Minus : public AccountMoneyInventoryVRowValue3
{
public:
	AccountMoneyInventoryVRowValue3Minus(const Account* account, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, MoneyFunction moneyFunction2, MoneyFunction moneyFunction3, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		AccountMoneyInventoryVRowValue3(account, inventoryView, comma, decDigits, truncate, moneyFunction, moneyFunction2, moneyFunction3, useEmptyValue, useNeutralColor, useTick)
	{
	}
	virtual bool isValueChanged() const override{return m_value != (m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) - (m_account->*m_moneyFunction3)(m_inventoryView);}
//	virtual const Money& GetObjectValue() const override{return (m_account->*m_moneyFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) - (m_account->*m_moneyFunction3)(m_inventoryView));}
	virtual bool UpdateValue() override{return SetValue((m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) - (m_account->*m_moneyFunction3)(m_inventoryView));}
	virtual bool isObjectValueZero() const override{return (m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) == (m_account->*m_moneyFunction3)(m_inventoryView);}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) - (m_account->*m_moneyFunction3)(m_inventoryView);}
};


class TGUI_API AccountMoneyRowValue : public MoneyRowValue
{
public:
	typedef const ValueType& (Account::*MoneyFunction)() const;
	AccountMoneyRowValue(const Account* const& account,
		const bool* comma,
		const unsigned char* decDigits,
		const bool* truncate,
		MoneyFunction moneyFunction,
		bool useEmptyValue = true,
		bool useNeutralColor = false,
		bool useTick = true):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_account(account),
		m_moneyFunction(moneyFunction)
		{}
	virtual const ValueType& GetObjectValue() const override{return (m_account->*m_moneyFunction)();}
	DECLARE_NED_NEW
protected:
	const Account* m_account;
	MoneyFunction m_moneyFunction;
};

class TGUI_API AccountMoneyInInventoryRowValue : public AccountMoneyRowValue
{
public:
	AccountMoneyInInventoryRowValue(const Account* const& account,
		const bool* const& comma,
		const unsigned char* const& decDigits,
		const bool* const& truncate,
		const MoneyFunction& moneyFunction,
		const bool& useEmptyValue = true,
		const bool& useNeutralColor = false,
		const bool& useTick = true):
		AccountMoneyRowValue(account, comma, decDigits, truncate, moneyFunction, useEmptyValue, useNeutralColor, useTick),
		m_hasInventory(false)
	{}

	virtual bool isValueEmpty() const override{return m_useEmptyValue && !m_hasInventory;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !m_account->hasInventory();}
	virtual bool isValueChanged() const override{return AccountMoneyRowValue::isValueChanged() || m_hasInventory != m_account->hasInventory();}
	virtual bool SetValue(const ValueType& value) override
	{
		bool ret = AccountMoneyRowValue::SetValue(value);
		if(m_hasInventory != m_account->hasInventory())
		{
			m_hasInventory = !m_hasInventory;
			ret = true;
		}
		return ret;
	}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{AccountMoneyRowValue::InitializeValue(); m_hasInventory = m_account->hasInventory();}
	bool m_hasInventory;
};

class TGUI_API AccountMoneyPositiveRowValue : public AccountMoneyRowValue
{
public:
	AccountMoneyPositiveRowValue(const Account* account, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		AccountMoneyRowValue(account, comma, decDigits, truncate, moneyFunction, useEmptyValue, useNeutralColor, useTick)
		{}
	virtual bool CanBeNegative() const override{return false;}
	DECLARE_NED_NEW
};

class TGUI_API AccountMoneyInventoryRowValue : public MoneyRowValue
{
public:
	typedef const ValueType& (Account::*MoneyFunction)(const bool& inventoryView) const;
	AccountMoneyInventoryRowValue(const Account* account, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_account(account),
		m_moneyFunction(moneyFunction),
		m_inventoryView(inventoryView)
		{}
	virtual const ValueType& GetObjectValue() const override{return (m_account->*m_moneyFunction)(m_inventoryView);}
	DECLARE_NED_NEW
protected:
	const Account* m_account;
	MoneyFunction m_moneyFunction;
	const bool& m_inventoryView;
};

class TGUI_API AccountMoneyInventoryPositiveRowValue : public AccountMoneyInventoryRowValue
{
public:
	AccountMoneyInventoryPositiveRowValue(const Account* account, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		AccountMoneyInventoryRowValue(account, inventoryView, comma, decDigits, truncate, moneyFunction, useEmptyValue, useNeutralColor, useTick)
		{}
	virtual bool CanBeNegative() const override{return false;}
	DECLARE_NED_NEW
};

class TGUI_API AccountUIntVRowValue : public UIntRowValue
{
public:
	typedef ValueType (Account::*UIntFunction)() const;
	AccountUIntVRowValue(const Account* account, const bool* comma, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true):
		UIntRowValue(comma, useEmptyValue, useTick),
		m_account(account),
		m_uintFunction(uintFunction){}
//	virtual const unsigned int& GetObjectValue() const override{return (m_account->*m_uintFunction)();}
	virtual bool isValueChanged() const override{return m_value != (m_account->*m_uintFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_account->*m_uintFunction)());}
	virtual bool UpdateValue() override{return SetValue((m_account->*m_uintFunction)());}
//	virtual bool isObjectValueEmpty() const;//{return m_useEmptyValue && (m_account->*m_uintFunction)() == m_emptyValue;}
	virtual bool isObjectValueZero() const override{return !(m_account->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_account->*m_uintFunction)();}
	const Account* m_account;
	UIntFunction m_uintFunction;
};

class TGUI_API AccountUIntInventoryVRowValue : public UIntRowValue
{
public:
	typedef ValueType (Account::*UIntFunction)(const bool& inventoryView) const;
	AccountUIntInventoryVRowValue(const Account* account, const bool& inventoryView, const bool* comma, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true):
		UIntRowValue(comma, useEmptyValue, useTick),
		m_account(account),
		m_uintFunction(uintFunction),
		m_inventoryView(inventoryView){}
//	virtual const unsigned int& GetObjectValue() const override{return (m_account->*m_uintFunction)();}
	virtual bool isValueChanged() const override{return m_value != (m_account->*m_uintFunction)(m_inventoryView);}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_account->*m_uintFunction)(m_inventoryView));}
	virtual bool UpdateValue() override{return SetValue((m_account->*m_uintFunction)(m_inventoryView));}
//	virtual bool isObjectValueEmpty() const;//{return m_useEmptyValue && (m_account->*m_uintFunction)() == m_emptyValue;}
	virtual bool isObjectValueZero() const override{return !(m_account->*m_uintFunction)(m_inventoryView);}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_account->*m_uintFunction)(m_inventoryView);}
	const Account* m_account;
	UIntFunction m_uintFunction;
	const bool& m_inventoryView;
};

///
class TGUI_API AccountMoneyPerShareRowValue : public AccountMoneyRowValue
{
public:
	typedef const unsigned int& (Account::*UIntFunction)() const;
	AccountMoneyPerShareRowValue(const Account* account, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, UIntFunction uintFunction, unsigned int multiplier, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		AccountMoneyRowValue(account, comma, decDigits, truncate, moneyFunction, useEmptyValue, useNeutralColor, useTick),
		m_uintFunction(uintFunction),
		m_shares(0),
		m_multiplier(multiplier)
	{
	}
	void DeriveValue(ValueType& value, const ValueType& money, const unsigned int& shares) const
	{
		if(shares)value = money * m_multiplier / shares;
		else value.SetZero();
	}
//	virtual const Money& GetObjectValue() const override{return (m_position->*m_moneyFunction)();}
	virtual bool isValueChanged() const override{return m_money != (m_account->*m_moneyFunction)() || m_shares != (m_account->*m_uintFunction)();}
	virtual short CompareAhead(const RowValue& other) const override//{Money value = (m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)();return -((const TypedRowValue&)other).CompareValue(value);}
	{
		Money value;
		DeriveValue(value, (m_account->*m_moneyFunction)(), (m_account->*m_uintFunction)());
		return -((const TypedRowValue&)other).CompareValue(value);
	}
	virtual bool UpdateValue() override//{return SetValue((m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)());}
	{
		m_money = (m_account->*m_moneyFunction)();
		m_shares = (m_account->*m_uintFunction)();

		Money value;
		DeriveValue(value, m_money, m_shares);
		return SetValue(value);
	}
	virtual bool isObjectValueZero() const override{return (m_account->*m_moneyFunction)().isZero() || !(m_account->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_money = (m_account->*m_moneyFunction)();
		m_shares = (m_account->*m_uintFunction)();
		DeriveValue(m_value, m_money, m_shares);
	}
	UIntFunction m_uintFunction;
	ValueType m_money;
	unsigned int m_shares;
	unsigned int m_multiplier;
};

class TGUI_API AccountMoneyPerShareInventoryRowValue : public AccountMoneyInventoryVRowValue
{
public:
	typedef const unsigned int& (Account::*UIntFunction)() const;
	AccountMoneyPerShareInventoryRowValue(const Account* account, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, UIntFunction uintFunction, unsigned int multiplier, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		AccountMoneyInventoryVRowValue(account, inventoryView, comma, decDigits, truncate, moneyFunction, useEmptyValue, useNeutralColor, useTick),
		m_uintFunction(uintFunction),
		m_shares(0),
		m_multiplier(multiplier)
	{
	}
	void DeriveValue(ValueType& value, const ValueType& money, const unsigned int& shares) const
	{
		if(shares)value = money * m_multiplier / shares;
		else value.SetZero();
	}
	virtual bool isValueChanged() const override{return m_money != (m_account->*m_moneyFunction)(m_inventoryView) || m_shares != (m_account->*m_uintFunction)();}
	virtual short CompareAhead(const RowValue& other) const override//{Money value = (m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)();return -((const TypedRowValue&)other).CompareValue(value);}
	{
		Money value;
		DeriveValue(value, (m_account->*m_moneyFunction)(m_inventoryView), (m_account->*m_uintFunction)());
		return -((const TypedRowValue&)other).CompareValue(value);
	}
	virtual bool UpdateValue() override//{return SetValue((m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)());}
	{
		m_money = (m_account->*m_moneyFunction)(m_inventoryView);
		m_shares = (m_account->*m_uintFunction)();

		Money value;
		DeriveValue(value, m_money, m_shares);
		return SetValue(value);
	}
	virtual bool isObjectValueZero() const override{return (m_account->*m_moneyFunction)(m_inventoryView).isZero() || !(m_account->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_money = (m_account->*m_moneyFunction)(m_inventoryView);
		m_shares = (m_account->*m_uintFunction)();
		DeriveValue(m_value, m_money, m_shares);
	}
	UIntFunction m_uintFunction;
	ValueType m_money;
	unsigned int m_shares;
	unsigned int m_multiplier;
};

///
class TGUI_API AccountMoneyRowValue2 : public AccountMoneyRowValue
{
public:
	AccountMoneyRowValue2(const Account* account, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, MoneyFunction moneyFunction2, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		AccountMoneyRowValue(account, comma, decDigits, truncate, moneyFunction, useEmptyValue, useNeutralColor, useTick),
		m_moneyFunction2(moneyFunction2)
	{
	}
	virtual bool isValueChanged() const override{return m_value != (m_account->*m_moneyFunction)() + (m_account->*m_moneyFunction2)();}
//	virtual const Money& GetObjectValue() const override{return (m_account->*m_moneyFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_account->*m_moneyFunction)() + (m_account->*m_moneyFunction2)());}
	virtual bool UpdateValue() override{return SetValue((m_account->*m_moneyFunction)() + (m_account->*m_moneyFunction2)());}
	virtual bool isObjectValueZero() const override{return ((m_account->*m_moneyFunction)() + (m_account->*m_moneyFunction2)()).isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_account->*m_moneyFunction)() + (m_account->*m_moneyFunction2)();}
	MoneyFunction m_moneyFunction2;
};

class TGUI_API AccountMoneyInventoryRowValue2 : public AccountMoneyInventoryRowValue
{
public:
	AccountMoneyInventoryRowValue2(const Account* account, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, MoneyFunction moneyFunction2, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		AccountMoneyInventoryRowValue(account, inventoryView, comma, decDigits, truncate, moneyFunction, useEmptyValue, useNeutralColor, useTick),
		m_moneyFunction2(moneyFunction2)
	{
	}
	virtual bool isValueChanged() const override{return m_value != (m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView);}
//	virtual const Money& GetObjectValue() const override{return (m_account->*m_moneyFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView));}
	virtual bool UpdateValue() override{return SetValue((m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView));}
	virtual bool isObjectValueZero() const override{return ((m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView)).isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView);}
	MoneyFunction m_moneyFunction2;
};

class TGUI_API AccountMoneyRowValueDiff : public AccountMoneyRowValue
{
public:
	AccountMoneyRowValueDiff(const Account* account, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, MoneyFunction moneyFunction2, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		AccountMoneyRowValue(account, comma, decDigits, truncate, moneyFunction, useEmptyValue, useNeutralColor, useTick),
		m_moneyFunction2(moneyFunction2)
	{
	}
	virtual bool isValueChanged() const override{return m_value != (m_account->*m_moneyFunction)() - (m_account->*m_moneyFunction2)();}
//	virtual const Money& GetObjectValue() const override{return (m_account->*m_moneyFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_account->*m_moneyFunction)() - (m_account->*m_moneyFunction2)());}
	virtual bool UpdateValue() override{return SetValue((m_account->*m_moneyFunction)() - (m_account->*m_moneyFunction2)());}
	virtual bool isObjectValueZero() const override{return (m_account->*m_moneyFunction)() == (m_account->*m_moneyFunction2)();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_account->*m_moneyFunction)() - (m_account->*m_moneyFunction2)();}
	MoneyFunction m_moneyFunction2;
};

class TGUI_API AccountMoneyInventoryRowValueDiff : public AccountMoneyInventoryRowValue
{
public:
	AccountMoneyInventoryRowValueDiff(const Account* account, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, MoneyFunction moneyFunction2, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		AccountMoneyInventoryRowValue(account, inventoryView, comma, decDigits, truncate, moneyFunction, useEmptyValue, useNeutralColor, useTick),
		m_moneyFunction2(moneyFunction2)
	{
	}
	virtual bool isValueChanged() const override{return m_value != (m_account->*m_moneyFunction)(m_inventoryView) - (m_account->*m_moneyFunction2)(m_inventoryView);}
//	virtual const Money& GetObjectValue() const override{return (m_account->*m_moneyFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_account->*m_moneyFunction)(m_inventoryView) - (m_account->*m_moneyFunction2)(m_inventoryView));}
	virtual bool UpdateValue() override{return SetValue((m_account->*m_moneyFunction)(m_inventoryView) - (m_account->*m_moneyFunction2)(m_inventoryView));}
	virtual bool isObjectValueZero() const override{return (m_account->*m_moneyFunction)(m_inventoryView) == (m_account->*m_moneyFunction2)(m_inventoryView);}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_account->*m_moneyFunction)(m_inventoryView) - (m_account->*m_moneyFunction2)(m_inventoryView);}
	MoneyFunction m_moneyFunction2;
};

class TGUI_API AccountMoneyInventoryVRowValueDiff : public AccountMoneyInventoryVRowValue
{
public:
	AccountMoneyInventoryVRowValueDiff(const Account* account, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, MoneyFunction moneyFunction2, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		AccountMoneyInventoryVRowValue(account, inventoryView, comma, decDigits, truncate, moneyFunction, useEmptyValue, useNeutralColor, useTick),
		m_moneyFunction2(moneyFunction2)
	{
	}
	virtual bool isValueChanged() const override{return m_value != (m_account->*m_moneyFunction)(m_inventoryView) - (m_account->*m_moneyFunction2)(m_inventoryView);}
//	virtual const Money& GetObjectValue() const override{return (m_account->*m_moneyFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_account->*m_moneyFunction)(m_inventoryView) - (m_account->*m_moneyFunction2)(m_inventoryView));}
	virtual bool UpdateValue() override{return SetValue((m_account->*m_moneyFunction)(m_inventoryView) - (m_account->*m_moneyFunction2)(m_inventoryView));}
	virtual bool isObjectValueZero() const override{return (m_account->*m_moneyFunction)(m_inventoryView) == (m_account->*m_moneyFunction2)(m_inventoryView);}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_account->*m_moneyFunction)(m_inventoryView) - (m_account->*m_moneyFunction2)(m_inventoryView);}
	MoneyFunction m_moneyFunction2;
};

class TGUI_API AccountMoneyRowValue3 : public AccountMoneyRowValue2
{
public:
	AccountMoneyRowValue3(const Account* account, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, MoneyFunction moneyFunction2, MoneyFunction moneyFunction3, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		AccountMoneyRowValue2(account, comma, decDigits, truncate, moneyFunction, moneyFunction2, useEmptyValue, useNeutralColor, useTick),
		m_moneyFunction3(moneyFunction3)
	{
	}
	virtual bool isValueChanged() const override{return m_value != (m_account->*m_moneyFunction)() + (m_account->*m_moneyFunction2)() + (m_account->*m_moneyFunction3)();}
//	virtual const Money& GetObjectValue() const override{return (m_account->*m_moneyFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_account->*m_moneyFunction)() + (m_account->*m_moneyFunction2)() + (m_account->*m_moneyFunction3)());}
	virtual bool UpdateValue() override{return SetValue((m_account->*m_moneyFunction)() + (m_account->*m_moneyFunction2)() + (m_account->*m_moneyFunction3)());}
	virtual bool isObjectValueZero() const override{return ((m_account->*m_moneyFunction)() + (m_account->*m_moneyFunction2)() + (m_account->*m_moneyFunction3)()).isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_account->*m_moneyFunction)() + (m_account->*m_moneyFunction2)() + (m_account->*m_moneyFunction3)();}
	MoneyFunction m_moneyFunction3;
};

class TGUI_API AccountMoneyInventoryRowValue3 : public AccountMoneyInventoryRowValue2
{
public:
	AccountMoneyInventoryRowValue3(const Account* account, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, MoneyFunction moneyFunction2, MoneyFunction moneyFunction3, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		AccountMoneyInventoryRowValue2(account, inventoryView, comma, decDigits, truncate, moneyFunction, moneyFunction2, useEmptyValue, useNeutralColor, useTick),
		m_moneyFunction3(moneyFunction3)
	{
	}
	virtual bool isValueChanged() const override{return m_value != (m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) + (m_account->*m_moneyFunction3)(m_inventoryView);}
//	virtual const Money& GetObjectValue() const override{return (m_account->*m_moneyFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) + (m_account->*m_moneyFunction3)(m_inventoryView));}
	virtual bool UpdateValue() override{return SetValue((m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) + (m_account->*m_moneyFunction3)(m_inventoryView));}
	virtual bool isObjectValueZero() const override{return ((m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) + (m_account->*m_moneyFunction3)(m_inventoryView)).isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) + (m_account->*m_moneyFunction3)(m_inventoryView);}
	MoneyFunction m_moneyFunction3;
};

class TGUI_API AccountMoneyInventoryRowValuePlusRowValue : public AccountMoneyInventoryRowValue
{
public:
	typedef const ValueType& (Account::*MoneyNoInvFunction)() const;
	AccountMoneyInventoryRowValuePlusRowValue(const Account* account, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, MoneyNoInvFunction moneyNoInvFunction, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		AccountMoneyInventoryRowValue(account, inventoryView, comma, decDigits, truncate, moneyFunction, useEmptyValue, useNeutralColor, useTick),
		m_moneyNoInvFunction(moneyNoInvFunction)
	{
	}
	virtual bool isValueChanged() const override{return m_value != (m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyNoInvFunction)();}
//	virtual const Money& GetObjectValue() const override{return (m_account->*m_moneyFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyNoInvFunction)());}
	virtual bool UpdateValue() override{return SetValue((m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyNoInvFunction)());}
	virtual bool isObjectValueZero() const override{return ((m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyNoInvFunction)()).isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyNoInvFunction)();}
	MoneyNoInvFunction m_moneyNoInvFunction;
};
/*
class TGUI_API AccountMoneyInventoryRowValueBy1Plus1RowValue : public AccountMoneyInventoryRowValuePlusRowValue
{
public:
	AccountMoneyInventoryRowValueBy1Plus1RowValue(const Account* account, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyNumeratorFunction, MoneyFunction moneyFunction, MoneyNoInvFunction moneyNoInvFunction, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		AccountMoneyInventoryRowValuePlusRowValue(account, inventoryView, comma, decDigits, truncate, moneyFunction, moneyNoInvFunction, useEmptyValue, useNeutralColor, useTick),
		m_moneyNumeratorFunction(moneyNumeratorFunction)
	{
	}
	virtual bool isValueChanged() const override
	{
		Money value((m_account->*m_moneyNumeratorFunction)(m_inventoryView));
		DivideMoneyByMoney(value, (m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyNoInvFunction)());
		return m_value != value;
	}
	virtual short CompareAhead(const RowValue& other) const override
	{
		Money value((m_account->*m_moneyNumeratorFunction)(m_inventoryView));
		DivideMoneyByMoney(value, (m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyNoInvFunction)());
		return -((const TypedRowValue&)other).CompareValue(value);
	}
	virtual bool UpdateValue() override
	{
		Money value((m_account->*m_moneyNumeratorFunction)(m_inventoryView));
		DivideMoneyByMoney(value, (m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyNoInvFunction)());
		return SetValue(value);
	}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_value = (m_account->*m_moneyNumeratorFunction)(m_inventoryView);
		DivideMoneyByMoney(m_value, (m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyNoInvFunction)());
	}
	MoneyFunction m_moneyNumeratorFunction;
};
*/
/*
class TGUI_API AccountMoneyInventoryRowValue2PlusRowValue : public AccountMoneyInventoryRowValue2
{
public:
	typedef const ValueType& (Account::*MoneyNoInvFunction)() const;
	AccountMoneyInventoryRowValue2PlusRowValue(const Account* account, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, MoneyFunction moneyFunction2, MoneyNoInvFunction moneyNoInvFunction, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		AccountMoneyInventoryRowValue2(account, inventoryView, comma, decDigits, truncate, moneyFunction, moneyFunction2, useEmptyValue, useNeutralColor, useTick),
		m_moneyNoInvFunction(moneyNoInvFunction)
	{
	}
	virtual bool isValueChanged() const override{return m_value != (m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) + (m_account->*m_moneyNoInvFunction)();}
//	virtual const Money& GetObjectValue() const override{return (m_account->*m_moneyFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) + (m_account->*m_moneyNoInvFunction)());}
	virtual bool UpdateValue() override{return SetValue((m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) + (m_account->*m_moneyNoInvFunction)());}
	virtual bool isObjectValueZero() const override{return ((m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) + (m_account->*m_moneyNoInvFunction)()).isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) + (m_account->*m_moneyNoInvFunction)();}
	MoneyNoInvFunction m_moneyNoInvFunction;
};

class TGUI_API AccountMoneyInventoryRowValueBy2Plus1RowValue : public AccountMoneyInventoryRowValue2PlusRowValue
{
public:
	AccountMoneyInventoryRowValueBy2Plus1RowValue(const Account* account, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyNumeratorFunction, MoneyFunction moneyFunction, MoneyFunction moneyFunction2, MoneyNoInvFunction moneyNoInvFunction, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		AccountMoneyInventoryRowValue2PlusRowValue(account, inventoryView, comma, decDigits, truncate, moneyFunction, moneyFunction2, moneyNoInvFunction, useEmptyValue, useNeutralColor, useTick),
		m_moneyNumeratorFunction(moneyNumeratorFunction)
	{
	}
	virtual bool isValueChanged() const override
	{
		Money value((m_account->*m_moneyNumeratorFunction)(m_inventoryView));
		DivideMoneyByMoney(value, (m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) + (m_account->*m_moneyNoInvFunction)());
		return m_value != value;
	}
	virtual short CompareAhead(const RowValue& other) const override
	{
		Money value((m_account->*m_moneyNumeratorFunction)(m_inventoryView));
		DivideMoneyByMoney(value, (m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) + (m_account->*m_moneyNoInvFunction)());
		return -((const TypedRowValue&)other).CompareValue(value);
	}
	virtual bool UpdateValue() override
	{
		Money value((m_account->*m_moneyNumeratorFunction)(m_inventoryView));
		DivideMoneyByMoney(value, (m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) + (m_account->*m_moneyNoInvFunction)());
		return SetValue(value);
	}
//	virtual bool isObjectValueZero() const override{return ((m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) + (m_account->*m_moneyNoInvFunction)()).isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_value = (m_account->*m_moneyNumeratorFunction)(m_inventoryView);
		DivideMoneyByMoney(m_value, (m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) + (m_account->*m_moneyNoInvFunction)());
	}
	MoneyFunction m_moneyNumeratorFunction;
};
*/
class TGUI_API AccountMoneyRowValue3Minus : public AccountMoneyRowValue3
{
public:
	AccountMoneyRowValue3Minus(const Account* account, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, MoneyFunction moneyFunction2, MoneyFunction moneyFunction3, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		AccountMoneyRowValue3(account, comma, decDigits, truncate, moneyFunction, moneyFunction2, moneyFunction3, useEmptyValue, useNeutralColor, useTick)
	{
	}
	virtual bool isValueChanged() const override{return m_value != (m_account->*m_moneyFunction)() + (m_account->*m_moneyFunction2)() - (m_account->*m_moneyFunction3)();}
//	virtual const Money& GetObjectValue() const override{return (m_account->*m_moneyFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_account->*m_moneyFunction)() + (m_account->*m_moneyFunction2)() - (m_account->*m_moneyFunction3)());}
	virtual bool UpdateValue() override{return SetValue((m_account->*m_moneyFunction)() + (m_account->*m_moneyFunction2)() - (m_account->*m_moneyFunction3)());}
	virtual bool isObjectValueZero() const override{return (m_account->*m_moneyFunction)() + (m_account->*m_moneyFunction2)() == (m_account->*m_moneyFunction3)();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_account->*m_moneyFunction)() + (m_account->*m_moneyFunction2)() - (m_account->*m_moneyFunction3)();}
};

class TGUI_API AccountMoneyInventoryRowValue3Minus : public AccountMoneyInventoryRowValue3
{
public:
	AccountMoneyInventoryRowValue3Minus(const Account* account, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, MoneyFunction moneyFunction2, MoneyFunction moneyFunction3, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		AccountMoneyInventoryRowValue3(account, inventoryView, comma, decDigits, truncate, moneyFunction, moneyFunction2, moneyFunction3, useEmptyValue, useNeutralColor, useTick)
	{
	}
	virtual bool isValueChanged() const override{return m_value != (m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) - (m_account->*m_moneyFunction3)(m_inventoryView);}
//	virtual const Money& GetObjectValue() const override{return (m_account->*m_moneyFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) - (m_account->*m_moneyFunction3)(m_inventoryView));}
	virtual bool UpdateValue() override{return SetValue((m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) - (m_account->*m_moneyFunction3)(m_inventoryView));}
	virtual bool isObjectValueZero() const override{return (m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) == (m_account->*m_moneyFunction3)(m_inventoryView);}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_account->*m_moneyFunction)(m_inventoryView) + (m_account->*m_moneyFunction2)(m_inventoryView) - (m_account->*m_moneyFunction3)(m_inventoryView);}
};

class TGUI_API AccountMoneyDivision : public MoneyRowValue
{
public:
	typedef const Money& (Account::*MoneyFunction)() const;
	AccountMoneyDivision(const Account* account, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction nominatorFunction, MoneyFunction denominatorFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useTick, useNeutralColor),
		m_account(account),
		m_nominatorFunction(nominatorFunction),
		m_denominatorFunction(denominatorFunction)
	{
	}

//	virtual bool CanBeNegative() const{return !m_absValue;}
	virtual Money DeriveValue(const Money& nominator, const Money& denominator) const
	{
		if(!nominator.isZero() && !denominator.isZero())
		{
			Money value(nominator);
			DivideMoneyByMoneyPercent(value, denominator);
//			value *= 1000000;
//			value /= (denominator * 10000).GetDollars();
			return value;
		}
		return Money::moneyZero;
	}
	Money DeriveValue() const{return DeriveValue(m_nominator, m_denominator);}
	Money CalculateValue() const{return DeriveValue((m_account->*m_nominatorFunction)(), (m_account->*m_denominatorFunction)());}
	virtual bool isValueChanged() const override{return m_nominator != (m_account->*m_nominatorFunction)() || m_denominator != (m_account->*m_denominatorFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_nominator = (m_account->*m_nominatorFunction)();
		m_denominator = (m_account->*m_denominatorFunction)();
		return SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return (m_account->*m_denominatorFunction)().isZero();}
	virtual bool isValueZero() const override{return m_denominator.isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_nominator = (m_account->*m_nominatorFunction)();
		m_denominator = (m_account->*m_denominatorFunction)();
		m_value = DeriveValue();
	}
	const Account* m_account;
	MoneyFunction m_nominatorFunction;
	MoneyFunction m_denominatorFunction;
	Money m_nominator;
	Money m_denominator;
};

class TGUI_API AccountMoneyDivisionFractionAbs : public AccountMoneyDivision
{
public:
	AccountMoneyDivisionFractionAbs(const Account* account, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction nominatorFunction, MoneyFunction denominatorFunction, bool useEmptyValue = true, bool useTick = false, bool useNeutralColor = true):
		AccountMoneyDivision(account, comma, decDigits, truncate, nominatorFunction, denominatorFunction, useEmptyValue, useTick, useNeutralColor)
	{
	}

	virtual bool CanBeNegative() const override{return false;}
	virtual Money DeriveValue(const Money& nominator, const Money& denominator) const override
	{
		if(!nominator.isZero() && !denominator.isZero())
		{
			Money value(nominator);
			DivideMoneyByMoney(value, denominator);
			return value;
		}
		return Money::moneyZero;
	}
	DECLARE_NED_NEW
};

class TGUI_API AccountMoneyDivisionV : public MoneyRowValue
{
public:
	typedef ValueType(Account::*MoneyFunction)() const;
	AccountMoneyDivisionV(const Account* account, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction nominatorFunction, MoneyFunction denominatorFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useTick, useNeutralColor),
		m_account(account),
		m_nominatorFunction(nominatorFunction),
		m_denominatorFunction(denominatorFunction)
	{
	}

//	virtual bool CanBeNegative() const{return !m_absValue;}
	virtual Money DeriveValue(const Money& nominator, const Money& denominator) const
	{
		if(!nominator.isZero() && !denominator.isZero())
		{
			Money value(nominator);
			DivideMoneyByMoneyPercent(value, denominator);
//			value *= 1000000;
//			value /= (denominator * 10000).GetDollars();
			return value;
		}
		return Money::moneyZero;
	}
	Money DeriveValue() const{return DeriveValue(m_nominator, m_denominator);}
	Money CalculateValue() const{return DeriveValue((m_account->*m_nominatorFunction)(), (m_account->*m_denominatorFunction)());}
	virtual bool isValueChanged() const override{return m_nominator != (m_account->*m_nominatorFunction)() || m_denominator != (m_account->*m_denominatorFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_nominator = (m_account->*m_nominatorFunction)();
		m_denominator = (m_account->*m_denominatorFunction)();
		return SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return (m_account->*m_denominatorFunction)().isZero();}
	virtual bool isValueZero() const override{return m_denominator.isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_nominator = (m_account->*m_nominatorFunction)();
		m_denominator = (m_account->*m_denominatorFunction)();
		m_value = DeriveValue();
	}
	const Account* m_account;
	MoneyFunction m_nominatorFunction;
	MoneyFunction m_denominatorFunction;
	Money m_nominator;
	Money m_denominator;
};

class TGUI_API AccountMoneyDivisionVFractionAbs : public AccountMoneyDivisionV
{
public:
	AccountMoneyDivisionVFractionAbs(const Account* account, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction nominatorFunction, MoneyFunction denominatorFunction, bool useEmptyValue = true, bool useTick = false, bool useNeutralColor = true):
		AccountMoneyDivisionV(account, comma, decDigits, truncate, nominatorFunction, denominatorFunction, useEmptyValue, useTick, useNeutralColor)
	{
	}

	virtual bool CanBeNegative() const override{return false;}
	virtual Money DeriveValue(const Money& nominator, const Money& denominator) const override
	{
		if(!nominator.isZero() && !denominator.isZero())
		{
			Money value(nominator);
			DivideMoneyByMoney(value, denominator);
			return value;
		}
		return Money::moneyZero;
	}
	DECLARE_NED_NEW
};


/*
class TGUI_API AccountMoneyDivisionPlus100Percent : public AccountMoneyDivision
{
public:
	AccountMoneyDivisionPlus100Percent(const Account* account, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction nominatorFunction, MoneyFunction denominatorFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		AccountMoneyDivision(account, comma, decDigits, truncate, nominatorFunction, denominatorFunction, useEmptyValue, useTick, useNeutralColor)
	{
	}

	virtual Money DeriveValue(const Money& nominator, const Money& denominator) const override
	{
		if(!nominator.isZero() && !denominator.isZero())
		{
			Money value(nominator);
			DivideMoneyByMoneyPercent(value, denominator);
			value.AddDollars(100);
			return value;
		}
		return Money::moneyZero;
	}
	DECLARE_NED_NEW
};
*/
class TGUI_API AccountMoneyInventoryByMoneyDivision : public AccountMoneyInventoryRowValue
{
public:
	typedef const Money& (Account::*MoneyNoInventoryFunction)() const;
	AccountMoneyInventoryByMoneyDivision(const Account* account, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction nominatorFunction, MoneyNoInventoryFunction denominatorFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		AccountMoneyInventoryRowValue(account, inventoryView, comma, decDigits, truncate, nominatorFunction, useEmptyValue, useNeutralColor, useTick),
		m_denominatorFunction(denominatorFunction)
	{
	}

	virtual Money DeriveValue(const Money& nominator, const Money& denominator) const
	{
		if(!nominator.isZero() && !denominator.isZero())
		{
			Money value(nominator);
			DivideMoneyByMoneyPercent(value, denominator);
			return value;
		}
		return Money::moneyZero;
	}
	Money DeriveValue() const{return DeriveValue(m_nominator, m_denominator);}
	Money CalculateValue() const{return DeriveValue((m_account->*m_moneyFunction)(m_inventoryView), (m_account->*m_denominatorFunction)());}
	virtual bool isValueChanged() const override{return m_nominator != (m_account->*m_moneyFunction)(m_inventoryView) || m_denominator != (m_account->*m_denominatorFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_nominator = (m_account->*m_moneyFunction)(m_inventoryView);
		m_denominator = (m_account->*m_denominatorFunction)();
		return SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return (m_account->*m_denominatorFunction)().isZero();}
	virtual bool isValueZero() const override{return m_denominator.isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_nominator = (m_account->*m_moneyFunction)(m_inventoryView);
		m_denominator = (m_account->*m_denominatorFunction)();
		m_value = DeriveValue();
	}
	MoneyNoInventoryFunction m_denominatorFunction;
	Money m_nominator;
	Money m_denominator;
};

class TGUI_API AccountMoneyInventoryDivision : public AccountMoneyInventoryRowValue
{
public:
	AccountMoneyInventoryDivision(const Account* account, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction nominatorFunction, MoneyFunction denominatorFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		AccountMoneyInventoryRowValue(account, inventoryView, comma, decDigits, truncate, nominatorFunction, useEmptyValue, useNeutralColor, useTick),
		m_denominatorFunction(denominatorFunction)
	{
	}

	virtual Money DeriveValue(const Money& nominator, const Money& denominator) const
	{
		if(!nominator.isZero() && !denominator.isZero())
		{
			Money value(nominator);
			DivideMoneyByMoney(value, denominator);
			return value;
		}
		return Money::moneyZero;
	}
	Money DeriveValue() const{return DeriveValue(m_nominator, m_denominator);}
	Money CalculateValue() const{return DeriveValue((m_account->*m_moneyFunction)(m_inventoryView), (m_account->*m_denominatorFunction)(m_inventoryView));}
	virtual bool isValueChanged() const override{return m_nominator != (m_account->*m_moneyFunction)(m_inventoryView) || m_denominator != (m_account->*m_denominatorFunction)(m_inventoryView);}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_nominator = (m_account->*m_moneyFunction)(m_inventoryView);
		m_denominator = (m_account->*m_denominatorFunction)(m_inventoryView);
		return SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return (m_account->*m_denominatorFunction)(m_inventoryView).isZero();}
	virtual bool isValueZero() const override{return m_denominator.isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_nominator = (m_account->*m_moneyFunction)(m_inventoryView);
		m_denominator = (m_account->*m_denominatorFunction)(m_inventoryView);
		m_value = DeriveValue();
	}
	MoneyFunction m_denominatorFunction;
	Money m_nominator;
	Money m_denominator;
};

/*
class TGUI_API AccountMoneyInventoryByMoneyDivisionPlus100Percent : public AccountMoneyInventoryByMoneyDivision
{
public:
	AccountMoneyInventoryByMoneyDivisionPlus100Percent(const Account* account, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction nominatorFunction, MoneyNoInventoryFunction denominatorFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		AccountMoneyInventoryByMoneyDivision(account, inventoryView, comma, decDigits, truncate, nominatorFunction, denominatorFunction, useEmptyValue, useTick, useNeutralColor)
	{
	}

	virtual Money DeriveValue(const Money& nominator, const Money& denominator) const override
	{
		if(!denominator.isZero())
		{
			if(!nominator.isZero())
			{
				Money value(nominator);
				DivideMoneyByMoneyPercent(value, denominator);
				value.AddDollars(100);
				return value;
			}
			return Money(100, 0);
		}
		return Money::moneyZero;
	}
	DECLARE_NED_NEW
};
*/
class TGUI_API AccountMoneyInventoryByMoneyDivisionPlus100PercentNoNegative : public AccountMoneyInventoryByMoneyDivision
{
public:
	AccountMoneyInventoryByMoneyDivisionPlus100PercentNoNegative(const Account* account, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction nominatorFunction, MoneyNoInventoryFunction denominatorFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		AccountMoneyInventoryByMoneyDivision(account, inventoryView, comma, decDigits, truncate, nominatorFunction, denominatorFunction, useEmptyValue, useTick, useNeutralColor)
	{
	}

	virtual Money DeriveValue(const Money& nominator, const Money& denominator) const override
	{
		if(denominator.isPositive() && -nominator < denominator)
		{
			Money value(nominator);
			DivideMoneyByMoneyPercent(value, denominator);
			value.AddDollars(100);
			return value;
		}
		return Money::moneyZero;
	}
	DECLARE_NED_NEW
};

class TGUI_API AccountMoneyInventoryByMoneyDivisionV : public AccountMoneyInventoryVRowValue
{
public:
	typedef Money (Account::*MoneyNoInventoryFunction)() const;
	AccountMoneyInventoryByMoneyDivisionV(const Account* account, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction nominatorFunction, MoneyNoInventoryFunction denominatorFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		AccountMoneyInventoryVRowValue(account, inventoryView, comma, decDigits, truncate, nominatorFunction, useEmptyValue, useNeutralColor, useTick),
		m_denominatorFunction(denominatorFunction)
	{
	}

	virtual Money DeriveValue(const Money& nominator, const Money& denominator) const
	{
		if(!nominator.isZero() && !denominator.isZero())
		{
			Money value(nominator);
			DivideMoneyByMoneyPercent(value, denominator);
			return value;
		}
		return Money::moneyZero;
	}
	Money DeriveValue() const{return DeriveValue(m_nominator, m_denominator);}
	Money CalculateValue() const{return DeriveValue((m_account->*m_moneyFunction)(m_inventoryView), (m_account->*m_denominatorFunction)());}
	virtual bool isValueChanged() const override{return m_nominator != (m_account->*m_moneyFunction)(m_inventoryView) || m_denominator != (m_account->*m_denominatorFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_nominator = (m_account->*m_moneyFunction)(m_inventoryView);
		m_denominator = (m_account->*m_denominatorFunction)();
		return SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return (m_account->*m_denominatorFunction)().isZero();}
	virtual bool isValueZero() const override{return m_denominator.isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_nominator = (m_account->*m_moneyFunction)(m_inventoryView);
		m_denominator = (m_account->*m_denominatorFunction)();
		m_value = DeriveValue();
	}
	MoneyNoInventoryFunction m_denominatorFunction;
	Money m_nominator;
	Money m_denominator;
};

class TGUI_API AccountMoneyInventoryByMoneyDivisionPlus100PercentNoNegativeV : public AccountMoneyInventoryByMoneyDivisionV
{
public:
	AccountMoneyInventoryByMoneyDivisionPlus100PercentNoNegativeV(const Account* account, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction nominatorFunction, MoneyNoInventoryFunction denominatorFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		AccountMoneyInventoryByMoneyDivisionV(account, inventoryView, comma, decDigits, truncate, nominatorFunction, denominatorFunction, useEmptyValue, useTick, useNeutralColor)
	{
	}

	virtual Money DeriveValue(const Money& nominator, const Money& denominator) const override
	{
		if(denominator.isPositive() && -nominator < denominator)
		{
			Money value(nominator);
			DivideMoneyByMoneyPercent(value, denominator);
			value.AddDollars(100);
			return value;
		}
		return Money::moneyZero;
	}
	DECLARE_NED_NEW
};



class TGUI_API AccountMoneyDivisionNegative : public AccountMoneyDivision
{
public:
	AccountMoneyDivisionNegative(const Account* account, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction nominatorFunction, MoneyFunction denominatorFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		AccountMoneyDivision(account, comma, decDigits, truncate, nominatorFunction, denominatorFunction, useEmptyValue, useTick, useNeutralColor)
	{
	}
	virtual Money DeriveValue(const Money& nominator, const Money& denominator) const override
	{
		if(!nominator.isZero() && !denominator.isZero())
		{
			Money value(-nominator);
			DivideMoneyByMoneyPercent(value, denominator);
//			value *= 1000000;
//			value /= (denominator * 10000).GetDollars();
			return value;
		}
		return Money::moneyZero;
	}
	DECLARE_NED_NEW
};

class TGUI_API AccountMoneyDivisionNegativeOrZero : public AccountMoneyDivision
{
public:
	AccountMoneyDivisionNegativeOrZero(const Account* account, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction nominatorFunction, MoneyFunction denominatorFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		AccountMoneyDivision(account, comma, decDigits, truncate, nominatorFunction, denominatorFunction, useEmptyValue, useTick, useNeutralColor)
	{
	}
	virtual Money DeriveValue(const Money& nominator, const Money& denominator) const override
	{
		if(nominator.isNegative() && !denominator.isZero())
		{
			Money value(-nominator);
			DivideMoneyByMoneyPercent(value, denominator);
//			value *= 1000000;
//			value /= (denominator * 10000).GetDollars();
			return value;
		}
		return Money::moneyZero;
	}
	virtual bool isValueChanged() const override//{return m_signedPrice != (m_security->*m_signedPriceFunction)() || m_price != (m_security->*m_priceFunction)();}
	{
		const Money& nominator = (m_account->*m_nominatorFunction)();
		return (nominator.isNegative() || m_nominator.isNegative()) && (m_nominator != nominator || m_denominator != (m_account->*m_denominatorFunction)());
	}
	DECLARE_NED_NEW
};

class TGUI_API AccountMoneyDivisionVNegativeOrZero : public AccountMoneyDivisionV
{
public:
	AccountMoneyDivisionVNegativeOrZero(const Account* account, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction nominatorFunction, MoneyFunction denominatorFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		AccountMoneyDivisionV(account, comma, decDigits, truncate, nominatorFunction, denominatorFunction, useEmptyValue, useTick, useNeutralColor)
	{
	}
	virtual Money DeriveValue(const Money& nominator, const Money& denominator) const override
	{
		if(nominator.isNegative() && !denominator.isZero())
		{
			Money value(-nominator);
			DivideMoneyByMoneyPercent(value, denominator);
//			value *= 1000000;
//			value /= (denominator * 10000).GetDollars();
			return value;
		}
		return Money::moneyZero;
	}
	virtual bool isValueChanged() const override//{return m_signedPrice != (m_security->*m_signedPriceFunction)() || m_price != (m_security->*m_priceFunction)();}
	{
		const Money& nominator = (m_account->*m_nominatorFunction)();
		return (nominator.isNegative() || m_nominator.isNegative()) && (m_nominator != nominator || m_denominator != (m_account->*m_denominatorFunction)());
	}
	DECLARE_NED_NEW
};

class TGUI_API AccountStringPtrRowValue : public StringRowValue
{
public:
	typedef const char* const& (Account::*StringPtrFunction)() const;
	AccountStringPtrRowValue(const Account* account, StringPtrFunction stringFunction):m_account(account),m_stringFunction(stringFunction){}
	virtual const ValueType& GetObjectValue() const override
	{
		const char* const& ret = (m_account->*m_stringFunction)();
		if(ret)
		{
			if(strcmp(m_tempValue.c_str(), ret))
			{
				m_tempValue = ret;
			}
		}
		else if(!m_tempValue.empty())
		{
			m_tempValue.clear();
		}
		return m_tempValue;
	}
	DECLARE_NED_NEW
protected:
	const Account* m_account;
	StringPtrFunction m_stringFunction;
	mutable ValueType m_tempValue;
};

class TGUI_API AccountCharPtrRowValue : public CharPtrRowValue
{
public:
	typedef ValueType (Account::*StringPtrFunction)() const;
	AccountCharPtrRowValue(const Account* account, StringPtrFunction stringFunction, bool caseInsensitive = false):
		CharPtrRowValue(caseInsensitive), m_account(account),m_stringFunction(stringFunction),m_tempValue(""){}
	virtual ValueType const& GetObjectValue() const override
	{
		const char* ret = (m_account->*m_stringFunction)();
		if(ret)
		{
			if(strcmp(m_tempValue, ret))
			{
				m_tempValue = ret;
			}
		}
		else
		{
			m_tempValue = "";
		}
		return m_tempValue;
	}
	DECLARE_NED_NEW
protected:
	const Account* m_account;
	StringPtrFunction m_stringFunction;
	mutable ValueType m_tempValue;
};
////

class TGUI_API PositionCharPtrRowValue : public CharPtrRowValue
{
public:
	typedef ValueType (PositionData::*StringPtrFunction)() const;
	PositionCharPtrRowValue(const PositionData* position, StringPtrFunction stringFunction, bool caseInsensitive = false):
		CharPtrRowValue(caseInsensitive), m_position(position),m_stringFunction(stringFunction),m_tempValue(""){}
	virtual ValueType const& GetObjectValue() const override
	{
		const char* ret = (m_position->*m_stringFunction)();
		if(ret)
		{
			if(strcmp(m_tempValue, ret))
			{
				m_tempValue = ret;
			}
		}
		else
		{
			m_tempValue = "";
		}
		return m_tempValue;
	}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	const PositionData* m_position;
	StringPtrFunction m_stringFunction;
	mutable ValueType m_tempValue;
};


class TGUI_API PositionStringRowValue : public StringRowValue
{
public:
	typedef const ValueType& (PositionData::*StringFunction)() const;
	PositionStringRowValue(const PositionData* position, StringFunction stringFunction):m_position(position),m_stringFunction(stringFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_position->*m_stringFunction)();}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	const PositionData* m_position;
	StringFunction m_stringFunction;
};

class TGUI_API PositionIntRowValueNoComma : public IntRowValueNoComma
{
public:
	typedef const ValueType& (PositionData::*IntFunction)() const;
	PositionIntRowValueNoComma(const PositionData* position, IntFunction intFunction, bool useEmptyValue = false, bool useTick = true):
		IntRowValueNoComma(useEmptyValue, useTick), m_position(position),m_intFunction(intFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_position->*m_intFunction)();}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	const PositionData* m_position;
	IntFunction m_intFunction;
};

class TGUI_API PositionIntRowValue : public IntRowValue
{
public:
	typedef const ValueType& (PositionData::*IntFunction)() const;
	PositionIntRowValue(const PositionData* const& position,
		const bool* comma,
		IntFunction intFunction,
		const bool& useEmptyValue = false,
		const bool& useTick = true):
		IntRowValue(comma, useEmptyValue, useTick), m_position(position),m_intFunction(intFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_position->*m_intFunction)();}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	const PositionData* m_position;
	IntFunction m_intFunction;
};

class TGUI_API PositionIntInInventoryRowValue : public PositionIntRowValue
{
public:
	PositionIntInInventoryRowValue(const PositionData* const& position,
		const bool* comma,
		IntFunction intFunction,
		const bool& useEmptyValue = false,
		const bool& useTick = true):
		PositionIntRowValue(position, comma, intFunction, useEmptyValue, useTick),
		m_hasInventory(false)
	{}

	virtual bool isValueEmpty() const override{return m_useEmptyValue && !m_hasInventory;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !m_position->hasInventory();}
	virtual bool isValueChanged() const override{return PositionIntRowValue::isValueChanged() || m_hasInventory != m_position->hasInventory();}
	virtual bool SetValue(const ValueType& value) override
	{
		bool ret = PositionIntRowValue::SetValue(value);
		if(m_hasInventory != m_position->hasInventory())
		{
			m_hasInventory = !m_hasInventory;
			ret = true;
		}
		return ret;
	}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{PositionIntRowValue::InitializeValue(); m_hasInventory = m_position->hasInventory();}
	bool m_hasInventory;
};

class TGUI_API PositionIntValRowValue : public IntRowValue
{
public:
	typedef ValueType (PositionData::*IntFunction)() const;
	PositionIntValRowValue(const PositionData* position, const bool* comma, IntFunction intFunction, bool useEmptyValue = false, bool useTick = true):
		IntRowValue(comma, useEmptyValue, useTick), m_position(position),m_intFunction(intFunction){}
//	virtual const ValueType& GetObjectValue() const override{return (m_position->*m_intFunction)();}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	virtual ValueType GetVal() const{return (m_position->*m_intFunction)();}
	virtual bool isValueChanged() const override{return m_value != GetVal();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(GetVal());}
	virtual bool UpdateValue() override{return SetValue(GetVal());}
	virtual bool isObjectValueZero() const override{return !GetVal();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue(){m_value = (m_position->*m_intFunction)();}
	const PositionData* m_position;
	IntFunction m_intFunction;
};

class TGUI_API PositionIntInventoryRowValue : public IntRowValue
{
public:
	typedef const ValueType& (PositionData::*IntFunction)(const bool& inventoryView) const;
	PositionIntInventoryRowValue(const PositionData* position, const bool& inventoryView, const bool* comma, IntFunction intFunction, bool useEmptyValue = false, bool useTick = true):
		IntRowValue(comma, useEmptyValue, useTick),
		m_position(position),
		m_intFunction(intFunction),
		m_inventoryView(inventoryView)
		{}
	virtual const ValueType& GetObjectValue() const override{return (m_position->*m_intFunction)(m_inventoryView);}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	const PositionData* m_position;
	IntFunction m_intFunction;
	const bool& m_inventoryView;
};
/*
class TGUI_API PositionIntSignRowValueNoComma : public PositionIntRowValueNoComma
{
public:
	PositionIntSignRowValueNoComma(const PositionData* position, IntFunction intFunction, bool useEmptyValue = false, bool useTick = true):
		PositionIntRowValueNoComma(position, intFunction, useEmptyValue, useTick){}
	virtual const ValueType& GetObjectValue() const
	{
		int val = (m_position->*m_intFunction)();
		return val < 0 ? minusOne : val > 0 ? one : zero;
	}
	DECLARE_NED_NEW
};
*/
class TGUI_API PositionIntSignRowValue : public PositionIntValRowValue
{
public:
	PositionIntSignRowValue(const PositionData* position, const bool* comma, IntFunction intFunction, bool useEmptyValue = false, bool useTick = true):
		PositionIntValRowValue(position, comma, intFunction, useEmptyValue, useTick){}
	virtual ValueType GetVal() const override
	{
		ValueType val = (m_position->*m_intFunction)();
		return val < 0 ? minusOne : val > 0 ? one : zero;
	}
/*
	virtual const ValueType& GetObjectValue() const
	{
		int val = (m_position->*m_intFunction)();
		return val < 0 ? minusOne : val > 0 ? one : zero;
	}
*/
	DECLARE_NED_NEW
};

class TGUI_API PositionIntSignConditionalRowValue : public PositionIntSignRowValue
{
public:
	PositionIntSignConditionalRowValue(const PositionData* position, const bool* comma, IntFunction intFunction, const bool& useValue, bool useEmptyValue = false, bool useTick = true):
		PositionIntSignRowValue(position, comma, intFunction, useEmptyValue, useTick),m_useValue(useValue){}
	virtual ValueType GetVal() const override
	{
//02/28/2019 if !m_useValue then show zero
		return m_useValue ? PositionIntValRowValue::GetVal() : 0;// PositionIntSignRowValue::GetVal();
	}
/*
	virtual const ValueType& GetObjectValue() const
	{
		return m_useValue ? PositionIntRowValue::GetObjectValue() : PositionIntSignRowValue::GetObjectValue();
	}
*/
	DECLARE_NED_NEW
	const bool& m_useValue;
};

class TGUI_API PositionUCharAsCharVRowValue : public UCharAsCharRowValue
{
public:
	typedef ValueType (PositionData::*UCharFunction)() const;
	PositionUCharAsCharVRowValue(const PositionData* position, UCharFunction ucharFunction, const ValueType& value = '\0', bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		UCharAsCharRowValue(value, useEmptyValue, useTick), m_position(position),m_ucharFunction(ucharFunction){}
	virtual bool isValueChanged() const override{return m_value != (m_position->*m_ucharFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_position->*m_ucharFunction)());}
	virtual bool UpdateValue() override{return SetValue((m_position->*m_ucharFunction)());}
	virtual bool isObjectValueZero() const override{return !(m_position->*m_ucharFunction)();}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_position->*m_ucharFunction)();}
	const PositionData* m_position;
	UCharFunction m_ucharFunction;
};

class TGUI_API PositionCharAsIntRowValue : public CharAsIntRowValue
{
public:
	typedef const ValueType& (PositionData::*CharFunction)() const;
	PositionCharAsIntRowValue(const PositionData* position, CharFunction charFunction, bool useEmptyValue = false, bool useTick = true):
		CharAsIntRowValue(useEmptyValue, useTick), m_position(position),m_charFunction(charFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_position->*m_charFunction)();}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	const PositionData* m_position;
	CharFunction m_charFunction;
};

class TGUI_API PositionIntRowValueNull : public PositionIntRowValue
{
public:
	PositionIntRowValueNull(const PositionData* position, const bool* comma, IntFunction intFunction, bool useEmptyValue = false, bool useTick = true):
		PositionIntRowValue(position, comma, intFunction, useEmptyValue, useTick),
		m_positionZero(!m_position)
		{}
	virtual const ValueType& GetObjectValue() const override{return m_position ? (m_position->*m_intFunction)() : zero;}
	virtual bool isValueEmpty() const override{return m_useEmptyValue && m_positionZero;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !m_position;}

	virtual bool isValueChanged() const override{return PositionIntRowValue::isValueChanged() || m_positionZero != !m_position;} //m_value != GetObjectValue();}
	virtual bool SetValue(const ValueType& value) override// in future we can add the time when the change happened
	{
		bool ret = PositionIntRowValue::SetValue(value);
		if(m_positionZero != !m_position)
		{
			m_positionZero = !m_position;
			ret = true;
		}
		return ret;
	}

	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{PositionIntRowValue::InitializeValue(); m_positionZero = !m_position;}
	bool m_positionZero;
};

class TGUI_API PositionIntInventoryRowValueNull : public PositionIntInventoryRowValue
{
public:
	PositionIntInventoryRowValueNull(const PositionData* position, const bool& inventoryView, const bool* comma, IntFunction intFunction, bool useEmptyValue = false, bool useTick = true):
		PositionIntInventoryRowValue(position, inventoryView, comma, intFunction, useEmptyValue, useTick),
		m_positionZero(!m_position)
	{}
	virtual const ValueType& GetObjectValue() const override{return m_position ? (m_position->*m_intFunction)(m_inventoryView) : zero;}
	virtual bool isValueEmpty() const override{return m_useEmptyValue && m_positionZero;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !m_position;}
	virtual bool isValueChanged() const override{return PositionIntInventoryRowValue::isValueChanged() || m_positionZero != !m_position;}
	virtual bool SetValue(const ValueType& value) override
	{
		bool ret = PositionIntInventoryRowValue::SetValue(value);
		if(m_positionZero != !m_position)
		{
			m_positionZero = !m_position;
			ret = true;
		}
		return ret;
	}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{PositionIntInventoryRowValue::InitializeValue(); m_positionZero = !m_position;}
	bool m_positionZero;
};

class TGUI_API PositionIntInventoryRowValueUIntPlusMinusAdjNull : public PositionIntInventoryRowValue
{
public:
//	typedef const ValueType& (PositionData::*IntFunction)(const bool& inventoryView) const;
	typedef const unsigned int& (PositionData::*UIntFunction)() const;

	PositionIntInventoryRowValueUIntPlusMinusAdjNull(const PositionData* position, const bool& inventoryView, const bool* comma, IntFunction intFunction, UIntFunction uintFunctionPlus, UIntFunction uintFunctionMinus, bool useEmptyValue = true, bool useTick = true):
		PositionIntInventoryRowValue(position, inventoryView, comma, intFunction, useEmptyValue, useTick),
		m_uintFunctionPlus(uintFunctionPlus),
		m_uintFunctionMinus(uintFunctionMinus),
		m_positionZero(!m_position)
	{
	}
	static ValueType CalculateSize(const ValueType& size, const ValueType& sizePlus, const ValueType& sizeMinus)//{if(price && price2)value = SignedPrice(price) - SignedPrice(price2);	else value.SetZero();}
	{
		return size + sizePlus - sizeMinus;
	}
	ValueType CalculateCurrentSize() const
	{
		return m_position ? CalculateSize((m_position->*m_intFunction)(m_inventoryView), (int)(m_position->*m_uintFunctionPlus)(), (int)(m_position->*m_uintFunctionMinus)()) : 0;
	}
//	virtual bool isValueChanged() const;
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateCurrentSize());}
	virtual bool UpdateValue() override{return SetValue(CalculateCurrentSize());}
	virtual bool isObjectValueZero() const override{return !CalculateCurrentSize();}
	virtual bool isValueEmpty() const override{return m_useEmptyValue && m_positionZero;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !m_position;}
	virtual bool isValueChanged() const override{return CalculateCurrentSize() != m_value || m_positionZero != !m_position;}
	virtual bool SetValue(const ValueType& value) override
	{
		bool ret = PositionIntInventoryRowValue::SetValue(value);
		if(m_positionZero != !m_position)
		{
			m_positionZero = !m_positionZero;//!m_position;
			ret = true;
		}
		return ret;
	}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_value = CalculateCurrentSize();
		m_positionZero = !m_position;
	}
	UIntFunction m_uintFunctionPlus;
	UIntFunction m_uintFunctionMinus;
	bool m_positionZero;
};

class TGUI_API PositionPriceInvMinusSecurityPriceAsPercentageOfSecurityPrice : public SignedPriceRowValue
{
public:
	typedef const Price& (PositionData::*PosPriceFunction)(const bool& inventoryView) const;
	typedef const Price& (Security::*SecPriceFunction)() const;

	PositionPriceInvMinusSecurityPriceAsPercentageOfSecurityPrice(const PositionData* position,
		const Security* security,
		const bool& inventoryView,
		const bool* comma,
		const unsigned char* decDigits,
		const bool* truncate,
		PosPriceFunction posFunction,
		SecPriceFunction secFunction,
		bool useEmptyValue = true,
		bool useTick = true,
		bool useNeutralColor = false):
		SignedPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick, useNeutralColor),
		m_posPriceFunction(posFunction),
		m_secPriceFunction(secFunction),
		m_position(position),
		m_security(security),
		m_inventoryView(inventoryView),
		m_positionZero(!m_position)
	{
	}
	static ValueType CalculateValue(const Price& posPrice, const Price& secPrice)
	{
		return posPrice.isZero() || secPrice.isZero() ? SignedPrice::signedPriceZero : secPrice.GetPercentChange(posPrice - secPrice);
	}
	ValueType CalculateCurrentValue() const
	{
		return m_position && m_security ? CalculateValue((m_position->*m_posPriceFunction)(m_inventoryView), (m_security->*m_secPriceFunction)()) : SignedPrice::signedPriceZero;
	}
//	virtual bool isValueChanged() const;
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateCurrentValue());}
	virtual bool UpdateValue() override
	{
		return SetValue(CalculateCurrentValue());
	}
	virtual bool isObjectValueZero() const override{return !CalculateCurrentValue();}
	virtual bool isValueEmpty() const override{return m_useEmptyValue && m_positionZero;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && (!m_position || !m_security);}
	virtual bool isValueChanged() const override{return CalculateCurrentValue() != m_value || m_positionZero != (!m_position || !m_security);}
	virtual bool SetValue(const ValueType& value) override
	{
		bool ret = SignedPriceRowValue::SetValue(value);
		if(m_positionZero != (!m_position || !m_security))
		{
			m_positionZero = (!m_position || !m_security);
			ret = true;
		}
		return ret;
	}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_value = CalculateCurrentValue();
		m_positionZero = (!m_position || !m_security);
	}
	PosPriceFunction m_posPriceFunction;
	SecPriceFunction m_secPriceFunction;
	const PositionData* m_position;
	const Security* m_security;
	const bool& m_inventoryView;
	bool m_positionZero;
};

class TGUI_API PositionUIntRowValue : public UIntRowValue
{
public:
	typedef const ValueType& (PositionData::*UIntFunction)() const;
	PositionUIntRowValue(const PositionData* position, const bool* comma, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true):
		UIntRowValue(comma, useEmptyValue, useTick), m_position(position),m_uintFunction(uintFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_position->*m_uintFunction)();}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	const PositionData* m_position;
	UIntFunction m_uintFunction;
};

class TGUI_API PositionUIntInventoryRowValue : public UIntRowValue
{
public:
	typedef const ValueType& (PositionData::*UIntFunction)(const bool& inventoryView) const;
	PositionUIntInventoryRowValue(const PositionData* position, const bool& inventoryView, const bool* comma, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true):
		UIntRowValue(comma, useEmptyValue, useTick),
		m_position(position),
		m_uintFunction(uintFunction),
		m_inventoryView(inventoryView)
	{}
	virtual const ValueType& GetObjectValue() const override{return (m_position->*m_uintFunction)(m_inventoryView);}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	const PositionData* m_position;
	UIntFunction m_uintFunction;
	const bool& m_inventoryView;
};

class TGUI_API PositionSecurityUIntDevidedByUIntInventoryRowValue : public PriceRowValue
{
public:
	typedef const unsigned int& (PositionData::*UIntPositionFunction)(const bool& inventoryView) const;
	typedef const unsigned int& (Security::*UIntSecurityFunction)() const;
	PositionSecurityUIntDevidedByUIntInventoryRowValue(const PositionData* position,
		const Security* const& security,
		const bool& inventoryView,
		const bool* comma,
		const unsigned char* decDigits,
		const bool* truncate,
		UIntPositionFunction uintPositionFunction,
		UIntSecurityFunction uintSecurityFunction,
		const unsigned int& multiplier,
		const bool& useEmptyValue = true):

		PriceRowValue(comma, decDigits, truncate, useEmptyValue, false),
		m_position(position),
		m_security(security),
		m_uintPositionFunction(uintPositionFunction),
		m_uintSecurityFunction(uintSecurityFunction),
		m_inventoryView(inventoryView),
		m_positionValue(0),//m_positionSize
		m_securityValue(0),//m_tierSize
		m_multiplier(multiplier ? multiplier : 1)
	{}
//	virtual const ValueType& GetObjectValue() const;//{return m_security ? (m_security->*m_uintFunction)() : zero;}//m_emptyValue;}
//	virtual void SetPosition(const PositionData* position){m_position = position;}
/*
	inline static bool isValueZeroStatic(const unsigned int& value)
	{
		switch(value)
		{
			case 0:
			case 0xFFFFFFFF:
			return true;

			default:
			return false;
		}
	}
*/
	Price DeriveValueFromComponents(const unsigned int& positionValue, const unsigned int& securityValue) const
	{
//		if(positionValue && !isValueZeroStatic(securityValue))
		if(positionValue && securityValue && securityValue != 0xFFFFFFFF)
		{
			Price result(positionValue, 0);
			result /= securityValue * m_multiplier;
			return result;
		}
		return Price::priceZero;
	}

	virtual const unsigned int& GetSecurityObjectValue() const{return (m_security->*m_uintSecurityFunction)();}

	Money DeriveValue() const{return DeriveValueFromComponents(m_positionValue, m_securityValue);}
	Money CalculateValue() const{return m_security ? DeriveValueFromComponents((m_position->*m_uintPositionFunction)(m_inventoryView), GetSecurityObjectValue()) : Price::priceZero;}

	virtual bool isValueChanged() const override{return m_security ? m_positionValue != (m_position->*m_uintPositionFunction)(m_inventoryView) || m_securityValue != GetSecurityObjectValue() : m_securityValue != 0;}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		bool changed;
		if(m_security)
		{
			const unsigned int& positionValue = (m_position->*m_uintPositionFunction)(m_inventoryView);
			const unsigned int& securityValue = GetSecurityObjectValue();
			changed = positionValue != m_positionValue;
			if(changed)m_positionValue = positionValue;
			if(securityValue != m_securityValue)
			{
				changed = true;
				m_securityValue = securityValue;
			}
		}
		else
		{
			changed = m_securityValue != 0;
			if(changed)m_securityValue = 0;
			m_positionValue = (m_position->*m_uintPositionFunction)(m_inventoryView);
		}
		return changed && SetValue(DeriveValue());
	}
//	virtual bool isObjectValueZero() const override{return !(m_position->*m_uintPositionFunction)(m_inventoryView) || !m_security || !GetSecurityObjectValue();}
//	virtual bool isValueZero() const override{return !m_positionValue || !m_securityValue;}

//	virtual bool isObjectValueZero() const override{return !(m_position->*m_uintPositionFunction)(m_inventoryView) || !m_security || isValueZeroStatic(GetSecurityObjectValue());}//!(m_security->*m_uintSecurityFunction)();}
//	virtual bool isValueZero() const override{return !m_positionValue || isValueZeroStatic(m_securityValue);}// !m_securityValue;}

	virtual bool isObjectValueZero() const override{return !(m_position->*m_uintPositionFunction)(m_inventoryView) || !m_security || GetSecurityObjectValue() == 0xFFFFFFFF;}//!(m_security->*m_uintSecurityFunction)();}
	virtual bool isValueZero() const override{return !m_positionValue || m_securityValue == 0xFFFFFFFF;}// !m_securityValue;}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_positionValue = (m_position->*m_uintPositionFunction)(m_inventoryView);
		m_securityValue = m_security ? GetSecurityObjectValue() : 0;
		m_value = DeriveValue();
	}
	const PositionData* m_position;
	const Security* const& m_security;
	UIntPositionFunction m_uintPositionFunction;
	UIntSecurityFunction m_uintSecurityFunction;
	const bool& m_inventoryView;
	unsigned int m_positionValue;
	unsigned int m_securityValue;
	unsigned int m_multiplier;
};

class TGUI_API PositionSecurityPriceInvMinusPriceAsPercentageOfSecurityPrice : public SignedPriceRowValue
{
public:
	typedef const Price& (PositionData::*PosPriceFunction)(const bool& inventoryView) const;
	typedef const Price& (Security::*SecPriceFunction)() const;

	PositionSecurityPriceInvMinusPriceAsPercentageOfSecurityPrice(const PositionData* position,
		const Security* const& security,
		const bool& inventoryView,
		const bool* comma,
		const unsigned char* decDigits,
		const bool* truncate,
		PosPriceFunction posFunction,
		SecPriceFunction secFunction,
		bool useEmptyValue = true,
		bool useTick = true,
		bool useNeutralColor = false):
		SignedPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick, useNeutralColor),
		m_posPriceFunction(posFunction),
		m_secPriceFunction(secFunction),
		m_position(position),
		m_security(security),
		m_inventoryView(inventoryView),
		m_securityZero(!security)
	{
	}
	static ValueType CalculateValue(const Price& posPrice, const Price& secPrice)
	{
		return posPrice.isZero() || secPrice.isZero() ? SignedPrice::signedPriceZero : secPrice.GetPercentChange(posPrice - secPrice);
	}
	ValueType CalculateCurrentValue() const
	{
		return m_security ? CalculateValue((m_position->*m_posPriceFunction)(m_inventoryView), (m_security->*m_secPriceFunction)()) : SignedPrice::signedPriceZero;
	}
//	virtual bool isValueChanged() const;
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateCurrentValue());}
	virtual bool UpdateValue() override
	{
		return SetValue(CalculateCurrentValue());
	}
	virtual bool isObjectValueZero() const override{return !CalculateCurrentValue();}
	virtual bool isValueEmpty() const override{return m_useEmptyValue && m_securityZero;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !m_security;}
	virtual bool isValueChanged() const override{return CalculateCurrentValue() != m_value || m_securityZero != !m_security;}
	virtual bool SetValue(const ValueType& value) override
	{
		bool ret = SignedPriceRowValue::SetValue(value);
		if(m_securityZero != !m_security)
		{
			m_securityZero = !m_security;
			ret = true;
		}
		return ret;
	}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_value = CalculateCurrentValue();
		m_securityZero = !m_security;
	}
	PosPriceFunction m_posPriceFunction;
	SecPriceFunction m_secPriceFunction;
	const PositionData* m_position;
	const Security* const& m_security;
	const bool& m_inventoryView;
	bool m_securityZero;
};

class TGUI_API PositionSecurityUIntDevidedByUIntAlternateInventoryRowValue : public PositionSecurityUIntDevidedByUIntInventoryRowValue
{
public:
	PositionSecurityUIntDevidedByUIntAlternateInventoryRowValue(const PositionData* position,
		const Security* const& security,
		const bool& inventoryView,
		const bool* comma,
		const unsigned char* decDigits,
		const bool* truncate,
		UIntPositionFunction uintPositionFunction,
		UIntSecurityFunction uintSecurityFunction,
		UIntSecurityFunction uintSecurityAlternateFunction,
		const unsigned int& multiplier,
		const bool& useEmptyValue = true) :

		PositionSecurityUIntDevidedByUIntInventoryRowValue(position, security, inventoryView, comma, decDigits, truncate, uintPositionFunction, uintSecurityFunction, multiplier, useEmptyValue),
		m_uintSecurityAlternateFunction(uintSecurityAlternateFunction)
	{}
	virtual const unsigned int& GetSecurityObjectValue() const
	{
		const unsigned int& value = (m_security->*m_uintSecurityFunction)();
		return value == 0xFFFFFFFF ? (m_security->*m_uintSecurityAlternateFunction)() : value;
	}
protected:
	UIntSecurityFunction m_uintSecurityAlternateFunction;
};

class TGUI_API PositionUCharRowValue : public UCharRowValue
{
public:
	typedef const ValueType& (PositionData::*UCharFunction)() const;
	PositionUCharRowValue(const PositionData* position, UCharFunction ucharFunction, bool useEmptyValue = true, bool useTick = true):
		UCharRowValue(useEmptyValue, useTick), m_position(position),m_ucharFunction(ucharFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_position->*m_ucharFunction)();}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	const PositionData* m_position;
	UCharFunction m_ucharFunction;
};

class TGUI_API PositionUCharCountableRowValue : public UCharCountableRowValue
{
public:
	typedef const ValueType& (PositionData::*UCharFunction)() const;
	PositionUCharCountableRowValue(const PositionData* position, UCharFunction ucharFunction, bool useEmptyValue = true, bool useTick = true):
		UCharCountableRowValue(useEmptyValue, useTick), m_position(position),m_ucharFunction(ucharFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_position->*m_ucharFunction)();}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	const PositionData* m_position;
	UCharFunction m_ucharFunction;
};

class TGUI_API PositionUntradeableRowValue : public PositionUCharCountableRowValue
{
public:
	PositionUntradeableRowValue(const PositionData* position) :
		PositionUCharCountableRowValue(position, &Position::GetUntradeable, true, false)
	{}
	virtual void toString(std::string& text) const override
	{
		switch(m_value)
		{
			case US_UNTRADEABLE_FULL:
			text += "Full Untradeable";
			break;

			case US_UNTRADEABLE_PARTIAL:
			text += "Partial Untradeable";
			break;
		}
	}
	DECLARE_NED_NEW
};



class TGUI_API PositionUIntRowValueNull : public PositionUIntRowValue
{
public:
	PositionUIntRowValueNull(const PositionData* position, const bool* comma, UIntFunction uintFunction, bool useEmptyValue = false, bool useTick = true):
		PositionUIntRowValue(position, comma, uintFunction, useEmptyValue, useTick),
		m_positionZero(!m_position)
		{}
	virtual const ValueType& GetObjectValue() const override{return m_position ? (m_position->*m_uintFunction)() : zero;}
	virtual bool isValueEmpty() const override{return m_useEmptyValue && m_positionZero;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !m_position;}
	virtual bool isValueChanged() const override{return PositionUIntRowValue::isValueChanged() || m_positionZero != !m_position;}
	virtual bool SetValue(const ValueType& value) override
	{
		bool ret = PositionUIntRowValue::SetValue(value);
		if(m_positionZero != !m_position)
		{
			m_positionZero = !m_position;
			ret = true;
		}
		return ret;
	}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{PositionUIntRowValue::InitializeValue(); m_positionZero = !m_position;}
	bool m_positionZero;
};

class TGUI_API PositionTimeRowValue : public TimeRowValue
{
public:
	typedef const ValueType& (PositionData::*UIntFunction)() const;
	PositionTimeRowValue(const PositionData* position, const bool* showMilliseconds, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = false):
		TimeRowValue(showMilliseconds, useEmptyValue, useTick), m_position(position),m_uintFunction(uintFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_position->*m_uintFunction)();}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	const PositionData* m_position;
	UIntFunction m_uintFunction;
};

class TGUI_API PositionTimeInventoryRowValue : public TimeRowValue
{
public:
	typedef const ValueType& (PositionData::*UIntFunction)(const bool& inventoryView) const;
	PositionTimeInventoryRowValue(const PositionData* position, const bool& inventoryView, const bool* showMilliseconds, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = false):
		TimeRowValue(showMilliseconds, useEmptyValue, useTick),
		m_position(position),
		m_uintFunction(uintFunction),
		m_inventoryView(inventoryView){}
	virtual const ValueType& GetObjectValue() const override{return (m_position->*m_uintFunction)(m_inventoryView);}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	const PositionData* m_position;
	UIntFunction m_uintFunction;
	const bool& m_inventoryView;
};

class TGUI_API PositionTimeRowValueNull : public PositionTimeRowValue
{
public:
	PositionTimeRowValueNull(const PositionData* position, const bool* showMilliseconds, UIntFunction uintFunction, bool useEmptyValue = false, bool useTick = false):
		PositionTimeRowValue(position, showMilliseconds, uintFunction, useEmptyValue, useTick),
		m_positionZero(!m_position)
	{}
	virtual const ValueType& GetObjectValue() const override{return m_position ? (m_position->*m_uintFunction)() : zero;}
	virtual bool isValueEmpty() const override{return m_useEmptyValue && m_positionZero;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !m_position;}
	virtual bool isValueChanged() const override{return PositionTimeRowValue::isValueChanged() || m_positionZero != !m_position;}
	virtual bool SetValue(const ValueType& value) override
	{
		bool ret = PositionTimeRowValue::SetValue(value);
		if(m_positionZero != !m_position)
		{
			m_positionZero = !m_position;
			ret = true;
		}
		return ret;
	}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{PositionTimeRowValue::InitializeValue(); m_positionZero = !m_position;}
	bool m_positionZero;
};

class TGUI_API PositionTimeInventoryRowValueNull : public PositionTimeInventoryRowValue
{
public:
	PositionTimeInventoryRowValueNull(const PositionData* position, const bool& inventoryView, const bool* showMilliseconds, UIntFunction uintFunction, bool useEmptyValue = false, bool useTick = false):
		PositionTimeInventoryRowValue(position, inventoryView, showMilliseconds, uintFunction, useEmptyValue, useTick),
		m_positionZero(!m_position)
		{}
	virtual const ValueType& GetObjectValue() const override{return m_position ? (m_position->*m_uintFunction)(m_inventoryView) : zero;}
	virtual bool isValueEmpty() const override{return m_useEmptyValue && m_positionZero;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !m_position;}
	virtual bool isValueChanged() const override{return PositionTimeInventoryRowValue::isValueChanged() || m_positionZero != !m_position;}
	virtual bool SetValue(const ValueType& value) override
	{
		bool ret = PositionTimeInventoryRowValue::SetValue(value);
		if(m_positionZero != !m_position)
		{
			m_positionZero = !m_position;
			ret = true;
		}
		return ret;
	}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{PositionTimeInventoryRowValue::InitializeValue(); m_positionZero = !m_position;}
	bool m_positionZero;
};

class TGUI_API PositionBoolRowValue : public BoolRowValue
{
public:
	typedef const ValueType& (PositionData::*BoolFunction)() const;
	PositionBoolRowValue(const PositionData* const& position, const BoolFunction& boolFunction, const char& trueValue = 'Y', const char& falseValue = '\0'):
		BoolRowValue(trueValue, falseValue), m_position(position),m_boolFunction(boolFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_position->*m_boolFunction)();}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	const PositionData* m_position;
	BoolFunction m_boolFunction;
};

class TGUI_API PositionBoolRowValueCountable : public BoolRowValueCountable
{
public:
	typedef const ValueType& (PositionData::*BoolFunction)() const;
	PositionBoolRowValueCountable(const PositionData* const& position, const BoolFunction& boolFunction, const char& trueValue = 'Y', const char& falseValue = '\0'):
		BoolRowValueCountable(trueValue, falseValue),
		m_position(position),
		m_boolFunction(boolFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_position->*m_boolFunction)();}
	DECLARE_NED_NEW
protected:
	const PositionData* m_position;
	BoolFunction m_boolFunction;
};

class TGUI_API PositionBoolInInventoryRowValueCountable : public PositionBoolRowValueCountable
{
public:
	PositionBoolInInventoryRowValueCountable(const PositionData* const& position, const BoolFunction& boolFunction, const char& trueValue = 'Y', const char& falseValue = 'N'):
		PositionBoolRowValueCountable(position, boolFunction, trueValue, falseValue),
		m_hasInventory(false)
	{}

//	virtual bool isValueEmpty() const override{return m_useEmptyValue && !m_hasInventory;}
	virtual bool isValueEmpty() const override{return !m_hasInventory;}
//	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !m_position->hasInventory();}
	virtual bool isObjectValueEmpty() const override{return !m_position->hasInventory();}
	virtual bool isValueChanged() const override{return PositionBoolRowValueCountable::isValueChanged() || m_hasInventory != m_position->hasInventory();}
	virtual bool SetValue(const ValueType& value) override
	{
		bool ret = PositionBoolRowValueCountable::SetValue(value);
		if(m_hasInventory != m_position->hasInventory())
		{
			m_hasInventory = !m_hasInventory;
			ret = true;
		}
		return ret;
	}
	virtual void toString(std::string& text) const override
	{
		if(m_hasInventory)
		{
			if(m_value)
			{
				if(m_trueValue)text += m_trueValue;
			}
			else if(m_falseValue)text += m_falseValue;
		}
	}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{PositionBoolRowValueCountable::InitializeValue(); m_hasInventory = m_position->hasInventory();}
	bool m_hasInventory;
};

class TGUI_API PositionUCharAsBoolRowValue : public UCharAsBoolRowValue
{
public:
	typedef bool (PositionData::*BoolFunction)() const;
	PositionUCharAsBoolRowValue(const PositionData* position, BoolFunction boolFunction, char trueValue = 'Y', char falseValue = '\0'):
		UCharAsBoolRowValue(trueValue, falseValue), m_position(position),m_boolFunction(boolFunction){}

	virtual bool isValueChanged() const override{return m_value != ((m_position->*m_boolFunction)() ? 1 : 0);}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_position->*m_boolFunction)() ? 1 : 0);}
	virtual bool UpdateValue() override{return SetValue((m_position->*m_boolFunction)() ? 1 : 0);}
	virtual bool isObjectValueZero() const override{return !(m_position->*m_boolFunction)();}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_position->*m_boolFunction)() ? 1 : 0;}
	const PositionData* m_position;
	BoolFunction m_boolFunction;
};
/*
class TGUI_API PositionUIntAsStrVRowValue : public UIntAsStrRowValue
{
public:
	typedef ValueType (PositionData::*UIntFunction)() const;
	PositionUIntAsStrVRowValue(const PositionData* position, UIntFunction uintFunction):
		UIntAsStrRowValue(zero, false),//useEmptyValue),
		m_position(position),
		m_uintFunction(uintFunction)
	{}
//	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_uintFunction)();}
	virtual bool isValueChanged() const override{return m_value != (m_position->*m_uintFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_position->*m_uintFunction)());}
	virtual bool UpdateValue() override{return SetValue((m_position->*m_uintFunction)());}
	virtual bool isObjectValueZero() const override{return !(m_position->*m_uintFunction)();}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_position->*m_uintFunction)();}
	const PositionData* m_position;
	UIntFunction m_uintFunction;
};
*/
class TGUI_API PositionHtbRowValue : public UIntAsStrRowValue
{
public:
//	typedef const ValueType& (Security::*UCharFunction)(const unsigned char& ordinal) const;
	PositionHtbRowValue(const PositionData* const& position, bool useEmptyValue = true, bool useTick = false):
		UIntAsStrRowValue(zero, useTick),
		m_position(position),
		m_valueValid(false),
		m_sharesAvailable(false)
	{}
//	virtual const ValueType& GetObjectValue() const override{return m_position->GetHtbString();}
	virtual bool isValueChanged() const override
	{
		return m_valueValid != m_position->isStockLoanInitialized()
			|| m_sharesAvailable != (m_position->GetBorrowAvailableSize() != 0)
			|| m_value != m_position->GetHtbString();
	}
	inline static short CompareHtb(const RowValue& other, const unsigned char& myValue, const bool& myValueValid, const bool& mySharesAvailable)
	{
		const PositionHtbRowValue& otherHtb = (const PositionHtbRowValue&)other;
		const ValueType otherValue = otherHtb.m_value;
		return otherValue == myValue ?
			otherHtb.m_valueValid ?
				myValueValid ?
					otherHtb.m_sharesAvailable ?
						mySharesAvailable ? 0 : 1:
						mySharesAvailable ? -1 : 0:
					1:
				myValueValid ? -1 : 0:
			myValue < otherValue ? -1 : 1;
/*
		if(otherValue == myValue)
		{
//			const bool otherValueValid = otherHtb.m_valueValid;
			if(otherHtb.m_valueValid)
			{
				if(myValueValid)
				{
//					const bool otherSharesAvailable = otherHtb.m_sharesAvailable;
					return otherHtb.m_sharesAvailable == mySharesAvailable ? 0:
						mySharesAvailable ? -1 : 1;
				}
				else
					return 1;
			}
			else
				return myValueValid ? -1 : 0;
		}
		else
			return myValue < otherValue ? -1 : 1;
*/
	}

	virtual short CompareAhead(const RowValue& other) const override
	{
//		return -((const TypedRowValue&)other).CompareValue(m_position->GetHtbString());
		return CompareHtb(other, m_position->GetHtbString(), m_position->isStockLoanInitialized(), m_position->GetBorrowAvailableSize() != 0);
	}
	virtual short Compare(const RowValue& other) const override
	{
		return CompareHtb(other, m_value, m_valueValid, m_sharesAvailable);
	}
	virtual bool UpdateValue() override
	{
		bool ret = false;
		if(m_position->isStockLoanInitialized())
		{
			if(!m_valueValid)
			{
				ret = true;
				m_valueValid = true;
			}
			const bool sharesAvailable = m_position->GetBorrowAvailableSize() != 0;
			if(sharesAvailable != m_sharesAvailable)
			{
				ret = true;
				m_sharesAvailable = sharesAvailable;
			}
		}
		else
		{
			if(m_valueValid)
			{
				ret = true;
				m_sharesAvailable = false;
				m_valueValid = false;
			}
		}
		return SetValue(m_position->GetHtbString()) || ret;
	}
	virtual bool isObjectValueZero() const override{return !m_position->GetHtbString();}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_value = m_position->GetHtbString();
		m_valueValid = m_position->isStockLoanInitialized();
		m_sharesAvailable = m_valueValid && m_position->GetBorrowAvailableSize() != 0;
	}
	const PositionData* m_position;
	bool m_valueValid;
	bool m_sharesAvailable;
};

class TGUI_API PositionUCharAsCharRowValue : public UCharAsCharRowValue
{
public:
	typedef const ValueType& (PositionData::*UCharFunction)() const;
	PositionUCharAsCharRowValue(const PositionData* position, UCharFunction ucharFunction, bool useEmptyValue = true, bool useTick = false):
		UCharAsCharRowValue(useEmptyValue, useTick), m_position(position),m_ucharFunction(ucharFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_position->*m_ucharFunction)();}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	const PositionData* m_position;
	UCharFunction m_ucharFunction;
};
/*
class TGUI_API PositionUCharRowValue : public UCharRowValue
{
public:
	typedef const ValueType& (PositionData::*UCharFunction)() const;
	PositionUCharRowValue(const PositionData* position, UCharFunction ucharFunction, bool useEmptyValue = true, bool useTick = true):
		UCharRowValue(useEmptyValue, useTick), m_position(position),m_ucharFunction(ucharFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_position->*m_ucharFunction)();}
	virtual void SetPosition(const PositionData* position){m_position = position;}
	DECLARE_NED_NEW
protected:
	const PositionData* m_position;
	UCharFunction m_ucharFunction;
};
*/
class TGUI_API PositionSecuritySubscriptionLevel : public CharRowValue
{
public:
	PositionSecuritySubscriptionLevel(const Security*& security):
		m_security(security)
//		CharRowValue(0, false, false, false),
	{
	}
	char CalculateSubscriptionLevel() const
	{
		return m_security ?
#ifndef TAKION_NO_OPTIONS
			m_security->GetOptionInfo() ? 'O' :
#endif
			m_security->isMarketDataStock() ? '2' :
			'1' :
			'\0';
	}
//	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_priceFunction)();}
//	virtual bool isValueZero() const override;//{return m_useEmptyValue && (!m_price || !m_price2);}
	virtual bool isValueChanged() const override{return m_value != CalculateSubscriptionLevel();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateSubscriptionLevel());}
	virtual bool UpdateValue() override{return SetValue(CalculateSubscriptionLevel());}
	virtual bool isObjectValueZero() const override{return !m_security;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = CalculateSubscriptionLevel();}
	const Security*& m_security;
};

class TGUI_API PositionUIntRowValueDiffOrZero : public PositionUIntRowValue
{
public:
	PositionUIntRowValueDiffOrZero(const PositionData* position, const bool* comma, UIntFunction uintFunction, UIntFunction uintFunction2, bool useEmptyValue = true, bool useTick = true):
		PositionUIntRowValue(position, comma, uintFunction, useEmptyValue, useTick), m_uintFunction2(uintFunction2),
		m_size1(0),
		m_size2(0)
	{
	}
	static ValueType CalculateSize(const ValueType& size1, const ValueType& size2)//{if(price && price2)value = SignedPrice(price) - SignedPrice(price2);	else value.SetZero();}
	{
		return size1 > size2 ? size1 - size2 : zero;
	}
//	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_priceFunction)();}
	virtual bool isValueZero() const override{return !m_size1;}
	virtual bool isValueChanged() const override{return m_size2 != (m_position->*m_uintFunction2)() || m_size1 != (m_position->*m_uintFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateSize((m_position->*m_uintFunction)(), (m_position->*m_uintFunction2)()));}
	virtual bool UpdateValue() override
	{
		InitValues();
		return SetValue(CalculateSize(m_size1, m_size2));
	}
	virtual bool isObjectValueZero() const override{return !(m_position->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	inline void InitValues()
	{
		m_size1 = (m_position->*m_uintFunction)();
		m_size2 = (m_position->*m_uintFunction2)();
	}
	virtual void InitializeValue() override
	{
		InitValues();
		m_value = CalculateSize(m_size1, m_size2);
	}
	UIntFunction m_uintFunction2;
	ValueType m_size1;
	ValueType m_size2;
};

class TGUI_API PositionIntRowValueUIntPlusMinusAdj : public IntRowValue
{
public:
	typedef const ValueType& (PositionData::*IntFunction)(const bool& inventoryView) const;
	typedef const unsigned int& (PositionData::*UIntFunction)() const;

	PositionIntRowValueUIntPlusMinusAdj(const PositionData* position, const bool& inventoryView, const bool* comma, IntFunction intFunction, UIntFunction uintFunctionPlus, UIntFunction uintFunctionMinus, bool useEmptyValue = true, bool useTick = true):
		IntRowValue(comma, useEmptyValue, useTick),
		m_position(position),
		m_intFunction(intFunction),
		m_uintFunctionPlus(uintFunctionPlus),
		m_uintFunctionMinus(uintFunctionMinus),
		m_inventoryView(inventoryView)
	{
	}
	static ValueType CalculateSize(const ValueType& size, const ValueType& sizePlus, const ValueType& sizeMinus)//{if(price && price2)value = SignedPrice(price) - SignedPrice(price2);	else value.SetZero();}
	{
		return size + sizePlus - sizeMinus;
	}
	ValueType CalculateCurrentSize() const
	{
		return CalculateSize((m_position->*m_intFunction)(m_inventoryView), (int)(m_position->*m_uintFunctionPlus)(), (int)(m_position->*m_uintFunctionMinus)());
	}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
//	virtual const ValueType& GetObjectValue() const;
//	virtual bool isValueZero() const;
	virtual bool isValueChanged() const override{return CalculateCurrentSize() != m_value;}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateCurrentSize());}
	virtual bool UpdateValue() override{return SetValue(CalculateCurrentSize());}
	virtual bool isObjectValueZero() const override{return !CalculateCurrentSize();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = CalculateCurrentSize();}
	const PositionData* m_position;
	IntFunction m_intFunction;
	UIntFunction m_uintFunctionPlus;
	UIntFunction m_uintFunctionMinus;
//	ValueType m_size;
//	ValueType m_sizePlus;
//	ValueType m_sizeMinus;
	const bool& m_inventoryView;
};

/*
template <class T>
class TGUI_API PositionMoneyRowValueConstPriceXNumber : public MoneyRowValue
{
public:
	typedef const unsigned int& (PositionData::*PriceFunction)() const;
	typedef const T& (PositionData::*NumberFunction)(const bool& inventoryView) const;

	PositionMoneyRowValueConstPriceXNumber(const PositionData* position,
		const bool& inventoryView,
		const bool* comma,
		const unsigned char* decDigits,
		const bool* truncate,
		const Price& price,
		PriceFunction priceFunction,
		NumberFunction numberFunction,
		bool useEmptyValue = true,
		bool useNeutralColor = false,
		bool useTick = true):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_position(position),
		m_priceFunction(priceFunction),
		m_numberFunction(numberFunction),
//		m_price(price),
		m_size(0),
		m_inventoryView(inventoryView)
	{
		if(position)m_price = Price((position->*m_numberFunction)());
	}
	static ValueType CalculateMoney(const T& size)//{if(price && price2)value = SignedPrice(price) - SignedPrice(price2);	else value.SetZero();}
	{
		return m_price * (__int64)size;
	}
	ValueType CalculateCurrentMoney() const
	{
		return CalculateMoney((m_position->*m_numberFunction)(m_inventoryView));
	}
	virtual void SetPosition(const PositionData* position) override
	{
		if(position != m_position)
		{
			m_position = position;
			if(position)m_price = Price((position->*m_priceFunction)());
			else m_price.SetZero();
		}
	}
//	virtual const ValueType& GetObjectValue() const;
	virtual bool isValueZero() const override{return !m_size || m_price.isZero();}
	virtual bool isValueChanged() const override{return (m_position->*m_numberFunction)(m_inventoryView) != m_size;}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateCurrentMoney());}
	virtual bool UpdateValue() override{return SetValue(CalculateCurrentMoney());}
	virtual bool isObjectValueZero() const override{return !(m_position->*m_numberFunction)(m_inventoryView) || m_price.isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = CalculateCurrentMoney();}
	const PositionData* m_position;
	PriceFunction m_priceFunction;
	NumberFunction m_numberFunction;
	Price m_price;
	T m_size;
	const bool& m_inventoryView;
};
*/

class TGUI_API PositionPriceRowValue : public PriceRowValue
{
public:
	typedef const ValueType& (PositionData::*PriceFunction)() const;
	PositionPriceRowValue(const PositionData* position, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true):
		PriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_position(position),
		m_priceFunction(priceFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_position->*m_priceFunction)();}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	const PositionData* m_position;
	PriceFunction m_priceFunction;
};

class TGUI_API PositionPriceVRowValue : public PriceRowValue
{
public:
	typedef ValueType (PositionData::*PriceFunction)() const;
	PositionPriceVRowValue(const PositionData* const& position,
		const bool* comma,
		const unsigned char* decDigits,
		const bool* truncate,
		PriceFunction priceFunction,
		bool useEmptyValue = true,
		bool useNeutralColor = false,
		bool useTick = true):
		PriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_position(position),
		m_priceFunction(priceFunction)
		{}
//	virtual const unsigned int& GetObjectValue() const override{return (m_account->*m_uintFunction)();}
	virtual bool isValueChanged() const override{return m_value != (m_position->*m_priceFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_position->*m_priceFunction)());}
	virtual bool UpdateValue() override{return SetValue((m_position->*m_priceFunction)());}
//	virtual bool isObjectValueEmpty() const;//{return m_useEmptyValue && (m_position->*m_uintFunction)() == m_emptyValue;}
	virtual bool isObjectValueZero() const override{return !(m_position->*m_priceFunction)();}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_position->*m_priceFunction)();}
	const PositionData* m_position;
	PriceFunction m_priceFunction;
};

class TGUI_API PositionPriceInInventoryRowValue : public PositionPriceRowValue
{
public:
	PositionPriceInInventoryRowValue(const PositionData* const& position,
		const bool* const& comma,
		const unsigned char* const& decDigits,
		const bool* const& truncate,
		const PriceFunction& priceFunction,
		const bool& useEmptyValue = true,
		const bool& useTick = true):
		PositionPriceRowValue(position, comma, decDigits, truncate, priceFunction, useEmptyValue, useTick),
		m_hasInventory(false)
	{}

	virtual bool isValueEmpty() const override{return m_useEmptyValue && !m_hasInventory;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !m_position->hasInventory();}
	virtual bool isValueChanged() const override{return PositionPriceRowValue::isValueChanged() || m_hasInventory != m_position->hasInventory();}
	virtual bool SetValue(const ValueType& value) override
	{
		bool ret = PositionPriceRowValue::SetValue(value);
		if(m_hasInventory != m_position->hasInventory())
		{
			m_hasInventory = !m_hasInventory;
			ret = true;
		}
		return ret;
	}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{PositionPriceRowValue::InitializeValue(); m_hasInventory = m_position->hasInventory();}
	bool m_hasInventory;
};

class TGUI_API PositionPriceInventoryRowValue : public PriceRowValue
{
public:
	typedef const ValueType& (PositionData::*PriceFunction)(const bool& inventoryView) const;
	PositionPriceInventoryRowValue(const PositionData* position, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true):
		PriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_position(position),
		m_priceFunction(priceFunction),
		m_inventoryView(inventoryView)
	{}
	virtual const ValueType& GetObjectValue() const override{return (m_position->*m_priceFunction)(m_inventoryView);}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	const PositionData* m_position;
	PriceFunction m_priceFunction;
	const bool& m_inventoryView;
};

class TGUI_API PositionPriceRowValueNull : public PositionPriceRowValue
{
public:
	PositionPriceRowValueNull(const PositionData* position, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, bool useEmptyValue = false, bool useTick = true):
		PositionPriceRowValue(position, comma, decDigits, truncate, priceFunction, useEmptyValue, useTick),
		m_positionZero(!m_position)
	{}
	virtual const ValueType& GetObjectValue() const override{return m_position ? (m_position->*m_priceFunction)() : zero;}
	virtual bool isValueEmpty() const override{return m_useEmptyValue && m_positionZero;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !m_position;}
	virtual bool isValueChanged() const override{return PositionPriceRowValue::isValueChanged() || m_positionZero != !m_position;}
	virtual bool SetValue(const ValueType& value) override
	{
		bool ret = PositionPriceRowValue::SetValue(value);
		if(m_positionZero != !m_position)
		{
			m_positionZero = !m_position;
			ret = true;
		}
		return ret;
	}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{PositionPriceRowValue::InitializeValue(); m_positionZero = !m_position;}
	bool m_positionZero;
};

class TGUI_API PositionPriceInventoryRowValueNull : public PositionPriceInventoryRowValue
{
public:
	PositionPriceInventoryRowValueNull(const PositionData* position, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, bool useEmptyValue = false, bool useTick = true):
		PositionPriceInventoryRowValue(position, inventoryView, comma, decDigits, truncate, priceFunction, useEmptyValue, useTick),
		m_positionZero(!m_position)
	{}
	virtual const ValueType& GetObjectValue() const override{return m_position ? (m_position->*m_priceFunction)(m_inventoryView) : zero;}
	virtual bool isValueEmpty() const override{return m_useEmptyValue && m_positionZero;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !m_position;}
	virtual bool isValueChanged() const override{return PositionPriceInventoryRowValue::isValueChanged() || m_positionZero != !m_position;}
	virtual bool SetValue(const ValueType& value) override
	{
		bool ret = PositionPriceInventoryRowValue::SetValue(value);
		if(m_positionZero != !m_position)
		{
			m_positionZero = !m_position;
			ret = true;
		}
		return ret;
	}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{PositionPriceInventoryRowValue::InitializeValue(); m_positionZero = !m_position;}
	bool m_positionZero;
};

class TGUI_API PositionUCharAsBoolRowValueNull : public PositionUCharAsBoolRowValue
{
public:
	PositionUCharAsBoolRowValueNull(const PositionData* position, BoolFunction boolFunction, char trueValue = 'Y', char falseValue = '\0'):
		PositionUCharAsBoolRowValue(position, boolFunction, trueValue, falseValue),
		m_positionZero(!m_position)
	{}
//	virtual const ValueType& GetObjectValue() const override{return m_position ? (m_position->*m_priceFunction)() : zero;}
//	virtual bool isValueChanged() const override{return m_value != (m_position && ((m_position->*m_boolFunction)()) ? 1 : 0);}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(m_position && (m_position->*m_boolFunction)() ? 1 : 0);}
	virtual bool UpdateValue() override{return SetValue(m_position && (m_position->*m_boolFunction)() ? 1 : 0);}
	virtual bool isObjectValueZero() const override{return !m_position || !(m_position->*m_boolFunction)();}
	virtual bool isValueEmpty() const override{return m_useEmptyValue && m_positionZero;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !m_position;}
	virtual bool isValueChanged() const override{return m_value != (m_position && ((m_position->*m_boolFunction)()) ? 1 : 0) || m_positionZero != !m_position;}
	virtual bool SetValue(const ValueType& value) override
	{
		bool ret = PositionUCharAsBoolRowValue::SetValue(value);
		if(m_positionZero != !m_position)
		{
			m_positionZero = !m_position;
			ret = true;
		}
		return ret;
	}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = m_position && (m_position->*m_boolFunction)() ? 1 : 0; m_positionZero = !m_position;}
	bool m_positionZero;
};
/*
class TGUI_API PositionPriceAsUIntRowValue : public PriceAsUIntRowValue
{
public:
	typedef const ValueType& (PositionData::*UIntFunction)() const;
	PositionPriceAsUIntRowValue(const PositionData* position, const bool* comma, const unsigned char* decDigits, const bool* truncate, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true):
		PriceAsUIntRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_position(position),
		m_uintFunction(uintFunction)
	{}
	virtual const ValueType& GetObjectValue() const override{return (m_position->*m_uintFunction)();}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	const PositionData* m_position;
	UIntFunction m_uintFunction;
};
*/
class TGUI_API PositionCompactPriceRowValue : public CompactPriceRowValue
{
public:
	typedef const ValueType& (PositionData::*PriceFunction)() const;
	PositionCompactPriceRowValue(const PositionData* position, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true):
		CompactPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_position(position),
		m_priceFunction(priceFunction)
	{}
	virtual const ValueType& GetObjectValue() const override{return (m_position->*m_priceFunction)();}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	const PositionData* m_position;
	PriceFunction m_priceFunction;
};

class TGUI_API PositionSignedPriceAsIntRowValue : public CompactSignedPriceRowValue
{
public:
	typedef const ValueType& (PositionData::*IntFunction)() const;
	PositionSignedPriceAsIntRowValue(const PositionData* position, const bool* comma, const unsigned char* decDigits, const bool* truncate, IntFunction intFunction, bool useEmptyValue = true, bool useTick = true):
		CompactSignedPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_position(position),
		m_intFunction(intFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_position->*m_intFunction)();}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	const PositionData* m_position;
	IntFunction m_intFunction;
};

class TGUI_API PositionBorrowPriceRowValue : public PositionCompactPriceRowValue//PositionPriceAsUIntRowValue
{
public:
	PositionBorrowPriceRowValue(const PositionData* position, const bool* comma, const unsigned char* decDigits, const bool* truncate) :
		PositionCompactPriceRowValue(position, comma, decDigits, truncate, &PositionData::GetCompactBorrowDiscountedPrice)
	{}
	virtual void toString(std::string& text) const override
	{
		if(!isValueEmpty())
		{
			text += "c ";
			U_PriceToStr(text, Price(m_value), *m_decDigits, '\0', *m_comma, '\0', *m_truncate);
		}
	}
	DECLARE_NED_NEW
};

class TGUI_API PositionUCharAsPercentRowValue : public PositionUCharRowValue
{
public:
	PositionUCharAsPercentRowValue(const PositionData* position, UCharFunction ucharFunction, bool useEmptyValue = true, bool useTick = true) :
//		PositionUCharRowValue(position, &PositionData::GetMargin, true, false)
		PositionUCharRowValue(position, ucharFunction, useEmptyValue, useTick)
	{}
	virtual void toString(std::string& text) const override
	{
		if(!isValueEmpty())toStringAsWholePercent(m_value, text);
	}
	DECLARE_NED_NEW
};

class TGUI_API PositionSecurityTimeRowValue : public TimeRowValue
{
public:
	typedef const ValueType& (Security::*UIntFunction)() const;
	PositionSecurityTimeRowValue(const Security* const& security, const bool* showMilliseconds, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true):
		TimeRowValue(showMilliseconds, useEmptyValue, useTick),
		m_security(security),
		m_uintFunction(uintFunction){}
	virtual const ValueType& GetObjectValue() const override{return m_security ? (m_security->*m_uintFunction)() : zero;}
	DECLARE_NED_NEW
protected:
	const Security* const& m_security;
	UIntFunction m_uintFunction;
};

class TGUI_API PositionSecurityBoolRowValueCountable : public BoolRowValueCountable
{
public:
	typedef const ValueType& (Security::*BoolFunction)() const;
	PositionSecurityBoolRowValueCountable(const Security* const& security, BoolFunction boolFunction, char trueValue = 'Y', char falseValue = '\0'):
		BoolRowValueCountable(trueValue, falseValue),
		m_security(security),
		m_boolFunction(boolFunction){}
	virtual const ValueType& GetObjectValue() const override{return m_security ? (m_security->*m_boolFunction)() : zero;}
	DECLARE_NED_NEW
protected:
	const Security* const& m_security;
	BoolFunction m_boolFunction;
};

class TGUI_API PositionSecurityBoolRefRowValue : public BoolRowValue
{
public:
	typedef ValueType (Security::*BoolFunction)() const;
	PositionSecurityBoolRefRowValue(const Security* const& security, BoolFunction boolFunction, char trueValue = 'Y', char falseValue = '\0') :
		BoolRowValue(trueValue, falseValue),
		m_security(security),
		m_boolFunction(boolFunction)
	{
	}
	virtual bool isValueChanged() const override{return m_value != (m_security && (m_security->*m_boolFunction)());}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(m_security && (m_security->*m_boolFunction)());}
	virtual bool UpdateValue() override{return SetValue(m_security && (m_security->*m_boolFunction)());}
	virtual bool isObjectValueZero() const override{return (!m_security || !(m_security->*m_boolFunction)());}// == m_emptyValue;}
//	virtual bool isValueEmpty() const{return m_valueEmpty;}
//	virtual bool isObjectValueEmpty() const{return m_useEmptyValue && !m_position;}

	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = m_security && (m_security->*m_boolFunction)();}
	const Security* const& m_security;
	BoolFunction m_boolFunction;
};

class TGUI_API PositionSecurityBoolRefOrEmptyRowValue : public CharRowValue
{
public:
	typedef bool (Security::*BoolFunction)() const;
	PositionSecurityBoolRefOrEmptyRowValue(const Security* const& security, BoolFunction boolFunction)://, char trueValue = 'Y', char falseValue = '\0') :
//		CharRowValue('\0', false),//, false, false),
		m_security(security),
		m_boolFunction(boolFunction)
	{
	}
	char CalculateValue() const{return m_security ? (m_security->*m_boolFunction)() ? 'Y' : 'N' : '\0';}
	virtual bool isValueChanged() const override{return m_value != CalculateValue();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override{return SetValue(CalculateValue());}
	virtual bool isObjectValueZero() const override{return !m_security;}
//	virtual bool isValueEmpty() const{return m_valueEmpty;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = CalculateValue();}
	const Security* const& m_security;
	BoolFunction m_boolFunction;
};

class TGUI_API PositionSecurityCharRefOrEmptyRowValue : public CharRowValue
{
public:
	typedef ValueType (Security::*CharFunction)() const;
	PositionSecurityCharRefOrEmptyRowValue(const Security* const& security, CharFunction charFunction, const char& value = '\0', bool useEmptyValue = false, bool useNeutralColor = false, bool useTick = false) :
		CharRowValue(value, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_charFunction(charFunction)
	{
	}
	char CalculateValue() const{return m_security ? (m_security->*m_charFunction)() : '\0';}
	virtual bool isValueChanged() const override{return m_value != CalculateValue();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override{return SetValue(CalculateValue());}
//	virtual bool isObjectValueZero() const{return !m_security;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = CalculateValue();}
	const Security* const& m_security;
	CharFunction m_charFunction;
};

class TGUI_API PositionSecurityUIntRowValue : public UIntRowValue
{
public:
	typedef const ValueType& (Security::*UIntFunction)() const;
	PositionSecurityUIntRowValue(const Security* const& security, const bool* comma, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true):
		UIntRowValue(comma, useEmptyValue, useTick),
		m_security(security),
		m_uintFunction(uintFunction){}
	virtual const ValueType& GetObjectValue() const override{return m_security ? (m_security->*m_uintFunction)() : zero;}//m_emptyValue;}
	DECLARE_NED_NEW
protected:
	const Security* const& m_security;
	UIntFunction m_uintFunction;
};

class TGUI_API PositionSecurityLONGRowValueCopy : public IntRowValue
{
public:
	typedef LONG (Security::*LONGFunction)() const;
	PositionSecurityLONGRowValueCopy(const Security* const& security, const bool* comma, LONGFunction longFunction, bool useEmptyValue = true, bool useTick = true):
		IntRowValue(comma, useEmptyValue, useTick),
		m_security(security),
		m_longFunction(longFunction){}
//	virtual const unsigned __int64& GetObjectValue() const override{return (m_security->*m_uint64Function)();}
	virtual bool isValueChanged() const override{return m_value != (m_security ? (m_security->*m_longFunction)() : zero);}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(m_security ? (m_security->*m_longFunction)() : zero);}
	virtual bool UpdateValue() override{return SetValue(m_security ? (m_security->*m_longFunction)() : zero);}
	virtual bool isObjectValueZero() const override{return !m_security || !(m_security->*m_longFunction)();}// == m_emptyValue;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = m_security ? (m_security->*m_longFunction)() : zero;}
	const Security* const& m_security;
	LONGFunction m_longFunction;
};


class TGUI_API PositionSecurityDateTimeRowValue : public DateTimeRowValue
{
public:
	typedef const ValueType& (Security::*UInt64Function)() const;
	PositionSecurityDateTimeRowValue(const Security* const& security, const bool* showMilliseconds, UInt64Function uint64Function, bool useEmptyValue = true, bool useTick = false):
		DateTimeRowValue(showMilliseconds, useEmptyValue, useTick),
		m_security(security),
		m_uint64Function(uint64Function){}
	virtual const ValueType& GetObjectValue() const override{return m_security ? (m_security->*m_uint64Function)() : zero;}
	DECLARE_NED_NEW
protected:
	const Security* const& m_security;
	UInt64Function m_uint64Function;
};

class TGUI_API PositionSecurityUInt64RowValue : public UInt64RowValue
{
public:
	typedef const ValueType& (Security::*UIntFunction)() const;
	PositionSecurityUInt64RowValue(const Security* const& security, const bool* comma, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true):
		UInt64RowValue(comma, useEmptyValue, useTick),
		m_security(security),
		m_uintFunction(uintFunction){}
	virtual const ValueType& GetObjectValue() const override{return m_security ? (m_security->*m_uintFunction)() : zero;}//m_emptyValue;}
	DECLARE_NED_NEW
protected:
	const Security* const& m_security;
	UIntFunction m_uintFunction;
};

class TGUI_API PositionSecurityPriceRowValue : public PriceRowValue
{
public:
	typedef const ValueType& (Security::*PriceFunction)() const;
	PositionSecurityPriceRowValue(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true):
		PriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_security(security),
		m_priceFunction(priceFunction){}
	virtual const ValueType& GetObjectValue() const override{return m_security ? (m_security->*m_priceFunction)() : Price::priceZero;}
	DECLARE_NED_NEW
protected:
	const Security* const& m_security;
	PriceFunction m_priceFunction;
};

class TGUI_API PositionSecurityCompactPriceRowValue : public CompactPriceRowValue
{
public:
	typedef const ValueType& (Security::*PriceFunction)() const;
	PositionSecurityCompactPriceRowValue(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true):
		CompactPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_security(security),
		m_priceFunction(priceFunction){}
	virtual const ValueType& GetObjectValue() const override{return m_security ? (m_security->*m_priceFunction)() : zero;}
	DECLARE_NED_NEW
protected:
	const Security* const& m_security;
	PriceFunction m_priceFunction;
};

class TGUI_API PositionSecurityCompactSignedPriceRowValue : public CompactSignedPriceRowValue
{
public:
	typedef const ValueType& (Security::*SignedPriceFunction)() const;
	PositionSecurityCompactSignedPriceRowValue(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, SignedPriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true):
		CompactSignedPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_security(security),
		m_priceFunction(priceFunction){}
	virtual const ValueType& GetObjectValue() const override{return m_security ? (m_security->*m_priceFunction)() : zero;}
	DECLARE_NED_NEW
protected:
	const Security* const& m_security;
	SignedPriceFunction m_priceFunction;
};

class TGUI_API PositionSecuritySignedPriceRowValue : public SignedPriceRowValue
{
public:
	typedef const ValueType& (Security::*SignedPriceFunction)() const;
	PositionSecuritySignedPriceRowValue(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, SignedPriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		SignedPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick, useNeutralColor),
		m_security(security),
		m_priceFunction(priceFunction){}
	virtual const ValueType& GetObjectValue() const override{return m_security ? (m_security->*m_priceFunction)() : SignedPrice::signedPriceZero;}
	DECLARE_NED_NEW
protected:
	const Security* const& m_security;
	SignedPriceFunction m_priceFunction;
};

#ifndef TAKION_NO_OPTIONS

class TGUI_API PositionOptionLastStrikeValue : public PriceRowValue
{
public:
	typedef const unsigned int& (Security::*UIntFunction)() const;
	virtual Price CalculateIntrinsicFromComponents(const unsigned int& lastNbboPrint) const
	{
		return m_uintStrikePrice < lastNbboPrint ? Price(lastNbboPrint).GetPositivePriceDiff(m_strikePrice) : Price::priceZero;
	}
protected:
	PositionOptionLastStrikeValue(const Security* const& underlier,
		UIntFunction printFunction,
		const unsigned int& strikePrice,
		const bool* comma,
		const unsigned char* decDigits,
		const bool* truncate,
		bool useEmptyValue = true,
		bool useTick = true)://, bool useNeutralColor = false):
		PriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_underlier(underlier),
		m_printFunction(printFunction),
		m_lastNbboPrint(0),
		m_uintStrikePrice(strikePrice),
		m_strikePrice(strikePrice)
	{
	}
//	virtual void InitializeValue() override{m_lastNbboPrint = m_underlier ? (m_underlier->*m_printFunction)() : Price::priceZero;}
	const Security* const& m_underlier;
	UIntFunction m_printFunction;
	unsigned int m_lastNbboPrint;
	unsigned int m_uintStrikePrice;
	Price m_strikePrice;
};

class TGUI_API PositionOptionCallIntrinsicValue : public PositionOptionLastStrikeValue
{
public:
	PositionOptionCallIntrinsicValue(const Security* const& underlier,
		UIntFunction printFunction,
		const unsigned int& strikePrice,
		const bool* comma,
		const unsigned char* decDigits,
		const bool* truncate,
		bool useEmptyValue = true,
		bool useTick = true) ://, bool useNeutralColor = false):
		PositionOptionLastStrikeValue(underlier, printFunction, strikePrice, comma, decDigits, truncate, useEmptyValue, useTick)
	{
	}
	Price DeriveValue() const{return CalculateIntrinsicFromComponents(m_lastNbboPrint);}
	Price CalculateValue() const{return m_underlier ? CalculateIntrinsicFromComponents((m_underlier->*m_printFunction)()) : Price::priceZero;}
	virtual bool isValueChanged() const override{return m_underlier ? m_lastNbboPrint != (m_underlier->*m_printFunction)() : m_lastNbboPrint != 0;}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		const unsigned int last = m_underlier ? (m_underlier->*m_printFunction)() : 0;
		if(last != m_lastNbboPrint)
		{
			m_lastNbboPrint = last;
			return SetValue(DeriveValue());
		}
		return false;
	}
	virtual bool isObjectValueZero() const override{return !m_underlier || (m_underlier->*m_printFunction)() <= m_uintStrikePrice;}
	virtual bool isValueZero() const override{return m_lastNbboPrint <= m_uintStrikePrice;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_lastNbboPrint = m_underlier ? (m_underlier->*m_printFunction)() : 0;
		m_value = DeriveValue();
	}
};

class TGUI_API PositionOptionPutIntrinsicValue : public PositionOptionCallIntrinsicValue
{
public:
	PositionOptionPutIntrinsicValue(const Security* const& underlier, UIntFunction printFunction, const unsigned int& strikePrice, const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useTick = true) ://, bool useNeutralColor = false):
		PositionOptionCallIntrinsicValue(underlier, printFunction, strikePrice, comma, decDigits, truncate, useEmptyValue, useTick)
	{
	}
	virtual Price CalculateIntrinsicFromComponents(const unsigned int& lastNbboPrint) const override
	{
		return lastNbboPrint && lastNbboPrint < m_uintStrikePrice ? m_strikePrice.GetPositivePriceDiff(Price(lastNbboPrint)) : Price::priceZero;
	}
	virtual bool isObjectValueZero() const override
	{
		if(m_underlier)
		{
			const unsigned int last = (m_underlier->*m_printFunction)();
			return !last || m_uintStrikePrice <= last;
		}
		return true;
	}
	virtual bool isValueZero() const override{return !m_lastNbboPrint || m_uintStrikePrice <= m_lastNbboPrint;}
	DECLARE_NED_NEW
};

class TGUI_API PositionOptionCallTimeValue : public PositionOptionLastStrikeValue
{
public:
	PositionOptionCallTimeValue(const Security* const& option,
		const Security* const& underlier,
		UIntFunction midpointFunction,
		UIntFunction printFunction,
		const unsigned int& strikePrice,
		const bool* comma,
		const unsigned char* decDigits,
		const bool* truncate,
		bool useEmptyValue = true,
		bool useTick = true)://, bool useNeutralColor = false):
		PositionOptionLastStrikeValue(underlier, printFunction, strikePrice, comma, decDigits, truncate, useEmptyValue, useTick),
		m_option(option),
		m_midpointFunction(midpointFunction),
		m_midPoint(0)
	{
	}
	Price DeriveValueFromComponents(const unsigned int& lastNbboPrint, const unsigned int& midPoint) const
	{
		if(lastNbboPrint && midPoint)
		{
			return Price(midPoint).GetPositivePriceDiff(CalculateIntrinsicFromComponents(lastNbboPrint));
		}
		return Price::priceZero;
	}
	Price DeriveValue() const{return DeriveValueFromComponents(m_lastNbboPrint, m_midPoint);}
	Price CalculateValue() const{return m_underlier && m_option ? DeriveValueFromComponents((m_underlier->*m_printFunction)(), (m_option->*m_midpointFunction)()) : Price::priceZero;}
	virtual bool isValueChanged() const override{return m_underlier && m_option ? m_lastNbboPrint != (m_underlier->*m_printFunction)() || m_midPoint != (m_option->*m_midpointFunction)() : m_lastNbboPrint != 0 || m_midPoint != 0;}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		unsigned int value = m_underlier ? (m_underlier->*m_printFunction)() : 0;
		bool change = value != m_lastNbboPrint;
		if(change)
		{
			m_lastNbboPrint = value;
		}
		value = m_option ? (m_option->*m_midpointFunction)() : 0;
		if(value != m_midPoint)
		{
			m_midPoint = value;
			change = true;
		}
		if(change)
		{
			return SetValue(DeriveValue());
		}
		return false;
	}
	virtual bool isObjectValueZero() const override{return !m_underlier || !m_option || !(m_underlier->*m_printFunction)() || !(m_option->*m_midpointFunction)();}
	virtual bool isValueZero() const override{return !m_lastNbboPrint || !m_midPoint;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_midPoint = m_option ? (m_option->*m_midpointFunction)() : 0;
		m_lastNbboPrint = m_underlier ? (m_underlier->*m_printFunction)() : 0;
		m_value = DeriveValue();
	}
	const Security* const& m_option;
	UIntFunction m_midpointFunction;
	unsigned int m_midPoint;
};

class TGUI_API PositionOptionPutTimeValue : public PositionOptionCallTimeValue
{
public:
	PositionOptionPutTimeValue(const Security* const& option,
		const Security* const& underlier,
		UIntFunction midpointFunction,
		UIntFunction printFunction,
		const unsigned int& strikePrice,
		const bool* comma,
		const unsigned char* decDigits,
		const bool* truncate,
		bool useEmptyValue = true,
		bool useTick = true):
		PositionOptionCallTimeValue(option, underlier, midpointFunction, printFunction, strikePrice, comma, decDigits, truncate, useEmptyValue, useTick)
	{
	}
	virtual Price CalculateIntrinsicFromComponents(const unsigned int& lastNbboPrint) const override//, const unsigned int& midPoint) const
	{
		return lastNbboPrint < m_uintStrikePrice ? m_strikePrice.GetPositivePriceDiff(Price(lastNbboPrint)) : Price::priceZero;
	}
	DECLARE_NED_NEW
};
#endif

class TGUI_API PositionSecurityPriceDivision : public MoneyRowValue
{
public:
	typedef const SignedPrice& (Security::*SignedPriceFunction)() const;
	typedef const Price& (Security::*PriceFunction)() const;
	PositionSecurityPriceDivision(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, SignedPriceFunction signedPriceFunction, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_signedPriceFunction(signedPriceFunction),
		m_priceFunction(priceFunction)
	{
	}
//	virtual bool CanBeNegative() const{return !m_absValue;}
	ValueType DeriveValue(const SignedPrice& signedPrice, const Price& price) const
	{
		if(!signedPrice.isZero() && !price.isZero())
		{
			Money value(signedPrice);
			if(DivideMoneyByPrice(value, price))return value;
		}
		return Money::moneyZero;
	}
	ValueType DeriveValue() const{return DeriveValue(m_signedPrice, m_price);}
	ValueType CalculateValue() const{return m_security ? DeriveValue((m_security->*m_signedPriceFunction)(), (m_security->*m_priceFunction)()) : Money::moneyZero;}
	virtual bool isValueChanged() const override{return m_security ? m_signedPrice != (m_security->*m_signedPriceFunction)() || m_price != (m_security->*m_priceFunction)() : !m_signedPrice.isZero() || !m_price.isZero();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		InitValues();
		return SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return !m_security || (m_security->*m_priceFunction)().isZero();}
	virtual bool isValueZero() const override{return m_price.isZero();}
	DECLARE_NED_NEW
protected:
	inline void InitValues()
	{
		if(m_security)
		{
			m_signedPrice = (m_security->*m_signedPriceFunction)();
			m_price = (m_security->*m_priceFunction)();
		}
		else
		{
			m_signedPrice.SetZero();
			m_price.SetZero();
		}
	}
	virtual void InitializeValue() override
	{
		InitValues();
		m_value = DeriveValue();
	}
	const Security* const& m_security;
	SignedPrice m_signedPrice;
	Price m_price;
	SignedPriceFunction m_signedPriceFunction;
	PriceFunction m_priceFunction;
};
/*
class TGUI_API PositionSecurityPriceDiffByPriceAsUIntDivision : public MoneyRowValue
{
public:
	typedef const unsigned int& (Security::*PriceAsUIntFunction)() const;
	typedef const Price& (Security::*PriceFunction)() const;
	PositionSecurityPriceDiffByPriceAsUIntDivision(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceAsUIntFunction priceAsUIntFunction, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_priceAsUIntFunction(priceAsUIntFunction),
		m_priceFunction(priceFunction)
//		m_absValue(absValue)
	{
	}
//	virtual bool CanBeNegative() const override{return !m_absValue;}
	virtual Money DeriveValue(const unsigned int& priceAsUInt, const Price& price) const
	{
		if(priceAsUInt != 0 && !price.isZero())
		{
			Price p(priceAsUInt);
			Money value(p - price);
			if(DivideMoneyByPrice(value, price))return value;
		}
		return Money::moneyZero;
	}
	Money DeriveValueFromComponents() const{return DeriveValue(m_priceAsUInt, m_price);}
	Money CalculateValue() const{return m_security ? DeriveValue((m_security->*m_priceAsUIntFunction)(), (m_security->*m_priceFunction)()) : Money::moneyZero;}
	virtual bool isValueChanged() const override{return m_security ? m_priceAsUInt != (m_security->*m_priceAsUIntFunction)() || m_price != (m_security->*m_priceFunction)() : m_priceAsUInt != 0 || !m_price.isZero();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		InitValues();
		return SetValue(DeriveValueFromComponents());
	}
	virtual bool isObjectValueZero() const override{return !m_security || !(m_security->*m_priceAsUIntFunction)() || (m_security->*m_priceFunction)().isZero();}
	virtual bool isValueZero() const override{return m_price.isZero() || !m_priceAsUInt;}
	DECLARE_NED_NEW
protected:
	inline void InitValues()
	{
		if(m_security)
		{
			m_priceAsUInt = (m_security->*m_priceAsUIntFunction)();
			m_price = (m_security->*m_priceFunction)();
		}
		else
		{
			m_priceAsUInt = 0;
			m_price.SetZero();
		}
	}
	virtual void InitializeValue() override
	{
		InitValues();
		m_value = DeriveValueFromComponents();
	}
	const Security* const& m_security;
	unsigned int m_priceAsUInt;
	Price m_price;
	PriceAsUIntFunction m_priceAsUIntFunction;
	PriceFunction m_priceFunction;
//	bool m_absValue;
};

class TGUI_API PositionSecurityPriceDiffByPriceAsUIntDivisionAbs : public PositionSecurityPriceDiffByPriceAsUIntDivision
{
public:
	PositionSecurityPriceDiffByPriceAsUIntDivisionAbs(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceAsUIntFunction priceAsUIntFunction, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		PositionSecurityPriceDiffByPriceAsUIntDivision(security, comma, decDigits, truncate, priceAsUIntFunction, priceFunction, useEmptyValue, useTick, useNeutralColor)
	{
	}
	virtual bool CanBeNegative() const override{return false;}
	virtual Money DeriveValue(const unsigned int& priceAsUInt, const Price& price) const
	{
		if(priceAsUInt != 0 && !price.isZero())
		{
			Price p(priceAsUInt);
			Money value(price < p ? p - price : price - p);
			if(DivideMoneyByPrice(value, price))return value;
		}
		return Money::moneyZero;
	}
	DECLARE_NED_NEW
};
*/
class TGUI_API PositionSecurityUIntPriceDiffByPriceDivision : public MoneyRowValue
{
public:
	typedef const Price& (Security::*PriceFunction)() const;
	typedef const unsigned int& (Security::*UIntFunction)() const;
	PositionSecurityUIntPriceDiffByPriceDivision(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction1, UIntFunction priceFunction2, PriceFunction priceFunction3, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_priceFunction1(priceFunction1),
		m_priceFunction2(priceFunction2),
		m_priceFunction3(priceFunction3)
	{
	}
//	virtual bool CanBeNegative() const{return !m_absValue;}
	virtual void CalculateDifferenceFromComponent(Money& diff, const Price& price1, const Price& price2) const
	{
		diff = Money(price2 - price1);
	}
	Money DeriveValueFromComponents(const Price& price1, const Price& price2, const Price& m_priceDenominator) const
	{
		if(!price1.isZero() && !price2.isZero() && !m_priceDenominator.isZero())
		{
			Money diff;
			CalculateDifferenceFromComponent(diff, price1, price2);
			if(DivideMoneyByPrice(diff, m_priceDenominator))return diff;
		}
		return Money::moneyZero;
	}
	Money DeriveValue() const{return DeriveValueFromComponents(m_price1, m_price2, m_priceDenominator);}
	Money CalculateValue() const{return m_security ? DeriveValueFromComponents((m_security->*m_priceFunction1)(), Price((m_security->*m_priceFunction2)()), (m_security->*m_priceFunction3)()) : Money::moneyZero;}
	virtual bool isValueChanged() const override{return m_security ? m_price1 != (m_security->*m_priceFunction1)() || m_price2 != Price((m_security->*m_priceFunction2)()) || m_priceDenominator != (m_security->*m_priceFunction3)() : !m_price1.isZero() || !m_price2.isZero() || !m_priceDenominator.isZero();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		bool changed;
		if(m_security)
		{
			const Price& price1 = (m_security->*m_priceFunction1)();
			const Price price2 = Price((m_security->*m_priceFunction2)());
			const Price& priceDenominator = (m_security->*m_priceFunction3)();
			changed = price1 != m_price1;
			if(changed)m_price1 = price1;
			if(price2 != m_price2)
			{
				changed = true;
				m_price2 = price2;
			}
			if(priceDenominator != m_priceDenominator)
			{
				changed = true;
				m_priceDenominator = priceDenominator;
			}
		}
		else
		{
			changed = !m_price1.isZero();
			if(changed)m_price1.SetZero();
			if(!m_price2.isZero())
			{
				changed = true;
				m_price2.SetZero();
			}
			if(!m_priceDenominator.isZero())
			{
				changed = true;
				m_priceDenominator.SetZero();
			}
		}
		return changed && SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return !m_security || (m_security->*m_priceFunction1)().isZero() || !(m_security->*m_priceFunction2)() || (m_security->*m_priceFunction3)().isZero();}
	virtual bool isValueZero() const override{return m_price1.isZero() || m_price2.isZero() || m_priceDenominator.isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		if(m_security)
		{
			m_price1 = (m_security->*m_priceFunction1)();
			m_price2 = Price((m_security->*m_priceFunction2)());
			m_priceDenominator = (m_security->*m_priceFunction3)();
		}
		else
		{
			m_price1.SetZero();
			m_price2.SetZero();
			m_priceDenominator.SetZero();
		}
		m_value = DeriveValue();
	}
	const Security* const& m_security;
	Price m_price1;
	Price m_price2;
	Price m_priceDenominator;
	PriceFunction m_priceFunction1;
	UIntFunction m_priceFunction2;
	PriceFunction m_priceFunction3;
//	bool m_absValue;
};

class TGUI_API PositionSecurityPriceAsUIntRowValueCopy : public CompactPriceRowValue//PriceAsUIntRowValue
{
public:
	typedef ValueType (Security::*UIntFunction)() const;
	PositionSecurityPriceAsUIntRowValueCopy(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true):
		CompactPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_security(security),
		m_uintFunction(uintFunction)
	{}
//	void SetSecurity(Security* security){m_security = security;}
//	virtual const unsigned __int64& GetObjectValue() const override{return (m_security->*m_uint64Function)();}
	virtual bool isValueChanged() const override{return m_value != (m_security ? (m_security->*m_uintFunction)() : 0);}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(m_security ? (m_security->*m_uintFunction)() : 0);}
	virtual bool UpdateValue() override{return SetValue(m_security ? (m_security->*m_uintFunction)() : 0);}
	virtual bool isObjectValueZero() const override{return !m_security || !(m_security->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = m_security ? (m_security->*m_uintFunction)() : 0;}
	const Security* const& m_security;
	UIntFunction m_uintFunction;
};

class TGUI_API PositionSecurityCharRowValue : public CharRowValue
{
public:
	typedef const ValueType& (Security::*CharFunction)() const;
	PositionSecurityCharRowValue(const Security* const& security, CharFunction charFunction, const char& value = '\0', bool useEmptyValue = false, bool useNeutralColor = false, bool useTick = false):
		CharRowValue(value, useEmptyValue, useNeutralColor, useTick), m_security(security),m_charFunction(charFunction){}
	virtual const ValueType& GetObjectValue() const override{return m_security ? (m_security->*m_charFunction)() : zero;}//m_emptyValue;}
	DECLARE_NED_NEW
protected:
	const Security* const& m_security;
	CharFunction m_charFunction;
};

class TGUI_API PositionSecurityUCharRowValue : public UCharRowValue
{
public:
	typedef const ValueType& (Security::*UCharFunction)() const;
	PositionSecurityUCharRowValue(const Security* const& security, UCharFunction ucharFunction, const char& value = '\0', bool useEmptyValue = false, bool useNeutralColor = false, bool useTick = false):
		UCharRowValue(value, useEmptyValue, useTick), m_security(security),m_ucharFunction(ucharFunction){}
	virtual const ValueType& GetObjectValue() const override{return m_security ? (m_security->*m_ucharFunction)() : zero;}//m_emptyValue;}
	DECLARE_NED_NEW
protected:
	const Security* const& m_security;
	UCharFunction m_ucharFunction;
};

class TGUI_API PositionSecurityIntRowValue : public IntRowValue
{
public:
	typedef const ValueType& (Security::*IntFunction)() const;
	PositionSecurityIntRowValue(const Security* const& security, const bool* comma, IntFunction intFunction, bool useEmptyValue = false, bool useTick = true):
		IntRowValue(comma, useEmptyValue, useTick),m_security(security),m_intFunction(intFunction){}
	virtual const ValueType& GetObjectValue() const override{return m_security ? (m_security->*m_intFunction)() : zero;}//m_emptyValue;}
	DECLARE_NED_NEW
protected:
	const Security* const& m_security;
	IntFunction m_intFunction;
};

class TGUI_API PositionSecurityIntByUInt64Division : public MoneyRowValue
{
public:
	typedef const int& (Security::*IntFunction)() const;
	typedef const unsigned __int64& (Security::*UInt64Function)() const;
	PositionSecurityIntByUInt64Division(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, IntFunction intFunction, UInt64Function uint64Function2, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_intFunction(intFunction),
		m_uint64Function2(uint64Function2)
	{
	}
	virtual bool CanBeNegative() const override{return false;}
	inline static Money CalculateFromValues(const int& numerator, const unsigned __int64& denominator)
	{
		if(denominator && numerator)
		{
			Money value((__int64)(numerator < 0 ? -numerator : numerator) * 100, 0);
			value /= denominator;
			return value;
		}
		return Money::moneyZero;
	}
	inline Money CalculateValue() const
	{
		return m_security ? CalculateFromValues((m_security->*m_intFunction)(), (m_security->*m_uint64Function2)()) : Money::moneyZero;
/*
		if(m_security)
		{
			unsigned __int64 denominator = (m_security->*m_uint64Function2)();
			if(denominator)
			{
				int numerator = (m_security->*m_intFunction)();
				Money value((__int64)(numerator < 0 ? -numerator : numerator) * 100, 0);
				value /= denominator;
				return value;
			}
		}
		return Money::moneyZero;
*/
	}
	inline Money DeriveValue() const
	{
		return CalculateFromValues(m_numerator, m_denominator);
/*
		if(m_denominator && m_numerator)
		{
			Money value((__int64)(m_numerator < 0 ? -m_numerator : m_numerator) * 100, 0);
			value /= m_denominator;
			return value;
		}
		return Money::moneyZero;
*/
	}
	virtual bool isValueChanged() const override
	{
		return m_security ?
			m_numerator != (m_security->*m_intFunction)() || m_denominator != (m_security->*m_uint64Function2)() :
			m_numerator || m_denominator;
	}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		InitValues();
		return SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return !m_security || !(m_security->*m_intFunction)() || !(m_security->*m_uint64Function2)();}
	virtual bool isValueZero() const override{return !m_numerator || !m_denominator;}
	DECLARE_NED_NEW
protected:
	inline void InitValues()
	{
		if(m_security)
		{
			m_numerator = (m_security->*m_intFunction)();
			m_denominator = (m_security->*m_uint64Function2)();
		}
		else
		{
			m_numerator = 0;
			m_denominator = 0;
		}
	}
	virtual void InitializeValue() override
	{
		InitValues();
		m_value = DeriveValue();
	}
	const Security* const& m_security;
	int m_numerator;
	unsigned __int64 m_denominator;
	IntFunction m_intFunction;
	UInt64Function m_uint64Function2;
};

class TGUI_API PositionSecurityPriceRowValueDiffAsUInt : public SignedPriceRowValue
{
public:
	typedef const Price& (Security::*PriceFunction)() const;
	typedef const unsigned int& (Security::*PriceAsUIntFunction)() const;
	PositionSecurityPriceRowValueDiffAsUInt(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunctionFirst, PriceAsUIntFunction priceFunctionLast, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = false):
		SignedPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick, useNeutralColor),
		m_security(security),
		m_last(0),
		m_priceFunctionFirst(priceFunctionFirst),
		m_priceFunctionLast(priceFunctionLast)
	{
	}
	virtual SignedPrice CalculateValue() const
	{
		if(m_security)
		{
			unsigned int last = (m_security->*m_priceFunctionLast)();
			if(last)
			{
				const Price& first = (m_security->*m_priceFunctionFirst)();
				if(!first.isZero())
				{
					return Price(last) - first;
				}
			}
		}
		return SignedPrice::signedPriceZero;
	}
	virtual SignedPrice DeriveValue() const{return m_last && !m_first.isZero() ? Price(m_last) - m_first : SignedPrice::signedPriceZero;}
	virtual bool isValueChanged() const override
	{
		return m_security ?
			m_last != (m_security->*m_priceFunctionLast)() || m_first != (m_security->*m_priceFunctionFirst)() :
			m_last || !m_first.isZero();
	}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		InitValues();
		return SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return !m_security || !(m_security->*m_priceFunctionLast)() || (m_security->*m_priceFunctionFirst)().isZero();}
	virtual bool isValueZero() const override{return !m_last || m_first.isZero();}

	DECLARE_NED_NEW
protected:
	inline void InitValues()
	{
		if(m_security)
		{
			m_last = (m_security->*m_priceFunctionLast)();
			m_first = (m_security->*m_priceFunctionFirst)();
		}
		else
		{
			m_last = 0;
			m_first.SetZero();
		}
	}
	virtual void InitializeValue() override
	{
		InitValues();
		m_value = DeriveValue();
	}
	const Security* const& m_security;
	unsigned int m_last;
	Price m_first;
	PriceFunction m_priceFunctionFirst;
	PriceAsUIntFunction m_priceFunctionLast;
};

class TGUI_API PositionSecurityPriceRowValueDiffAsUIntReversed : public PositionSecurityPriceRowValueDiffAsUInt
{
public:
	PositionSecurityPriceRowValueDiffAsUIntReversed(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunctionFirst, PriceAsUIntFunction priceFunctionLast, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = false):
		PositionSecurityPriceRowValueDiffAsUInt(security, comma, decDigits, truncate, priceFunctionFirst, priceFunctionLast, useEmptyValue, useTick, useNeutralColor)
	{
	}
	virtual SignedPrice CalculateValue() const override
	{
		if(m_security)
		{
			unsigned int last = (m_security->*m_priceFunctionLast)();
			if(last)
			{
				const Price& first = (m_security->*m_priceFunctionFirst)();
				if(!first.isZero())
				{
					return first - Price(last);
				}
			}
		}
		return SignedPrice::signedPriceZero;
	}
	virtual SignedPrice DeriveValue() const override{return m_last && !m_first.isZero() ? m_first - Price(m_last) : SignedPrice::signedPriceZero;}
	DECLARE_NED_NEW
};


class TGUI_API PositionSecurityPriceRowValueDiffAsUIntDividedByFirst : public SignedPriceRowValue
{
public:
	typedef const Price& (Security::*PriceFunction)() const;
//	typedef unsigned int (Security::*PriceAsUIntFunction)() const;
	typedef const unsigned int& (Security::*PriceAsUIntFunction)() const;
	PositionSecurityPriceRowValueDiffAsUIntDividedByFirst(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunctionFirst, PriceAsUIntFunction priceFunctionLast, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = false):
		SignedPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick, useNeutralColor),
		m_security(security),
		m_last(0),
		m_priceFunctionFirst(priceFunctionFirst),
		m_priceFunctionLast(priceFunctionLast)
	{
	}
	virtual SignedPrice CalculateValue() const
	{
		if(m_security)
		{
			unsigned int last = (m_security->*m_priceFunctionLast)();
			if(last)
			{
				const Price& first = (m_security->*m_priceFunctionFirst)();
				if(!first.isZero())
				{
					return first.GetPercentChange(Price(last) - first);
				}
			}
		}
		return SignedPrice::signedPriceZero;
	}
	virtual SignedPrice DeriveValue() const{return m_last && !m_first.isZero() ? m_first.GetPercentChange(Price(m_last) - m_first) : SignedPrice::signedPriceZero;}
	virtual bool isValueChanged() const override
	{
		return m_security ?
			m_last != (m_security->*m_priceFunctionLast)() || m_first != (m_security->*m_priceFunctionFirst)() :
			m_last || !m_first.isZero();
	}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		InitValues();
		return SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const{return !m_security || !(m_security->*m_priceFunctionLast)() || (m_security->*m_priceFunctionFirst)().isZero();}
	virtual bool isValueZero() const{return !m_last || m_first.isZero();}

	DECLARE_NED_NEW
protected:
	inline void InitValues()
	{
		if(m_security)
		{
			m_last = (m_security->*m_priceFunctionLast)();
			m_first = (m_security->*m_priceFunctionFirst)();
		}
		else
		{
			m_last = 0;
			m_first.SetZero();
		}
	}
	virtual void InitializeValue() override
	{
		InitValues();
		m_value = DeriveValue();
	}
	const Security* const& m_security;
	unsigned int m_last;
	Price m_first;
	PriceFunction m_priceFunctionFirst;
	PriceAsUIntFunction m_priceFunctionLast;
};

class TGUI_API PositionSecurityPriceRowValueDiffAsUIntDividedByFirstReversed : public PositionSecurityPriceRowValueDiffAsUIntDividedByFirst
{
public:
	PositionSecurityPriceRowValueDiffAsUIntDividedByFirstReversed(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunctionFirst, PriceAsUIntFunction priceFunctionLast, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = false):
		PositionSecurityPriceRowValueDiffAsUIntDividedByFirst(security, comma, decDigits, truncate, priceFunctionFirst, priceFunctionLast, useEmptyValue, useTick, useNeutralColor)
	{
	}
	virtual SignedPrice CalculateValue() const override
	{
		if(m_security)
		{
			unsigned int last = (m_security->*m_priceFunctionLast)();
			if(last)
			{
				const Price& first = (m_security->*m_priceFunctionFirst)();
				if(!first.isZero())
				{
					Price lastPrice(last);
					return lastPrice.GetPercentChange(first - lastPrice);
				}
			}
		}
		return SignedPrice::signedPriceZero;
	}
	virtual SignedPrice DeriveValue() const override
	{
		if(m_last && !m_first.isZero())
		{
			Price lastPrice(m_last);
			return lastPrice.GetPercentChange(m_first - lastPrice);
		}
		return SignedPrice::signedPriceZero;
	}
	DECLARE_NED_NEW
};


class TGUI_API PositionUIntDiffDividedByInt : public MoneyRowValue
{
public:
	typedef const unsigned int& (PositionData::*UIntFunction)() const;
	typedef const int& (PositionData::*IntFunction)() const;
	PositionUIntDiffDividedByInt(const PositionData* position,
		const bool* comma,
		const unsigned char* decDigits,
		const bool* truncate,
		UIntFunction functionFirst,
		UIntFunction functionSecond,
		IntFunction functionDenominator,
		bool useEmptyValue = true,
		bool useNeutralColor = false,
		bool useTick = true):

		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_position(position),
		m_functionFirst(functionFirst),
		m_functionSecond(functionSecond),
		m_functionDenominator(functionDenominator)
	{
	}
//	virtual const ValueType& GetObjectValue() const override{return (m_position->*m_moneyFunction)();}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}

	Money CalculateValue() const
	{
		int denominator = (m_position->*m_functionDenominator)();
		if(denominator)
		{
			Money value((int)(m_position->*m_functionFirst)() - (int)(m_position->*m_functionSecond)(), 0);
			if(!value.isZero())
			{
				value /= denominator;
			}
			return value;
		}
		return Money::moneyZero;
	}
	Money DeriveValue() const
	{
		if(m_denominator && m_numerator)
		{
			Money value(m_numerator, 0);
			value /= m_denominator;
			return value;
		}
		return Money::moneyZero;
	}
	virtual bool isValueChanged() const override{return m_numerator != (int)(m_position->*m_functionFirst)() - (int)(m_position->*m_functionSecond)() || m_denominator != (m_position->*m_functionDenominator)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override//{m_numerator = (m_security->*m_intFunction)();m_denominator = (m_security->*m_intFunction2)();return SetValue(DeriveValue());}
	{
		m_numerator = (int)(m_position->*m_functionFirst)() - (int)(m_position->*m_functionSecond)();
		m_denominator = (m_position->*m_functionDenominator)();
		return SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return !(m_position->*m_functionDenominator)();}//return (m_security->*m_intFunction)() == 0 || (m_security->*m_intFunction2)() == 0;}
	virtual bool isValueZero() const override{return !m_denominator;}//{return m_numerator == 0 || m_denominator == 0;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override//{m_numerator = (m_security->*m_intFunction)();m_denominator = (m_security->*m_intFunction2)();m_value = DeriveValue();}
	{
		m_numerator = (int)(m_position->*m_functionFirst)() - (int)(m_position->*m_functionSecond)();
		m_denominator = (m_position->*m_functionDenominator)();
		m_value = DeriveValue();
	}
	const PositionData* m_position;
	int m_numerator;
	int m_denominator;
	UIntFunction m_functionFirst;
	UIntFunction m_functionSecond;
	IntFunction m_functionDenominator;
};

class TGUI_API PositionUIntDiffDividedByIntInventory : public MoneyRowValue
{
public:
	typedef const unsigned int& (PositionData::*UIntFunction)() const;
	typedef const int& (PositionData::*IntFunction)(const bool& inventoryView) const;
	PositionUIntDiffDividedByIntInventory(const PositionData* position,
		const bool& inventoryView,
		const bool* comma,
		const unsigned char* decDigits,
		const bool* truncate,
		UIntFunction functionFirst,
		UIntFunction functionSecond,
		IntFunction functionDenominator,
		bool useEmptyValue = true,
		bool useNeutralColor = false,
		bool useTick = true):

		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_position(position),
		m_functionFirst(functionFirst),
		m_functionSecond(functionSecond),
		m_functionDenominator(functionDenominator),
		m_inventoryView(inventoryView)
	{
	}
//	virtual const ValueType& GetObjectValue() const override{return (m_position->*m_moneyFunction)();}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}

	Money CalculateValue() const
	{
		const int denominator = (m_position->*m_functionDenominator)(m_inventoryView);
		if(denominator)
		{
			Money value((int)(m_position->*m_functionFirst)() - (int)(m_position->*m_functionSecond)(), 0);
			if(!value.isZero())
			{
				value /= denominator;
			}
			return value;
		}
		return Money::moneyZero;
	}
	Money DeriveValue() const
	{
		if(m_denominator && m_numerator)
		{
			Money value(m_numerator, 0);
			value /= m_denominator;
			return value;
		}
		return Money::moneyZero;
	}

	virtual bool isValueChanged() const override{return m_numerator != (int)(m_position->*m_functionFirst)() - (int)(m_position->*m_functionSecond)() || m_denominator != (m_position->*m_functionDenominator)(m_inventoryView);}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_numerator = (int)(m_position->*m_functionFirst)() - (int)(m_position->*m_functionSecond)();
		m_denominator = (m_position->*m_functionDenominator)(m_inventoryView);
		return SetValue(DeriveValue());
	}

	virtual bool isObjectValueZero() const override{return !(m_position->*m_functionDenominator)(m_inventoryView);}
	virtual bool isValueZero() const override{return !m_denominator;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_numerator = (int)(m_position->*m_functionFirst)() - (int)(m_position->*m_functionSecond)();
		m_denominator = (m_position->*m_functionDenominator)(m_inventoryView);
		m_value = DeriveValue();
	}
	const PositionData* m_position;
	int m_numerator;
	int m_denominator;
	UIntFunction m_functionFirst;
	UIntFunction m_functionSecond;
	IntFunction m_functionDenominator;
	const bool& m_inventoryView;
};

class TGUI_API PositionSecurityIntByIntDivision : public MoneyRowValue
{
public:
	typedef const int& (Security::*IntFunction)() const;
	PositionSecurityIntByIntDivision(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, IntFunction intFunction, IntFunction intFunction2, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_intFunction(intFunction),
		m_intFunction2(intFunction2)
	{
	}
	inline static Money CalculateFromValues(const int& numerator, const int& denominator)
	{
		if(denominator && numerator)
		{
			Money value((__int64)numerator * 100, 0);
			value /= denominator;
			return value;
		}
		return Money::moneyZero;
	}
	inline Money CalculateValue() const
	{
		return m_security ? CalculateFromValues((m_security->*m_intFunction)(), (m_security->*m_intFunction2)()) : Money::moneyZero;
/*
		if(m_security)
		{
			const int denominator = (m_security->*m_intFunction2)();
			if(denominator)
			{
				const int numerator = (m_security->*m_intFunction)();
				Money value((__int64)numerator * 100, 0);
				value /= denominator;
				return value;
			}
		}
		return Money::moneyZero;
*/
	}
	inline Money DeriveValue() const
	{
		return CalculateFromValues(m_numerator, m_denominator);
/*
		if(m_denominator && m_numerator)
		{
			Money value((__int64)m_numerator * 100, 0);
			value /= m_denominator;
			return value;
		}
		return Money::moneyZero;
*/
	}
	virtual bool isValueChanged() const override//{return m_numerator != (m_security->*m_intFunction)() || m_denominator != (m_security->*m_intFunction2)();}
	{
		return m_security ?
			m_numerator != (m_security->*m_intFunction)() || m_denominator != (m_security->*m_intFunction2)():
			m_numerator || m_denominator;
	}

	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		if(m_security)
		{
			m_numerator = (m_security->*m_intFunction)();
			m_denominator = (m_security->*m_intFunction2)();
		}
		else
		{
			m_numerator = 0;
			m_denominator = 0;
		}
		return SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return !m_security || !(m_security->*m_intFunction)() || !(m_security->*m_intFunction2)();}
	virtual bool isValueZero() const override{return !m_numerator || !m_denominator;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		if(m_security)
		{
			m_numerator = (m_security->*m_intFunction)();
			m_denominator = (m_security->*m_intFunction2)();
		}
		else
		{
			m_numerator = 0;
			m_denominator = 0;
		}
		m_value = DeriveValue();
	}
	const Security* const& m_security;
	int m_numerator;
	int m_denominator;
	IntFunction m_intFunction;
	IntFunction m_intFunction2;
};
/*
class TGUI_API PositionSecurityBoolOrdinalRowValue : public BoolRowValue
{
public:
	typedef ValueType (Security::*BoolFunction)(const unsigned int& ordinal) const;
	PositionSecurityBoolOrdinalRowValue(const Security* const& security, BoolFunction boolFunction, const unsigned int& ordinal, char trueValue = 'Y', char falseValue = '\0'):
		BoolRowValue(trueValue, falseValue), m_security(security), m_boolFunction(boolFunction), m_ordinal(ordinal){}
	ValueType GetMyObjectValue() const{return m_security != NULL && (m_security->*m_boolFunction)(m_ordinal);}

//	virtual const ValueType& GetObjectValue() const override{return GetMyObjectValue();}

	virtual bool isValueChanged() const override{return m_value != GetMyObjectValue();}//(m_security != NULL && (m_security->*m_boolFunction)(m_ordinal));}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(GetMyObjectValue());}//m_security != NULL && (m_security->*m_boolFunction)(m_ordinal));}
	virtual bool UpdateValue() override{return SetValue(GetMyObjectValue());}//m_security != NULL && (m_security->*m_boolFunction)(m_ordinal));}

	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = GetMyObjectValue();}//m_security != NULL && (m_security->*m_boolFunction)(m_ordinal);}
	const Security* const& m_security;
	BoolFunction m_boolFunction;
	const unsigned int& m_ordinal;
};
*/
class TGUI_API PositionSecurityUCharAsCharOrdinalRowValue : public UCharAsCharRowValue
{
public:
	typedef const ValueType& (Security::*UCharFunction)(const unsigned char& ordinal) const;
	PositionSecurityUCharAsCharOrdinalRowValue(const Security* const& security, UCharFunction ucharFunction, const ValueType& defaultUCharValue, const unsigned char& ordinal, bool useEmptyValue = true, bool useTick = false):
		UCharAsCharRowValue(useEmptyValue, useTick), m_security(security), m_ucharFunction(ucharFunction), m_ordinal(ordinal), m_defaultUCharValue(defaultUCharValue){}

	virtual const ValueType& GetObjectValue() const override{return m_security ? (m_security->*m_ucharFunction)(m_ordinal) : m_defaultUCharValue;}
/*
	const ValueType& GetMyObjectValue() const{return m_security ? (m_security->*m_ucharFunction)(m_ordinal) : m_defaultUCharValue;}
	
	virtual const ValueType& GetObjectValue() const override{return GetMyObjectValue();}
	virtual bool isValueChanged() const override{return m_value != GetMyObjectValue();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(GetMyObjectValue());}
	virtual bool UpdateValue() override{return SetValue(GetMyObjectValue());}
//	virtual bool isValueZero() const override{return m_value == m_defaultUCharValue;}
//	virtual bool isObjectValueZero() const override{return GetMyObjectValue() == m_defaultUCharValue;}
*/
	DECLARE_NED_NEW
protected:
//	virtual void InitializeValue() override{m_value = GetMyObjectValue();}
	const Security* const& m_security;
	UCharFunction m_ucharFunction;
	const unsigned char& m_ordinal;
	ValueType m_defaultUCharValue;
};
/*
class TGUI_API PositionSecurityExchangeRowValue : public StringRowValue
{
public:
	PositionSecurityExchangeRowValue(const Security* const& security):StringRowValue(), m_security(security){}
	virtual bool isValueChanged() const override{return m_security ? strcmp(m_value.c_str(), m_security->GetPrimaryExchangeName()) != 0 : !m_value.empty();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(std::string(m_security ? m_security->GetPrimaryExchangeName() : ""));}

	virtual bool UpdateValue() override;

//	virtual bool isObjectValueEmpty() const override{return false;}

protected:
	virtual void InitializeValue() override;
	const Security* const& m_security;
};
*/
class TGUI_API PositionSecurityUIntAsStrRowValue : public UIntAsStrRowValue
{
public:
	typedef const ValueType& (Security::*UIntFunction)() const;
	PositionSecurityUIntAsStrRowValue(const Security* const& security, UIntFunction uintFunction, const bool& useEmptyValue = true):
		UIntAsStrRowValue(zero, useEmptyValue),
		m_security(security),
		m_uintFunction(uintFunction){}
	virtual const ValueType& GetObjectValue() const override{return m_security ? (m_security->*m_uintFunction)() : zero;}
	DECLARE_NED_NEW
protected:
	const Security* const& m_security;
	UIntFunction m_uintFunction;
};

class TGUI_API PositionSignedPriceRowValue : public SignedPriceRowValue
{
public:
	typedef const ValueType& (PositionData::*PriceFunction)() const;
	PositionSignedPriceRowValue(const PositionData* position, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		SignedPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick, useNeutralColor),
		m_position(position),
		m_priceFunction(priceFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_position->*m_priceFunction)();}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	const PositionData* m_position;
	PriceFunction m_priceFunction;
};

class TGUI_API PositionSignedPriceInventoryRowValue : public SignedPriceRowValue
{
public:
	typedef const ValueType& (PositionData::*PriceFunction)(const bool& inventoryView) const;
	PositionSignedPriceInventoryRowValue(const PositionData* position, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		SignedPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick, useNeutralColor),
		m_position(position),
		m_priceFunction(priceFunction),
		m_inventoryView(inventoryView)
		{}
	virtual const ValueType& GetObjectValue() const override{return (m_position->*m_priceFunction)(m_inventoryView);}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	const PositionData* m_position;
	PriceFunction m_priceFunction;
	const bool& m_inventoryView;
};

class TGUI_API PositionSignedPriceInventoryPositiveRowValue : public PriceRowValue
{
public:
	typedef const SignedPrice& (PositionData::*PriceFunction)(const bool& inventoryView) const;
	PositionSignedPriceInventoryPositiveRowValue(const PositionData* position, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true):
		PriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_position(position),
		m_priceFunction(priceFunction),
		m_inventoryView(inventoryView)
	{}
//	virtual const ValueType& GetObjectValue() const override{return (m_position->*m_priceFunction)(m_inventoryView);}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}

////
//	virtual bool CanBeNegative() const{return false;}
	Price CalculateValue() const
	{
		SignedPrice signedPrice = (m_position->*m_priceFunction)(m_inventoryView);
		signedPrice.SetAbs();
		return Price(signedPrice.GetDollars(), signedPrice.GetDollarFraction());
	}

	virtual bool isValueChanged() const override{return CalculateValue() != m_value;}
	virtual short CompareAhead(const RowValue& other) const override { return -((const TypedRowValue&)other).CompareValue(CalculateValue()); }
	virtual bool UpdateValue() override
	{
		return SetValue(CalculateValue());
	}

	virtual bool isObjectValueZero() const override{return (m_position->*m_priceFunction)(m_inventoryView).isZero();}
//	virtual bool isValueZero() const override{return m_value.isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_value = CalculateValue();
	}
	const PositionData* m_position;
	PriceFunction m_priceFunction;
	Price m_price;
	const bool& m_inventoryView;
};

class TGUI_API PositionSignedPriceRowValueNull : public PositionSignedPriceRowValue
{
public:
	PositionSignedPriceRowValueNull(const PositionData* position, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, bool useEmptyValue = false, bool useTick = true):
		PositionSignedPriceRowValue(position, comma, decDigits, truncate, priceFunction, useEmptyValue, useTick),
		m_positionZero(!m_position)
		{}
	virtual const ValueType& GetObjectValue() const override{return m_position ? (m_position->*m_priceFunction)() : zero;}
	virtual bool isValueEmpty() const override{return m_useEmptyValue && m_positionZero;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !m_position;}
	virtual bool isValueChanged() const override{return PositionSignedPriceRowValue::isValueChanged() || m_positionZero != !m_position;}
	virtual bool SetValue(const ValueType& value) override
	{
		bool ret = PositionSignedPriceRowValue::SetValue(value);
		if(m_positionZero != !m_position)
		{
			m_positionZero = !m_position;
			ret = true;
		}
		return ret;
	}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{PositionSignedPriceRowValue::InitializeValue(); m_positionZero = !m_position;}
	bool m_positionZero;
};

class TGUI_API PositionSignedPriceInventoryRowValueNull : public PositionSignedPriceInventoryRowValue
{
public:
	PositionSignedPriceInventoryRowValueNull(const PositionData* position, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, bool useEmptyValue = false, bool useNeutralColor = false, bool useTick = true):
		PositionSignedPriceInventoryRowValue(position, inventoryView, comma, decDigits, truncate, priceFunction, useEmptyValue, useNeutralColor, useTick),
		m_positionZero(!m_position)
		{}
	virtual const ValueType& GetObjectValue() const override{return m_position ? (m_position->*m_priceFunction)(m_inventoryView) : zero;}
	virtual bool isValueEmpty() const override{return m_useEmptyValue && m_positionZero;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !m_position;}
	virtual bool isValueChanged() const override{return PositionSignedPriceInventoryRowValue::isValueChanged() || m_positionZero != !m_position;}
	virtual bool SetValue(const ValueType& value) override
	{
		bool ret = PositionSignedPriceInventoryRowValue::SetValue(value);
		if(m_positionZero != !m_position)
		{
			m_positionZero = !m_position;
			ret = true;
		}
		return ret;
	}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{PositionSignedPriceInventoryRowValue::InitializeValue(); m_positionZero = !m_position;}
	bool m_positionZero;
};

class TGUI_API PositionMoneyRowValue : public MoneyRowValue
{
public:
	typedef const ValueType& (PositionData::*MoneyFunction)() const;
	PositionMoneyRowValue(const PositionData* position, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_position(position),
		m_moneyFunction(moneyFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_position->*m_moneyFunction)();}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	const PositionData* m_position;
	MoneyFunction m_moneyFunction;
};

class TGUI_API PositionMoneyVRowValue : public MoneyRowValue
{
public:
	typedef ValueType (PositionData::*MoneyFunction)() const;
	PositionMoneyVRowValue(const PositionData* const& position,
		const bool* comma,
		const unsigned char* decDigits,
		const bool* truncate,
		MoneyFunction moneyFunction,
		bool useEmptyValue = true,
		bool useNeutralColor = false,
		bool useTick = true):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_position(position),
		m_moneyFunction(moneyFunction)
		{}
//	virtual const unsigned int& GetObjectValue() const override{return (m_account->*m_uintFunction)();}
	virtual bool isValueChanged() const override{return m_value != (m_position->*m_moneyFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_position->*m_moneyFunction)());}
	virtual bool UpdateValue() override{return SetValue((m_position->*m_moneyFunction)());}
//	virtual bool isObjectValueEmpty() const;//{return m_useEmptyValue && (m_position->*m_moneyFunction)() == m_emptyValue;}
	virtual bool isObjectValueZero() const override{return !(m_position->*m_moneyFunction)();}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_position->*m_moneyFunction)();}
	const PositionData* m_position;
	MoneyFunction m_moneyFunction;
};

class TGUI_API PositionMoneyVRowValueNull : public PositionMoneyVRowValue
{
public:
	PositionMoneyVRowValueNull(const PositionData* position, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, bool useEmptyValue = false, bool useNeutralColor = false, bool useTick = true):
		PositionMoneyVRowValue(position, comma, decDigits, truncate, moneyFunction, useEmptyValue, useNeutralColor, useTick),
		m_positionZero(!m_position)
		{}
//	virtual const Money& GetObjectValue() const override{return m_position ? (m_position->*m_moneyFunction)() : zero;}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(m_position ? (m_position->*m_moneyFunction)() : zero);}
	virtual bool UpdateValue() override{return SetValue(m_position ? (m_position->*m_moneyFunction)() : zero);}
	virtual bool isObjectValueZero() const override{return !m_position || (m_position->*m_moneyFunction)().isZero();}
	virtual bool isValueEmpty() const override{return m_useEmptyValue && m_positionZero;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !m_position;}
	virtual bool isValueChanged() const override{return m_positionZero != !m_position || (m_positionZero ? !m_value.isZero() : PositionMoneyVRowValue::isValueChanged());}
	virtual bool SetValue(const ValueType& value) override
	{
		bool ret = PositionMoneyVRowValue::SetValue(value);
		if(m_positionZero != !m_position)
		{
			m_positionZero = !m_position;
			ret = true;
		}
		return ret;
	}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_positionZero = !m_position;
		m_value = m_positionZero ? zero : (m_position->*m_moneyFunction)();
//		if(m_positionZero)m_value = zero;
//		else PositionMoneyInventoryVRowValue::InitializeValue();
	}
	bool m_positionZero;
};

class TGUI_API PositionMoneyInInventoryRowValue : public PositionMoneyRowValue
{
public:
	PositionMoneyInInventoryRowValue(const PositionData* const& position,
		const bool* const& comma,
		const unsigned char* const& decDigits,
		const bool* const& truncate,
		const MoneyFunction& moneyFunction,
		const bool& useEmptyValue = true,
		const bool& useNeutralColor = false,
		const bool& useTick = true):
		PositionMoneyRowValue(position, comma, decDigits, truncate, moneyFunction, useEmptyValue, useNeutralColor, useTick),
		m_hasInventory(false)
	{}

	virtual bool isValueEmpty() const override{return m_useEmptyValue && !m_hasInventory;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !m_position->hasInventory();}
	virtual bool isValueChanged() const override{return PositionMoneyRowValue::isValueChanged() || m_hasInventory != m_position->hasInventory();}
	virtual bool SetValue(const ValueType& value) override
	{
		bool ret = PositionMoneyRowValue::SetValue(value);
		if(m_hasInventory != m_position->hasInventory())
		{
			m_hasInventory = !m_hasInventory;
			ret = true;
		}
		return ret;
	}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{PositionMoneyRowValue::InitializeValue(); m_hasInventory = m_position->hasInventory();}
	bool m_hasInventory;
};

class TGUI_API PositionMoneyInventoryRowValue : public MoneyRowValue
{
public:
	typedef const ValueType& (PositionData::*MoneyFunction)(const bool& inventoryView) const;
	PositionMoneyInventoryRowValue(const PositionData* const& position,
		const bool& inventoryView,
		const bool* const& comma,
		const unsigned char* const& decDigits,
		const bool* const& truncate,
		const MoneyFunction& moneyFunction,
		const bool& useEmptyValue = true,
		const bool& useNeutralColor = false,
		const bool& useTick = true):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_position(position),
		m_moneyFunction(moneyFunction),
		m_inventoryView(inventoryView)
		{}
	virtual const ValueType& GetObjectValue() const override{return (m_position->*m_moneyFunction)(m_inventoryView);}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	const PositionData* m_position;
	MoneyFunction m_moneyFunction;
	const bool& m_inventoryView;
};

class TGUI_API PositionMoneyInventoryPositiveRowValue : public PositionMoneyInventoryRowValue
{
public:
	PositionMoneyInventoryPositiveRowValue(const PositionData* position, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		PositionMoneyInventoryRowValue(position, inventoryView, comma, decDigits, truncate, moneyFunction, useEmptyValue, useNeutralColor, useTick)
		{}
	virtual bool CanBeNegative() const override{return false;}
	DECLARE_NED_NEW
};

class TGUI_API PositionMoneyInventoryVRowValue : public MoneyRowValue
{
public:
	typedef ValueType (PositionData::*MoneyFunction)(const bool& inventoryView) const;
	PositionMoneyInventoryVRowValue(const PositionData* position, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_position(position),
		m_moneyFunction(moneyFunction),
		m_inventoryView(inventoryView)
		{}
	virtual bool isValueChanged() const override{return m_value != (m_position->*m_moneyFunction)(m_inventoryView);}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_position->*m_moneyFunction)(m_inventoryView));}
	virtual bool UpdateValue() override{return SetValue((m_position->*m_moneyFunction)(m_inventoryView));}
	virtual bool isObjectValueZero() const override{return !(m_position->*m_moneyFunction)(m_inventoryView);}// == m_emptyValue;}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_position->*m_moneyFunction)(m_inventoryView);}
	const PositionData* m_position;
	MoneyFunction m_moneyFunction;
	const bool& m_inventoryView;
};

class TGUI_API PositionMoneyInventoryPositiveVRowValue : public PositionMoneyInventoryVRowValue
{
public:
	PositionMoneyInventoryPositiveVRowValue(const PositionData* position, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		PositionMoneyInventoryVRowValue(position, inventoryView, comma, decDigits, truncate, moneyFunction, useEmptyValue, useNeutralColor, useTick)
		{}
	virtual bool CanBeNegative() const override{return false;}
	DECLARE_NED_NEW
};

class TGUI_API PositionMoneyRowValueNull : public PositionMoneyRowValue
{
public:
	PositionMoneyRowValueNull(const PositionData* position, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, bool useEmptyValue = false, bool useNeutralColor = false, bool useTick = true):
		PositionMoneyRowValue(position, comma, decDigits, truncate, moneyFunction, useEmptyValue, useNeutralColor, useTick),
		m_positionZero(!m_position)
		{}
	virtual const Money& GetObjectValue() const override{return m_position ? (m_position->*m_moneyFunction)() : zero;}
	virtual bool isValueEmpty() const override{return m_useEmptyValue && m_positionZero;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !m_position;}
	virtual bool isValueChanged() const override{return PositionMoneyRowValue::isValueChanged() || m_positionZero != !m_position;}
	virtual bool SetValue(const ValueType& value) override
	{
		bool ret = PositionMoneyRowValue::SetValue(value);
		if(m_positionZero != !m_position)
		{
			m_positionZero = !m_position;
			ret = true;
		}
		return ret;
	}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{PositionMoneyRowValue::InitializeValue(); m_positionZero = !m_position;}
	bool m_positionZero;
};

class TGUI_API PositionMoneyInventoryRowValueNull : public PositionMoneyInventoryRowValue
{
public:
	PositionMoneyInventoryRowValueNull(const PositionData* position, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, bool useEmptyValue = false, bool useNeutralColor = false, bool useTick = true):
		PositionMoneyInventoryRowValue(position, inventoryView, comma, decDigits, truncate, moneyFunction, useEmptyValue, useNeutralColor, useTick),
		m_positionZero(!m_position)
		{}
	virtual const Money& GetObjectValue() const override{return m_position ? (m_position->*m_moneyFunction)(m_inventoryView) : zero;}
	virtual bool isValueEmpty() const override{return m_useEmptyValue && m_positionZero;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !m_position;}
	virtual bool isValueChanged() const override{return PositionMoneyInventoryRowValue::isValueChanged() || m_positionZero != !m_position;}
	virtual bool SetValue(const ValueType& value) override
	{
		bool ret = PositionMoneyInventoryRowValue::SetValue(value);
		if(m_positionZero != !m_position)
		{
			m_positionZero = !m_position;
			ret = true;
		}
		return ret;
	}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{PositionMoneyInventoryRowValue::InitializeValue(); m_positionZero = !m_position;}
	bool m_positionZero;
};

class TGUI_API PositionMoneyInventoryVRowValueNull : public PositionMoneyInventoryVRowValue
{
public:
	PositionMoneyInventoryVRowValueNull(const PositionData* position, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, bool useEmptyValue = false, bool useNeutralColor = false, bool useTick = true):
		PositionMoneyInventoryVRowValue(position, inventoryView, comma, decDigits, truncate, moneyFunction, useEmptyValue, useNeutralColor, useTick),
		m_positionZero(!m_position)
		{}
//	virtual const Money& GetObjectValue() const override{return m_position ? (m_position->*m_moneyFunction)(m_inventoryView) : zero;}

	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(m_position ? (m_position->*m_moneyFunction)(m_inventoryView) : zero);}
	virtual bool UpdateValue() override{return SetValue(m_position ? (m_position->*m_moneyFunction)(m_inventoryView) : zero);}
	virtual bool isObjectValueZero() const override{return !m_position || (m_position->*m_moneyFunction)(m_inventoryView).isZero();}//{return m_useEmptyValue && (!m_position || (m_position->*m_uintFunction)() == m_emptyValue);}
	virtual bool isValueEmpty() const override{return m_useEmptyValue && m_positionZero;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !m_position;}
	virtual bool isValueChanged() const override{return m_positionZero != !m_position || (m_positionZero ? !m_value.isZero() : PositionMoneyInventoryVRowValue::isValueChanged());}
	virtual bool SetValue(const ValueType& value) override
	{
		bool ret = PositionMoneyInventoryVRowValue::SetValue(value);
		if(m_positionZero != !m_position)
		{
			m_positionZero = !m_position;
			ret = true;
		}
		return ret;
	}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_positionZero = !m_position;
		m_value = m_positionZero ? zero : (m_position->*m_moneyFunction)(m_inventoryView);
//		if(m_positionZero)m_value = zero;
//		else PositionMoneyInventoryVRowValue::InitializeValue();
	}
	bool m_positionZero;
};

class TGUI_API PositionUIntVRowValue : public UIntRowValue
{
public:
	typedef ValueType (PositionData::*UIntFunction)() const;
	PositionUIntVRowValue(const PositionData* position, const bool* comma, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true):
		UIntRowValue(comma, useEmptyValue, useTick), m_position(position),m_uintFunction(uintFunction){}
//	virtual const unsigned int& GetObjectValue() const override{return (m_position->*m_uintFunction)();}
	virtual bool isValueChanged() const override{return m_value != (m_position->*m_uintFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_position->*m_uintFunction)());}
	virtual bool UpdateValue() override{return SetValue((m_position->*m_uintFunction)());}
	virtual bool isObjectValueZero() const override{return !(m_position->*m_uintFunction)();}//{return m_useEmptyValue && (m_position->*m_uintFunction)() == m_emptyValue;}
	virtual void SetPosition(const PositionData* position) override{m_position = position;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_position->*m_uintFunction)();}
	const PositionData* m_position;
	UIntFunction m_uintFunction;
};

class TGUI_API PositionUIntVRowValueNull : public PositionUIntVRowValue
{
public:
	PositionUIntVRowValueNull(const PositionData* position, const bool* comma, UIntFunction uintFunction, bool useEmptyValue = false, bool useTick = true):
		PositionUIntVRowValue(position, comma, uintFunction, useEmptyValue, useTick),
		m_positionZero(!m_position)
		{}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(m_position ? (m_position->*m_uintFunction)() : zero);}
	virtual bool UpdateValue() override{return SetValue(m_position ? (m_position->*m_uintFunction)() : zero);}
	virtual bool isObjectValueZero() const override{return !m_position || !(m_position->*m_uintFunction)();}//{return m_useEmptyValue && (!m_position || (m_position->*m_uintFunction)() == m_emptyValue);}
//	virtual bool isValueZero() const override{return m_positionZero || !m_value;}
	virtual bool isValueEmpty() const override{return m_useEmptyValue && m_positionZero;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !m_position;}
	virtual bool isValueChanged() const override{return m_value != (m_position ? (m_position->*m_uintFunction)() : zero) || m_positionZero != !m_position;}
	virtual bool SetValue(const ValueType& value) override
	{
		bool ret = PositionUIntVRowValue::SetValue(value);
		if(m_positionZero != !m_position)
		{
			m_positionZero = !m_position;
			ret = true;
		}
		return ret;
	}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_positionZero = !m_position;
		m_value = m_positionZero ? zero : (m_position->*m_uintFunction)();
	}
	bool m_positionZero;
};

///
class TGUI_API PositionMoneyPerShareRowValue : public PositionMoneyRowValue
{
public:
	typedef const unsigned int& (PositionData::*UIntFunction)() const;
	PositionMoneyPerShareRowValue(const PositionData* position, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, UIntFunction uintFunction, unsigned int multiplier, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		PositionMoneyRowValue(position, comma, decDigits, truncate, moneyFunction, useEmptyValue, useNeutralColor, useTick),
		m_uintFunction(uintFunction),
		m_shares(0),
		m_multiplier(multiplier)
	{
	}
	void DeriveValue(ValueType& value, const ValueType& money, const unsigned int& shares) const
	{
		if(shares)value = money * m_multiplier / shares;
		else value.SetZero();
	}
//	virtual const Money& GetObjectValue() const override{return (m_position->*m_moneyFunction)();}
	virtual bool isValueChanged() const override;//{return m_value != (m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)();}
	virtual short CompareAhead(const RowValue& other) const override;//{Money value = (m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)();return -((const TypedRowValue&)other).CompareValue(value);}
	virtual bool UpdateValue() override;//{return SetValue((m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)());}
	virtual bool isObjectValueZero() const override;//{return m_useEmptyValue && (m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)() == m_emptyValue;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override;
	UIntFunction m_uintFunction;
	ValueType m_money;
	unsigned int m_shares;
	unsigned int m_multiplier;
};

class TGUI_API PositionMoneyPerShareInventoryRowValue : public PositionMoneyInventoryVRowValue
{
public:
	typedef const unsigned int& (PositionData::*UIntFunction)() const;
	PositionMoneyPerShareInventoryRowValue(const PositionData* position, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, UIntFunction uintFunction, unsigned int multiplier, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		PositionMoneyInventoryVRowValue(position, inventoryView, comma, decDigits, truncate, moneyFunction, useEmptyValue, useNeutralColor, useTick),
		m_uintFunction(uintFunction),
		m_shares(0),
		m_multiplier(multiplier)
	{
	}
	void DeriveValue(ValueType& value, const ValueType& money, const unsigned int& shares) const
	{
		if(shares)value = money * m_multiplier / shares;
		else value.SetZero();
	}
	virtual bool isValueChanged() const override{return m_money != (m_position->*m_moneyFunction)(m_inventoryView) || m_shares != (m_position->*m_uintFunction)();}
	virtual short CompareAhead(const RowValue& other) const override//{Money value = (m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)();return -((const TypedRowValue&)other).CompareValue(value);}
	{
		Money value;
		DeriveValue(value, (m_position->*m_moneyFunction)(m_inventoryView), (m_position->*m_uintFunction)());
		return -((const TypedRowValue&)other).CompareValue(value);
	}
	virtual bool UpdateValue() override//{return SetValue((m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)());}
	{
		m_money = (m_position->*m_moneyFunction)(m_inventoryView);
		m_shares = (m_position->*m_uintFunction)();

		Money value;
		DeriveValue(value, m_money, m_shares);
		return SetValue(value);
	}
	virtual bool isObjectValueZero() const override{return (m_position->*m_moneyFunction)(m_inventoryView).isZero() || !(m_position->*m_uintFunction)();}//{return m_useEmptyValue && (m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)() == m_emptyValue;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_money = (m_position->*m_moneyFunction)(m_inventoryView);
		m_shares = (m_position->*m_uintFunction)();
		DeriveValue(m_value, m_money, m_shares);
	}
	UIntFunction m_uintFunction;
	ValueType m_money;
	unsigned int m_shares;
	unsigned int m_multiplier;
};
/*
///
class TGUI_API PositionMoneyWholePercentInventoryRowValue : public PositionMoneyInventoryRowValue
{
public:
//	typedef const ValueType& (PositionData::*MoneyFunction)(const bool& inventoryView) const;
	typedef const unsigned char& (PositionData::*PercentFunction)() const;
	PositionMoneyWholePercentInventoryRowValue(const PositionData* position, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, PercentFunction percentFunction, bool useEmptyValue = true, bool useNeutralColor = true, bool useTick = false):
		PositionMoneyInventoryRowValue(position, inventoryView, comma, decDigits, truncate, moneyFunction, useEmptyValue, useNeutralColor, useTick),
		m_percentFunction(percentFunction)
	{
	}
	virtual bool CanBeNegative() const override{return false;}
	void DeriveValue(ValueType& value, const ValueType& money, const unsigned char& percent) const
	{
		value = money;// *percent / 100;
		if(percent != 100)
		{
			value *= percent;
			value /= 100;
		}
	}
	virtual bool isValueChanged() const override{return m_money != (m_position->*m_moneyFunction)(m_inventoryView) || m_percent != (m_position->*m_percentFunction)();}
	virtual short CompareAhead(const RowValue& other) const override//{Money value = (m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)();return -((const TypedRowValue&)other).CompareValue(value);}
	{
		Money value;
		DeriveValue(value, (m_position->*m_moneyFunction)(m_inventoryView), (m_position->*m_percentFunction)());
		return -((const TypedRowValue&)other).CompareValue(value);
	}
	virtual bool UpdateValue() override//{return SetValue((m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)());}
	{
		m_money = (m_position->*m_moneyFunction)(m_inventoryView);
		m_percent = (m_position->*m_percentFunction)();

		Money value;
		DeriveValue(value, m_money, m_percent);
		return SetValue(value);
	}
	virtual bool isObjectValueZero() const override{return (m_position->*m_moneyFunction)(m_inventoryView).isZero() || !(m_position->*m_percentFunction)();}//{return m_useEmptyValue && (m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)() == m_emptyValue;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_money = (m_position->*m_moneyFunction)(m_inventoryView);
		m_percent = (m_position->*m_percentFunction)();
		DeriveValue(m_value, m_money, m_percent);
	}
	MoneyFunction m_moneyFunction;
	PercentFunction m_percentFunction;
	ValueType m_money;
	unsigned char m_percent;
};
*/

class TGUI_API PositionMoneyRowValue2 : public PositionMoneyRowValue
{
public:
	PositionMoneyRowValue2(const PositionData* position, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, MoneyFunction moneyFunction2, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		PositionMoneyRowValue(position, comma, decDigits, truncate, moneyFunction, useEmptyValue, useNeutralColor, useTick),
		m_moneyFunction2(moneyFunction2)
	{
	}
//	virtual const Money& GetObjectValue() const override{return (m_position->*m_moneyFunction)();}
	virtual bool isValueChanged() const override{return m_value != (m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)());}
	virtual bool UpdateValue() override{return SetValue((m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)());}
	virtual bool isObjectValueZero() const override { return ((m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)()).isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)();}
	MoneyFunction m_moneyFunction2;
};

class TGUI_API PositionMoneyInventoryRowValue2 : public PositionMoneyInventoryRowValue
{
public:
	PositionMoneyInventoryRowValue2(const PositionData* position, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, MoneyFunction moneyFunction2, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		PositionMoneyInventoryRowValue(position, inventoryView, comma, decDigits, truncate, moneyFunction, useEmptyValue, useNeutralColor, useTick),
		m_moneyFunction2(moneyFunction2)
	{
	}
//	virtual const Money& GetObjectValue() const override{return (m_position->*m_moneyFunction)();}
	virtual bool isValueChanged() const override{return m_value != (m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView);}
	virtual short CompareAhead(const RowValue& other) const override
	{
		Money value = (m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView);
		return -((const TypedRowValue&)other).CompareValue(value);
	}
	virtual bool UpdateValue() override{return SetValue((m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView));}
	virtual bool isObjectValueZero() const override{return ((m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView)).isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView);}
	MoneyFunction m_moneyFunction2;
};

class TGUI_API PositionMoneyRowValue3Minus : public PositionMoneyRowValue2
{
public:
	PositionMoneyRowValue3Minus(const PositionData* position, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, MoneyFunction moneyFunction2, MoneyFunction moneyFunction3, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		PositionMoneyRowValue2(position, comma, decDigits, truncate, moneyFunction, moneyFunction2, useEmptyValue, useNeutralColor, useTick),
		m_moneyFunction3(moneyFunction3)
	{
	}
	virtual bool isValueChanged() const override{return m_value != (m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)() - (m_position->*m_moneyFunction3)();}
	virtual short CompareAhead(const RowValue& other) const override
	{
		Money value = (m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)() - (m_position->*m_moneyFunction3)();
		return -((const TypedRowValue&)other).CompareValue(value);
	}
	virtual bool UpdateValue() override{return SetValue((m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)() - (m_position->*m_moneyFunction3)());}
	virtual bool isObjectValueZero() const override{return (m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)() == (m_position->*m_moneyFunction3)();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)() - (m_position->*m_moneyFunction3)();}
	MoneyFunction m_moneyFunction3;
};

class TGUI_API PositionMoneyInventoryRowValue3Minus : public PositionMoneyInventoryRowValue2
{
public:
	PositionMoneyInventoryRowValue3Minus(const PositionData* position, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, MoneyFunction moneyFunction2, MoneyFunction moneyFunction3, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		PositionMoneyInventoryRowValue2(position, inventoryView, comma, decDigits, truncate, moneyFunction, moneyFunction2, useEmptyValue, useNeutralColor, useTick),
		m_moneyFunction3(moneyFunction3)
	{
	}
	virtual bool isValueChanged() const override{return m_value != (m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView) - (m_position->*m_moneyFunction3)(m_inventoryView);}
	virtual short CompareAhead(const RowValue& other) const override
	{
		Money value = (m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView) - (m_position->*m_moneyFunction3)(m_inventoryView);
		return -((const TypedRowValue&)other).CompareValue(value);
	}
	virtual bool UpdateValue() override{return SetValue((m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView) - (m_position->*m_moneyFunction3)(m_inventoryView));}
	virtual bool isObjectValueZero() const override{return (m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView) == (m_position->*m_moneyFunction3)(m_inventoryView);}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView) - (m_position->*m_moneyFunction3)(m_inventoryView);}
	MoneyFunction m_moneyFunction3;
};

class TGUI_API PositionMoneyRowValue2Null : public PositionMoneyRowValue2
{
public:
	PositionMoneyRowValue2Null(const PositionData* position, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, MoneyFunction moneyFunction2, bool useEmptyValue = false, bool useNeutralColor = false, bool useTick = true):
		PositionMoneyRowValue2(position, comma, decDigits, truncate, moneyFunction, moneyFunction2, useEmptyValue, useNeutralColor, useTick),
		m_positionZero(!m_position)
		{}
//	virtual const Money& GetObjectValue() const override{return m_position ? (m_position->*m_moneyFunction)() : zero;}
//	virtual bool isValueChanged() const;//{return m_value != (m_position ? (m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)() : zero);}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(m_position ? (m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)() : zero);}
	virtual bool UpdateValue() override{return SetValue(m_position ? (m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)() : zero);}
	virtual bool isObjectValueZero() const override{return !m_position || ((m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)()).isZero();}//{return m_useEmptyValue && (!m_position || (m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)() == m_emptyValue);}
	virtual bool isValueEmpty() const override{return m_useEmptyValue && m_positionZero;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !m_position;}
	virtual bool isValueChanged() const override{return m_value != (m_position ? (m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)() : zero) || m_positionZero != !m_position;}
	virtual bool SetValue(const ValueType& value) override
	{
		bool ret = PositionMoneyRowValue2::SetValue(value);
		if(m_positionZero != !m_position)
		{
			m_positionZero = !m_position;
			ret = true;
		}
		return ret;
	}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_value = m_position ? (m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)() : zero;
		m_positionZero = !m_position;
	}
	bool m_positionZero;
};

class TGUI_API PositionMoneyInventoryRowValue2Null : public PositionMoneyInventoryRowValue2
{
public:
	PositionMoneyInventoryRowValue2Null(const PositionData* position, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, MoneyFunction moneyFunction2, bool useEmptyValue = false, bool useNeutralColor = false, bool useTick = true):
		PositionMoneyInventoryRowValue2(position, inventoryView, comma, decDigits, truncate, moneyFunction, moneyFunction2, useEmptyValue, useNeutralColor, useTick),
		m_positionZero(!m_position)
		{}
//	virtual const Money& GetObjectValue() const override{return m_position ? (m_position->*m_moneyFunction)() : zero;}
//	virtual bool isValueChanged() const;//{return m_value != (m_position ? (m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)() : zero);}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(m_position ? (m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView) : zero);}
	virtual bool UpdateValue() override{return SetValue(m_position ? (m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView) : zero);}
	virtual bool isObjectValueZero() const override{return !m_position || ((m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView)).isZero();}//{return m_useEmptyValue && (!m_position || (m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)() == m_emptyValue);}
	virtual bool isValueEmpty() const override{return m_useEmptyValue && m_positionZero;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !m_position;}
	virtual bool isValueChanged() const override{return m_value != (m_position ? (m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView) : zero) || m_positionZero != !m_position;}
	virtual bool SetValue(const ValueType& value) override
	{
		bool ret = PositionMoneyInventoryRowValue2::SetValue(value);
		if(m_positionZero != !m_position)
		{
			m_positionZero = !m_position;
			ret = true;
		}
		return ret;
	}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_value = m_position ? (m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView) : zero;
		m_positionZero = !m_position;
	}
	bool m_positionZero;
};

class TGUI_API PositionMoneyInventoryVRowValue2 : public PositionMoneyInventoryVRowValue
{
public:
	PositionMoneyInventoryVRowValue2(const PositionData* position, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, MoneyFunction moneyFunction2, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		PositionMoneyInventoryVRowValue(position, inventoryView, comma, decDigits, truncate, moneyFunction, useEmptyValue, useNeutralColor, useTick),
		m_moneyFunction2(moneyFunction2)
	{
	}
	virtual bool isValueChanged() const override{return m_value != (m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView);}
	virtual short CompareAhead(const RowValue& other) const override
	{
		Money value = (m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView);
		return -((const TypedRowValue&)other).CompareValue(value);
	}
	virtual bool UpdateValue() override{return SetValue((m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView));}
	virtual bool isObjectValueZero() const override{return ((m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView)).isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView);}
	MoneyFunction m_moneyFunction2;
};

class TGUI_API PositionMoneyInventoryVRowValue3Minus : public PositionMoneyInventoryVRowValue2
{
public:
	PositionMoneyInventoryVRowValue3Minus(const PositionData* position, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, MoneyFunction moneyFunction2, MoneyFunction moneyFunction3, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		PositionMoneyInventoryVRowValue2(position, inventoryView, comma, decDigits, truncate, moneyFunction, moneyFunction2, useEmptyValue, useNeutralColor, useTick),
		m_moneyFunction3(moneyFunction3)
	{
	}
	virtual bool isValueChanged() const override{return m_value != (m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView) - (m_position->*m_moneyFunction3)(m_inventoryView);}
	virtual short CompareAhead(const RowValue& other) const override
	{
		Money value = (m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView) - (m_position->*m_moneyFunction3)(m_inventoryView);
		return -((const TypedRowValue&)other).CompareValue(value);
	}
	virtual bool UpdateValue() override{return SetValue((m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView) - (m_position->*m_moneyFunction3)(m_inventoryView));}
	virtual bool isObjectValueZero() const override{return (m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView) == (m_position->*m_moneyFunction3)(m_inventoryView);}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView) - (m_position->*m_moneyFunction3)(m_inventoryView);}
	MoneyFunction m_moneyFunction3;
};

class TGUI_API PositionMoneyInventoryVRowValue2Null : public PositionMoneyInventoryVRowValue2
{
public:
	PositionMoneyInventoryVRowValue2Null(const PositionData* position, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, MoneyFunction moneyFunction2, bool useEmptyValue = false, bool useNeutralColor = false, bool useTick = true):
		PositionMoneyInventoryVRowValue2(position, inventoryView, comma, decDigits, truncate, moneyFunction, moneyFunction2, useEmptyValue, useNeutralColor, useTick),
		m_positionZero(!m_position)
		{}
//	virtual const Money& GetObjectValue() const override{return m_position ? (m_position->*m_moneyFunction)() : zero;}
//	virtual bool isValueChanged() const;//{return m_value != (m_position ? (m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)() : zero);}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(m_position ? (m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView) : zero);}
	virtual bool UpdateValue() override{return SetValue(m_position ? (m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView) : zero);}
	virtual bool isObjectValueZero() const override{return !m_position || ((m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView)).isZero();}//{return m_useEmptyValue && (!m_position || (m_position->*m_moneyFunction)() + (m_position->*m_moneyFunction2)() == m_emptyValue);}
	virtual bool isValueEmpty() const override{return m_useEmptyValue && m_positionZero;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !m_position;}
	virtual bool isValueChanged() const override{return m_value != (m_position ? (m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView) : zero) || m_positionZero != !m_position;}
	virtual bool SetValue(const ValueType& value) override
	{
		bool ret = PositionMoneyInventoryVRowValue2::SetValue(value);
		if(m_positionZero != !m_position)
		{
			m_positionZero = !m_position;
			ret = true;
		}
		return ret;
	}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_value = m_position ? (m_position->*m_moneyFunction)(m_inventoryView) + (m_position->*m_moneyFunction2)(m_inventoryView) : zero;
		m_positionZero = !m_position;
	}
	bool m_positionZero;
};


////
class TGUI_API AlertStringRowValue : public StringRowValue
{
public:
	typedef const ValueType& (Alert::*StringFunction)() const;
	AlertStringRowValue(const Alert* alert, StringFunction stringFunction):m_alert(alert),m_stringFunction(stringFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_alert->*m_stringFunction)();}
	DECLARE_NED_NEW
protected:
	const Alert* m_alert;
	StringFunction m_stringFunction;
};

class TGUI_API AlertDateRowValue : public DateRowValue
{
public:
	typedef const ValueType& (Alert::*UIntFunction)() const;
	AlertDateRowValue(const Alert* alert, UIntFunction uintFunction):
		m_alert(alert),
		m_uintFunction(uintFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_alert->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	const Alert* m_alert;
	UIntFunction m_uintFunction;
};

class TGUI_API AlertTimeRowValue : public TimeRowValue
{
public:
	typedef const ValueType& (Alert::*UIntFunction)() const;
	AlertTimeRowValue(const Alert* alert, const bool* showMilliseconds, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = false):
		TimeRowValue(showMilliseconds, useEmptyValue, useTick),
		m_alert(alert),
		m_uintFunction(uintFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_alert->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	const Alert* m_alert;
	UIntFunction m_uintFunction;
};

class TGUI_API AlertBoolRowValue : public BoolRowValue
{
public:
	typedef const ValueType& (Alert::*BoolFunction)() const;
	AlertBoolRowValue(const Alert* alert, BoolFunction boolFunction, char trueValue = 'Y', char falseValue = '\0'):
		BoolRowValue(trueValue, falseValue),
		m_alert(alert),
		m_boolFunction(boolFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_alert->*m_boolFunction)();}
	DECLARE_NED_NEW
protected:
	const Alert* m_alert;
	BoolFunction m_boolFunction;
};

class TGUI_API AlertPriceRowValue : public PriceRowValue
{
public:
	typedef const ValueType& (Alert::*PriceFunction)() const;
	AlertPriceRowValue(const Alert* alert, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = false):
		PriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_alert(alert),
		m_priceFunction(priceFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_alert->*m_priceFunction)();}
	virtual void toString(std::string& text) const override
	{
		if(!isValueEmpty())
		{
			if(m_alert->GetAlertType() == AT_BORROW_SIZE_AVAILABLE)text += 'c';
			U_PriceToStr(text, m_value, *m_decDigits, 0, *m_comma, '\0', *m_truncate);
		}
	}
	DECLARE_NED_NEW
protected:
	const Alert* m_alert;
	PriceFunction m_priceFunction;
};

class TGUI_API AlertCompactPriceRowValue : public CompactPriceRowValue
{
public:
	typedef const ValueType& (Alert::*PriceFunction)() const;
	AlertCompactPriceRowValue(const Alert* alert, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = false):
		CompactPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_alert(alert),
		m_priceFunction(priceFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_alert->*m_priceFunction)();}
	DECLARE_NED_NEW
protected:
	const Alert* m_alert;
	PriceFunction m_priceFunction;
};

class TGUI_API AlertSignedPriceRowValue : public SignedPriceRowValue
{
public:
	typedef const ValueType& (Alert::*PriceFunction)() const;
	AlertSignedPriceRowValue(const Alert* alert, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = false, bool useNeutralColor = false):
		SignedPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick, useNeutralColor),
		m_alert(alert),
		m_priceFunction(priceFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_alert->*m_priceFunction)();}
	DECLARE_NED_NEW
protected:
	const Alert* m_alert;
	PriceFunction m_priceFunction;
};

class TGUI_API AlertUInt64RowValue : public UInt64RowValue
{
public:
	typedef const ValueType& (Alert::*UInt64Function)() const;
	AlertUInt64RowValue(const Alert* alert, const bool* comma, UInt64Function uint64Function, bool useEmptyValue = true, bool useTick = false):
		UInt64RowValue(comma, useEmptyValue, useTick),
		m_alert(alert),
		m_uint64Function(uint64Function){}
	virtual const ValueType& GetObjectValue() const override{return (m_alert->*m_uint64Function)();}
	DECLARE_NED_NEW
protected:
	const Alert* m_alert;
	UInt64Function m_uint64Function;
};

class TGUI_API AlertUIntRowValue : public UIntRowValue
{
public:
	typedef const ValueType& (Alert::*UIntFunction)() const;
	AlertUIntRowValue(const Alert* alert, const bool* comma, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = false):
		UIntRowValue(comma, useEmptyValue, useTick),
		m_alert(alert),
		m_uintFunction(uintFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_alert->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	const Alert* m_alert;
	UIntFunction m_uintFunction;
};

class TGUI_API AlertIntRowValue : public IntRowValue
{
public:
	typedef const ValueType& (Alert::*IntFunction)() const;
	AlertIntRowValue(const Alert* alert, const bool* comma, IntFunction intFunction, bool useEmptyValue = true, bool useTick = false):
		IntRowValue(comma, useEmptyValue, useTick),
		m_alert(alert),
		m_intFunction(intFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_alert->*m_intFunction)();}
	DECLARE_NED_NEW
protected:
	const Alert* m_alert;
	IntFunction m_intFunction;
};

class TGUI_API AlertImbalanceRowValue : public AlertIntRowValue
{
public:
	AlertImbalanceRowValue(const Alert* alert, const bool* comma, IntFunction intFunction)://, bool useEmptyValue = true, bool useTick = false):
		AlertIntRowValue(alert, comma, intFunction, true, false)
	{
	}
	virtual bool isValueEmpty() const{return m_useEmptyValue && !m_alert->GetImbalancePtr();}
	virtual bool isObjectValueEmpty() const{return m_useEmptyValue && !m_alert->GetImbalancePtr();}
	DECLARE_NED_NEW
};

class TGUI_API AlertTypeRowValue : public UCharRowValue
{
public:
//	typedef AlertType (Alert::*AlertTypeFunction)() const;

	virtual void toString(std::string& text) const;
	AlertTypeRowValue(const Alert* alert):UCharRowValue(0, false, false), m_alert(alert){}
//	virtual const unsigned char& GetObjectValue() const override{return (m_alert->*m_ucharFunction)();}
//	virtual UINT GetHorizontalJustification() const{return DT_LEFT;}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(m_alert->GetAlertType());}
	virtual bool isValueChanged() const override{return m_value != m_alert->GetAlertType();}
	virtual bool UpdateValue() override{return SetValue(m_alert->GetAlertType());}
//	virtual bool isObjectValueEmpty() const{return false;}//m_useEmptyValue && GetObjectValue() == m_emptyValue;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = m_alert->GetAlertType();}
	const Alert* m_alert;
//	UCharFunction m_ucharFunction;
};

////
class TGUI_API SecurityStringRowValue : public StringRowValue
{
public:
	typedef const ValueType& (Security::*StringFunction)() const;
	SecurityStringRowValue(const Security* const& security, StringFunction stringFunction):m_security(security),m_stringFunction(stringFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_stringFunction)();}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	StringFunction m_stringFunction;
};

class TGUI_API SecurityIntRowValue : public IntRowValue
{
public:
	typedef const ValueType& (Security::*IntFunction)() const;
	SecurityIntRowValue(const Security* const& security, const bool* comma, IntFunction intFunction, bool useEmptyValue = false, bool useTick = true):
		IntRowValue(comma, useEmptyValue, useTick),
		m_security(security),
		m_intFunction(intFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_intFunction)();}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	IntFunction m_intFunction;
};

class TGUI_API SecurityIntAbsRowValue : public UIntAbsRowValue
{
public:
	typedef const SignedValueType& (Security::*IntFunction)() const;
	SecurityIntAbsRowValue(const Security* const& security, const bool* comma, IntFunction intFunction, bool useEmptyValue = false, bool useTick = true):
		UIntAbsRowValue(comma, useEmptyValue, useTick),
		m_security(security),
		m_intFunction(intFunction){}
//	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_intFunction)();}
	virtual const SignedValueType& GetObjectSignedValue() const override{return (m_security->*m_intFunction)();}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	IntFunction m_intFunction;
};

class TGUI_API SecurityUIntRefSubstituteRowValue : public UIntRowValue
{
public:
	typedef const ValueType& (Security::*UIntFunction)() const;
	SecurityUIntRefSubstituteRowValue(const Security* const& security, const bool* comma, const ValueType& uintRefSubstitute, const bool& applySubstitute, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true):
		UIntRowValue(comma, useEmptyValue, useTick),
		m_security(security),
		m_uintFunction(uintFunction),
		m_uintRefSubstitute(uintRefSubstitute),
		m_applySubstitute(applySubstitute){}
//	virtual const unsigned int& GetObjectValue() const override{return (m_security->*m_uintFunction)();}
	virtual bool isValueChanged() const override{return m_value != (m_uintRefSubstitute || !m_applySubstitute ? (int)m_uintRefSubstitute : (int)(m_security->*m_uintFunction)());}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(m_uintRefSubstitute || !m_applySubstitute ? (int)m_uintRefSubstitute : (int)(m_security->*m_uintFunction)());}
	virtual bool UpdateValue() override{return SetValue(m_uintRefSubstitute || !m_applySubstitute ? (int)m_uintRefSubstitute : (int)(m_security->*m_uintFunction)());}
	virtual bool isObjectValueZero() const override{return !(m_uintRefSubstitute || !m_applySubstitute ? (int)m_uintRefSubstitute : (int)(m_security->*m_uintFunction)());}
	virtual unsigned int GetUIntValue() const override{return m_uintRefSubstitute;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue(){m_value = m_uintRefSubstitute || !m_applySubstitute ? (int)m_uintRefSubstitute : (int)(m_security->*m_uintFunction)();}
	const Security* m_security;
	UIntFunction m_uintFunction;
	const unsigned int& m_uintRefSubstitute;
	const bool& m_applySubstitute;
};

class TGUI_API SecurityUIntRefSubstituteXIntRowValue : public IntRowValue
{
public:
	typedef const unsigned int& (Security::*UIntFunction)() const;
	SecurityUIntRefSubstituteXIntRowValue(const Security* security,
		const bool* comma,
		const int& intRefValue,
		const unsigned int& uintRefSubstitute,
		const bool& applySubstitute,
		UIntFunction uintFunction,
		bool useEmptyValue = true,
		bool useTick = true):
		IntRowValue(comma, useEmptyValue, useTick),
		m_security(security),
		m_uintFunction(uintFunction),
		m_intRefValue(intRefValue),
		m_uintRefSubstitute(uintRefSubstitute),
		m_applySubstitute(applySubstitute){}
//	virtual const unsigned int& GetObjectValue() const override{return (m_security->*m_uintFunction)();}
	virtual bool isValueChanged() const override{return m_value != m_intRefValue * (m_uintRefSubstitute || !m_applySubstitute ? (int)m_uintRefSubstitute : (int)(m_security->*m_uintFunction)());}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(m_intRefValue * (m_uintRefSubstitute || !m_applySubstitute ? (int)m_uintRefSubstitute : (int)(m_security->*m_uintFunction)()));}
	virtual bool UpdateValue() override{return SetValue(m_intRefValue * (m_uintRefSubstitute || !m_applySubstitute ? (int)m_uintRefSubstitute : (int)(m_security->*m_uintFunction)()));}
	virtual bool isObjectValueZero() const override{return !m_intRefValue || !(m_uintRefSubstitute || !m_applySubstitute ? (int)m_uintRefSubstitute : (int)(m_security->*m_uintFunction)());}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = m_intRefValue * (m_uintRefSubstitute || !m_applySubstitute ? (int)m_uintRefSubstitute : (int)(m_security->*m_uintFunction)());}
	const Security* m_security;
	UIntFunction m_uintFunction;
	const int& m_intRefValue;
	const unsigned int& m_uintRefSubstitute;
	const bool& m_applySubstitute;
};

class TGUI_API SecurityPriceXUIntRefSubstituteXIntRowValue : public MoneyRowValue
{
public:
	typedef const unsigned int& (Security::*UIntFunction)() const;
	SecurityPriceXUIntRefSubstituteXIntRowValue(const Security* security,
		const bool* comma,
		const unsigned char* decDigits,
		const bool* truncate,
		const int& intRefValue,
		const unsigned int& uintRefSubstitute,
		const bool& applySubstitute,
		UIntFunction priceFunction,
		UIntFunction uintFunction,
		bool useEmptyValue = true,
		bool useTick = true):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_security(security),
		m_priceFunction(priceFunction),
		m_uintFunction(uintFunction),
		m_intRefValue(intRefValue),
		m_uintRefSubstitute(uintRefSubstitute),
		m_applySubstitute(applySubstitute){}
	virtual bool isValueChanged() const override{return m_value != Price((m_security->*m_priceFunction)()) * ((unsigned int)(m_intRefValue > 0 ? m_intRefValue : -m_intRefValue) * (m_uintRefSubstitute || !m_applySubstitute ? m_uintRefSubstitute : (m_security->*m_uintFunction)()));}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(Price((m_security->*m_priceFunction)()) * ((unsigned int)(m_intRefValue > 0 ? m_intRefValue : -m_intRefValue) * (m_uintRefSubstitute || !m_applySubstitute ? m_uintRefSubstitute : (m_security->*m_uintFunction)())));}
	virtual bool UpdateValue() override{return SetValue(Price((m_security->*m_priceFunction)()) * ((unsigned int)(m_intRefValue > 0 ? m_intRefValue : -m_intRefValue) * (m_uintRefSubstitute || !m_applySubstitute ? m_uintRefSubstitute : (m_security->*m_uintFunction)())));}
	virtual bool isObjectValueZero() const override{return !m_intRefValue || !(m_security->*m_priceFunction)() || !(m_uintRefSubstitute || !m_applySubstitute ? m_uintRefSubstitute : (m_security->*m_uintFunction)());}
	virtual bool CanBeNegative() const override{return false;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = Price((m_security->*m_priceFunction)()) * ((unsigned int)(m_intRefValue > 0 ? m_intRefValue : -m_intRefValue) * (m_uintRefSubstitute || !m_applySubstitute ? m_uintRefSubstitute : (m_security->*m_uintFunction)()));}
	const Security* m_security;
	UIntFunction m_priceFunction;
	UIntFunction m_uintFunction;
	const int& m_intRefValue;
	const unsigned int& m_uintRefSubstitute;
	const bool& m_applySubstitute;
};

class TGUI_API SecurityPriceRefXUIntRefSubstituteXIntRowValue : public MoneyRowValue
{
public:
	typedef const unsigned int& (Security::*UIntFunction)() const;
	SecurityPriceRefXUIntRefSubstituteXIntRowValue(const Security* security,
		const bool* comma,
		const unsigned char* decDigits,
		const bool* truncate,
		const int& intRefValue,
		const unsigned int& uintRefSubstitute,
		const bool& applySubstitute,
		UIntFunction bidFunction,
		UIntFunction askFunction,
		const Price& limitPrice,
		UIntFunction uintFunction,
		bool useEmptyValue = true,
		bool useTick = true):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_security(security),
		m_bidFunction(bidFunction),
		m_askFunction(askFunction),
		m_limitPrice(limitPrice),
		m_uintFunction(uintFunction),
		m_intRefValue(intRefValue),
		m_uintRefSubstitute(uintRefSubstitute),
		m_applySubstitute(applySubstitute){}
	virtual bool isValueChanged() const override
	{
		const bool positive = m_intRefValue >= 0;
		return m_value != (m_limitPrice.isZero() ? Price(positive ? (m_security->*m_askFunction)() : (m_security->*m_bidFunction)()) : m_limitPrice)
			* ((unsigned int)(positive ? m_intRefValue : -m_intRefValue) * (m_uintRefSubstitute || !m_applySubstitute ? m_uintRefSubstitute : (m_security->*m_uintFunction)()));
	}
	virtual short CompareAhead(const RowValue& other) const override
	{
		const bool positive = m_intRefValue >= 0;
		return -((const TypedRowValue&)other).CompareValue((m_limitPrice.isZero() ? Price(positive ? (m_security->*m_askFunction)() : (m_security->*m_bidFunction)()) : m_limitPrice)
			* ((unsigned int)(positive ? m_intRefValue : -m_intRefValue) * (m_uintRefSubstitute || !m_applySubstitute ? m_uintRefSubstitute : (m_security->*m_uintFunction)())));
	}
	virtual bool UpdateValue() override
	{
		const bool positive = m_intRefValue >= 0;
		return SetValue((m_limitPrice.isZero() ? Price(positive ? (m_security->*m_askFunction)() : (m_security->*m_bidFunction)()) : m_limitPrice)
			* ((unsigned int)(positive ? m_intRefValue : -m_intRefValue) * (m_uintRefSubstitute || !m_applySubstitute ? m_uintRefSubstitute : (m_security->*m_uintFunction)())));
	}
	virtual bool isObjectValueZero() const override
	{
		const bool positive = m_intRefValue >= 0;
		return !m_intRefValue
			|| !(m_limitPrice.isZero() ? Price(positive ? (m_security->*m_askFunction)() : (m_security->*m_bidFunction)()) : m_limitPrice)
			|| !(m_uintRefSubstitute || !m_applySubstitute ? m_uintRefSubstitute : (m_security->*m_uintFunction)());
	}
	virtual bool CanBeNegative() const override{return false;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		const bool positive = m_intRefValue >= 0;
		m_value = (m_limitPrice.isZero() ? Price(positive ? (m_security->*m_askFunction)() : (m_security->*m_bidFunction)()) : m_limitPrice)
			* ((unsigned int)(positive ? m_intRefValue : -m_intRefValue) * (m_uintRefSubstitute || !m_applySubstitute ? m_uintRefSubstitute : (m_security->*m_uintFunction)()));
	}
	const Security* m_security;
	UIntFunction m_bidFunction;
	UIntFunction m_askFunction;
	Price m_limitPrice;
	UIntFunction m_uintFunction;
	const int& m_intRefValue;
	const unsigned int& m_uintRefSubstitute;
	const bool& m_applySubstitute;
};

class TGUI_API SecurityUIntRowValue : public UIntRowValue
{
public:
	typedef const ValueType& (Security::*UIntFunction)() const;
	SecurityUIntRowValue(const Security* const& security, const bool* comma, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true):
		UIntRowValue(comma, useEmptyValue, useTick),
		m_security(security),
		m_uintFunction(uintFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	UIntFunction m_uintFunction;
};

class TGUI_API SecurityUIntMinusOneEmptyRowValue : public SecurityUIntRowValue
{
public:
	typedef const ValueType& (Security::*UIntFunction)() const;
	SecurityUIntMinusOneEmptyRowValue(const Security* const& security, const bool* comma, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true):
		SecurityUIntRowValue(security, comma, uintFunction, useEmptyValue, useTick)
	{}
//	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_uintFunction)();}
//	virtual bool isValueEmpty() const override{return m_useEmptyValue && isValueZero();}
//	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && isObjectValueZero();}//GetObjectValue() == m_emptyValue;}
/*
	inline static bool isValueZeroStatic(const ValueType& value)
	{
		switch(value)
		{
			case 0:
			case 0xFFFFFFFF:
			return true;

			default:
			return false;
		}
	}
*/
	virtual bool isValueZero() const override{return m_value == 0xFFFFFFFF;}
	virtual bool isObjectValueZero() const override{return GetObjectValue() == 0xFFFFFFFF;}
	DECLARE_NED_NEW
};

class TGUI_API SecurityUIntRowValueNoComma : public UIntRowValueNoComma
{
public:
	typedef const ValueType& (Security::*UIntFunction)() const;
	SecurityUIntRowValueNoComma(const Security* const& security, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true) :
		UIntRowValueNoComma(useEmptyValue, useTick),
		m_security(security),
		m_uintFunction(uintFunction) {}
	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	UIntFunction m_uintFunction;
};

class TGUI_API SecurityUShortRowValue : public UShortRowValue
{
public:
	typedef const ValueType& (Security::*UShortFunction)() const;
	SecurityUShortRowValue(const Security* const& security, UShortFunction ushortFunction, bool useEmptyValue = true, bool useTick = true):
		UShortRowValue(useEmptyValue, useTick),
		m_security(security),
		m_ushortFunction(ushortFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_ushortFunction)();}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	UShortFunction m_ushortFunction;
};

class TGUI_API SecurityShortRowValue : public ShortRowValue
{
public:
	typedef const ValueType& (Security::*ShortFunction)() const;
	SecurityShortRowValue(const Security* const& security, ShortFunction shortFunction, bool useEmptyValue = true, bool useTick = true):
		ShortRowValue(useEmptyValue, useTick),
		m_security(security),
		m_shortFunction(shortFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_shortFunction)();}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	ShortFunction m_shortFunction;
};

class TGUI_API SecurityUCharRowValue : public UCharRowValue
{
public:
	typedef const ValueType& (Security::*UCharFunction)() const;
	SecurityUCharRowValue(const Security* const& security, UCharFunction ucharFunction, bool useEmptyValue = true, bool useTick = true):
		UCharRowValue(useEmptyValue, useTick),
		m_security(security),
		m_ucharFunction(ucharFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_ucharFunction)();}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	UCharFunction m_ucharFunction;
};

class TGUI_API SecurityTimeRowValue : public TimeRowValue
{
public:
	typedef const ValueType& (Security::*UIntFunction)() const;
	SecurityTimeRowValue(const Security* const& security, const bool* showMilliseconds, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true):
		TimeRowValue(showMilliseconds, useEmptyValue, useTick),
		m_security(security),
		m_uintFunction(uintFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	UIntFunction m_uintFunction;
};

class TGUI_API SecurityDateTimeRowValue : public DateTimeRowValue
{
public:
	typedef const ValueType& (Security::*UInt64Function)() const;
	SecurityDateTimeRowValue(const Security* const& security, const bool* showMilliseconds, UInt64Function uint64Function, bool useEmptyValue = true, bool useTick = false):
		DateTimeRowValue(showMilliseconds, useEmptyValue, useTick),
		m_security(security),
		m_uint64Function(uint64Function){}
	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_uint64Function)();}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	UInt64Function m_uint64Function;
};

class TGUI_API SecurityCharRowValue : public CharRowValue
{
public:
	typedef const ValueType& (Security::*CharFunction)() const;
	SecurityCharRowValue(const Security* const& security, CharFunction charFunction, const ValueType& value = '\0', bool useEmptyValue = false, bool useNeutralColor = false, bool useTick = false):
		CharRowValue(value, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_charFunction(charFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_charFunction)();}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	CharFunction m_charFunction;
};

class TGUI_API SecurityCharVRowValue : public CharRowValue
{
public:
	typedef ValueType (Security::*CharFunction)() const;
	SecurityCharVRowValue(const Security* const& security, CharFunction charFunction, const ValueType& value = '\0', bool useEmptyValue = false, bool useNeutralColor = false, bool useTick = false):
		CharRowValue(value, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_charFunction(charFunction){}
//	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_charFunction)();}
	virtual bool isValueChanged() const override{return m_value != (m_security->*m_charFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_security->*m_charFunction)());}
	virtual bool UpdateValue() override{return SetValue((m_security->*m_charFunction)());}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_charFunction)();}// == m_emptyValue;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_security->*m_charFunction)();}
	const Security* m_security;
	CharFunction m_charFunction;
};

class TGUI_API SecurityCharRowValueWithEmpty : public CharRowValueWithEmpty
{
public:
	typedef const ValueType& (Security::*CharFunction)() const;
	SecurityCharRowValueWithEmpty(const Security* const& security, CharFunction charFunction, const ValueType& emptyValue, const ValueType& value = '\0', bool useNeutralColor = false):
		CharRowValueWithEmpty(emptyValue, value, useNeutralColor),
		m_security(security),
		m_charFunction(charFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_charFunction)();}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	CharFunction m_charFunction;
};

class TGUI_API SecurityCBRowValue : public SecurityCharRowValue
{
public:
	SecurityCBRowValue(const Security* security):
		SecurityCharRowValue(security, &Security::GetRegSHOTestIndicator, '0', true, false, false){}
	static bool staticIsValueZero(const char& value)
	{
		switch(value)
		{
			case '0':
			case ' ':
			case 'D':
			return true;

			default:
			return false;
		}
	}
	virtual bool isObjectValueZero() const override{return staticIsValueZero((m_security->*m_charFunction)());}
	virtual bool isValueZero() const override{return staticIsValueZero(m_value);}
	DECLARE_NED_NEW
};

class TGUI_API SecurityRpiRowValue : public SecurityCharRowValue
{
public:
	SecurityRpiRowValue(const Security* security):
		SecurityCharRowValue(security, &Security::GetRpiIndicator, '0', true, false, false){}
	virtual bool isObjectValueZero() const{return (m_security->*m_charFunction)() == '0';}
	virtual bool isValueZero() const{return m_value == '0';}
	DECLARE_NED_NEW
};

class TGUI_API SecurityCharPtrRowValue : public CharPtrRowValue
{
public:
	typedef const ValueType& (Security::*StringPtrFunction)() const;
	SecurityCharPtrRowValue(const Security* const& security, StringPtrFunction stringFunction, const bool& caseInsensitive = false):
		CharPtrRowValue(caseInsensitive), m_security(security),m_stringFunction(stringFunction),m_tempValue(""){}
	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_stringFunction)();}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	StringPtrFunction m_stringFunction;
	mutable ValueType m_tempValue;
};

class TGUI_API SecuritySplitRowValue : public SplitRowValue
{
public:
	typedef const ValueType& (Security::*UIntFunction)() const;
	SecuritySplitRowValue(const Security* const& security, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true):
		SplitRowValue(useEmptyValue, useTick),
		m_security(security),
		m_uintFunction(uintFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	UIntFunction m_uintFunction;
};

class TGUI_API SecurityUInt64RowValue : public UInt64RowValue
{
public:
	typedef const ValueType& (Security::*UInt64Function)() const;
	SecurityUInt64RowValue(const Security* const& security, const bool* comma, UInt64Function uint64Function, bool useEmptyValue = true, bool useTick = true):
		UInt64RowValue(comma, useEmptyValue, useTick),
		m_security(security),
		m_uint64Function(uint64Function){}
	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_uint64Function)();}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	UInt64Function m_uint64Function;
};

class TGUI_API SecurityThreeCharDateValueCopy : public ThreeCharDateRowValue
{
public:
	typedef unsigned int (Security::*UIntFunction)() const;
	SecurityThreeCharDateValueCopy(const Security* const& security, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true):
		ThreeCharDateRowValue(useEmptyValue, useTick),
		m_security(security),
		m_uintFunction(uintFunction){}
//	virtual const unsigned __int64& GetObjectValue() const override{return (m_security->*m_uint64Function)();}
	virtual bool isValueChanged() const override{return m_value != (m_security->*m_uintFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_security->*m_uintFunction)());}
	virtual bool UpdateValue() override{return SetValue((m_security->*m_uintFunction)());}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_uintFunction)();}// == zero;}//m_emptyValue;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_security->*m_uintFunction)();}
	const Security* m_security;
	UIntFunction m_uintFunction;
};
/*
class TGUI_API SecurityAbsIntRowValue : public UIntRowValue
{
public:
	typedef const int& (Security::*IntFunction)() const;
	SecurityAbsIntRowValue(const Security* const& security, const bool* comma, IntFunction intFunction, bool useEmptyValue = true, bool useTick = true):
		UIntRowValue(comma, useEmptyValue, useTick),
		m_security(security),
		m_intFunction(intFunction){}
//	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_uintFunction)();}
	ValueType GetObjectAbsValue() const{int value = (m_security->*m_intFunction)(); return value < 0 ? -value : value;}
	virtual bool isValueChanged() const override{return m_value != GetObjectAbsValue();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(GetObjectAbsValue());}
	virtual bool UpdateValue() override{return SetValue(GetObjectAbsValue());}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_intFunction)();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = GetObjectAbsValue();}
	const Security* m_security;
	IntFunction m_intFunction;
};
*/
class TGUI_API SecurityUIntRowValueCopy : public UIntRowValue
{
public:
	typedef unsigned int (Security::*UIntFunction)() const;
	SecurityUIntRowValueCopy(const Security* const& security, const bool* comma, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true):
		UIntRowValue(comma, useEmptyValue, useTick),
		m_security(security),
		m_uintFunction(uintFunction){}
//	virtual const unsigned __int64& GetObjectValue() const override{return (m_security->*m_uint64Function)();}
	virtual bool isValueChanged() const override{return m_value != (m_security->*m_uintFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_security->*m_uintFunction)());}
	virtual bool UpdateValue() override{return SetValue((m_security->*m_uintFunction)());}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_uintFunction)();}// == m_emptyValue;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_security->*m_uintFunction)();}
	const Security* m_security;
	UIntFunction m_uintFunction;
};

class TGUI_API SecurityLONGRowValueCopy : public IntRowValue
{
public:
	typedef LONG (Security::*LONGFunction)() const;
	SecurityLONGRowValueCopy(const Security* const& security, const bool* comma, LONGFunction longFunction, bool useEmptyValue = true, bool useTick = true):
		IntRowValue(comma, useEmptyValue, useTick),
		m_security(security),
		m_longFunction(longFunction){}
//	virtual const unsigned __int64& GetObjectValue() const override{return (m_security->*m_uint64Function)();}
	virtual bool isValueChanged() const override{return m_value != (m_security->*m_longFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_security->*m_longFunction)());}
	virtual bool UpdateValue() override{return SetValue((m_security->*m_longFunction)());}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_longFunction)();}// == m_emptyValue;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_security->*m_longFunction)();}
	const Security* m_security;
	LONGFunction m_longFunction;
};

class TGUI_API SecurityUInt64RowValueCopy : public UInt64RowValue
{
public:
//	typedef unsigned __int64 (Security::*UInt64Function)() const;
	typedef ValueType (Security::*UInt64Function)() const;
	SecurityUInt64RowValueCopy(const Security* const& security, const bool* comma, UInt64Function uint64Function, bool useEmptyValue = true, bool useTick = true):
		UInt64RowValue(comma, useEmptyValue, useTick),
		m_security(security),
		m_uint64Function(uint64Function){}
//	virtual const unsigned __int64& GetObjectValue() const override{return (m_security->*m_uint64Function)();}
	virtual bool isValueChanged() const override{return m_value != (m_security->*m_uint64Function)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_security->*m_uint64Function)());}
	virtual bool UpdateValue() override{return SetValue((m_security->*m_uint64Function)());}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_uint64Function)();}// == m_emptyValue;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_security->*m_uint64Function)();}
	const Security* m_security;
	UInt64Function m_uint64Function;
};

class TGUI_API SecurityPriceAsUInt64RowValueCopy : public PriceAsUInt64RowValue
{
public:
//	typedef unsigned __int64 (Security::*UInt64Function)() const;
	typedef ValueType (Security::*UInt64Function)() const;
	SecurityPriceAsUInt64RowValueCopy(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, UInt64Function uint64Function, bool useEmptyValue = true, bool useTick = true):
		PriceAsUInt64RowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_security(security),
		m_uint64Function(uint64Function){}
//	virtual const unsigned __int64& GetObjectValue() const override{return (m_security->*m_uint64Function)();}
	virtual bool isValueChanged() const override{return m_value != (m_security->*m_uint64Function)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_security->*m_uint64Function)());}
	virtual bool UpdateValue() override{return SetValue((m_security->*m_uint64Function)());}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_uint64Function)();}// == m_emptyValue;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_security->*m_uint64Function)();}
	const Security* m_security;
	UInt64Function m_uint64Function;
};

class TGUI_API SecurityPriceAsUIntRowValueCopy : public CompactPriceRowValue//PriceAsUIntRowValue
{
public:
	typedef ValueType (Security::*UIntFunction)() const;
	SecurityPriceAsUIntRowValueCopy(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true):
		CompactPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_security(security),
		m_uintFunction(uintFunction){}
//	virtual const unsigned __int64& GetObjectValue() const override{return (m_security->*m_uint64Function)();}
	virtual bool isValueChanged() const override{return m_value != (m_security->*m_uintFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_security->*m_uintFunction)());}
	virtual bool UpdateValue() override{return SetValue((m_security->*m_uintFunction)());}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_uintFunction)();}// == m_emptyValue;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_security->*m_uintFunction)();}
	const Security* m_security;
	UIntFunction m_uintFunction;
};

class TGUI_API SecurityUIntAsStrRowValue : public UIntAsStrRowValue
{
public:
	typedef const ValueType& (Security::*UIntFunction)() const;
	SecurityUIntAsStrRowValue(const Security* const& security, UIntFunction uintFunction):
		m_security(security),
		m_uintFunction(uintFunction)
	{}
	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	UIntFunction m_uintFunction;
};

class TGUI_API SecurityBoolRowValue : public BoolRowValue
{
public:
	typedef const ValueType& (Security::*BoolFunction)() const;
	SecurityBoolRowValue(const Security* const& security, BoolFunction boolFunction, char trueValue = 'Y', char falseValue = '\0'):
		BoolRowValue(trueValue, falseValue),
		m_security(security),
		m_boolFunction(boolFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_boolFunction)();}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	BoolFunction m_boolFunction;
};

class TGUI_API SecurityBoolRowValueCountable : public BoolRowValueCountable
{
public:
	typedef const ValueType& (Security::*BoolFunction)() const;
	SecurityBoolRowValueCountable(const Security* const& security, BoolFunction boolFunction, char trueValue = 'Y', char falseValue = '\0'):
		BoolRowValueCountable(trueValue, falseValue),
		m_security(security),
		m_boolFunction(boolFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_boolFunction)();}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	BoolFunction m_boolFunction;
};

class TGUI_API SecurityBoolRefRowValue : public BoolRowValue
{
public:
	typedef ValueType (Security::*BoolFunction)() const;
	SecurityBoolRefRowValue(const Security* const& security, BoolFunction boolFunction, char trueValue = 'Y', char falseValue = '\0'):
		BoolRowValue(trueValue, falseValue),
		m_security(security),
		m_boolFunction(boolFunction)
	{
//			InitializeValue();
	}
//	virtual const bool& GetObjectValue() const override{return m_security && (m_security->*m_boolFunction)();}

	virtual bool isValueChanged() const override{return m_value != (m_security && (m_security->*m_boolFunction)());}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(m_security && (m_security->*m_boolFunction)());}
	virtual bool UpdateValue() override{return SetValue(m_security && (m_security->*m_boolFunction)());}
	virtual bool isObjectValueZero() const override{return (!m_security || !(m_security->*m_boolFunction)());}// == m_emptyValue;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = m_security && (m_security->*m_boolFunction)();}
	const Security* const& m_security;
	BoolFunction m_boolFunction;
};
/*
class TGUI_API SecurityBoolValOrdinalRowValue : public BoolRowValue
{
public:
	typedef bool (Security::*BoolFunction)(const unsigned char& ordinal) const;
	SecurityBoolValOrdinalRowValue(const Security* const& security, BoolFunction boolFunction, const unsigned char& ordinal, char trueValue = 'Y', char falseValue = '\0'):
		BoolRowValue(trueValue, falseValue),
		m_security(security),
		m_boolFunction(boolFunction),
		m_ordinal(ordinal){}
//	virtual const bool& GetObjectValue() const override{return (m_security->isHtb()();}
	virtual bool isValueChanged() const override{return m_value != (m_security->*m_boolFunction)(m_ordinal);}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_security->*m_boolFunction)(m_ordinal));}
	virtual bool UpdateValue() override{return SetValue((m_security->*m_boolFunction)(m_ordinal));}

	virtual bool isObjectValueZero() const override{return !(m_security->*m_boolFunction)(m_ordinal);}
//	virtual bool isValueZero() const{return !m_value;}

	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_security->*m_boolFunction)(m_ordinal);}
	const Security* m_security;
	BoolFunction m_boolFunction;
	const unsigned char& m_ordinal;
};
*/
class TGUI_API SecurityUCharAsCharOrdinalRowValue : public UCharAsCharRowValue
{
public:
	typedef const ValueType& (Security::*UCharFunction)(const unsigned char& ordinal) const;
	SecurityUCharAsCharOrdinalRowValue(const Security* const& security,
		UCharFunction ucharFunction,
		const unsigned char& ordinal,
		const bool& useEmptyValue = true,
		const bool& useTick = false,
		const char& invalidReplacement = '\0'):
		UCharAsCharRowValue(useEmptyValue, useTick, invalidReplacement),
		m_security(security),
		m_ucharFunction(ucharFunction),
		m_ordinal(ordinal){}
	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_ucharFunction)(m_ordinal);}
//	virtual bool isValueChanged() const override{return m_value != (m_security->*m_boolFunction)(m_ordinal);}
//	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_security->*m_boolFunction)(m_ordinal));}
//	virtual bool UpdateValue() override{return SetValue((m_security->*m_boolFunction)(m_ordinal));}
//	virtual bool isObjectValueZero() const override{return !(m_security->*m_boolFunction)(m_ordinal);}

	DECLARE_NED_NEW
protected:
//	virtual void InitializeValue() override{m_value = (m_security->*m_boolFunction)(m_ordinal);}
	const Security* m_security;
	UCharFunction m_ucharFunction;
	const unsigned char& m_ordinal;
};

class TGUI_API SecurityHtbRowValue : public UCharAsCharRowValue
{
public:
//	typedef const ValueType& (Security::*UCharFunction)(const unsigned char& ordinal) const;
	SecurityHtbRowValue(const Security* const& security,
		const unsigned char& ordinal,
		const bool& useEmptyValue = true,
		const bool& useTick = false,
		const char& invalidReplacement = '\0'):
		UCharAsCharRowValue(useEmptyValue, useTick, invalidReplacement),
		m_security(security),
		m_ordinal(ordinal),
		m_valueValid(false),
		m_sharesAvailable(false)
	{}
	virtual const ValueType& GetObjectValue() const override{return m_security->isHTB(m_ordinal);}
	virtual bool isValueChanged() const override
	{
		if(m_value != m_security->isHTB(m_ordinal))
			return true;
		else
		{
			const unsigned int* borrowSize = m_security->GetBorrowSize(m_ordinal);
			return borrowSize ?
				!m_valueValid || (*borrowSize != 0) != m_sharesAvailable :
				m_valueValid;
		}
	}
	inline static short CompareHtb(const RowValue& other, const unsigned char& myValue, const bool& myValueValid, const bool& mySharesAvailable)
	{
//		return CompareValue(((const TypedRowValue&)other).m_value);
		const SecurityHtbRowValue& otherHtb = (const SecurityHtbRowValue&)other;
		const ValueType otherValue = otherHtb.m_value;
		return otherValue == myValue ?
			otherHtb.m_valueValid ?
				myValueValid ?
					otherHtb.m_sharesAvailable ?
						mySharesAvailable ? 0 : 1:
						mySharesAvailable ? -1 : 0:
					1:
				myValueValid ? -1 : 0:
			myValue < otherValue ? -1 : 1;

/*
		if(otherValue == myValue)
		{
//			const bool otherValueValid = otherHtb.m_valueValid;
//			const unsigned int* borrowSize = m_security->GetBorrowSize(m_ordinal);
			if(otherHtb.m_valueValid)
			{
				if(myValueValid)
				{
//					const bool otherSharesAvailable = otherHtb.m_sharesAvailable;
					return otherHtb.m_sharesAvailable == mySharesAvailable ? 0:
						mySharesAvailable ? -1 : 1;
				}
				else
					return 1;
			}
			else
				return myValueValid ? -1 : 0;
		}
		else
			return myValue < otherValue ? -1 : 1;
*/
	}
	virtual short CompareAhead(const RowValue& other) const override
	{
		const unsigned int* borrowSize = m_security->GetBorrowSize(m_ordinal);
		const bool myValueValid = borrowSize != NULL;
		return CompareHtb(other, m_security->isHTB(m_ordinal), myValueValid, myValueValid && *borrowSize != 0);
/*
		const unsigned char value = m_security->isHTB(m_ordinal);
		if(value == m_value)
		{
			const unsigned int* borrowSize = m_security->GetBorrowSize(m_ordinal);
			if(borrowSize)
			{
				if(m_valueValid)
				{
					const bool sharesAvailable = *borrowSize != 0;
					return sharesAvailable == m_sharesAvailable ? 0 :
						sharesAvailable ? -1 : 1;
				}
				else
					return -1;
			}
			else
				return m_valueValid ? 1 : -1;
		}
		else
			return value < m_value ? -1 : 1;
//		return -((const TypedRowValue&)other).CompareValue(m_security->isHTB(m_ordinal));
*/
	}
	virtual short Compare(const RowValue& other) const override
	{
		return CompareHtb(other, m_value, m_valueValid, m_sharesAvailable);
/*
//		return CompareValue(((const TypedRowValue&)other).m_value);
		const SecurityHtbRowValue& otherHtb = (const SecurityHtbRowValue&)other;
		const unsigned char value = otherHtb.m_value;
		if(value == m_value)
		{
			const bool valueValid = otherHtb.m_valueValid;
//			const unsigned int* borrowSize = m_security->GetBorrowSize(m_ordinal);
			if(valueValid)
			{
				if(m_valueValid)
				{
					const bool sharesAvailable = otherHtb.m_sharesAvailable;
					return sharesAvailable == m_sharesAvailable ? 0:
						sharesAvailable ? 1 : -1;
				}
				else
					return 1;
			}
			else
				return m_valueValid ? -1 : 1;
		}
		else
			return value < m_value ? 1 : -1;
*/
	}

/*
	virtual short CompareValue(const ValueType& other) const override
	{
//		return m_value < other ? -1 : other < m_value ? 1 : 0;
	}
*/
	virtual bool UpdateValue() override
	{
		bool ret = false;
		const unsigned int* borrowSize = m_security->GetBorrowSize(m_ordinal);
		if(borrowSize)
		{
			if(!m_valueValid)
			{
				ret = true;
				m_valueValid = true;
			}
			const bool sharesAvailable = *borrowSize != 0;
			if(sharesAvailable != m_sharesAvailable)
			{
				ret = true;
				m_sharesAvailable = sharesAvailable;
			}
		}
		else
		{
			if(m_valueValid)
			{
				ret = true;
				m_sharesAvailable = false;
				m_valueValid = false;
			}
		}
		return SetValue(m_security->isHTB(m_ordinal)) || ret;
	}
//	virtual bool isObjectValueZero() const{return !(m_security->*m_boolFunction)(m_ordinal);}

	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_value = m_security->isHTB(m_ordinal);
		const unsigned int* borrowSize = m_security->GetBorrowSize(m_ordinal);
		if(borrowSize)
		{
			m_valueValid = true;
			m_sharesAvailable = *borrowSize != 0;
		}
		else
		{
			m_sharesAvailable = false;
			m_valueValid = false;
		}
	}
	const Security* m_security;
//	UCharFunction m_ucharFunction;
	const unsigned char& m_ordinal;
	bool m_valueValid;
	bool m_sharesAvailable;
};

class TGUI_API SecurityBoolOrdinalRowValue : public BoolRowValue//Countable
{
public:
	typedef const bool* (Security::*OrdinalFunction)(const unsigned char& ordinal) const;
	SecurityBoolOrdinalRowValue(const Security* const& security, OrdinalFunction ordinalFunction, const unsigned char& ordinal):
//		BoolRowValueCountable('Y', 'N'),
		BoolRowValue('Y', 'N'),
		m_security(security),
		m_ordinalFunction(ordinalFunction),
		m_ordinal(ordinal),
		m_valueValid(false)
	{}
	virtual bool isValueChanged() const override
	{
		const ValueType* value = (m_security->*m_ordinalFunction)(m_ordinal);
		return value ? !m_valueValid || *value != m_value : m_valueValid;
	}
	virtual short CompareAhead(const RowValue& other) const override
	{
		const SecurityBoolOrdinalRowValue& otherValue = (const SecurityBoolOrdinalRowValue&)other;
		const ValueType* value = (m_security->*m_ordinalFunction)(m_ordinal);
		return otherValue.m_valueValid ?
			value ? -otherValue.CompareValue(*value) : 1:
			value ? -1 : 0;
	}
	virtual bool UpdateValue() override
	{
		const ValueType* value = (m_security->*m_ordinalFunction)(m_ordinal);
		if(value)
		{
			bool ret = !m_valueValid;
			if(ret)
			{
				m_valueValid = true;
			}
			return SetValue(*value) || ret;
		}
		else if(m_valueValid)
		{
			m_valueValid = false;
			SetValue(0);
			return true;
		}
		return false;
	}

	virtual bool isObjectValueZero() const override
	{
		const ValueType* value = (m_security->*m_ordinalFunction)(m_ordinal);
		return !value;// || !*value;
	}
//	virtual bool isValueZero() const{return m_value == 0;}

	virtual bool isValueEmpty() const override{return m_useEmptyValue && !m_valueValid;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !(m_security->*m_ordinalFunction)(m_ordinal);}

//	virtual void toString(std::string& text) const{if(!isValueEmpty())text += U_UnsignedNumberToStrWithCommasNoDecDigits(m_value, num, sizeof(num), *m_comma);}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		const ValueType* value = (m_security->*m_ordinalFunction)(m_ordinal);
		m_valueValid = value != NULL;
		m_value = m_valueValid ? *value : 0;
	}
	const Security* m_security;
	OrdinalFunction m_ordinalFunction;
	const unsigned char& m_ordinal;
	bool m_valueValid;
};

class TGUI_API SecurityBoolDefaultOrdinalRowValue : public BoolRowValue
{
public:
	typedef const ValueType& (Security::*OrdinalFunction)(const unsigned char& ordinal) const;
	SecurityBoolDefaultOrdinalRowValue(const Security* const& security, OrdinalFunction ordinalFunction, const unsigned char& ordinal):
		BoolRowValue('Y', 'N'),
		m_security(security),
		m_ordinalFunction(ordinalFunction),
		m_ordinal(ordinal)
	{}
	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_ordinalFunction)(m_ordinal);}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	OrdinalFunction m_ordinalFunction;
	const unsigned char& m_ordinal;
};

template<class V>
class SecurityUnsignedNumberDefaultOrdinalRowValue : public CommaUnsignedNumberRowValue<V>
{
public:
	typedef const ValueType& (Security::*OrdinalFunction)(const unsigned char& ordinal) const;
	SecurityUnsignedNumberDefaultOrdinalRowValue(const Security* const& security, const bool* comma, OrdinalFunction ordinalFunction, const unsigned char& ordinal, bool useEmptyValue = true, bool useTick = true):
		CommaUnsignedNumberRowValue(comma, 0, useEmptyValue, useTick),
		m_security(security),
		m_ordinalFunction(ordinalFunction),
		m_ordinal(ordinal)
	{}
	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_ordinalFunction)(m_ordinal);}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	OrdinalFunction m_ordinalFunction;
	const unsigned char& m_ordinal;
};

class TGUI_API SecurityUCharDefaultOrdinalRowValue : public SecurityUnsignedNumberDefaultOrdinalRowValue<unsigned char>
{
public:
	SecurityUCharDefaultOrdinalRowValue(const Security* const& security, OrdinalFunction ordinalFunction, const unsigned char& ordinal, bool useEmptyValue = true, bool useTick = true):
		SecurityUnsignedNumberDefaultOrdinalRowValue(security, &noValue, ordinalFunction, ordinal, useEmptyValue, useTick)
	{}
	DECLARE_NED_NEW
};

class TGUI_API SecurityUCharAsCharDefaultOrdinalRowValue : public SecurityUCharDefaultOrdinalRowValue
{
public:
	SecurityUCharAsCharDefaultOrdinalRowValue(const Security* const& security, OrdinalFunction ordinalFunction, const unsigned char& ordinal, bool useEmptyValue = true, bool useTick = true):
		SecurityUCharDefaultOrdinalRowValue(security, ordinalFunction, ordinal, useEmptyValue, useTick)
	{}
	virtual void toString(std::string& text) const override{if(!isValueEmpty())U_AppendPrintableCharIfValid(text, m_value);}
	DECLARE_NED_NEW
};

class TGUI_API SecurityUIntDefaultOrdinalRowValue : public SecurityUnsignedNumberDefaultOrdinalRowValue<unsigned int>
{
public:
	SecurityUIntDefaultOrdinalRowValue(const Security* const& security, const bool* comma, OrdinalFunction ordinalFunction, const unsigned char& ordinal, bool useEmptyValue = true, bool useTick = true):
		SecurityUnsignedNumberDefaultOrdinalRowValue(security, comma, ordinalFunction, ordinal, useEmptyValue, useTick)
	{}
	DECLARE_NED_NEW
};

class TGUI_API SecurityTimestampDefaultOrdinalRowValue : public SecurityUIntDefaultOrdinalRowValue
{
public:
	SecurityTimestampDefaultOrdinalRowValue(const Security* const& security, const bool* showMilliseconds, OrdinalFunction ordinalFunction, const unsigned char& ordinal, bool useEmptyValue = true):
		SecurityUIntDefaultOrdinalRowValue(security, &noValue, ordinalFunction, ordinal, useEmptyValue, false),
		m_showMilliseconds(showMilliseconds)
	{}
	virtual void toString(std::string& text) const override{if(!isValueEmpty())U_AppendMillisecond(text, m_value, *m_showMilliseconds);}
	DECLARE_NED_NEW
protected:
	const bool* m_showMilliseconds;
};

////
template<class V>
class SecurityUnsignedNumberOrdinalRowValue : public CommaUnsignedNumberRowValue<V>
{
public:
	typedef const ValueType* (Security::*OrdinalFunction)(const unsigned char& ordinal) const;
	SecurityUnsignedNumberOrdinalRowValue(const Security* const& security, const bool* comma, OrdinalFunction ordinalFunction, const unsigned char& ordinal, bool useEmptyValue = true, bool useTick = true):
		CommaUnsignedNumberRowValue(comma, useEmptyValue, useTick),
		m_security(security),
		m_ordinalFunction(ordinalFunction),
		m_ordinal(ordinal),
		m_valueValid(false)
	{}
//	virtual const bool& GetObjectValue() const override{return (m_security->isHtb()();}
/*
	inline unsigned int GetPrice() const
	{
		const Price* price = (m_security->*m_priceFunction)(m_ordinal);
		return price ? *price : Price::priceZero;
	}
*/
	virtual bool isValueChanged() const override
	{
		const ValueType* value = (m_security->*m_ordinalFunction)(m_ordinal);
		return value ? !m_valueValid || *value != m_value : m_valueValid;
	}
	virtual short CompareAhead(const RowValue& other) const override
	{
		const SecurityUnsignedNumberOrdinalRowValue& otherValue = (const SecurityUnsignedNumberOrdinalRowValue&)other;
		const ValueType* value = (m_security->*m_ordinalFunction)(m_ordinal);
		return otherValue.m_valueValid ?
			value ? -otherValue.CompareValue(*value) : 1:
			value ? -1 : 0;
	}
	virtual bool UpdateValue() override
	{
		const ValueType* value = (m_security->*m_ordinalFunction)(m_ordinal);
		if(value)
		{
			bool ret = !m_valueValid;
			if(ret)
			{
				m_valueValid = true;
			}
			return SetValue(*value) || ret;
		}
		else if(m_valueValid)
		{
			m_valueValid = false;
			SetValue(0);
			return true;
		}
		return false;
	}

	virtual bool isObjectValueZero() const override
	{
		const ValueType* value = (m_security->*m_ordinalFunction)(m_ordinal);
		return !value || !*value;
	}
//	virtual bool isValueZero() const{return m_value == 0;}

	virtual bool isValueEmpty() const override{return m_useEmptyValue && !m_valueValid;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !(m_security->*m_ordinalFunction)(m_ordinal);}

//	virtual void toString(std::string& text) const{if(!isValueEmpty())text += U_UnsignedNumberToStrWithCommasNoDecDigits(m_value, num, sizeof(num), *m_comma);}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		const ValueType* value = (m_security->*m_ordinalFunction)(m_ordinal);
		m_valueValid = value != NULL;
		m_value = m_valueValid ? *value : 0;
	}
	const Security* m_security;
	OrdinalFunction m_ordinalFunction;
	const unsigned char& m_ordinal;
	bool m_valueValid;
};

class TGUI_API SecurityUIntOrdinalRowValue : public SecurityUnsignedNumberOrdinalRowValue<unsigned int>
{
public:
	SecurityUIntOrdinalRowValue(const Security* const& security, const bool* comma, OrdinalFunction ordinalFunction, const unsigned char& ordinal, bool useEmptyValue = true, bool useTick = true):
		SecurityUnsignedNumberOrdinalRowValue(security, comma, ordinalFunction, ordinal, useEmptyValue, useTick)
	{}
	virtual unsigned int GetUIntValue() const override{return m_value;}

	DECLARE_NED_NEW
};

class TGUI_API SecurityUCharOrdinalRowValue : public SecurityUnsignedNumberOrdinalRowValue<unsigned char>
{
public:
//	SecurityUCharOrdinalRowValue(const Security* const& security, const bool* comma, OrdinalFunction ordinalFunction, const unsigned char& ordinal, bool useEmptyValue = true, bool useTick = true):
	SecurityUCharOrdinalRowValue(const Security* const& security, OrdinalFunction ordinalFunction, const unsigned char& ordinal, bool useEmptyValue = true, bool useTick = true):
		SecurityUnsignedNumberOrdinalRowValue(security, &noValue, ordinalFunction, ordinal, useEmptyValue, useTick)
	{}
	virtual unsigned int GetUIntValue() const override{return m_value;}

	DECLARE_NED_NEW
};
/*Declared before on line 19937
class TGUI_API SecurityUCharAsCharOrdinalRowValue : public SecurityUCharOrdinalRowValue
{
public:
	SecurityUCharAsCharOrdinalRowValue(const Security* const& security, OrdinalFunction ordinalFunction, const unsigned char& ordinal, bool useEmptyValue = true, bool useTick = true):
		SecurityUCharOrdinalRowValue(security, ordinalFunction, ordinal, useEmptyValue, useTick)
	{}

	virtual void toString(std::string& text) const override//{if(!isValueEmpty())text += U_UCharToStr(m_value, num, sizeof(num));}
	{
		if(!isValueEmpty())U_AppendPrintableCharIfValid(text, m_value);
	}
	DECLARE_NED_NEW
};
*/
class TGUI_API SecurityUCharAsPercentOrdinalRowValue : public SecurityUnsignedNumberOrdinalRowValue<unsigned char>
{
public:
	SecurityUCharAsPercentOrdinalRowValue(const Security* const& security, const bool* comma, OrdinalFunction ordinalFunction, const unsigned char& ordinal, bool useEmptyValue = true, bool useTick = true):
		SecurityUnsignedNumberOrdinalRowValue(security, comma, ordinalFunction, ordinal, useEmptyValue, useTick)
	{}
	virtual void toString(std::string& text) const override
	{
		if(!isValueEmpty())toStringAsWholePercent(m_value, text);
	}
	DECLARE_NED_NEW
};
/*
class TGUI_API SecurityPriceOrdinalRowValue : public PriceRowValue
{
public:
	typedef const ValueType* (Security::*PriceFunction)(const unsigned char& ordinal) const;
	SecurityPriceOrdinalRowValue(const Security* const& security, PriceFunction priceFunction, const unsigned char& ordinal, const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useTick = true):
		PriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_security(security),
		m_priceFunction(priceFunction),
		m_ordinal(ordinal),
		m_valueValid(false)
		{}
//	virtual const bool& GetObjectValue() const override{return (m_security->isHtb()();}
//	virtual Price GetPrice() const;//{const Price* price = (m_security->*m_priceFunction)(m_ordinal);return price ? *price : Price::priceZero;}
	virtual bool isValueChanged() const override
	{
		const ValueType* value = (m_security->*m_priceFunction)(m_ordinal);
		return value ? !m_valueValid || *value != m_value : m_valueValid;
//		return m_value != GetPrice();
	}
	virtual short CompareAhead(const RowValue& other) const override
	{
		const SecurityPriceOrdinalRowValue& otherValue = (const SecurityPriceOrdinalRowValue&)other;
		const ValueType* value = (m_security->*m_priceFunction)(m_ordinal);
		return otherValue.m_valueValid ?
			value ? -otherValue.CompareValue(*value) : 1:
			value ? -1 : 0;
	}
	virtual bool UpdateValue() override
	{
		const ValueType* value = (m_security->*m_priceFunction)(m_ordinal);
		if(value)
		{
			bool ret = !m_valueValid;
			if(ret)
			{
				m_valueValid = true;
			}
			return SetValue(*value) || ret;
		}
		else if(m_valueValid)
		{
			m_valueValid = false;
			SetValue(Price::priceZero);
			return true;
		}
		return false;
	}

	virtual bool isObjectValueZero() const override
	{
		const ValueType* value = (m_security->*m_priceFunction)(m_ordinal);
		return !value || value->isZero();
	}
//	virtual bool isValueZero() const{return m_value.isZero();}

	virtual bool isValueEmpty() const override{return m_useEmptyValue && !m_valueValid;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !(m_security->*m_priceFunction)(m_ordinal);}

	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
//		m_value = GetPrice();
		const ValueType* value = (m_security->*m_priceFunction)(m_ordinal);
		m_valueValid = value != NULL;
		if(m_valueValid)m_value = *value;
		else m_value.SetZero();
	}
	const Security* m_security;
	PriceFunction m_priceFunction;
	const unsigned char& m_ordinal;
	bool m_valueValid;
};
*/
class TGUI_API SecurityCompactPriceOrdinalRowValue : public CompactPriceRowValue
{
public:
	typedef const ValueType* (Security::*PriceFunction)(const unsigned char& ordinal) const;
	SecurityCompactPriceOrdinalRowValue(const Security* const& security, PriceFunction priceFunction, const unsigned char& ordinal, const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useTick = true):
		CompactPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_security(security),
		m_priceFunction(priceFunction),
		m_ordinal(ordinal),
		m_valueValid(false)
		{}
//	virtual const bool& GetObjectValue() const override{return (m_security->isHtb()();}
//	virtual Price GetPrice() const;//{const Price* price = (m_security->*m_priceFunction)(m_ordinal);return price ? *price : Price::priceZero;}
	virtual bool isValueChanged() const override
	{
		const ValueType* value = (m_security->*m_priceFunction)(m_ordinal);
		return value ? !m_valueValid || *value != m_value : m_valueValid;
//		return m_value != GetPrice();
	}
	virtual short CompareAhead(const RowValue& other) const override
	{
		const SecurityCompactPriceOrdinalRowValue& otherValue = (const SecurityCompactPriceOrdinalRowValue&)other;
		const ValueType* value = (m_security->*m_priceFunction)(m_ordinal);
		return otherValue.m_valueValid ?
			value ? -otherValue.CompareValue(*value) : 1:
			value ? -1 : 0;
	}
	virtual bool UpdateValue() override
	{
		const ValueType* value = (m_security->*m_priceFunction)(m_ordinal);
		if(value)
		{
			bool ret = !m_valueValid;
			if(ret)
			{
				m_valueValid = true;
			}
			return SetValue(*value) || ret;
		}
		else if(m_valueValid)
		{
			m_valueValid = false;
			SetValue(0);// Price::priceZero);
			return true;
		}
		return false;
	}

	virtual bool isObjectValueZero() const override
	{
		const ValueType* value = (m_security->*m_priceFunction)(m_ordinal);
		return !value || !*value;// value->isZero();
	}
//	virtual bool isValueZero() const{return m_value.isZero();}

	virtual bool isValueEmpty() const override{return m_useEmptyValue && !m_valueValid;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !(m_security->*m_priceFunction)(m_ordinal);}

	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
//		m_value = GetPrice();
		const ValueType* value = (m_security->*m_priceFunction)(m_ordinal);
		m_valueValid = value != NULL;
		if(m_valueValid)m_value = *value;
		else m_value = 0;// m_value.SetZero();
	}
	const Security* m_security;
	PriceFunction m_priceFunction;
	const unsigned char& m_ordinal;
	bool m_valueValid;
};

class TGUI_API SecurityCompactSignedPriceOrdinalRowValue : public CompactSignedPriceRowValue
{
public:
	typedef const ValueType* (Security::*SignedPriceFunction)(const unsigned char& ordinal) const;
	SecurityCompactSignedPriceOrdinalRowValue(const Security* const& security, SignedPriceFunction priceFunction, const unsigned char& ordinal, const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useTick = true):
		CompactSignedPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_security(security),
		m_priceFunction(priceFunction),
		m_ordinal(ordinal),
		m_valueValid(false)
		{}
//	virtual const bool& GetObjectValue() const override{return (m_security->isHtb()();}
//	virtual Price GetPrice() const;//{const Price* price = (m_security->*m_priceFunction)(m_ordinal);return price ? *price : Price::priceZero;}
	virtual bool isValueChanged() const override
	{
		const ValueType* value = (m_security->*m_priceFunction)(m_ordinal);
		return value ? !m_valueValid || *value != m_value : m_valueValid;
//		return m_value != GetPrice();
	}
	virtual short CompareAhead(const RowValue& other) const override
	{
		const SecurityCompactSignedPriceOrdinalRowValue& otherValue = (const SecurityCompactSignedPriceOrdinalRowValue&)other;
		const ValueType* value = (m_security->*m_priceFunction)(m_ordinal);
		return otherValue.m_valueValid ?
			value ? -otherValue.CompareValue(*value) : 1:
			value ? -1 : 0;
	}
	virtual bool UpdateValue() override
	{
		const ValueType* value = (m_security->*m_priceFunction)(m_ordinal);
		if(value)
		{
			bool ret = !m_valueValid;
			if(ret)
			{
				m_valueValid = true;
			}
			return SetValue(*value) || ret;
		}
		else if(m_valueValid)
		{
			m_valueValid = false;
			SetValue(0);// Price::priceZero);
			return true;
		}
		return false;
	}

	virtual bool isObjectValueZero() const override
	{
		const ValueType* value = (m_security->*m_priceFunction)(m_ordinal);
//		return !value || value->isZero();
		return !value || !*value;
	}
//	virtual bool isValueZero() const{return m_value.isZero();}

	virtual bool isValueEmpty() const override{return m_useEmptyValue && !m_valueValid;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !(m_security->*m_priceFunction)(m_ordinal);}

	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
//		m_value = GetPrice();
		const ValueType* value = (m_security->*m_priceFunction)(m_ordinal);
		m_valueValid = value != NULL;
		if(m_valueValid)m_value = *value;
		else m_value = 0;//m_value.SetZero();
	}
	const Security* m_security;
	SignedPriceFunction m_priceFunction;
	const unsigned char& m_ordinal;
	bool m_valueValid;
};
/*
class TGUI_API SecuritySignedPriceOrdinalRowValue : public SignedPriceRowValue
{
public:
	typedef const ValueType* (Security::*SignedPriceFunction)(const unsigned char& ordinal) const;
	SecuritySignedPriceOrdinalRowValue(const Security* const& security, SignedPriceFunction priceFunction, const unsigned char& ordinal, const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useTick = true):
		SignedPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_security(security),
		m_priceFunction(priceFunction),
		m_ordinal(ordinal),
		m_valueValid(false)
		{}
//	virtual const bool& GetObjectValue() const override{return (m_security->isHtb()();}
//	virtual Price GetPrice() const;//{const Price* price = (m_security->*m_priceFunction)(m_ordinal);return price ? *price : Price::priceZero;}
	virtual bool isValueChanged() const override
	{
		const ValueType* value = (m_security->*m_priceFunction)(m_ordinal);
		return value ? !m_valueValid || *value != m_value : m_valueValid;
//		return m_value != GetPrice();
	}
	virtual short CompareAhead(const RowValue& other) const override
	{
		const SecuritySignedPriceOrdinalRowValue& otherValue = (const SecuritySignedPriceOrdinalRowValue&)other;
		const ValueType* value = (m_security->*m_priceFunction)(m_ordinal);
		return otherValue.m_valueValid ?
			value ? -otherValue.CompareValue(*value) : 1:
			value ? -1 : 0;
	}
	virtual bool UpdateValue() override
	{
		const ValueType* value = (m_security->*m_priceFunction)(m_ordinal);
		if(value)
		{
			bool ret = !m_valueValid;
			if(ret)
			{
				m_valueValid = true;
			}
			return SetValue(*value) || ret;
		}
		else if(m_valueValid)
		{
			m_valueValid = false;
			SetValue(Price::priceZero);
			return true;
		}
		return false;
	}

	virtual bool isObjectValueZero() const override
	{
		const ValueType* value = (m_security->*m_priceFunction)(m_ordinal);
		return !value || value->isZero();
	}
//	virtual bool isValueZero() const{return m_value.isZero();}

	virtual bool isValueEmpty() const override{return m_useEmptyValue && !m_valueValid;}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && !(m_security->*m_priceFunction)(m_ordinal);}

	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
//		m_value = GetPrice();
		const ValueType* value = (m_security->*m_priceFunction)(m_ordinal);
		m_valueValid = value != NULL;
		if(m_valueValid)m_value = *value;
		else m_value.SetZero();
	}
	const Security* m_security;
	SignedPriceFunction m_priceFunction;
	const unsigned char& m_ordinal;
	bool m_valueValid;
};
*/
class TGUI_API SecurityBorrowPriceRowValue : public SecurityCompactPriceOrdinalRowValue//SecurityPriceOrdinalRowValue
{
public:
	SecurityBorrowPriceRowValue(const Security* const& security, const unsigned char& ordinal, const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useTick = true):
		SecurityCompactPriceOrdinalRowValue(security, &Security::GetCompactBorrowPrice, ordinal, comma, decDigits, truncate, useEmptyValue, useTick){}
//	virtual const bool& GetObjectValue() const override{return (m_security->isHtb()();}
//	virtual Price GetPrice() const override;

	virtual bool isValueChanged() const override;
	virtual short CompareAhead(const RowValue& other) const override;
	virtual bool UpdateValue() override;
/*
	virtual bool isObjectValueZero() const
	{
		const ValueType* value = (m_security->*m_priceFunction)(m_ordinal);
		return !value || value->isZero();
	}
*/
	virtual void toString(std::string& text) const override
	{
		if(!isValueEmpty())
		{
			text += "c ";
			U_CompactPriceToStr(text, m_value, *m_decDigits, '\0', *m_comma, '\0', *m_truncate);
		}
	}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override;
};
/*
class TGUI_API SecurityBorrowSizeRowValue : public SecurityUIntOrdinalRowValue
{
public:
	SecurityBorrowSizeRowValue(const Security* const& security, const unsigned int& ordinal, bool useEmptyValue = true, bool useTick = true):SecurityUIntOrdinalRowValue(security, &Security::GetBorrowSize, ordinal, useEmptyValue, useTick){}
	DECLARE_NED_NEW
};
*/
class TGUI_API SecurityDateRowValue : public DateRowValue
{
public:
	typedef const ValueType& (Security::*UIntFunction)() const;
	SecurityDateRowValue(const Security* const& security, UIntFunction uintFunction):m_security(security),m_uintFunction(uintFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	UIntFunction m_uintFunction;
};

class TGUI_API SecurityFullYearDateRowValue : public FullYearDateRowValue
{
public:
	typedef const ValueType& (Security::*UIntFunction)() const;
	SecurityFullYearDateRowValue(const Security* const& security, UIntFunction uintFunction):m_security(security),m_uintFunction(uintFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	UIntFunction m_uintFunction;
};


class TGUI_API SecurityPriceAsUInt64RowValue : public PriceAsUInt64RowValue
{
public:
//	typedef unsigned __int64& (Security::*UInt64Function)() const;
	typedef ValueType& (Security::*UInt64Function)() const;
	SecurityPriceAsUInt64RowValue(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, UInt64Function uint64Function, bool useEmptyValue = true, bool useTick = true):
		PriceAsUInt64RowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_security(security),
		m_uint64Function(uint64Function){}
	virtual const unsigned __int64& GetObjectValue() const override{return (m_security->*m_uint64Function)();}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	UInt64Function m_uint64Function;
};

class TGUI_API SecurityCompactPriceRowValue : public CompactPriceRowValue
{
public:
	typedef const ValueType& (Security::*PriceFunction)() const;
	SecurityCompactPriceRowValue(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true):
		CompactPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_security(security),
		m_priceFunction(priceFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_priceFunction)();}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	PriceFunction m_priceFunction;
};

/*
class TGUI_API SecurityPriceAsUIntRowValue : public PriceAsUIntRowValue
{
public:
	typedef unsigned int& (Security::*UIntFunction)() const;
	SecurityPriceAsUIntRowValue(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true):
		PriceAsUIntRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_security(security),
		m_uintFunction(uintFunction){}
	virtual const unsigned int& GetObjectValue() const override{return (m_security->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	UIntFunction m_uintFunction;
};

class TGUI_API SecurityPriceAsConstUIntRowValue : public PriceAsUIntRowValue
{
public:
	typedef const unsigned int& (Security::*UIntFunction)() const;
	SecurityPriceAsConstUIntRowValue(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true):
		PriceAsUIntRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_security(security),
		m_uintFunction(uintFunction){}
	virtual const unsigned int& GetObjectValue() const override{return (m_security->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	UIntFunction m_uintFunction;
};
*/
class TGUI_API SecurityPriceRowValue : public PriceRowValue
{
public:
	typedef const ValueType& (Security::*PriceFunction)() const;
	SecurityPriceRowValue(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true):
		PriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_security(security),
		m_priceFunction(priceFunction){}
	virtual const Price& GetObjectValue() const override{return (m_security->*m_priceFunction)();}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	PriceFunction m_priceFunction;
};

class TGUI_API SecurityChartPriceRowValue : public PriceRowValue
{
public:
	typedef const ValueType& (SecurityChartRow::*PriceFunction)() const;
	SecurityChartPriceRowValue(const SecurityChartRow* const& securityChartRow, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true):
		PriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_securityChartRow(securityChartRow),
		m_priceFunction(priceFunction){}
	virtual const Price& GetObjectValue() const override{return (m_securityChartRow->*m_priceFunction)();}
	DECLARE_NED_NEW
protected:
	const SecurityChartRow* m_securityChartRow;
	PriceFunction m_priceFunction;
};

class TGUI_API SecuritySignedPriceRowValue : public SignedPriceRowValue
{
public:
	typedef const ValueType& (Security::*SignedPriceFunction)() const;
	SecuritySignedPriceRowValue(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, SignedPriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		SignedPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick, useNeutralColor),
		m_security(security),
		m_priceFunction(priceFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_priceFunction)();}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	SignedPriceFunction m_priceFunction;
};

class TGUI_API SecurityCompactSignedPriceRowValue : public CompactSignedPriceRowValue
{
public:
	typedef const ValueType& (Security::*SignedPriceFunction)() const;
	SecurityCompactSignedPriceRowValue(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, SignedPriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true):
		CompactSignedPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_security(security),
		m_priceFunction(priceFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_priceFunction)();}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	SignedPriceFunction m_priceFunction;
};

class TGUI_API SecurityPriceXInt : public MoneyRowValue
{
public:
	typedef const Price& (Security::*PriceFunction)() const;
	typedef const int& (Security::*IntFunction)() const;
	SecurityPriceXInt(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, IntFunction intFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_number(0),
		m_priceFunction(priceFunction),
		m_intFunction(intFunction)
	{
	}
//	virtual bool CanBeNegative() const{return false;}
	virtual int CalculateNumber(const int& number) const{return number;}

	Money CalculateValue() const
	{
		const int number = (m_security->*m_intFunction)();
		if(number)
		{
			const Price& price = (m_security->*m_priceFunction)();
			if(!price.isZero())
			{
				return price * CalculateNumber(number);
			}
		}
		return Money::moneyZero;
	}
	Money DeriveValue() const
	{
		if(m_number && !m_price.isZero())
		{
			return m_price * CalculateNumber(m_number);
		}
		return Money::moneyZero;
	}

	virtual bool isValueChanged() const override{return m_number != (m_security->*m_intFunction)() || m_price != (m_security->*m_priceFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_number = (m_security->*m_intFunction)();
		m_price = (m_security->*m_priceFunction)();
		return SetValue(DeriveValue());
	}

	virtual bool isObjectValueZero() const override{return (m_security->*m_priceFunction)().isZero() || !(m_security->*m_intFunction)();}
//	virtual bool isValueZero() const{return m_value.isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_price = (m_security->*m_priceFunction)();
		m_number = (m_security->*m_intFunction)();
		m_value = m_price * CalculateNumber(m_number);
	}
	const Security* m_security;
	Price m_price;
	int m_number;
	PriceFunction m_priceFunction;
	IntFunction m_intFunction;
};

class TGUI_API SecurityPriceXIntAbs : public SecurityPriceXInt
{
public:
//	typedef const Price& (Security::*PriceFunction)() const;
//	typedef const int& (Security::*IntFunction)() const;
	SecurityPriceXIntAbs(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, IntFunction intFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		SecurityPriceXInt(security, comma, decDigits, truncate, priceFunction, intFunction, useEmptyValue, useTick, useNeutralColor)
	{
	}
	virtual bool CanBeNegative() const override{return false;}
	virtual int CalculateNumber(const int& number) const override{return number < 0 ? -number : number;}
	DECLARE_NED_NEW
/*
	Money CalculateValue() const
	{
		const int number = (m_security->*m_intFunction)();
		if(number)
		{
			const Price& price = (m_security->*m_priceFunction)();
			if(!price.isZero())
			{
				return price * (unsigned int))(number < 0 ? -number : number);
			}
		}
		return Money::moneyZero;
	}
	Money DeriveValue() const
	{
		if(m_number && !m_price.isZero())
		{
			return m_price * (unsigned int)(m_number < 0 ? -m_number : m_number);
		}
		return Money::moneyZero;
	}

//	virtual bool isValueChanged() const;//{return m_number != (m_security->*m_intFunction)() || m_price != (m_security->*m_priceFunction)();}
//	virtual bool isObjectValueEmpty() const;//{return (m_security->*m_priceFunction)().isZero() || !(m_security->*m_intFunction)();}
//	virtual bool isValueEmpty() const{return m_value.isZero();}

	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_number = (m_security->*m_intFunction)();
		m_price = (m_security->*m_priceFunction)();
		return SetValue(DeriveValue());
	}

	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_price = (m_security->*m_priceFunction)();
		m_number = (m_security->*m_intFunction)();
		m_value = m_price * (m_number < 0 ? -m_number : m_number);
	}
*/
};

class TGUI_API SecurityCompactPriceXUInt : public MoneyRowValue
{
public:
	typedef const unsigned int& (Security::*PriceFunction)() const;
	typedef const unsigned int& (Security::*UIntFunction)() const;
	SecurityCompactPriceXUInt(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_price(0),
		m_number(0),
		m_priceFunction(priceFunction),
		m_uintFunction(uintFunction)
	{
	}
	virtual bool CanBeNegative() const override{return false;}

	Money CalculateValue() const
	{
		const int unsigned number = (m_security->*m_uintFunction)();
		if(number)
		{
			const unsigned int price = (m_security->*m_priceFunction)();
			if(price)
			{
				return Price(price) * number;
			}
		}
		return Money::moneyZero;
	}
	Money DeriveValue() const
	{
		if(m_number && m_price)
		{
			return Price(m_price) * m_number;
		}
		return Money::moneyZero;
	}

	virtual bool isValueChanged() const override{return m_number != (m_security->*m_uintFunction)() || m_price != (m_security->*m_priceFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_number = (m_security->*m_uintFunction)();
		m_price = (m_security->*m_priceFunction)();
		return SetValue(DeriveValue());
	}

	virtual bool isObjectValueZero() const override{return !(m_security->*m_priceFunction)() || !(m_security->*m_uintFunction)();}
//	virtual bool isValueZero() const{return m_value.isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_price = (m_security->*m_priceFunction)();
		m_number = (m_security->*m_uintFunction)();
		m_value = DeriveValue();// m_price * m_number;
	}
	const Security* m_security;
	unsigned int m_price;
	unsigned int m_number;
	PriceFunction m_priceFunction;
	UIntFunction m_uintFunction;
};


class TGUI_API SecurityUIntByUIntDivision : public MoneyRowValue
{
public:
	typedef const unsigned int& (Security::*UIntFunction)() const;
	SecurityUIntByUIntDivision(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, UIntFunction uintFunction, UIntFunction uintFunction2, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_numerator(0),
		m_denominator(0),
		m_uintFunction(uintFunction),
		m_uintFunction2(uintFunction2)
	{
	}
	virtual bool CanBeNegative() const override{return false;}
	Money CalculateValue() const
	{
		const unsigned int denominator = (m_security->*m_uintFunction2)();
		if(denominator)
		{
			unsigned int numerator = (m_security->*m_uintFunction)();
			Money value((__int64)numerator * 100, 0);
			value /= denominator;
			return value;
		}
		return Money::moneyZero;
	}
	Money DeriveValue() const
	{
		if(m_denominator && m_numerator)
		{
			Money value((__int64)m_numerator * 100, 0);
			value /= m_denominator;
			return value;
		}
		return Money::moneyZero;
	}
	virtual bool isValueChanged() const override{return m_numerator != (m_security->*m_uintFunction)() || m_denominator != (m_security->*m_uintFunction2)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_numerator = (m_security->*m_uintFunction)();
		m_denominator = (m_security->*m_uintFunction2)();
		return SetValue(DeriveValue());
	}

	virtual bool isObjectValueZero() const override{return !(m_security->*m_uintFunction)() || !(m_security->*m_uintFunction2)();}
	virtual bool isValueZero() const override{return !m_numerator || !m_denominator;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_numerator = (m_security->*m_uintFunction)();
		m_denominator = (m_security->*m_uintFunction2)();
		m_value = DeriveValue();
	}
	const Security* m_security;
	int m_numerator;
	unsigned int m_denominator;
	UIntFunction m_uintFunction;
	UIntFunction m_uintFunction2;
};

class TGUI_API SecurityIntByIntDivision : public MoneyRowValue
{
public:
	typedef const int& (Security::*IntFunction)() const;
	SecurityIntByIntDivision(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, IntFunction intFunction, IntFunction intFunction2, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_numerator(0),
		m_denominator(0),
		m_intFunction(intFunction),
		m_intFunction2(intFunction2)
	{
	}
	Money CalculateValue() const
	{
		const int denominator = (m_security->*m_intFunction2)();
		if(denominator)
		{
			int numerator = (m_security->*m_intFunction)();
			Money value((__int64)numerator * 100, 0);
			value /= denominator;
			return value;
		}
		return Money::moneyZero;
	}
	Money DeriveValue() const
	{
		if(m_denominator && m_numerator)
		{
			Money value((__int64)m_numerator * 100, 0);
			value /= m_denominator;
			return value;
		}
		return Money::moneyZero;
	}
	virtual bool isValueChanged() const override{return m_numerator != (m_security->*m_intFunction)() || m_denominator != (m_security->*m_intFunction2)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override{m_numerator = (m_security->*m_intFunction)();m_denominator = (m_security->*m_intFunction2)();return SetValue(DeriveValue());}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_intFunction)() || !(m_security->*m_intFunction2)();}
	virtual bool isValueZero() const override{return !m_numerator || !m_denominator;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_numerator = (m_security->*m_intFunction)();m_denominator = (m_security->*m_intFunction2)();m_value = DeriveValue();}
	const Security* m_security;
	int m_numerator;
	int m_denominator;
	IntFunction m_intFunction;
	IntFunction m_intFunction2;
};

class TGUI_API SecurityIntByIntDivisionFraction : public SecurityIntByIntDivision
{
public:
	SecurityIntByIntDivisionFraction(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, IntFunction intFunction, IntFunction intFunction2, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		SecurityIntByIntDivision(security, comma, decDigits, truncate, intFunction, intFunction2, useEmptyValue, useTick, useNeutralColor)
	{
	}
	Money CalculateValue() const
	{
		const int denominator = (m_security->*m_intFunction2)();
		if(denominator)
		{
			int numerator = (m_security->*m_intFunction)();
			Money value(numerator, 0);
			value /= denominator;
			return value;
		}
		return Money::moneyZero;
	}
	Money DeriveValue() const
	{
		if(m_denominator && m_numerator)
		{
			Money value(m_numerator, 0);
			value /= m_denominator;
			return value;
		}
		return Money::moneyZero;
	}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_numerator = (m_security->*m_intFunction)();
		m_denominator = (m_security->*m_intFunction2)();
		return SetValue(DeriveValue());
	}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_numerator = (m_security->*m_intFunction)();
		m_denominator = (m_security->*m_intFunction2)();
		m_value = DeriveValue();
	}
};
/////
class TGUI_API SecurityUIntByIntDivisionNegative : public MoneyRowValue
{
public:
	typedef const unsigned int& (Security::*UIntFunction)() const;
	typedef const int& (Security::*IntFunction)() const;
	SecurityUIntByIntDivisionNegative(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, UIntFunction uintFunction, IntFunction intFunction2, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_numerator(0),
		m_denominator(0),
		m_uintFunction(uintFunction),
		m_intFunction2(intFunction2)
	{
	}
	virtual Money CalculateValue() const
	{
		const int denominator = (m_security->*m_intFunction2)();
		if(denominator)
		{
			unsigned int numerator = (m_security->*m_uintFunction)();
			Money value((__int64)numerator * 100, 0);
			value /= denominator;
			return value;
		}
		return Money::moneyZero;
	}
	virtual Money DeriveValue() const
	{
		if(m_denominator && m_numerator)
		{
			Money value((__int64)m_numerator * 100, 0);
			value /= m_denominator;
			return value;
		}
		return Money::moneyZero;
	}
	virtual bool isValueChanged() const override{return m_numerator != (m_security->*m_uintFunction)() || m_denominator != (m_security->*m_intFunction2)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue()
	{
		m_numerator = (m_security->*m_uintFunction)();
		m_denominator = (m_security->*m_intFunction2)();
		return SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_intFunction2)() || !(m_security->*m_uintFunction)();}
	virtual bool isValueZero() const override{return !m_numerator || !m_denominator;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_numerator = (m_security->*m_uintFunction)();
		m_denominator = (m_security->*m_intFunction2)();
		m_value = DeriveValue();
	}
	const Security* m_security;
	unsigned int m_numerator;
	int m_denominator;
	UIntFunction m_uintFunction;
	IntFunction m_intFunction2;
};

class TGUI_API SecurityUIntByIntDivision : public SecurityUIntByIntDivisionNegative
{
public:
	SecurityUIntByIntDivision(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, UIntFunction uintFunction, IntFunction intFunction2, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		SecurityUIntByIntDivisionNegative(security, comma, decDigits, truncate, uintFunction, intFunction2, useEmptyValue, useTick, useNeutralColor)
	{
	}
	virtual bool CanBeNegative() const override{return false;}
	virtual Money CalculateValue() const override
	{
		const int denominator = (m_security->*m_intFunction2)();
		if(denominator)
		{
			unsigned int numerator = (m_security->*m_uintFunction)();
			Money value((__int64)(numerator) * 100, 0);
			value /= (denominator > 0 ? denominator : -denominator);
			return value;
		}
		return Money::moneyZero;
	}
	virtual Money DeriveValue() const override
	{
		if(m_denominator && m_numerator)
		{
			Money value((__int64)m_numerator * 100, 0);
			value /= (m_denominator > 0 ? m_denominator : -m_denominator);
			return value;
		}
		return Money::moneyZero;
	}
	DECLARE_NED_NEW
};

class TGUI_API SecurityUIntByIntDivisionFraction : public SecurityUIntByIntDivision
{
public:
	SecurityUIntByIntDivisionFraction(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, UIntFunction uintFunction, IntFunction intFunction2, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = true):
		SecurityUIntByIntDivision(security, comma, decDigits, truncate, uintFunction, intFunction2, useEmptyValue, useTick, useNeutralColor)
	{
	}
	virtual Money CalculateValue() const override
	{
		int denominator = (m_security->*m_intFunction2)();
		if(denominator)
		{
			const unsigned int numerator = (m_security->*m_uintFunction)();
			Money value(numerator, 0);
			value /= (denominator > 0 ? denominator : -denominator);
			return value;
		}
		return Money::moneyZero;
	}
	virtual Money DeriveValue() const override
	{
		if(m_denominator && m_numerator)
		{
			Money value(m_numerator, 0);
			value /= (m_denominator > 0 ? m_denominator : -m_denominator);
			return value;
		}
		return Money::moneyZero;
	}
	DECLARE_NED_NEW
};

//////////
class TGUI_API SecurityIntByUIntDivisionNegative : public MoneyRowValue
{
public:
	typedef const int& (Security::*IntFunction)() const;
	typedef const unsigned int& (Security::*UIntFunction)() const;
	SecurityIntByUIntDivisionNegative(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, IntFunction intFunction, UIntFunction uintFunction2, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_numerator(0),
		m_denominator(0),
		m_intFunction(intFunction),
		m_uintFunction2(uintFunction2)
	{
	}

	virtual unsigned int GetNumerator(int numerator) const{return numerator;}

	inline Money CalculateFromValues(const int& numerator, const unsigned int& denominator) const
	{
		if(denominator && numerator)
		{
			Money value((__int64)GetNumerator(numerator) * 100, 0);
			value /= denominator;
			return value;
		}
		return Money::moneyZero;
	}
	inline Money CalculateValue() const
	{
		return CalculateFromValues((m_security->*m_intFunction)(), (m_security->*m_uintFunction2)());
	}
	inline Money DeriveValue() const
	{
		return CalculateFromValues(m_numerator, m_denominator);
	}
	virtual bool isValueChanged() const override{return m_numerator != (m_security->*m_intFunction)() || m_denominator != (m_security->*m_uintFunction2)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_numerator = (m_security->*m_intFunction)();
		m_denominator = (m_security->*m_uintFunction2)();
		return SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_intFunction)() || !(m_security->*m_uintFunction2)();}
	virtual bool isValueZero() const override{return !m_numerator || !m_denominator;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_numerator = (m_security->*m_intFunction)();
		m_denominator = (m_security->*m_uintFunction2)();
		m_value = DeriveValue();
	}

	const Security* m_security;
	int m_numerator;
	unsigned int m_denominator;
	IntFunction m_intFunction;
	UIntFunction m_uintFunction2;
};

class TGUI_API SecurityIntByUIntPlusIntDivisionPositive : public MoneyRowValue
{
public:
	typedef const int& (Security::*IntFunction)() const;
	typedef const unsigned int& (Security::*UIntFunction)() const;
	SecurityIntByUIntPlusIntDivisionPositive(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, IntFunction intFunction, UIntFunction uintFunction2, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_numerator(0),
		m_denominator(0),
		m_intFunction(intFunction),
		m_uintFunction2(uintFunction2)
	{
	}
	virtual bool CanBeNegative() const override{return false;}
	virtual Money CalculateValue() const
	{
		__int64 numerator = (m_security->*m_intFunction)();
		if(numerator)
		{
			if(numerator < 0)
			{
				numerator = -numerator;
			}
			Money value(numerator * 100, 0);
			value /= (numerator + (__int64)(m_security->*m_uintFunction2)());
			return value;
		}
		return Money::moneyZero;
	}
	virtual Money DeriveValue() const
	{
		if(m_numerator)
		{
			const __int64 numerator = m_numerator > 0 ? m_numerator : -m_numerator;
			Money value(numerator * 100, 0);
			value /= (numerator + (__int64)m_denominator);
			return value;
		}
		return Money::moneyZero;
	}
	virtual bool isValueChanged() const override{return m_numerator != (m_security->*m_intFunction)() || m_denominator != (m_security->*m_uintFunction2)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override{m_numerator = (m_security->*m_intFunction)();m_denominator = (m_security->*m_uintFunction2)();return SetValue(DeriveValue());}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_intFunction)();}// || !(m_security->*m_uintFunction2)();}
	virtual bool isValueZero() const override{return !m_numerator;}// || !m_denominator;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_numerator = (m_security->*m_intFunction)();m_denominator = (m_security->*m_uintFunction2)();m_value = DeriveValue();}
	const Security* m_security;
	int m_numerator;
	unsigned int m_denominator;
	IntFunction m_intFunction;
	UIntFunction m_uintFunction2;
};

class TGUI_API SecurityIntByUIntDivision : public SecurityIntByUIntDivisionNegative
{
public:
	SecurityIntByUIntDivision(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, IntFunction intFunction, UIntFunction uintFunction2, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		SecurityIntByUIntDivisionNegative(security, comma, decDigits, truncate, intFunction, uintFunction2, useEmptyValue, useTick, useNeutralColor)
	{
	}
	virtual bool CanBeNegative() const override{return false;}
	virtual unsigned int GetNumerator(int numerator) const override{return numerator < 0 ? -numerator : numerator;}
	DECLARE_NED_NEW
};

class TGUI_API SecurityIntByUInt64Division : public MoneyRowValue
{
public:
	typedef const int& (Security::*IntFunction)() const;
	typedef const unsigned __int64& (Security::*UInt64Function)() const;
	SecurityIntByUInt64Division(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, IntFunction intFunction, UInt64Function uint64Function2, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_numerator(0),
		m_denominator(0),
		m_intFunction(intFunction),
		m_uint64Function2(uint64Function2)
	{
	}
	virtual bool CanBeNegative() const override{return false;}
//	virtual
	Money CalculateValue(const int& numerator, const unsigned __int64& denominator) const
	{
		if(numerator && denominator)
		{
			Money value((__int64)(numerator < 0 ? -numerator : numerator) * 100, 0);
			value /= denominator;
			return value;
		}
		return Money::moneyZero;
	}

	Money CalculateValue() const
	{
		return CalculateValue((m_security->*m_intFunction)(), (m_security->*m_uint64Function2)());
/*
		const unsigned __int64 denominator = (m_security->*m_uint64Function2)();
		if(denominator)
		{
			const int numerator = (m_security->*m_intFunction)();
			Money value((__int64)(numerator < 0 ? -numerator : numerator) * 100, 0);
			value /= denominator;
			return value;
		}
		return Money::moneyZero;
*/
	}
	Money DeriveValue() const
	{
		return CalculateValue(m_numerator, m_denominator);
/*
		if(m_denominator && m_numerator)
		{
			Money value((__int64)(m_numerator < 0 ? -m_numerator : m_numerator) * 100, 0);
			value /= m_denominator;
			return value;
		}
		return Money::moneyZero;
*/
	}
	virtual bool isValueChanged() const override{return m_numerator != (m_security->*m_intFunction)() || m_denominator != (m_security->*m_uint64Function2)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_numerator = (m_security->*m_intFunction)();
		m_denominator = (m_security->*m_uint64Function2)();
		return SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_intFunction)() || !(m_security->*m_uint64Function2)();}
	virtual bool isValueZero() const override{return m_numerator == 0 || m_denominator == 0;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_numerator = (m_security->*m_intFunction)();
		m_denominator = (m_security->*m_uint64Function2)();
		m_value = DeriveValue();
	}
	const Security* m_security;
	int m_numerator;
	unsigned __int64 m_denominator;
	IntFunction m_intFunction;
	UInt64Function m_uint64Function2;
};
/*
class TGUI_API SecurityIntByUInt64DivisionFraction : public SecurityIntByUInt64Division
{
public:
	SecurityIntByUInt64DivisionFraction(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, IntFunction intFunction, UInt64Function uint64Function2, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		SecurityIntByUInt64Division(security, comma, decDigits, truncate, intFunction, uint64Function2, useEmptyValue, useTick, useNeutralColor)
	{
	}
	virtual Money CalculateValue(const int& numerator, const unsigned __int64& denominator) const override
	{
		if(numerator && denominator)
		{
			Money value((__int64)(numerator < 0 ? -numerator : numerator), 0);
			value /= denominator;
			return value;
		}
		return Money::moneyZero;
	}
};
*/
class TGUI_API SecurityPriceAsUIntByPriceDivision : public MoneyRowValue
{
public:
	typedef const unsigned int& (Security::*PriceAsUIntFunction)() const;
	typedef const Price& (Security::*PriceFunction)() const;
	SecurityPriceAsUIntByPriceDivision(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceAsUIntFunction priceAsUIntFunction, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_priceAsUInt(0),
		m_priceAsUIntFunction(priceAsUIntFunction),
		m_priceFunction(priceFunction)
	{
	}
	virtual bool CanBeNegative() const override{return false;}
	virtual Money DeriveValue(const unsigned int& priceAsUInt, const Price& price) const
	{
		if(priceAsUInt != 0 && !price.isZero())
		{
			Price p(priceAsUInt);
			Money value(p);
			if(DivideMoneyByPrice(value, price))return value;
		}
		return Money::moneyZero;
	}
	Money DeriveValueFromComponents() const{return DeriveValue(m_priceAsUInt, m_price);}
	Money CalculateValue() const{return DeriveValue((m_security->*m_priceAsUIntFunction)(), (m_security->*m_priceFunction)());}
	virtual bool isValueChanged() const override{return m_priceAsUInt != (m_security->*m_priceAsUIntFunction)() || m_price != (m_security->*m_priceFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_priceAsUInt = (m_security->*m_priceAsUIntFunction)();
		m_price = (m_security->*m_priceFunction)();
		return SetValue(DeriveValueFromComponents());
	}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_priceAsUIntFunction)() || (m_security->*m_priceFunction)().isZero();}
	virtual bool isValueZero() const override{return m_price.isZero() || !m_priceAsUInt;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_priceAsUInt = (m_security->*m_priceAsUIntFunction)();
		m_price = (m_security->*m_priceFunction)();
		m_value = DeriveValueFromComponents();
	}
	const Security* m_security;
	unsigned int m_priceAsUInt;
	Price m_price;
	PriceAsUIntFunction m_priceAsUIntFunction;
	PriceFunction m_priceFunction;
};

class TGUI_API SecurityPriceDiffByPriceAsUIntDivision : public MoneyRowValue
{
public:
//	typedef unsigned int (Security::*PriceAsUIntFunction)() const;
	typedef const unsigned int& (Security::*PriceAsUIntFunction)() const;
	typedef const Price& (Security::*PriceFunction)() const;
	SecurityPriceDiffByPriceAsUIntDivision(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceAsUIntFunction priceAsUIntFunction, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_priceAsUInt(0),
		m_priceAsUIntFunction(priceAsUIntFunction),
		m_priceFunction(priceFunction)
//		m_absValue(absValue)
	{
	}
//	virtual bool CanBeNegative() const{return !m_absValue;}
	virtual Money DeriveValue(const unsigned int& priceAsUInt, const Price& price) const
	{
		if(priceAsUInt != 0 && !price.isZero())
		{
			Price p(priceAsUInt);
			Money value(p - price);
			if(DivideMoneyByPrice(value, price))return value;
		}
		return Money::moneyZero;
	}
	Money DeriveValueFromComponents() const{return DeriveValue(m_priceAsUInt, m_price);}
	Money CalculateValue() const{return DeriveValue((m_security->*m_priceAsUIntFunction)(), (m_security->*m_priceFunction)());}
	virtual bool isValueChanged() const override{return m_priceAsUInt != (m_security->*m_priceAsUIntFunction)() || m_price != (m_security->*m_priceFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_priceAsUInt = (m_security->*m_priceAsUIntFunction)();
		m_price = (m_security->*m_priceFunction)();
		return SetValue(DeriveValueFromComponents());
	}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_priceAsUIntFunction)() || (m_security->*m_priceFunction)().isZero();}
	virtual bool isValueZero() const override{return m_price.isZero() || !m_priceAsUInt;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_priceAsUInt = (m_security->*m_priceAsUIntFunction)();
		m_price = (m_security->*m_priceFunction)();
		m_value = DeriveValueFromComponents();
	}
	const Security* m_security;
	unsigned int m_priceAsUInt;
	Price m_price;
	PriceAsUIntFunction m_priceAsUIntFunction;
	PriceFunction m_priceFunction;
//	bool m_absValue;
};

class TGUI_API SecurityAbsPriceDiffByPriceAsUIntDivision : public SecurityPriceDiffByPriceAsUIntDivision
{
public:
	SecurityAbsPriceDiffByPriceAsUIntDivision(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceAsUIntFunction priceAsUIntFunction, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		SecurityPriceDiffByPriceAsUIntDivision(security, comma, decDigits, truncate, priceAsUIntFunction, priceFunction, useEmptyValue, useTick, useNeutralColor)
	{
	}
	virtual bool CanBeNegative() const{return false;}
	virtual Money DeriveValue(const unsigned int& priceAsUInt, const Price& price) const
	{
		if(priceAsUInt != 0 && !price.isZero())
		{
			Price p(priceAsUInt);
			Money value(price < p ? p - price : price - p);
			if(DivideMoneyByPrice(value, price))return value;
		}
		return Money::moneyZero;
	}
	DECLARE_NED_NEW
};

class TGUI_API SecurityPriceDiffByPriceAsUIntDivisionByUInt : public SecurityPriceDiffByPriceAsUIntDivision
{
public:
	SecurityPriceDiffByPriceAsUIntDivisionByUInt(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceAsUIntFunction priceAsUIntFunction, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		SecurityPriceDiffByPriceAsUIntDivision(security, comma, decDigits, truncate, priceAsUIntFunction, priceFunction, useEmptyValue, useTick, useNeutralColor)
	{
	}
	virtual Money DeriveValue(const unsigned int& priceAsUInt, const Price& price) const
	{
		if(priceAsUInt != 0 && !price.isZero())
		{
			Price p(priceAsUInt);
	//		Money value(p < price || !m_absValue ? price - p : p - price);
			Money value(price - p);
			if(DivideMoneyByPrice(value, p))return value;
		}
		return Money::moneyZero;
	}
	DECLARE_NED_NEW
};

class TGUI_API SecurityAbsPriceDiffByPriceAsUIntDivisionByUInt : public SecurityPriceDiffByPriceAsUIntDivision
{
public:
	SecurityAbsPriceDiffByPriceAsUIntDivisionByUInt(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceAsUIntFunction priceAsUIntFunction, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		SecurityPriceDiffByPriceAsUIntDivision(security, comma, decDigits, truncate, priceAsUIntFunction, priceFunction, useEmptyValue, useTick, useNeutralColor)
	{
	}
	virtual bool CanBeNegative() const{return false;}
	virtual Money DeriveValue(const unsigned int& priceAsUInt, const Price& price) const
	{
		if(priceAsUInt != 0 && !price.isZero())
		{
			Price p(priceAsUInt);
			Money value(p < price ? price - p : p - price);
			if(DivideMoneyByPrice(value, p))return value;
		}
		return Money::moneyZero;
	}
	DECLARE_NED_NEW
};

class TGUI_API SecurityPriceReversedDiffByPriceAsUIntDivisionByUInt : public SecurityPriceDiffByPriceAsUIntDivision
{
public:
	SecurityPriceReversedDiffByPriceAsUIntDivisionByUInt(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceAsUIntFunction priceAsUIntFunction, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		SecurityPriceDiffByPriceAsUIntDivision(security, comma, decDigits, truncate, priceAsUIntFunction, priceFunction, useEmptyValue, useTick, useNeutralColor)
	{
	}
	virtual Money DeriveValue(const unsigned int& priceAsUInt, const Price& price) const
	{
		if(priceAsUInt != 0 && !price.isZero())
		{
			Price p(priceAsUInt);
	//		Money value(p < price || !m_absValue ? price - p : p - price);
			Money value(p - price);
			if(DivideMoneyByPrice(value, p))return value;
		}
		return Money::moneyZero;
	}
	DECLARE_NED_NEW
};

//Instead Use SecurityPriceDiffByPriceAsUIntDivisionByUInt or SecurityAbsPriceDiffByPriceAsUIntDivisionByUInt
/*
class TGUI_API SecurityPriceDiffByOnePriceAsUIntDivision : public MoneyRowValue
{
public:
	typedef unsigned int (Security::*PriceAsUIntFunction)() const;
	typedef const Price& (Security::*PriceFunction)() const;
	SecurityPriceDiffByOnePriceAsUIntDivision(bool absValue, const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceAsUIntFunction priceAsUIntFunction, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_priceAsUIntFunction(priceAsUIntFunction),
		m_priceFunction(priceFunction),
		m_absValue(absValue)
	{
	}
	virtual bool CanBeNegative() const{return !m_absValue;}
//	Money DeriveValue(const unsigned int& priceAsUInt, const Price& price) const;
	virtual Money DeriveValue(const unsigned int& priceAsUInt, const Price& price) const;
	Money DeriveValueFromComponents() const;//{return DeriveValue(m_priceAsUInt, m_price);}
	Money CalculateValue() const;//{return DeriveValue((m_security->*m_priceAsUIntFunction)(), (m_security->*m_priceFunction)());}
	virtual bool isValueChanged() const;//{return m_priceAsUInt != (m_security->*m_priceAsUIntFunction)() || m_price != (m_security->*m_priceFunction)();}
	virtual short CompareAhead(const RowValue& other) const;//{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue();//{m_priceAsUInt = (m_security->*m_priceAsUIntFunction)();m_price = (m_security->*m_priceFunction)();return SetValue(DeriveValue());}
	virtual bool isObjectValueZero() const;//{return (m_security->*m_priceAsUIntFunction)() == 0 || (m_security->*m_priceFunction)().isZero();}
	virtual bool isValueZero() const;//{return m_price.isZero() || m_priceAsUInt == 0;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue();//{m_priceAsUInt = (m_security->*m_priceAsUIntFunction)();m_price = (m_security->*m_priceFunction)();m_value = DeriveValue();}
	const Security* m_security;
	unsigned int m_priceAsUInt;
	Price m_price;
	PriceAsUIntFunction m_priceAsUIntFunction;
	PriceFunction m_priceFunction;
	bool m_absValue;
};
*/
class TGUI_API SecurityPriceDiffByOnePriceAsUIntDivisionAsInt : public MoneyRowValue
{
public:
	typedef const int& (Security::*IntFunction)() const;
//	typedef unsigned int (Security::*PriceAsUIntFunction)() const;
	typedef const unsigned int& (Security::*PriceAsUIntFunction)() const;
	typedef const Price& (Security::*PriceFunction)() const;
	SecurityPriceDiffByOnePriceAsUIntDivisionAsInt(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceAsUIntFunction priceAsUIntFunction, PriceAsUIntFunction priceAsUIntFunction2, PriceFunction priceFunction, IntFunction intFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_intPositive(true),
		m_priceAsUIntFunction(priceAsUIntFunction),
		m_priceAsUIntFunction2(priceAsUIntFunction2),
		m_priceFunction(priceFunction),
		m_intFunction(intFunction)
//		m_absValue(absValue)
	{
	}
	virtual bool CanBeNegative() const{return false;}//!m_absValue;}
	Money DeriveValue(const bool& intPositive, const unsigned int& priceAsUInt, const unsigned int& priceAsUInt2, const Price& price) const
	{
		const unsigned int& puint = intPositive ? priceAsUInt2 : priceAsUInt;
		if(puint != 0 && !price.isZero())
		{
			Price p(puint);
//			Money value(p < price || !m_absValue ? price - p : p - price);
			Money value(price.GetAbsDiff(p));
			if(DivideMoneyByPrice(value, p))return value;
		}
		return Money::moneyZero;
	}
	Money DeriveValue() const{return DeriveValue(m_intPositive, m_priceAsUInt, m_priceAsUInt2, m_price);}
	Money CalculateValue() const{return DeriveValue((m_security->*m_intFunction)() >= 0, (m_security->*m_priceAsUIntFunction)(), (m_security->*m_priceAsUIntFunction2)(), (m_security->*m_priceFunction)());}
	virtual bool isValueChanged() const override
	{
		if(m_price != (m_security->*m_priceFunction)())
		{
			return true;
		}
		if(m_intPositive != (m_security->*m_intFunction)() >= 0)
		{
			return true;
		}
		return m_intPositive ? m_priceAsUInt2 != (m_security->*m_priceAsUIntFunction2)() : m_priceAsUInt != (m_security->*m_priceAsUIntFunction)();
	}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_intPositive = (m_security->*m_intFunction)() >= 0;
		m_priceAsUInt = (m_security->*m_priceAsUIntFunction)();
		m_priceAsUInt2 = (m_security->*m_priceAsUIntFunction2)();
		m_price = (m_security->*m_priceFunction)();
		return SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return (m_security->*m_priceFunction)().isZero() || !((m_security->*m_intFunction)() >= 0 ? (m_security->*m_priceAsUIntFunction2)() : (m_security->*m_priceAsUIntFunction)());}
	virtual bool isValueZero() const override{return m_price.isZero() || !(m_intPositive ? m_priceAsUInt2 : m_priceAsUInt);}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_intPositive = (m_security->*m_intFunction)() >= 0;
		m_priceAsUInt = (m_security->*m_priceAsUIntFunction)();
		m_priceAsUInt2 = (m_security->*m_priceAsUIntFunction2)();
		m_price = (m_security->*m_priceFunction)();
		m_value = DeriveValue();
	}
	const Security* m_security;
	unsigned int m_priceAsUInt;
	unsigned int m_priceAsUInt2;
	bool m_intPositive;
	Price m_price;
	PriceAsUIntFunction m_priceAsUIntFunction;
	PriceAsUIntFunction m_priceAsUIntFunction2;
	PriceFunction m_priceFunction;
	IntFunction m_intFunction;
//	bool m_absValue;
};

class TGUI_API SecurityPriceDivision : public MoneyRowValue
{
public:
	typedef const SignedPrice& (Security::*SignedPriceFunction)() const;
	typedef const Price& (Security::*PriceFunction)() const;
	SecurityPriceDivision(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, SignedPriceFunction signedPriceFunction, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_signedPriceFunction(signedPriceFunction),
		m_priceFunction(priceFunction)
	{
	}
//	virtual bool CanBeNegative() const{return !m_absValue;}
	Money DeriveValue(const SignedPrice& signedPrice, const Price& price) const
	{
		if(!signedPrice.isZero() && !price.isZero())
		{
			Money value(signedPrice);
			if(DivideMoneyByPrice(value, price))return value;
		}
		return Money::moneyZero;
	}
	Money DeriveValue() const{return DeriveValue(m_signedPrice, m_price);}
	Money CalculateValue() const{return DeriveValue((m_security->*m_signedPriceFunction)(), (m_security->*m_priceFunction)());}
	virtual bool isValueChanged() const override{return m_signedPrice != (m_security->*m_signedPriceFunction)() || m_price != (m_security->*m_priceFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue()
	{
		m_signedPrice = (m_security->*m_signedPriceFunction)();
		m_price = (m_security->*m_priceFunction)();
		return SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return (m_security->*m_priceFunction)().isZero();}
	virtual bool isValueZero() const override{return m_price.isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_signedPrice = (m_security->*m_signedPriceFunction)();
		m_price = (m_security->*m_priceFunction)();
		m_value = DeriveValue();
	}
	const Security* m_security;
	SignedPrice m_signedPrice;
	Price m_price;
	SignedPriceFunction m_signedPriceFunction;
	PriceFunction m_priceFunction;
};

class TGUI_API SecurityPriceDivisionForcedPositive : public MoneyRowValue
{
public:
	typedef const SignedPrice& (Security::*SignedPriceFunction)() const;
	typedef const Price& (Security::*PriceFunction)() const;
	SecurityPriceDivisionForcedPositive(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, SignedPriceFunction signedPriceFunction, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_signedPriceFunction(signedPriceFunction),
		m_priceFunction(priceFunction)
	{
	}
	virtual bool CanBeNegative() const override{return false;}
//	Money DeriveValue(const SignedPrice& signedPrice, const Price& price) const;
	Money DeriveValue(const Price& signedPrice, const Price& price) const
	{
		if(!signedPrice.isZero() && !price.isZero())
		{
			Money value(signedPrice);
			if(DivideMoneyByPrice(value, price))return value;
		}
		return Money::moneyZero;
	}
	Money DeriveValue() const{return DeriveValue(m_signedPrice, m_price);}
	Money CalculateValue() const
	{
		SignedPrice signedPrice = (m_security->*m_signedPriceFunction)();
		if(signedPrice.isNegative())signedPrice.Negate();
		return DeriveValue(Price(signedPrice), (m_security->*m_priceFunction)());
	}
	virtual bool isValueChanged() const override
	{
		if(m_price != (m_security->*m_priceFunction)())
		{
			return true;
		}
		else
		{
			SignedPrice signedPrice = (m_security->*m_signedPriceFunction)();
			if(signedPrice.isNegative())signedPrice.Negate();
			return m_signedPrice != Price(signedPrice);
		}
	}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		SignedPrice signedPrice = (m_security->*m_signedPriceFunction)();
		if(signedPrice.isNegative())signedPrice.Negate();
		m_signedPrice = Price(signedPrice);
		m_price = (m_security->*m_priceFunction)();
		return SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return (m_security->*m_priceFunction)().isZero();}
	virtual bool isValueZero() const override{return m_price.isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		SignedPrice signedPrice = (m_security->*m_signedPriceFunction)();
		if(signedPrice.isNegative())signedPrice.Negate();
		m_signedPrice = Price(signedPrice);
		m_price = (m_security->*m_priceFunction)();
		m_value = DeriveValue();
	}
	const Security* m_security;
//	SignedPrice m_signedPrice;
	Price m_signedPrice;
	Price m_price;
	SignedPriceFunction m_signedPriceFunction;
	PriceFunction m_priceFunction;
};

class TGUI_API SecurityPositivePriceDivision : public MoneyRowValue
{
public:
	typedef const Price& (Security::*PriceFunction)() const;
	SecurityPositivePriceDivision(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction signedPriceFunction, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_signedPriceFunction(signedPriceFunction),
		m_priceFunction(priceFunction)
	{
	}
	virtual bool CanBeNegative() const{return false;}
	Money DeriveValue(const Price& signedPrice, const Price& price) const
	{
		if(!signedPrice.isZero() && !price.isZero())
		{
			Money value(signedPrice);
			if(DivideMoneyByPrice(value, price))return value;
		}
		return Money::moneyZero;
	}
	Money DeriveValue() const{return DeriveValue(m_signedPrice, m_price);}
	Money CalculateValue() const{return DeriveValue((m_security->*m_signedPriceFunction)(), (m_security->*m_priceFunction)());}
	virtual bool isValueChanged() const override{return m_signedPrice != (m_security->*m_signedPriceFunction)() || m_price != (m_security->*m_priceFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_signedPrice = (m_security->*m_signedPriceFunction)();
		m_price = (m_security->*m_priceFunction)();
		return SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return (m_security->*m_priceFunction)().isZero();}
	virtual bool isValueZero() const override{return m_price.isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_signedPrice = (m_security->*m_signedPriceFunction)();
		m_price = (m_security->*m_priceFunction)();
		m_value = DeriveValue();
	}
	const Security* m_security;
	Price m_signedPrice;
	Price m_price;
	PriceFunction m_signedPriceFunction;
	PriceFunction m_priceFunction;
};

class TGUI_API SecurityPriceDiffByOnePriceDivision : public MoneyRowValue
{
public:
	typedef const Price& (Security::*PriceFunction)() const;
	SecurityPriceDiffByOnePriceDivision(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction1, PriceFunction priceFunction2, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_priceFunction1(priceFunction1),
		m_priceFunction2(priceFunction2)
//		m_absValue(absValue)
	{
	}
//	virtual bool CanBeNegative() const{return !m_absValue;}
	virtual void CalculateDifferenceFromComponent(Money& diff, const Price& price1, const Price& price2) const
	{
		diff = Money(price2 - price1);
	}
	Money DeriveValueFromComponents(const Price& price1, const Price& price2) const
	{
		if(!price1.isZero() && !price2.isZero())
		{
			Money diff;
			CalculateDifferenceFromComponent(diff, price1, price2);
			if(DivideMoneyByPrice(diff, price1))return diff;
		}
		return Money::moneyZero;
	}
	Money DeriveValue() const{return DeriveValueFromComponents(m_price1, m_price2);}
	Money CalculateValue() const{return DeriveValueFromComponents((m_security->*m_priceFunction1)(), (m_security->*m_priceFunction2)());}
	virtual bool isValueChanged() const override{return m_price1 != (m_security->*m_priceFunction1)() || m_price2 != (m_security->*m_priceFunction2)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		const Price& price1 = (m_security->*m_priceFunction1)();
		const Price& price2 = (m_security->*m_priceFunction2)();
		bool changed = price1 != m_price1;
		if(changed)m_price1 = price1;
		if(price2 != m_price2)
		{
			changed = true;
			m_price2 = price2;
		}
		return changed && SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return (m_security->*m_priceFunction1)().isZero() || (m_security->*m_priceFunction2)().isZero();}
	virtual bool isValueZero() const override{return m_price1.isZero() || m_price2.isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_price1 = (m_security->*m_priceFunction1)();
		m_price2 = (m_security->*m_priceFunction2)();
		m_value = DeriveValue();
	}
	const Security* m_security;
	Price m_price1;
	Price m_price2;
	PriceFunction m_priceFunction1;
	PriceFunction m_priceFunction2;
//	bool m_absValue;
};

class TGUI_API SecurityPriceDiffByOnePriceDivisionAbs : public SecurityPriceDiffByOnePriceDivision
{
public:
	SecurityPriceDiffByOnePriceDivisionAbs(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction1, PriceFunction priceFunction2, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		SecurityPriceDiffByOnePriceDivision(security, comma, decDigits, truncate, priceFunction1, priceFunction2, useEmptyValue, useTick, useNeutralColor)
	{
	}
	virtual bool CanBeNegative() const override{return false;}
	virtual void CalculateDifferenceFromComponent(Money& diff, const Price& price1, const Price& price2) const override
	{
		diff = Money(price1.GetAbsDiff(price2));
//		diff = Money(price1 < price2 ? price2 - price1 : price1 - price2);
	}
	DECLARE_NED_NEW
};

class TGUI_API SecurityPriceDiffByPriceDivision : public SecurityPriceDiffByOnePriceDivision
{
public:
//	typedef const Price& (Security::*PriceFunction)() const;
	SecurityPriceDiffByPriceDivision(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction1, PriceFunction priceFunction2, PriceFunction priceFunction3, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		SecurityPriceDiffByOnePriceDivision(security, comma, decDigits, truncate, priceFunction1, priceFunction2, useEmptyValue, useTick, useNeutralColor),
		m_priceFunction3(priceFunction3)
	{
	}
	Money DeriveValueFromComponents(const Price& price1, const Price& price2, const Price& priceDenominator) const
	{
		if(!price1.isZero() && !price2.isZero() && !priceDenominator.isZero())
		{
			Money diff;
			CalculateDifferenceFromComponent(diff, price1, price2);
			if(DivideMoneyByPrice(diff, priceDenominator))return diff;
		}
		return Money::moneyZero;
	}
	Money DeriveValue() const{return DeriveValueFromComponents(m_price1, m_price2, m_priceDenominator);}
	Money CalculateValue() const{return DeriveValueFromComponents((m_security->*m_priceFunction1)(), (m_security->*m_priceFunction2)(), (m_security->*m_priceFunction3)());}
	virtual bool isValueChanged() const override{return m_price1 != (m_security->*m_priceFunction1)() || m_price2 != (m_security->*m_priceFunction2)() || m_priceDenominator != (m_security->*m_priceFunction3)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override{CalculateComponents(); return SetValue(DeriveValue());}
	virtual bool isObjectValueZero() const override{return (m_security->*m_priceFunction1)().isZero() || (m_security->*m_priceFunction2)().isZero() || (m_security->*m_priceFunction3)().isZero();}
	virtual bool isValueZero() const{return m_price1.isZero() || m_price2.isZero() || m_priceDenominator.isZero();}
	DECLARE_NED_NEW
protected:
	void CalculateComponents()
	{
		m_price1 = (m_security->*m_priceFunction1)();
		m_price2 = (m_security->*m_priceFunction2)();
		m_priceDenominator = (m_security->*m_priceFunction3)();
	}
	virtual void InitializeValue() override{CalculateComponents(); m_value = DeriveValue();}
	Price m_priceDenominator;
	PriceFunction m_priceFunction3;
};

class TGUI_API SecurityUIntPriceDiffByPriceDivision : public MoneyRowValue
{
public:
	typedef const Price& (Security::*PriceFunction)() const;
	typedef const unsigned int& (Security::*UIntFunction)() const;
	SecurityUIntPriceDiffByPriceDivision(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction1, UIntFunction priceFunction2, PriceFunction priceFunction3, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_priceFunction1(priceFunction1),
		m_priceFunction2(priceFunction2),
		m_priceFunction3(priceFunction3)
	{
	}
//	virtual bool CanBeNegative() const{return !m_absValue;}
	virtual void CalculateDifferenceFromComponent(Money& diff, const Price& price1, const Price& price2) const
	{
		diff = Money(price2 - price1);
	}
	Money DeriveValueFromComponents(const Price& price1, const Price& price2, const Price& priceDenominator) const
	{
		if(!price1.isZero() && !price2.isZero() && !priceDenominator.isZero())
		{
			Money diff;
			CalculateDifferenceFromComponent(diff, price1, price2);
			if(DivideMoneyByPrice(diff, priceDenominator))return diff;
		}
		return Money::moneyZero;
	}
	Money DeriveValue() const{return DeriveValueFromComponents(m_price1, m_price2, m_priceDenominator);}
	Money CalculateValue() const{return DeriveValueFromComponents((m_security->*m_priceFunction1)(), Price((m_security->*m_priceFunction2)()), (m_security->*m_priceFunction3)());}
	virtual bool isValueChanged() const override{return m_price1 != (m_security->*m_priceFunction1)() || m_price2 != Price((m_security->*m_priceFunction2)()) || m_priceDenominator != (m_security->*m_priceFunction3)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		const Price& price1 = (m_security->*m_priceFunction1)();
		const Price price2 = Price((m_security->*m_priceFunction2)());
		const Price& priceDenominator = (m_security->*m_priceFunction3)();
		bool changed = price1 != m_price1;
		if(changed)m_price1 = price1;
		if(price2 != m_price2)
		{
			changed = true;
			m_price2 = price2;
		}
		if(priceDenominator != m_priceDenominator)
		{
			changed = true;
			m_priceDenominator = priceDenominator;
		}
		return changed && SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return (m_security->*m_priceFunction1)().isZero() || !(m_security->*m_priceFunction2)() || (m_security->*m_priceFunction3)().isZero();}
	virtual bool isValueZero() const override{return m_price1.isZero() || m_price2.isZero() || m_priceDenominator.isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_price1 = (m_security->*m_priceFunction1)();
		m_price2 = Price((m_security->*m_priceFunction2)());
		m_priceDenominator = (m_security->*m_priceFunction3)();
		m_value = DeriveValue();
	}
	const Security* m_security;
	Price m_price1;
	Price m_price2;
	Price m_priceDenominator;
	PriceFunction m_priceFunction1;
	UIntFunction m_priceFunction2;
	PriceFunction m_priceFunction3;
//	bool m_absValue;
};

class TGUI_API SecurityPriceDiffByPriceDivisionAbs : public SecurityPriceDiffByPriceDivision
{
public:
	typedef const Price& (Security::*PriceFunction)() const;
	SecurityPriceDiffByPriceDivisionAbs(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction1, PriceFunction priceFunction2, PriceFunction priceFunction3, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		SecurityPriceDiffByPriceDivision(security, comma, decDigits, truncate, priceFunction1, priceFunction2, priceFunction3, useEmptyValue, useTick, useNeutralColor)
	{
	}
	virtual bool CanBeNegative() const override{return false;}
	virtual void CalculateDifferenceFromComponent(Money& diff, const Price& price1, const Price& price2) const override
	{
		diff = Money(price1 < price2 ? price2 - price1 : price1 - price2);
	}
	DECLARE_NED_NEW
};

class TGUI_API SecurityPriceRowValueDiff : public SignedPriceRowValue
{
public:
	typedef const Price& (Security::*PriceFunction)() const;
	SecurityPriceRowValueDiff(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, PriceFunction priceFunction2, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = false):
		SignedPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick, useNeutralColor),
		m_security(security),
		m_priceFunction(priceFunction),
		m_priceFunction2(priceFunction2)
	{
	}
	virtual SignedPrice DeriveValue(const Price& price, const Price& price2) const
	{
		return price.isZero() || price2.isZero() ? SignedPrice::signedPriceZero : price - price2;
	}

	SignedPrice CalculateValue() const
	{
		return DeriveValue((m_security->*m_priceFunction)(), (m_security->*m_priceFunction2)());
/*
		const Price& price = (m_security->*m_priceFunction)();
		if(!price.isZero())
		{
			const Price& price2 = (m_security->*m_priceFunction2)();
			if(!price2.isZero())
			{
				return price - price2;
			}
		}
		return SignedPrice::signedPriceZero;
*/
	}
//	virtual SignedPrice DeriveValue() const{return m_price.isZero() || m_price2.isZero() ? SignedPrice::signedPriceZero : m_price - m_price2;}
	SignedPrice DeriveValue() const
	{
		return DeriveValue(m_price, m_price2);
//		return m_price.isZero() || m_price2.isZero() ? SignedPrice::signedPriceZero : m_price - m_price2;
	}
	virtual bool isValueChanged() const override{return m_price != (m_security->*m_priceFunction)() || m_price2 != (m_security->*m_priceFunction2)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_price = (m_security->*m_priceFunction)();
		m_price2 = (m_security->*m_priceFunction2)();
		return SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return (m_security->*m_priceFunction)().isZero() || (m_security->*m_priceFunction2)().isZero();}
	virtual bool isValueZero() const override{return m_price.isZero() || m_price2.isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_price = (m_security->*m_priceFunction)();
		m_price2 = (m_security->*m_priceFunction2)();
		m_value = DeriveValue();
	}
	const Security* m_security;
	Price m_price;
	Price m_price2;
	PriceFunction m_priceFunction;
	PriceFunction m_priceFunction2;
};

class TGUI_API SecurityPriceRowValueDiffAbs : public SecurityPriceRowValueDiff
{
public:
	SecurityPriceRowValueDiffAbs(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, PriceFunction priceFunction2, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = true):
		SecurityPriceRowValueDiff(security, comma, decDigits, truncate, priceFunction, priceFunction2, useEmptyValue, useTick, useNeutralColor)
	{
	}
	virtual bool CanBeNegative() const override{return false;}
	virtual SignedPrice DeriveValue(const Price& price, const Price& price2) const override
	{
		if(price.isZero() || price2.isZero())
		{
			return SignedPrice::signedPriceZero;
		}
		else
		{
			return SignedPrice(price.GetAbsDiff(price2));
		}
	}
/*
	virtual SignedPrice CalculateValue() const override
	{
		const Price& price = (m_security->*m_priceFunction)();
		if(!price.isZero())
		{
			const Price& price2 = (m_security->*m_priceFunction2)();
			if(!price2.isZero())
			{
				return price < price2 ? price2 - price : price - price2;
			}
		}
		return SignedPrice::signedPriceZero;
	}
	virtual SignedPrice DeriveValue() const override
	{
		if(m_price.isZero() || m_price2.isZero())
		{
			return SignedPrice::signedPriceZero;
		}
		return m_price < m_price2 ? m_price2 - m_price : m_price - m_price2;
	}
*/
	DECLARE_NED_NEW
};

class TGUI_API SecuritySignedPriceRowValueDiff : public SignedPriceRowValue
{
public:
	typedef const ValueType& (Security::*SignedPriceFunction)() const;
	SecuritySignedPriceRowValueDiff(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, SignedPriceFunction priceFunction, SignedPriceFunction priceFunction2, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = false):
		SignedPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick, useNeutralColor),
		m_security(security),
		m_priceFunction(priceFunction),
		m_priceFunction2(priceFunction2)
	{
	}
	virtual bool isValueChanged() const override{return m_value != (m_security->*m_priceFunction)() - (m_security->*m_priceFunction2)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_security->*m_priceFunction)() - (m_security->*m_priceFunction2)());}
	virtual bool UpdateValue() override{return SetValue((m_security->*m_priceFunction)() - (m_security->*m_priceFunction2)());}
	virtual bool isObjectValueZero() const override{return (m_security->*m_priceFunction)() == (m_security->*m_priceFunction2)();}
//	virtual bool isValueZero() const{return m_price.isZero() || m_price2.isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_security->*m_priceFunction)() - (m_security->*m_priceFunction2)();}
	const Security* m_security;
	SignedPriceFunction m_priceFunction;
	SignedPriceFunction m_priceFunction2;
};

class TGUI_API SecuritySignedPriceRowValueRefDiff : public SignedPriceRowValueRef
{
public:
	typedef const SignedPrice& (Security::*SignedPriceFunction)() const;
	SecuritySignedPriceRowValueRefDiff(const Security* const& security, const SignedPrice& ref, const bool* comma, const unsigned char* decDigits, const bool* truncate, SignedPriceFunction priceFunction, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = false):
		SignedPriceRowValueRef(ref, comma, decDigits, truncate, useEmptyValue, useTick, useNeutralColor),
		m_security(security),
		m_priceFunction(priceFunction)
	{
	}
	virtual bool isValueChanged() const override{return m_value != m_valueRef - (m_security->*m_priceFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(m_valueRef - (m_security->*m_priceFunction)());}
	virtual bool UpdateValue() override{return SetValue(m_valueRef - (m_security->*m_priceFunction)());}
	virtual bool isObjectValueZero() const override{return m_valueRef == (m_security->*m_priceFunction)();}
//	virtual bool isValueZero() const override;//{return m_value.isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = m_valueRef - (m_security->*m_priceFunction)();}
	const Security* m_security;
	SignedPriceFunction m_priceFunction;
};
/*
class TGUI_API SecurityPriceAsUIntRowValueDiff : public SignedPriceRowValue
{
public:
	typedef const unsigned int& (Security::*PriceAsUIntFunction)() const;
	SecurityPriceAsUIntRowValueDiff(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceAsUIntFunction priceFunction1, PriceAsUIntFunction priceFunction2, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = false):
		SignedPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick, useNeutralColor),
		m_security(security),
		m_value1(0),
		m_value2(0),
		m_priceFunction1(priceFunction1),
		m_priceFunction2(priceFunction2)
	{
	}
	static SignedPrice DeriveValue(const unsigned int& priceAsUInt1, const unsigned int& priceAsUInt2){return priceAsUInt1 && priceAsUInt2 ? SignedPrice(priceAsUInt1) - SignedPrice(priceAsUInt2) : SignedPrice::signedPriceZero;}
	SignedPrice DeriveValueFromComponents() const{return DeriveValue(m_value1, m_value2);}
	SignedPrice CalculateValue() const{return DeriveValue((m_security->*m_priceFunction1)(), (m_security->*m_priceFunction2)());}
	virtual bool isValueChanged() const override{return m_value1 != (m_security->*m_priceFunction1)() || m_value2 != (m_security->*m_priceFunction2)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_value1 = (m_security->*m_priceFunction1)();
		m_value2 = (m_security->*m_priceFunction2)();
		return SetValue(DeriveValueFromComponents());
	}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_priceFunction1)() || (m_security->*m_priceFunction2)();}
	virtual bool isValueZero() const override{return !m_value1 || m_value2;}

	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_value1 = (m_security->*m_priceFunction1)();
		m_value2 = (m_security->*m_priceFunction2)();
		m_value = DeriveValueFromComponents();
	}
	const Security* m_security;
	unsigned int m_value1;
	unsigned int m_value2;
	PriceAsUIntFunction m_priceFunction1;
	PriceAsUIntFunction m_priceFunction2;
};
*/
class TGUI_API SecurityPriceRowValueDiffAsUInt : public SignedPriceRowValue
{
public:
	typedef const Price& (Security::*PriceFunction)() const;
	typedef const unsigned int& (Security::*PriceAsUIntFunction)() const;
	SecurityPriceRowValueDiffAsUInt(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunctionFirst, PriceAsUIntFunction priceFunctionLast, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = false):
		SignedPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick, useNeutralColor),
		m_security(security),
		m_last(0),
		m_priceFunctionFirst(priceFunctionFirst),
		m_priceFunctionLast(priceFunctionLast)
	{
	}
	virtual SignedPrice DeriveValue(const unsigned int& priceAsUInt, const Price& price) const{return priceAsUInt && !price.isZero() ? SignedPrice(priceAsUInt) - SignedPrice(price) : SignedPrice::signedPriceZero;}
	SignedPrice DeriveValueFromComponents() const{return DeriveValue(m_last, m_first);}
	SignedPrice CalculateValue() const{return DeriveValue((m_security->*m_priceFunctionLast)(), (m_security->*m_priceFunctionFirst)());}
//	virtual SignedPrice CalculateValue() const;
//	virtual SignedPrice DeriveValue() const;//{if(m_last && !m_first.isZero())return Price(m_last) - m_first;return SignedPrice();}
	virtual bool isValueChanged() const override{return m_last != (m_security->*m_priceFunctionLast)() || m_first != (m_security->*m_priceFunctionFirst)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_last = (m_security->*m_priceFunctionLast)();
		m_first = (m_security->*m_priceFunctionFirst)();
		return SetValue(DeriveValueFromComponents());
	}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_priceFunctionLast)() || (m_security->*m_priceFunctionFirst)().isZero();}
	virtual bool isValueZero() const override{return !m_last || m_first.isZero();}

	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_last = (m_security->*m_priceFunctionLast)();
		m_first = (m_security->*m_priceFunctionFirst)();
		m_value = DeriveValueFromComponents();
	}
	const Security* m_security;
	unsigned int m_last;
	Price m_first;
	PriceFunction m_priceFunctionFirst;
	PriceAsUIntFunction m_priceFunctionLast;
};

class TGUI_API SecurityPriceRowValueDiffAsUIntReversed : public SecurityPriceRowValueDiffAsUInt
{
public:
	SecurityPriceRowValueDiffAsUIntReversed(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunctionFirst, PriceAsUIntFunction priceFunctionLast, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = false):
		SecurityPriceRowValueDiffAsUInt(security, comma, decDigits, truncate, priceFunctionFirst, priceFunctionLast, useEmptyValue, useTick, useNeutralColor)
	{
	}
	virtual SignedPrice DeriveValue(const unsigned int& priceAsUInt, const Price& price) const override
	{
		return priceAsUInt && !price.isZero() ? SignedPrice(price) - SignedPrice(priceAsUInt) : SignedPrice::signedPriceZero;
	}
//	virtual SignedPrice CalculateValue() const;
//	virtual SignedPrice DeriveValue() const;
	DECLARE_NED_NEW
};


class TGUI_API SecurityCompactPriceRowValueDiff : public SignedPriceRowValue
{
public:
	typedef const unsigned int& (Security::*PriceAsUIntFunction)() const;
	SecurityCompactPriceRowValueDiff(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceAsUIntFunction priceFunctionFirst, PriceAsUIntFunction priceFunctionLast, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		SignedPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick, useNeutralColor),
		m_security(security),
		m_last(0),
		m_first(0),
		m_priceFunctionFirst(priceFunctionFirst),
		m_priceFunctionLast(priceFunctionLast)
	{
	}
	virtual SignedPrice DeriveValue(const unsigned int& priceLast, const unsigned int& priceFirst) const{return priceLast && priceFirst ? Price(priceLast) - Price(priceFirst) : SignedPrice::signedPriceZero;}
	SignedPrice DeriveValueFromComponents() const{return DeriveValue(m_last, m_first);}
	SignedPrice CalculateValue() const{return DeriveValue((m_security->*m_priceFunctionLast)(), (m_security->*m_priceFunctionFirst)());}
//	virtual SignedPrice CalculateValue() const;
//	virtual SignedPrice DeriveValue() const;//{if(m_last && !m_first.isZero())return Price(m_last) - m_first;return SignedPrice();}
	virtual bool isValueChanged() const override{return m_last != (m_security->*m_priceFunctionLast)() || m_first != (m_security->*m_priceFunctionFirst)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_last = (m_security->*m_priceFunctionLast)();
		m_first = (m_security->*m_priceFunctionFirst)();
		return SetValue(DeriveValueFromComponents());
	}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_priceFunctionLast)() || !(m_security->*m_priceFunctionFirst)();}
	virtual bool isValueZero() const override{return !m_last || !m_first;}

	DECLARE_NED_NEW
protected:
	virtual void InitializeValue()
	{
		m_last = (m_security->*m_priceFunctionLast)();
		m_first = (m_security->*m_priceFunctionFirst)();
		m_value = DeriveValueFromComponents();
	}
	const Security* m_security;
	unsigned int m_last;
	unsigned int m_first;
	PriceAsUIntFunction m_priceFunctionFirst;
	PriceAsUIntFunction m_priceFunctionLast;
};

class TGUI_API SecurityCompactPriceRowValueDiffPercent : public SecurityCompactPriceRowValueDiff
{
public:
	SecurityCompactPriceRowValueDiffPercent(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceAsUIntFunction priceFunctionFirst, PriceAsUIntFunction priceFunctionLast, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		SecurityCompactPriceRowValueDiff(security, comma, decDigits, truncate, priceFunctionFirst, priceFunctionLast, useEmptyValue, useTick, useNeutralColor)
	{
	}
	virtual SignedPrice DeriveValue(const unsigned int& priceLast, const unsigned int& priceFirst) const override
	{
		if(priceLast && priceFirst)
		{
			const Price price1(priceFirst);
			return price1.GetPercentChange(Price(priceLast) - price1);
		}
		return SignedPrice::signedPriceZero;
	}
	DECLARE_NED_NEW
};

class TGUI_API SecurityPriceRowValueLesserDiffAsUInt : public SignedPriceRowValue
{
public:
	typedef const Price& (Security::*PriceFunction)() const;
	typedef const unsigned int& (Security::*PriceAsUIntFunction)() const;
	SecurityPriceRowValueLesserDiffAsUInt(const Security* const& security,
		const bool* comma,
		const unsigned char* decDigits,
		const bool* truncate,
		PriceFunction priceFunctionLow,
		PriceFunction priceFunctionHigh,
		PriceAsUIntFunction priceFunctionBetween,
		bool useEmptyValue = false,
		bool useTick = true,
		bool useNeutralColor = false):

		SignedPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick, useNeutralColor),
		m_security(security),
		m_between(0),
		m_priceFunctionLow(priceFunctionLow),
		m_priceFunctionHigh(priceFunctionHigh),
		m_priceFunctionBetween(priceFunctionBetween)
	{
	}
//	virtual
	SignedPrice DeriveValue(const unsigned int& priceAsUInt, const Price& priceLow, const Price& priceHigh) const
	{
		if(!priceAsUInt)
		{
			return SignedPrice::signedPriceZero;
		}
		else if(priceLow.isZero())
		{
			return priceHigh.isZero() ? SignedPrice::signedPriceZero : SignedPrice(priceHigh) - SignedPrice(priceAsUInt);
		}
		else if(priceHigh.isZero())
		{
			return SignedPrice(priceAsUInt) - SignedPrice(priceLow);
		}
		else
		{
			const SignedPrice low = SignedPrice(priceAsUInt) - SignedPrice(priceLow);
			const SignedPrice high = SignedPrice(priceHigh) - SignedPrice(priceAsUInt);
			return low < high ? low : high;
		}
	}
	SignedPrice DeriveValueFromComponents() const{return DeriveValue(m_between, m_low, m_high);}
	SignedPrice CalculateValue() const{return DeriveValue((m_security->*m_priceFunctionBetween)(), (m_security->*m_priceFunctionLow)(), (m_security->*m_priceFunctionHigh)());}

	virtual bool isValueChanged() const override{return m_between != (m_security->*m_priceFunctionBetween)() || m_low != (m_security->*m_priceFunctionLow)() || m_high != (m_security->*m_priceFunctionHigh)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_between = (m_security->*m_priceFunctionBetween)();
		m_low = (m_security->*m_priceFunctionLow)();
		m_high = (m_security->*m_priceFunctionHigh)();
		return SetValue(DeriveValueFromComponents());
	}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_priceFunctionBetween)() || (m_security->*m_priceFunctionLow)().isZero() && (m_security->*m_priceFunctionHigh)().isZero();}
	virtual bool isValueZero() const override{return !m_between || m_low.isZero() && m_high.isZero();}

	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_between = (m_security->*m_priceFunctionBetween)();
		m_low = (m_security->*m_priceFunctionLow)();
		m_high = (m_security->*m_priceFunctionHigh)();
		m_value = DeriveValueFromComponents();
	}
	const Security* m_security;
	unsigned int m_between;
	Price m_low;
	Price m_high;
	PriceFunction m_priceFunctionLow;
	PriceFunction m_priceFunctionHigh;
	PriceAsUIntFunction m_priceFunctionBetween;
};

class TGUI_API SecurityPriceRowValueLesserDiffAsUIntPercent : public MoneyRowValue
{
public:
	typedef const Price& (Security::*PriceFunction)() const;
	typedef const unsigned int& (Security::*PriceAsUIntFunction)() const;
	SecurityPriceRowValueLesserDiffAsUIntPercent(const Security* const& security,
		const bool* comma,
		const unsigned char* decDigits,
		const bool* truncate,
		PriceFunction priceFunctionLow,
		PriceFunction priceFunctionHigh,
		PriceAsUIntFunction priceFunctionBetween,
		bool useEmptyValue = false,
		bool useTick = true,
		bool useNeutralColor = false):

		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useTick, useNeutralColor),
		m_security(security),
		m_between(0),
		m_priceFunctionLow(priceFunctionLow),
		m_priceFunctionHigh(priceFunctionHigh),
		m_priceFunctionBetween(priceFunctionBetween)
	{
	}
	Money DeriveValue(const unsigned int& priceAsUInt, const Price& priceLow, const Price& priceHigh) const
	{
		if(!priceAsUInt)
		{
			return Money::moneyZero;
		}
		else
		{
			SignedPrice p(priceAsUInt);
			SignedPrice diff;
			if(priceLow.isZero())
			{
				if(priceHigh.isZero())
				{
					return Money::moneyZero;
				}
				else
				{
					diff = SignedPrice(priceHigh) - p;
				}
			}
			else if(priceHigh.isZero())
			{
				diff = p - SignedPrice(priceLow);
			}
			else
			{
				diff = p - SignedPrice(priceLow);
				const SignedPrice high = SignedPrice(priceHigh) - p;
				if(high < diff)diff = high;
			}
			Money value(diff);
			return DivideMoneyByPrice(value, Price(p)) ? value : Money::moneyZero;
		}
	}
	Money DeriveValueFromComponents() const{return DeriveValue(m_between, m_low, m_high);}
	Money CalculateValue() const{return DeriveValue((m_security->*m_priceFunctionBetween)(), (m_security->*m_priceFunctionLow)(), (m_security->*m_priceFunctionHigh)());}
	virtual bool isValueChanged() const override{return m_between != (m_security->*m_priceFunctionBetween)() || m_low != (m_security->*m_priceFunctionLow)() || m_high != (m_security->*m_priceFunctionHigh)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_between = (m_security->*m_priceFunctionBetween)();
		m_low = (m_security->*m_priceFunctionLow)();
		m_high = (m_security->*m_priceFunctionHigh)();
		return SetValue(DeriveValueFromComponents());
	}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_priceFunctionBetween)() || (m_security->*m_priceFunctionLow)().isZero() && (m_security->*m_priceFunctionHigh)().isZero();}
	virtual bool isValueZero() const override{return !m_between || m_low.isZero() && m_high.isZero();}

	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_between = (m_security->*m_priceFunctionBetween)();
		m_low = (m_security->*m_priceFunctionLow)();
		m_high = (m_security->*m_priceFunctionHigh)();
		m_value = DeriveValueFromComponents();
	}
	const Security* m_security;
	unsigned int m_between;
	Price m_low;
	Price m_high;
	PriceFunction m_priceFunctionLow;
	PriceFunction m_priceFunctionHigh;
	PriceAsUIntFunction m_priceFunctionBetween;
};

class TGUI_API SecurityPriceRowValueDiffAsUIntXIntAbs : public MoneyRowValue
{
public:
	typedef const Price& (Security::*PriceFunction)() const;
	typedef const unsigned int& (Security::*PriceAsUIntFunction)() const;
	typedef const int& (Security::*IntFunction)() const;
	SecurityPriceRowValueDiffAsUIntXIntAbs(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunctionFirst, PriceAsUIntFunction priceFunctionLast, IntFunction intFunction, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = true):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_last(0),
		m_number(0),
		m_priceFunctionFirst(priceFunctionFirst),
		m_priceFunctionLast(priceFunctionLast),
		m_intFunction(intFunction)
	{
	}
	virtual bool CanBeNegative() const override{return false;}
	inline static Money DeriveValue(const Price& first, const unsigned int& last, const int& number)
	{
		if(number && last && !first.isZero())
		{
			return first.GetAbsDiff(Price(last)) * (number < 0 ? -number : number);
		}
		return Money::moneyZero;
	}
	Money CalculateValue() const
	{
		return DeriveValue((m_security->*m_priceFunctionFirst)(), (m_security->*m_priceFunctionLast)(), (m_security->*m_intFunction)());
/*
		const int number = (m_security->*m_intFunction)();
		if(number)
		{
			const unsigned int last = (m_security->*m_priceFunctionLast)();
			if(last)
			{
				const Price& first = (m_security->*m_priceFunctionFirst)();
				if(!first.isZero())
				{
					const Price lp(last);
					return (lp < first ? first - lp : lp - first) * (number < 0 ? -number : number);
				}
			}
		}
		return Money::moneyZero;
*/
	}
	Money DeriveValue() const
	{
		return DeriveValue(m_first, m_last, m_number);
/*
		if(m_number && m_last && !m_first.isZero())
		{
			const Price lp(m_last);
			return (lp < m_first ? m_first - lp : lp - m_first) * (m_number < 0 ? -m_number : m_number);
		}
		return Money::moneyZero;
*/
	}
	virtual bool isValueChanged() const override{return m_number != (m_security->*m_intFunction)() || m_last != (m_security->*m_priceFunctionLast)() || m_first != (m_security->*m_priceFunctionFirst)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		InitValues();
		return SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_intFunction)() || !(m_security->*m_priceFunctionLast)() || (m_security->*m_priceFunctionFirst)().isZero();}
	virtual bool isValueZero() const override{return !m_number || !m_last || m_first.isZero();}

	DECLARE_NED_NEW
protected:
	inline void InitValues()
	{
		m_number = (m_security->*m_intFunction)();
		m_last = (m_security->*m_priceFunctionLast)();
		m_first = (m_security->*m_priceFunctionFirst)();
	}
	virtual void InitializeValue() override
	{
		InitValues();
		m_value = DeriveValue();
	}
	const Security* m_security;
	unsigned int m_last;
	int m_number;
	Price m_first;
	PriceFunction m_priceFunctionFirst;
	PriceAsUIntFunction m_priceFunctionLast;
	IntFunction m_intFunction;
};

class TGUI_API SecurityMoneyRowValueAverage64 : public MoneyRowValue
{
public:
	typedef const Money& (Security::*MoneyFunction)() const;
	typedef const unsigned __int64& (Security::*UInt64Function)() const;
	SecurityMoneyRowValueAverage64(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, UInt64Function volumeFunction, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_moneyFunction(moneyFunction),
		m_volumeFunction(volumeFunction),
		m_volume(0)
	{}

//	virtual const Money& GetObjectValue() const override{return (m_security->*m_moneyFunction)();}
	Money CalculateValue() const
	{
		unsigned __int64 volume = (m_security->*m_volumeFunction)();
		if(volume)
		{
			const Money& money = (m_security->*m_moneyFunction)();
			if(!money.isZero())
			{
				return money.operator/(volume);
			}
		}
		return Money::moneyZero;
	}
	Money DeriveValue() const
	{
		if(m_volume && !m_money.isZero())
		{
			return m_money.operator/(m_volume);
		}
		return Money::moneyZero;
	}
	virtual bool isValueChanged() const override{return m_volume != (m_security->*m_volumeFunction)() || m_money != (m_security->*m_moneyFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_volume = (m_security->*m_volumeFunction)();
		m_money = (m_security->*m_moneyFunction)();
		return SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return!(m_security->*m_volumeFunction)() || (m_security->*m_moneyFunction)().isZero();}
	virtual bool isValueZero() const override{return !m_volume || m_money.isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_volume = (m_security->*m_volumeFunction)();
		m_money = (m_security->*m_moneyFunction)();
		m_value = DeriveValue();
	}
	const Security* m_security;
	MoneyFunction m_moneyFunction;
	UInt64Function m_volumeFunction;
	unsigned __int64 m_volume;
	Money m_money;
};
////////////
class TGUI_API SecurityMoneyRowValueAverage64PriceAsUIntDiff : public MoneyRowValue
{
public:
	typedef const Money& (Security::*MoneyFunction)() const;
	typedef const unsigned __int64& (Security::*UInt64Function)() const;
	typedef const unsigned int& (Security::*UIntFunction)() const;

	SecurityMoneyRowValueAverage64PriceAsUIntDiff(const Security* security,
		const bool* comma,
		const unsigned char* decDigits,
		const bool* truncate,
		MoneyFunction moneyFunction,
		UInt64Function volumeFunction,
		UIntFunction priceFunction,
		bool useEmptyValue = true,
		bool useNeutralColor = false,
		bool useTick = true):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_moneyFunction(moneyFunction),
		m_volumeFunction(volumeFunction),
		m_priceFunction(priceFunction),
		m_volume(0),
		m_price(0)
	{}

//	virtual const Money& GetObjectValue() const override{return (m_security->*m_moneyFunction)();}
	Money CalculateValue() const
	{
		const unsigned __int64 volume = (m_security->*m_volumeFunction)();
		if(volume)
		{
			const unsigned int price = (m_security->*m_priceFunction)();
			if(price)
			{
				const Money& money = (m_security->*m_moneyFunction)();
				if(!money.isZero())
				{
					return Money(price) - money / volume;
				}
			}
		}
		return Money::moneyZero;
	}
	Money DeriveValue() const
	{
		if(m_price && m_volume && !m_money.isZero())
		{
			return Money(m_price) - m_money.operator/(m_volume);
		}
		return Money::moneyZero;
	}
	virtual bool isValueChanged() const override{return m_price != (m_security->*m_priceFunction)() || m_volume != (m_security->*m_volumeFunction)() || m_money != (m_security->*m_moneyFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_volume = (m_security->*m_volumeFunction)();
		m_money = (m_security->*m_moneyFunction)();
		m_price = (m_security->*m_priceFunction)();
		return SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_priceFunction)() || !(m_security->*m_volumeFunction)() || (m_security->*m_moneyFunction)().isZero();}
	virtual bool isValueZero() const override{return !m_price || !m_volume || m_money.isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_volume = (m_security->*m_volumeFunction)();
		m_money = (m_security->*m_moneyFunction)();
		m_price = (m_security->*m_priceFunction)();
		m_value = DeriveValue();
	}
	const Security* m_security;
	MoneyFunction m_moneyFunction;
	UInt64Function m_volumeFunction;
	UIntFunction m_priceFunction;
	unsigned __int64 m_volume;
	Money m_money;
	unsigned int m_price;
};
////////////
class TGUI_API SecurityMoneyRowValueAverage64PriceAsUIntDiffPercent : public MoneyRowValue
{
public:
	typedef const Money& (Security::*MoneyFunction)() const;
	typedef const unsigned __int64& (Security::*UInt64Function)() const;
	typedef const unsigned int& (Security::*UIntFunction)() const;

	SecurityMoneyRowValueAverage64PriceAsUIntDiffPercent(const Security* security,
		const bool* comma,
		const unsigned char* decDigits,
		const bool* truncate,
		MoneyFunction moneyFunction,
		UInt64Function volumeFunction,
		UIntFunction priceFunction,
		bool useEmptyValue = true,
		bool useNeutralColor = false,
		bool useTick = true):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_moneyFunction(moneyFunction),
		m_volumeFunction(volumeFunction),
		m_priceFunction(priceFunction),
		m_volume(0),
		m_price(0)
	{}

//	virtual const Money& GetObjectValue() const override{return (m_security->*m_moneyFunction)();}
	Money CalculateValue() const
	{
		unsigned __int64 volume = (m_security->*m_volumeFunction)();
		if(volume)
		{
			unsigned int price = (m_security->*m_priceFunction)();
			if(price)
			{
				const Money& money = (m_security->*m_moneyFunction)();
				if(!money.isZero())
				{
					Money vwap = money.operator/(volume);
					return vwap.GetPercentChange(Money(price) - vwap);
				}
			}
		}
		return Money::moneyZero;
	}
	Money DeriveValue() const
	{
		if(m_price && m_volume && !m_money.isZero())
		{
			Money vwap = m_money.operator/(m_volume);
			return vwap.GetPercentChange(Money(m_price) - vwap);
		}
		return Money::moneyZero;
	}
	virtual bool isValueChanged() const override{return m_price != (m_security->*m_priceFunction)() || m_volume != (m_security->*m_volumeFunction)() || m_money != (m_security->*m_moneyFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_volume = (m_security->*m_volumeFunction)();
		m_money = (m_security->*m_moneyFunction)();
		m_price = (m_security->*m_priceFunction)();
		return SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_priceFunction)() || !(m_security->*m_volumeFunction)() || (m_security->*m_moneyFunction)().isZero();}
	virtual bool isValueZero() const override{return !m_price || !m_volume || m_money.isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_volume = (m_security->*m_volumeFunction)();
		m_money = (m_security->*m_moneyFunction)();
		m_price = (m_security->*m_priceFunction)();
		m_value = DeriveValue();
	}
	const Security* m_security;
	MoneyFunction m_moneyFunction;
	UInt64Function m_volumeFunction;
	UIntFunction m_priceFunction;
	unsigned __int64 m_volume;
	Money m_money;
	unsigned int m_price;
};

////////////
class TGUI_API SecurityPercentUInt64ByUInt64 : public MoneyRowValue
{
public:
	typedef const unsigned __int64& (Security::*UInt64Function)() const;
	SecurityPercentUInt64ByUInt64(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, unsigned __int64& uint64NumeratorRef, UInt64Function uint64Function, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_uint64Function(uint64Function),
		m_uint64NumeratorRef(uint64NumeratorRef),
		m_uint64Numerator(0),
		m_uint64Denominator(0)
	{}

	Money CalculateValue() const
	{
		if(m_uint64NumeratorRef)
		{
			const unsigned __int64 uint64Denominator = (m_security->*m_uint64Function)();
			if(uint64Denominator)
			{
				return Money(m_uint64NumeratorRef * 100, 0) / uint64Denominator;
			}
		}
		return Money::moneyZero;
	}

	Money DeriveValue() const{return m_uint64Numerator && m_uint64Denominator ? Money(m_uint64Numerator * 100, 0) / m_uint64Denominator : Money::moneyZero;}
	virtual bool isValueChanged() const override{return m_uint64Denominator != (m_security->*m_uint64Function)() || m_uint64Numerator != m_uint64NumeratorRef;}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_uint64Numerator = m_uint64NumeratorRef;
		m_uint64Denominator = (m_security->*m_uint64Function)();
		return SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return !m_uint64NumeratorRef || !(m_security->*m_uint64Function)();}
	virtual bool isValueZero() const override{return !m_uint64Numerator || !m_uint64Denominator;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_uint64Numerator = m_uint64NumeratorRef;
		m_uint64Denominator = (m_security->*m_uint64Function)();
		m_value = DeriveValue();
	}
	const Security* m_security;
	UInt64Function m_uint64Function;
	unsigned __int64& m_uint64NumeratorRef;
	unsigned __int64 m_uint64Numerator;
	unsigned __int64 m_uint64Denominator;
};
/*
class TGUI_API SecurityPercentUInt64ByUInt64Func : public MoneyRowValue
{
public:
	typedef const unsigned __int64& (Security::*UInt64Function)() const;
	SecurityPercentUInt64ByUInt64Func(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, UInt64Function uint64FunctionNumerator, UInt64Function uint64FunctionDenominator, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_security(security),
		m_uint64FunctionNumerator(uint64FunctionNumerator),
		m_uint64FunctionDenominator(uint64FunctionDenominator),
		m_uint64Numerator(0),
		m_uint64Denominator(0)
	{}

	Money CalculateValue() const
	{
		const unsigned __int64 uint64Numerator = (m_security->*m_uint64FunctionNumerator)();
		if(uint64Numerator)
		{
			const unsigned __int64 uint64Denominator = (m_security->*m_uint64FunctionDenominator)();
			if(uint64Denominator)
			{
				return Money(uint64Numerator * 100, 0) / uint64Denominator;
			}
		}
		return Money::moneyZero;
	}

	Money DeriveValue() const{return m_uint64Numerator && m_uint64Denominator ? Money(m_uint64Numerator * 100, 0) / m_uint64Denominator : Money::moneyZero;}
	bool isValueChanged() const{return m_uint64Numerator != (m_security->*m_uint64FunctionNumerator)() || m_uint64Denominator != (m_security->*m_uint64FunctionDenominator)();}
	short CompareAhead(const RowValue& other) const{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	bool UpdateValue()
	{
		m_uint64Numerator = (m_security->*m_uint64FunctionNumerator)();
		m_uint64Denominator = (m_security->*m_uint64FunctionDenominator)();
		return SetValue(DeriveValue());
	}
	bool isObjectValueZero() const{return !(m_security->*m_uint64FunctionNumerator)() || !(m_security->*m_uint64FunctionDenominator)();}
	bool isValueZero() const{return !m_uint64Numerator || !m_uint64Denominator;}
	DECLARE_NED_NEW
protected:
	void InitializeValue()
	{
		m_uint64Numerator = (m_security->*m_uint64FunctionNumerator)();
		m_uint64Denominator = (m_security->*m_uint64FunctionDenominator)();
		m_value = DeriveValue();
	}
	const Security* m_security;
	UInt64Function m_uint64FunctionNumerator;
	UInt64Function m_uint64FunctionDenominator;
	unsigned __int64 m_uint64Numerator;
	unsigned __int64 m_uint64Denominator;
};
*/
class TGUI_API SecurityVolumeDiff : public Int64RowValue
{
public:
	typedef const unsigned __int64& (Security::*UInt64Function)() const;
	SecurityVolumeDiff(const Security* const& security, const bool* comma, UInt64Function function1, UInt64Function function2, UInt64Function function3, UInt64Function function4, bool useEmptyValue = false, bool useTick = false):
		Int64RowValue(comma, useEmptyValue, useTick),
		m_security(security),
		m_function1(function1),
		m_function2(function2),
		m_function3(function3),
		m_function4(function4)
	{}

//	virtual const Money& GetObjectValue() const override{return (m_security->*m_moneyFunction)();}
	__int64 CalculateValue() const{return (__int64)(m_security->*m_function1)() - (__int64)((m_security->*m_function2)() + (m_security->*m_function3)() + (m_security->*m_function4)());}
	virtual bool isValueChanged() const override{return m_value != CalculateValue();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override{return SetValue(CalculateValue());}
	virtual bool isObjectValueZero() const override{return (m_security->*m_function1)() == (m_security->*m_function2)() + (m_security->*m_function3)() + (m_security->*m_function4)();}
//	virtual bool isValueZero() const override;//{return m_useEmptyValue && !m_value;}//m_volume1 == m_volume2;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = CalculateValue();}
	const Security* m_security;
	UInt64Function m_function1;
	UInt64Function m_function2;
	UInt64Function m_function3;
	UInt64Function m_function4;
//	__int64 m_volume1;
//	__int64 m_volume2;
};

class TGUI_API SecurityPriceRowValueDiffAsUIntDividedByFirst : public SignedPriceRowValue
{
public:
	typedef const Price& (Security::*PriceFunction)() const;
//	typedef unsigned int (Security::*PriceAsUIntFunction)() const;
	typedef const unsigned int& (Security::*PriceAsUIntFunction)() const;
	SecurityPriceRowValueDiffAsUIntDividedByFirst(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunctionFirst, PriceAsUIntFunction priceFunctionLast, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = false):
		SignedPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick, useNeutralColor),
		m_security(security),
		m_last(0),
		m_priceFunctionFirst(priceFunctionFirst),
		m_priceFunctionLast(priceFunctionLast)
	{
	}
	virtual SignedPrice CalculateValue() const
	{
		unsigned int last = (m_security->*m_priceFunctionLast)();
		if(last)
		{
			const Price& first = (m_security->*m_priceFunctionFirst)();
			if(!first.isZero())
			{
				return first.GetPercentChange(Price(last) - first);
			}
		}
		return SignedPrice::signedPriceZero;
	}
	virtual SignedPrice DeriveValue() const{return m_last && !m_first.isZero() ? m_first.GetPercentChange(Price(m_last) - m_first) : SignedPrice::signedPriceZero;}
	virtual bool isValueChanged() const override{return m_last != (m_security->*m_priceFunctionLast)() || m_first != (m_security->*m_priceFunctionFirst)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_last = (m_security->*m_priceFunctionLast)();
		m_first = (m_security->*m_priceFunctionFirst)();
		return SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_priceFunctionLast)() || (m_security->*m_priceFunctionFirst)().isZero();}
	virtual bool isValueZero() const override{return !m_last || m_first.isZero();}

	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_last = (m_security->*m_priceFunctionLast)();m_first = (m_security->*m_priceFunctionFirst)();m_value = DeriveValue();}
	const Security* m_security;
	unsigned int m_last;
	Price m_first;
	PriceFunction m_priceFunctionFirst;
	PriceAsUIntFunction m_priceFunctionLast;
};

class TGUI_API SecurityPriceRowValueDiffAsUIntDividedByFirstReversed : public SecurityPriceRowValueDiffAsUIntDividedByFirst
{
public:
	SecurityPriceRowValueDiffAsUIntDividedByFirstReversed(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunctionFirst, PriceAsUIntFunction priceFunctionLast, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = false):
		SecurityPriceRowValueDiffAsUIntDividedByFirst(security, comma, decDigits, truncate, priceFunctionFirst, priceFunctionLast, useEmptyValue, useTick, useNeutralColor)
	{
	}
	virtual SignedPrice CalculateValue() const override
	{
		unsigned int last = (m_security->*m_priceFunctionLast)();
		if(last)
		{
			const Price& first = (m_security->*m_priceFunctionFirst)();
			if(!first.isZero())
			{
				Price lastPrice(last);
				return lastPrice.GetPercentChange(first - lastPrice);
			}
		}
		return SignedPrice::signedPriceZero;
	}
	virtual SignedPrice DeriveValue() const override
	{
		if(m_last && !m_first.isZero())
		{
			Price lastPrice(m_last);
			return lastPrice.GetPercentChange(m_first - lastPrice);
		}
		return SignedPrice::signedPriceZero;
	}
	DECLARE_NED_NEW
};

class TGUI_API SecurityPriceRowValueDiffAsUIntDividedByFirstAsMoney : public MoneyRowValue
{
public:
	typedef const Price& (Security::*PriceFunction)() const;
//	typedef unsigned int (Security::*PriceAsUIntFunction)() const;
	typedef const unsigned int& (Security::*PriceAsUIntFunction)() const;
	SecurityPriceRowValueDiffAsUIntDividedByFirstAsMoney(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunctionFirst, PriceAsUIntFunction priceFunctionLast, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = false):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useTick, useNeutralColor),
		m_security(security),
		m_last(0),
		m_priceFunctionFirst(priceFunctionFirst),
		m_priceFunctionLast(priceFunctionLast)
	{
	}
	virtual Money CalculateValue() const
	{
		unsigned int last = (m_security->*m_priceFunctionLast)();
		if(last)
		{
			const Money first((m_security->*m_priceFunctionFirst)());
			if(!first.isZero())
			{
				return first.GetPercentChange(Money(Price(last)) - first);
			}
		}
		return Money::moneyZero;
	}
	virtual Money DeriveValue() const{return m_last && !m_first.isZero() ? m_first.GetPercentChange(Money(Price(m_last)) - m_first) : Money::moneyZero;}
	virtual bool isValueChanged() const override{return m_last != (m_security->*m_priceFunctionLast)() || m_first != (m_security->*m_priceFunctionFirst)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override{m_last = (m_security->*m_priceFunctionLast)();m_first = (m_security->*m_priceFunctionFirst)();return SetValue(DeriveValue());}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_priceFunctionLast)() || (m_security->*m_priceFunctionFirst)().isZero();}
	virtual bool isValueZero() const override{return !m_last || m_first.isZero();}

	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_last = (m_security->*m_priceFunctionLast)();m_first = Money((m_security->*m_priceFunctionFirst)());m_value = DeriveValue();}
	const Security* m_security;
	unsigned int m_last;
	Money m_first;
	PriceFunction m_priceFunctionFirst;
	PriceAsUIntFunction m_priceFunctionLast;
};

class TGUI_API SecurityPriceRowValueDiffAsUIntDividedByFirstAsMoneyReversed : public SecurityPriceRowValueDiffAsUIntDividedByFirstAsMoney
{
public:
	SecurityPriceRowValueDiffAsUIntDividedByFirstAsMoneyReversed(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunctionFirst, PriceAsUIntFunction priceFunctionLast, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = false):
		SecurityPriceRowValueDiffAsUIntDividedByFirstAsMoney(security, comma, decDigits, truncate, priceFunctionFirst, priceFunctionLast, useEmptyValue, useTick, useNeutralColor)
	{
	}
	virtual Money CalculateValue() const override
	{
		unsigned int last = (m_security->*m_priceFunctionLast)();
		if(last)
		{
			const Money first((m_security->*m_priceFunctionFirst)());
			if(!first.isZero())
			{
				const Money lastMoney = Money(Price(last));
				return lastMoney.GetPercentChange(first - lastMoney);
			}
		}
		return Money::moneyZero;
	}
	virtual Money DeriveValue() const override
	{
		if(m_last && !m_first.isZero())
		{
			Money lastPrice = Money(Price(m_last));
			return lastPrice.GetPercentChange(m_first - lastPrice);
		}
		return Money::moneyZero;
	}
	DECLARE_NED_NEW
};

class TGUI_API SecurityPriceRowValueDiffPositiveOnly : public SecurityPriceRowValueDiff
{
public:
	SecurityPriceRowValueDiffPositiveOnly(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, PriceFunction priceFunction2, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = true):
		SecurityPriceRowValueDiff(security, comma, decDigits, truncate, priceFunction, priceFunction2, useEmptyValue, useTick, useNeutralColor)
	{
	}
	virtual bool CanBeNegative() const override{return false;}
	DECLARE_NED_NEW
};

class TGUI_API SecurityPriceAsUInt64RowValueDiff : public SignedPriceRowValue
{
public:
	typedef unsigned __int64 (Security::*PriceFunction)() const;
	SecurityPriceAsUInt64RowValueDiff(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, PriceFunction priceFunction2, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = false):
		SignedPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick, useNeutralColor),
		m_security(security),
		m_priceFunction(priceFunction),
		m_priceFunction2(priceFunction2)
	{
	}

	virtual bool isValueChanged() const override{return m_value != Price((m_security->*m_priceFunction)()) - Price((m_security->*m_priceFunction2)());}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(Price((m_security->*m_priceFunction)()) - Price((m_security->*m_priceFunction2)()));}
	virtual bool UpdateValue() override{return SetValue(Price((m_security->*m_priceFunction)()) - Price((m_security->*m_priceFunction2)()));}
	virtual bool isObjectValueZero() const override{return (m_security->*m_priceFunction)() == (m_security->*m_priceFunction2)();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = Price((m_security->*m_priceFunction)()) - Price((m_security->*m_priceFunction2)());}
	const Security* m_security;
	PriceFunction m_priceFunction;
	PriceFunction m_priceFunction2;
};

class TGUI_API SecurityPriceAsUIntRowValueDiffBase : public SignedPriceRowValue
{
public:
	static void CalculatePrice(unsigned int price, unsigned int price2, SignedPrice& value)
	{
		if(price && price2)
		{
			value = SignedPrice(price) - SignedPrice(price2);
		}
		else
		{
			value.SetZero();
		}
	}
//	virtual bool isValueZero() const{return m_useEmptyValue && (!m_price || !m_price2);}
	virtual bool isValueZero() const override{return !m_price || !m_price2;}
	DECLARE_NED_NEW
protected:
	SecurityPriceAsUIntRowValueDiffBase(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		SignedPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick, useNeutralColor),
		m_security(security),
		m_price(0),
		m_price2(0)
	{
	}

	const Security* m_security;
	unsigned int m_price;
	unsigned int m_price2;
};

class TGUI_API SecurityPriceAsUIntRowValueDiff : public SecurityPriceAsUIntRowValueDiffBase
{
public:
	typedef const unsigned int& (Security::*PriceFunction)() const;
	SecurityPriceAsUIntRowValueDiff(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, PriceFunction priceFunction2, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		SecurityPriceAsUIntRowValueDiffBase(security, comma, decDigits, truncate, useEmptyValue, useTick, useNeutralColor),
		m_priceFunction(priceFunction),
		m_priceFunction2(priceFunction2)
	{
	}

	virtual bool isValueChanged() const override{return m_price != (m_security->*m_priceFunction)() || m_price2 != (m_security->*m_priceFunction2)();}
	virtual short CompareAhead(const RowValue& other) const override
	{
		SignedPrice value;
		CalculatePrice((m_security->*m_priceFunction)(), (m_security->*m_priceFunction2)(), value);
		return -((const TypedRowValue&)other).CompareValue(value);
	}
	virtual bool UpdateValue() override
	{
		m_price = (m_security->*m_priceFunction)();
		m_price2 = (m_security->*m_priceFunction2)();
		SignedPrice value;
		CalculatePrice(m_price, m_price2, value);
		return SetValue(value);
	}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_priceFunction)() || !(m_security->*m_priceFunction2)();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_price = (m_security->*m_priceFunction)();
		m_price2 = (m_security->*m_priceFunction2)();
		CalculatePrice(m_price, m_price2, m_value);
	}
	PriceFunction m_priceFunction;
	PriceFunction m_priceFunction2;
};

class TGUI_API SecurityPriceAsUIntRowValueDiffPositiveOnly : public SecurityPriceAsUIntRowValueDiff
{
public:
	SecurityPriceAsUIntRowValueDiffPositiveOnly(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, PriceFunction priceFunction2, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = true):
		SecurityPriceAsUIntRowValueDiff(security, comma, decDigits, truncate, priceFunction, priceFunction2, useEmptyValue, useTick, useNeutralColor)
	{
	}
	virtual bool CanBeNegative() const override{return false;}
	DECLARE_NED_NEW
};

class TGUI_API SecurityPriceAsUIntRowValueCopyDiff : public SecurityPriceAsUIntRowValueDiffBase
{
public:
	typedef unsigned int (Security::*PriceFunction)() const;
	SecurityPriceAsUIntRowValueCopyDiff(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, PriceFunction priceFunction2, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		SecurityPriceAsUIntRowValueDiffBase(security, comma, decDigits, truncate, useEmptyValue, useTick, useNeutralColor),
		m_priceFunction(priceFunction),
		m_priceFunction2(priceFunction2)
	{
	}

	virtual bool isValueChanged() const override{return m_price != (m_security->*m_priceFunction)() || m_price2 != (m_security->*m_priceFunction2)();}
	virtual short CompareAhead(const RowValue& other) const override
	{
		SignedPrice value;
		CalculatePrice((m_security->*m_priceFunction)(), (m_security->*m_priceFunction2)(), value);
		return -((const TypedRowValue&)other).CompareValue(value);
	}
	virtual bool UpdateValue() override
	{
		m_price = (m_security->*m_priceFunction)();
		m_price2 = (m_security->*m_priceFunction2)();
		SignedPrice value;
		CalculatePrice(m_price, m_price2, value);
		return SetValue(value);
	}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_priceFunction)() || !(m_security->*m_priceFunction2)();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_price = (m_security->*m_priceFunction)();
		m_price2 = (m_security->*m_priceFunction2)();
		CalculatePrice(m_price, m_price2, m_value);
	}
	PriceFunction m_priceFunction;
	PriceFunction m_priceFunction2;
};

class TGUI_API SecurityPriceAsUInt64RowValueDiffPositiveOnly : public SecurityPriceAsUInt64RowValueDiff
{
public:
	SecurityPriceAsUInt64RowValueDiffPositiveOnly(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, PriceFunction priceFunction2, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = true):
		SecurityPriceAsUInt64RowValueDiff(security, comma, decDigits, truncate, priceFunction, priceFunction2, useEmptyValue, useTick, useNeutralColor)
	{
	}
	virtual bool CanBeNegative() const override{return false;}
	DECLARE_NED_NEW
};

class TGUI_API SecurityPriceAsUIntRowValueCopyDiffPositiveOnly : public SecurityPriceAsUIntRowValueCopyDiff
{
public:
	SecurityPriceAsUIntRowValueCopyDiffPositiveOnly(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, PriceFunction priceFunction2, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = true):
		SecurityPriceAsUIntRowValueCopyDiff(security, comma, decDigits, truncate, priceFunction, priceFunction2, useEmptyValue, useTick, useNeutralColor)
	{
	}
	virtual bool CanBeNegative() const override{return false;}
	DECLARE_NED_NEW
};

class TGUI_API SecurityPercentChangeRowValue : public SignedPriceRowValue
{
public:
	typedef const SignedPrice& (Security::*ChangeFunction)() const;
	typedef const Price& (Security::*BaseFunction)() const;
	SecurityPercentChangeRowValue(const Security* const& security,
		ChangeFunction changeFunction,
		BaseFunction baseFunction,
		const bool* const& comma,
		const unsigned char* const& decDigits,
		const bool* const& truncate):
		SignedPriceRowValue(comma, decDigits, truncate, true, true, false), m_security(security),
		m_changeFunction(changeFunction),
		m_baseFunction(baseFunction)
	{}

	virtual bool isValueChanged() const override{return m_netChange != (m_security->*m_changeFunction)() || m_closePrice != (m_security->*m_baseFunction)();}
	
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_security->*m_baseFunction)().GetPercentChange((m_security->*m_changeFunction)()));}
	virtual bool UpdateValue() override
	{
		const SignedPrice& netChange = (m_security->*m_changeFunction)();
		const Price& closePrice = (m_security->*m_baseFunction)();
		bool changed = m_netChange != netChange;
		if(changed)
		{
			m_netChange = netChange;
		}
		if(m_closePrice != closePrice)
		{
			m_closePrice = closePrice;
			changed = true;
		}
		if(changed)
		{
			return SetValue(m_closePrice.GetPercentChange(m_netChange));
		}
		return false;
	}
	virtual bool isObjectValueZero() const override{return (m_security->*m_baseFunction)().isZero();}
	virtual bool isValueZero() const override{return m_closePrice.isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_netChange = (m_security->*m_changeFunction)();
		m_closePrice = (m_security->*m_baseFunction)();
		m_value = m_closePrice.GetPercentChange(m_netChange);
	}
	ChangeFunction m_changeFunction;
	BaseFunction m_baseFunction;
	SignedPrice m_netChange;
	Price m_closePrice;
	const Security* m_security;
};

class TGUI_API SecurityMoneyRowValue : public MoneyRowValue
{
public:
	typedef const ValueType& (Security::*MoneyFunction)() const;
	SecurityMoneyRowValue(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick), m_security(security),m_moneyFunction(moneyFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_security->*m_moneyFunction)();}
	DECLARE_NED_NEW
protected:
	const Security* m_security;
	MoneyFunction m_moneyFunction;
};

class TGUI_API SecurityUIntVRowValue : public UIntRowValue
{
public:
	typedef ValueType (Security::*UIntFunction)() const;
	SecurityUIntVRowValue(const Security* const& security, const bool* comma, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true):
		UIntRowValue(comma, useEmptyValue, useTick), m_security(security),m_uintFunction(uintFunction){}
	virtual bool isValueChanged() const override{return m_value != (m_security->*m_uintFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_security->*m_uintFunction)());}
	virtual bool UpdateValue() override{return SetValue((m_security->*m_uintFunction)());}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_uintFunction)();}// == m_emptyValue;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_security->*m_uintFunction)();}
	const Security* m_security;
	UIntFunction m_uintFunction;
};

class TGUI_API SecurityUIntVDiffRowValue : public IntRowValue
{
public:
	typedef unsigned int (Security::*UIntFunction)() const;
	SecurityUIntVDiffRowValue(const Security* const& security, const bool* comma, UIntFunction uintFunction1, UIntFunction uintFunction2, bool useEmptyValue = false, bool useTick = false) :
		IntRowValue(comma, useEmptyValue, useTick), m_security(security), m_uintFunction1(uintFunction1), m_uintFunction2(uintFunction2) {}
	virtual bool isValueChanged() const override{return m_value != (int)(m_security->*m_uintFunction1)() - (int)(m_security->*m_uintFunction2)(); }
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((int)(m_security->*m_uintFunction1)() - (int)(m_security->*m_uintFunction2)());}
	virtual bool UpdateValue() override
	{
		m_value1 = (m_security->*m_uintFunction1)();
		m_value2 = (m_security->*m_uintFunction2)();
		return SetValue(m_value1 > m_value2 ? (int)(m_value1 - m_value2) : -(int)(m_value2 - m_value1));
	}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_uintFunction1)() && !(m_security->*m_uintFunction2)();}
	virtual bool isValueZero() const override{return !m_value1 && !m_value2;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_value1 = (int)(m_security->*m_uintFunction1)();
		m_value2 = (int)(m_security->*m_uintFunction2)();
		m_value = m_value1 - m_value2;
	}
	const Security* m_security;
	UIntFunction m_uintFunction1;
	UIntFunction m_uintFunction2;
	int m_value1;
	int m_value2;
};

//value1 - value2
class TGUI_API SecurityIntRowValueDiff : public IntRowValue
{
public:
	typedef const ValueType& (Security::*IntFunction)() const;
	SecurityIntRowValueDiff(const Security* const& security, const bool* comma, IntFunction intFunction1, IntFunction intFunction2, bool useEmptyValue = false, bool useTick = false):
		IntRowValue(comma, useEmptyValue, useTick), m_security(security),m_intFunction1(intFunction1),m_intFunction2(intFunction2){}
	virtual bool isValueChanged() const override{return m_value1 != (m_security->*m_intFunction1)() || m_value2 != (m_security->*m_intFunction2)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_security->*m_intFunction1)() - (m_security->*m_intFunction2)());}
	virtual bool UpdateValue() override{CalculateComponens(); return SetValue(m_value1 - m_value2);}
	virtual bool isObjectValueZero() const override{return !(m_security->*m_intFunction1)() && !(m_security->*m_intFunction2)();}
	virtual bool isValueZero() const override{return !m_value1 && !m_value2;}
	DECLARE_NED_NEW
protected:
	inline void CalculateComponens()
	{
		m_value1 = (m_security->*m_intFunction1)();
		m_value2 = (m_security->*m_intFunction2)();
	}
	virtual void InitializeValue() override{CalculateComponens(); m_value = m_value1 - m_value2;}
	const Security* m_security;
	IntFunction m_intFunction1;
	IntFunction m_intFunction2;
	int m_value1;
	int m_value2;
};

class TGUI_API SecurityMoneyRowValue2 : public SecurityMoneyRowValue
{
public:
	SecurityMoneyRowValue2(const Security* const& security, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, MoneyFunction moneyFunction2, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		SecurityMoneyRowValue(security, comma, decDigits, truncate, moneyFunction, useEmptyValue, useNeutralColor, useTick),
		m_moneyFunction2(moneyFunction2)
	{
	}
	virtual bool isValueChanged() const override{return m_value != (m_security->*m_moneyFunction)() + (m_security->*m_moneyFunction2)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_security->*m_moneyFunction)() + (m_security->*m_moneyFunction2)());}
	virtual bool UpdateValue() override{return SetValue((m_security->*m_moneyFunction)() + (m_security->*m_moneyFunction2)());}
	virtual bool isObjectValueZero() const override{return ((m_security->*m_moneyFunction)() + (m_security->*m_moneyFunction2)()).isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_security->*m_moneyFunction)() + (m_security->*m_moneyFunction2)();}
	MoneyFunction m_moneyFunction2;
};

#ifndef TAKION_NO_OPTIONS

class TGUI_API OptionLastStrikeValue : public PriceRowValue
{
public:
	virtual Price CalculateIntrinsicFromComponents(const unsigned int& lastNbboPrint) const
	{
		return m_uintStrikePrice < lastNbboPrint ? Price(lastNbboPrint).GetPositivePriceDiff(m_strikePrice) : Price::priceZero;
	}
protected:
	OptionLastStrikeValue(const unsigned int& strikePrice, const unsigned int& lastNbboPrint, const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useTick = true) ://, bool useNeutralColor = false):
		PriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_lastNbboPrintRef(lastNbboPrint),
		m_lastNbboPrint(lastNbboPrint),
		m_uintStrikePrice(strikePrice),
		m_strikePrice(strikePrice)
	{
	}
	const unsigned int& m_lastNbboPrintRef;
	unsigned int m_lastNbboPrint;
	unsigned int m_uintStrikePrice;
	Price m_strikePrice;
};

class TGUI_API OptionCallIntrinsicValue : public OptionLastStrikeValue
{
public:
	OptionCallIntrinsicValue(const unsigned int& strikePrice, const unsigned int& lastNbboPrint, const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useTick = true)://, bool useNeutralColor = false):
		OptionLastStrikeValue(strikePrice, lastNbboPrint, comma, decDigits, truncate, useEmptyValue, useTick)
	{
	}
/*
	virtual Price CalculateIntrinsicFromComponents(const unsigned int& lastNbboPrint) const
	{
		return m_uintStrikePrice < lastNbboPrint ? Price(lastNbboPrint).GetPositivePriceDiff(m_strikePrice) : Price::priceZero;
	}
*/
	Price DeriveValue() const{return CalculateIntrinsicFromComponents(m_lastNbboPrint);}
	Price CalculateValue() const{return CalculateIntrinsicFromComponents(m_lastNbboPrintRef);}
	virtual bool isValueChanged() const override{return m_lastNbboPrint != m_lastNbboPrintRef;}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		if(m_lastNbboPrintRef != m_lastNbboPrint)
		{
			m_lastNbboPrint = m_lastNbboPrintRef;
			return SetValue(DeriveValue());
		}
		return false;
	}
//	virtual bool isObjectValueZero() const override{return !m_lastNbboPrintRef || Price(m_lastNbboPrintRef) <= m_strikePrice;}
	virtual bool isObjectValueZero() const override{return m_lastNbboPrintRef <= m_uintStrikePrice;}
//	virtual bool isValueZero() const override{return !m_lastNbboPrint || Price(m_lastNbboPrint) <= m_strikePrice;}
	virtual bool isValueZero() const override{return m_lastNbboPrint <= m_uintStrikePrice;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_lastNbboPrint = m_lastNbboPrintRef;
		m_value = DeriveValue();
	}
};

class TGUI_API OptionPutIntrinsicValue : public OptionCallIntrinsicValue
{
public:
	OptionPutIntrinsicValue(const unsigned int& strikePrice, const unsigned int& lastNbboPrint, const bool* comma, const unsigned char* decDigits, const bool* truncate, bool useEmptyValue = true, bool useTick = true)://, bool useNeutralColor = false):
		OptionCallIntrinsicValue(strikePrice, lastNbboPrint, comma, decDigits, truncate, useEmptyValue, useTick)
	{
	}
	virtual Price CalculateIntrinsicFromComponents(const unsigned int& lastNbboPrint) const override
	{
		return lastNbboPrint && lastNbboPrint < m_uintStrikePrice ? m_strikePrice.GetPositivePriceDiff(Price(lastNbboPrint)) : Price::priceZero;
	}
	virtual bool isObjectValueZero() const override{return !m_lastNbboPrintRef || m_uintStrikePrice <= m_lastNbboPrintRef;}
	virtual bool isValueZero() const override{return !m_lastNbboPrint || m_uintStrikePrice <= m_lastNbboPrint;}
	DECLARE_NED_NEW
};

class TGUI_API OptionCallTimeValue : public OptionLastStrikeValue
{
public:
	typedef const unsigned int& (Security::*UIntFunction)() const;
	OptionCallTimeValue(const Security* const& security, const unsigned int& lastNbboPrint, const bool* comma, const unsigned char* decDigits, const bool* truncate, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true)://, bool useNeutralColor = false):
		OptionLastStrikeValue(security->GetStrikePrice(), lastNbboPrint, comma, decDigits, truncate, useEmptyValue, useTick),
		m_security(security),
		m_uintFunction(uintFunction),
		m_midPoint(0)
	{
	}
/*
	virtual Price CalculateIntrinsicFromComponents(const unsigned int& lastNbboPrint) const//, const unsigned int& midPoint) const
	{
		return m_uintStrikePrice < lastNbboPrint ? Price(lastNbboPrint).GetPositivePriceDiff(m_strikePrice) : Price::priceZero;
	}
*/
//	SignedPrice DeriveValueFromComponents(const unsigned int& lastNbboPrint, const unsigned int& midPoint) const
	Price DeriveValueFromComponents(const unsigned int& lastNbboPrint, const unsigned int& midPoint) const
	{
		if(lastNbboPrint && midPoint)
		{
//			return Price(midPoint) - CalculateIntrinsicFromComponents(lastNbboPrint);
			return Price(midPoint).GetPositivePriceDiff(CalculateIntrinsicFromComponents(lastNbboPrint));
		}
		return Price::priceZero;
	}
	Price DeriveValue() const{return DeriveValueFromComponents(m_lastNbboPrint, m_midPoint);}
	Price CalculateValue() const{return DeriveValueFromComponents(m_lastNbboPrintRef, (m_security->*m_uintFunction)());}
	virtual bool isValueChanged() const override{return m_lastNbboPrint != m_lastNbboPrintRef || m_midPoint != (m_security->*m_uintFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		bool change = m_lastNbboPrintRef != m_lastNbboPrint;
		if(change)
		{
			m_lastNbboPrint = m_lastNbboPrintRef;
		}
		const unsigned int midPoint = (m_security->*m_uintFunction)();
		if(midPoint != m_midPoint)
		{
			m_midPoint = midPoint;
			change = true;
		}
		if(change)
		{
			return SetValue(DeriveValue());
		}
		return false;
	}
	virtual bool isObjectValueZero() const override{return !m_lastNbboPrintRef || !(m_security->*m_uintFunction)();}// || m_lastNbboPrintRef <= m_uintStrikePrice;}
	virtual bool isValueZero() const override{return !m_lastNbboPrint || !m_midPoint;}// || m_lastNbboPrint <= m_uintStrikePrice;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_midPoint = (m_security->*m_uintFunction)();
		m_lastNbboPrint = m_lastNbboPrintRef;
		m_value = DeriveValue();
	}
	const Security* m_security;
	UIntFunction m_uintFunction;

	unsigned int m_midPoint;
};

class TGUI_API OptionPutTimeValue : public OptionCallTimeValue
{
public:
	OptionPutTimeValue(const Security* const& security, const unsigned int& lastNbboPrint, const bool* comma, const unsigned char* decDigits, const bool* truncate, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true)://, bool useNeutralColor = false):
		OptionCallTimeValue(security, lastNbboPrint, comma, decDigits, truncate, uintFunction, useEmptyValue, useTick)
	{
	}
	virtual Price CalculateIntrinsicFromComponents(const unsigned int& lastNbboPrint) const override//, const unsigned int& midPoint) const
	{
		return lastNbboPrint < m_uintStrikePrice ? m_strikePrice.GetPositivePriceDiff(Price(lastNbboPrint)) : Price::priceZero;
	}
//	virtual bool isObjectValueZero() const override{return !m_lastNbboPrintRef || !(m_security->*m_uintFunction)();}// || m_uintStrikePrice <= m_lastNbboPrintRef;}
//	virtual bool isValueZero() const override{return !m_lastNbboPrint || !m_midPoint;}// || m_uintStrikePrice <= m_lastNbboPrint;}
	DECLARE_NED_NEW
};

#endif

class TGUI_API IndexStringRowValue : public StringRowValue
{
public:
	typedef const ValueType& (Index::*StringFunction)() const;
	IndexStringRowValue(const Index* const& index, StringFunction stringFunction):m_index(index),m_stringFunction(stringFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_index->*m_stringFunction)();}
	DECLARE_NED_NEW
protected:
	const Index* m_index;
	StringFunction m_stringFunction;
};

class TGUI_API IndexBoolRowValue : public BoolRowValue
{
public:
	typedef const ValueType& (Index::*BoolFunction)() const;
	IndexBoolRowValue(const Index* const& index, BoolFunction boolFunction, char trueValue = 'Y', char falseValue = '\0'):
		BoolRowValue(trueValue, falseValue),
		m_index(index),
		m_boolFunction(boolFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_index->*m_boolFunction)();}
	DECLARE_NED_NEW
protected:
	const Index* m_index;
	BoolFunction m_boolFunction;
};

class TGUI_API IndexTimeRowValue : public TimeRowValue
{
public:
	typedef const ValueType& (Index::*UIntFunction)() const;
	IndexTimeRowValue(const Index* const& index, const bool* showMilliseconds, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true):
		TimeRowValue(showMilliseconds, useEmptyValue, useTick),
		m_index(index),
		m_uintFunction(uintFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_index->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	const Index* m_index;
	UIntFunction m_uintFunction;
};

class TGUI_API IndexBoolRefRowValue : public BoolRowValue
{
public:
	typedef bool (Index::*BoolFunction)() const;
	IndexBoolRefRowValue(const Index* const& index, BoolFunction boolFunction, char trueValue = 'Y', char falseValue = '\0'):
		BoolRowValue(trueValue, falseValue),
		m_index(index),
		m_boolFunction(boolFunction)
	{
//			InitializeValue();
	}
//	virtual const bool& GetObjectValue() const override{return m_security && (m_security->*m_boolFunction)();}

	virtual bool isValueChanged() const override{return m_value != (m_index && (m_index->*m_boolFunction)());}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(m_index && (m_index->*m_boolFunction)());}
	virtual bool UpdateValue() override{return SetValue(m_index && (m_index->*m_boolFunction)());}
	virtual bool isObjectValueZero() const override{return (!m_index || !(m_index->*m_boolFunction)());}// == m_emptyValue;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = m_index && (m_index->*m_boolFunction)();}
	const Index* const& m_index;
	BoolFunction m_boolFunction;
};

class TGUI_API IndexPriceRowValue : public PriceRowValue
{
public:
	typedef const ValueType& (Index::*PriceFunction)() const;
	IndexPriceRowValue(const Index* const& index, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, bool useEmptyValue = false, bool useTick = true):
		PriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick), m_index(index),m_priceFunction(priceFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_index->*m_priceFunction)();}
	DECLARE_NED_NEW
protected:
	const Index* m_index;
	PriceFunction m_priceFunction;
};

class TGUI_API IndexCompactPriceRowValue : public CompactPriceRowValue
{
public:
	typedef const ValueType& (Index::*PriceFunction)() const;
	IndexCompactPriceRowValue(const Index* const& index, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, bool useEmptyValue = false, bool useTick = true):
		CompactPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick), m_index(index),m_priceFunction(priceFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_index->*m_priceFunction)();}
	DECLARE_NED_NEW
protected:
	const Index* m_index;
	PriceFunction m_priceFunction;
};

class TGUI_API IndexSignedPriceRowValue : public SignedPriceRowValue
{
public:
	typedef const ValueType& (Index::*SignedPriceFunction)() const;
	IndexSignedPriceRowValue(const Index* const& index, const bool* comma, const unsigned char* decDigits, const bool* truncate, SignedPriceFunction signedPriceFunction, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = false):
		SignedPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick, useNeutralColor), m_index(index),m_signedPriceFunction(signedPriceFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_index->*m_signedPriceFunction)();}
	DECLARE_NED_NEW
protected:
	const Index* m_index;
	SignedPriceFunction m_signedPriceFunction;
};

class TGUI_API IndexPriceDivision : public MoneyRowValue
{
public:
	typedef const SignedPrice& (Index::*SignedPriceFunction)() const;
	IndexPriceDivision(const Index* const& index, const bool* comma, const unsigned char* decDigits, const bool* truncate, SignedPriceFunction signedPriceFunction, SignedPriceFunction dividerFunction, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = false):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_index(index),
		m_signedPriceFunction(signedPriceFunction),
		m_dividerFunction(dividerFunction)
	{
	}
//	virtual bool CanBeNegative() const{return !m_absValue;}
	inline static ValueType DeriveValue(const SignedPrice& signedPrice, const SignedPrice& divider)
	{
		if(!divider.isZero())
		{
			Money value(signedPrice);
			if(DivideMoneyBySignedPrice(value, divider))return value;
		}
		return Money::moneyZero;
	}
	inline ValueType DeriveValue() const{return DeriveValue(m_signedPrice, m_divider);}
	inline ValueType CalculateValue() const{return DeriveValue((m_index->*m_signedPriceFunction)(), (m_index->*m_dividerFunction)());}
	virtual bool isValueChanged() const override{return m_signedPrice != (m_index->*m_signedPriceFunction)() || m_divider != (m_index->*m_dividerFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_signedPrice = (m_index->*m_signedPriceFunction)();
		m_divider = (m_index->*m_dividerFunction)();
		return SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return (m_index->*m_dividerFunction)().isZero();}
	virtual bool isValueZero() const override{return m_divider.isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_signedPrice = (m_index->*m_signedPriceFunction)();
		m_divider = (m_index->*m_dividerFunction)();
		m_value = DeriveValue();
	}
	const Index* m_index;
	SignedPrice m_signedPrice;
	SignedPrice m_divider;
	SignedPriceFunction m_signedPriceFunction;
	SignedPriceFunction m_dividerFunction;
};

class TGUI_API IndexPriceRowValueDiff : public SignedPriceRowValue
{
public:
	typedef const ValueType& (Index::*PriceFunction)() const;
	IndexPriceRowValueDiff(const Index* const& index, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, PriceFunction priceFunction2, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		SignedPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick, useNeutralColor),
		m_index(index),
		m_priceFunction(priceFunction),
		m_priceFunction2(priceFunction2)
	{
	}
	inline ValueType CalculateValue() const{return (m_index->*m_priceFunction)() - (m_index->*m_priceFunction2)();}
	inline ValueType DeriveValue() const{return m_price - m_price2;}
	virtual bool isValueChanged() const override{return m_price != (m_index->*m_priceFunction)() || m_price2 != (m_index->*m_priceFunction2)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue() override
	{
		m_price = (m_index->*m_priceFunction)();
		m_price2 = (m_index->*m_priceFunction2)();
		return SetValue(DeriveValue());
	}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_price = (m_index->*m_priceFunction)();
		m_price2 = (m_index->*m_priceFunction2)();
		m_value = DeriveValue();
	}
	const Index* m_index;
	ValueType m_price;
	ValueType m_price2;
	PriceFunction m_priceFunction;
	PriceFunction m_priceFunction2;
};

class TGUI_API IndexPriceRowValueDiffPositiveOnly : public IndexPriceRowValueDiff
{
public:
	IndexPriceRowValueDiffPositiveOnly(const Index* const& index, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, PriceFunction priceFunction2, bool useEmptyValue = false, bool useTick = true, bool useNeutralColor = true):
		IndexPriceRowValueDiff(index, comma, decDigits, truncate, priceFunction, priceFunction2, useEmptyValue, useTick, useNeutralColor)
	{
	}
	virtual bool CanBeNegative() const override{return false;}
	DECLARE_NED_NEW
};

class TGUI_API IndexPriceDiffByOnePriceDivision : public MoneyRowValue
{
public:
	typedef const SignedPrice& (Index::*PriceFunction)() const;
	IndexPriceDiffByOnePriceDivision(bool absValue, const Index* const& index, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction1, PriceFunction priceFunction2, bool useEmptyValue = true, bool useTick = true, bool useNeutralColor = false):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_index(index),
		m_priceFunction1(priceFunction1),
		m_priceFunction2(priceFunction2),
		m_absValue(absValue)
	{
	}
	virtual bool CanBeNegative() const override{return !m_absValue;}
	inline Money DeriveValue(const SignedPrice& price1, const SignedPrice& price2) const
	{
		if(!price1.isZero())
		{
			Money value(price1 < price2 || !m_absValue ? price2 - price1 : price1 - price2);
			if(DivideMoneyBySignedPrice(value, price1))return value;
		}
		return Money::moneyZero;
	}
	inline Money DeriveValue() const{return DeriveValue(m_price1, m_price2);}
	inline Money CalculateValue() const{return DeriveValue((m_index->*m_priceFunction1)(), (m_index->*m_priceFunction2)());}
	virtual bool isValueChanged() const override{return m_price1 != (m_index->*m_priceFunction1)() || m_price2 != (m_index->*m_priceFunction2)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(CalculateValue());}
	virtual bool UpdateValue()override
	{
		m_price1 = (m_index->*m_priceFunction1)();
		m_price2 = (m_index->*m_priceFunction2)();
		return SetValue(DeriveValue());
	}
	virtual bool isObjectValueZero() const override{return (m_index->*m_priceFunction1)().isZero();}
	virtual bool isValueZero() const override{return m_price1.isZero();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_price1 = (m_index->*m_priceFunction1)();
		m_price2 = (m_index->*m_priceFunction2)();
		m_value = DeriveValue();
	}
	const Index* m_index;
	SignedPrice m_price1;
	SignedPrice m_price2;
	PriceFunction m_priceFunction1;
	PriceFunction m_priceFunction2;
	bool m_absValue;
};

////
class TGUI_API OrderCharRowValue : public CharRowValue
{
public:
	typedef const ValueType& (Order::*CharFunction)() const;
	OrderCharRowValue(const Order* const& order, CharFunction charFunction, const ValueType& value = '\0', bool useEmptyValue = false, bool useNeutralColor = false, bool useTick = false):
		CharRowValue(value, useEmptyValue, useNeutralColor, useTick), m_order(order),m_charFunction(charFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_order->*m_charFunction)();}
	DECLARE_NED_NEW
protected:
	const Order* m_order;
	CharFunction m_charFunction;
};

class TGUI_API OrderUCharAsCharVRowValue : public UCharAsCharRowValue
{
public:
	typedef ValueType (Order::*UCharFunction)() const;
	OrderUCharAsCharVRowValue(const Order* const& order, UCharFunction ucharFunction, const ValueType& value = '\0', bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		UCharAsCharRowValue(value, useEmptyValue, useTick), m_order(order),m_ucharFunction(ucharFunction){}
	virtual bool isValueChanged() const override{return m_value != (m_order->*m_ucharFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_order->*m_ucharFunction)());}
	virtual bool UpdateValue() override{return SetValue((m_order->*m_ucharFunction)());}
	virtual bool isObjectValueZero() const override{return !(m_order->*m_ucharFunction)();}// == m_emptyValue;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_order->*m_ucharFunction)();}
	const Order* m_order;
	UCharFunction m_ucharFunction;
};

class TGUI_API OrderBoolRowValue : public BoolRowValue
{
public:
	typedef const ValueType& (Order::*BoolFunction)() const;
	OrderBoolRowValue(const Order* const& order, BoolFunction boolFunction, char trueValue = 'Y', char falseValue = '\0'):
		BoolRowValue(trueValue, falseValue),
		m_order(order),
		m_boolFunction(boolFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_order->*m_boolFunction)();}
	DECLARE_NED_NEW
protected:
	const Order* m_order;
	BoolFunction m_boolFunction;
};

class TGUI_API OrderPendingStateRowValue : public UCharRowValue
{
public:
//	typedef const ValueType& (Order::*UCharFunction)() const;
	OrderPendingStateRowValue(const Order* const& order):
		UCharRowValue(false, false),
		m_order(order)
	{}
	virtual const ValueType& GetObjectValue() const override{return m_order->GetOrderState();}
	virtual void toString(std::string& text) const override;
	DECLARE_NED_NEW
protected:
	const Order* m_order;
//	UCharFunction m_boolFunction;
};

class TGUI_API OrderBoolRowValueCountable : public BoolRowValueCountable
{
public:
	typedef const ValueType& (Order::*BoolFunction)() const;
	OrderBoolRowValueCountable(const Order* const& order, BoolFunction boolFunction, const char& trueValue = 'Y', const char& falseValue = '\0'):
		BoolRowValueCountable(trueValue, falseValue),
		m_order(order),
		m_boolFunction(boolFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_order->*m_boolFunction)();}
	DECLARE_NED_NEW
protected:
	const Order* m_order;
	BoolFunction m_boolFunction;
};

class TGUI_API OrderBoolRowValueCountableOpposite : public BoolRowValueCountableOpposite
{
public:
	typedef const ValueType& (Order::*BoolFunction)() const;
	OrderBoolRowValueCountableOpposite(const Order* const& order, BoolFunction boolFunction, const char& trueValue = '\0', const char& falseValue = 'N'):
		BoolRowValueCountableOpposite(trueValue, falseValue),
		m_order(order),
		m_boolFunction(boolFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_order->*m_boolFunction)();}
	DECLARE_NED_NEW
protected:
	const Order* m_order;
	BoolFunction m_boolFunction;
};

class TGUI_API OrderBoolRefRowValueCountable : public BoolRowValueCountable
{
public:
	typedef ValueType (Order::*BoolFunction)() const;
	OrderBoolRefRowValueCountable(const Order* const& order, BoolFunction boolFunction, char trueValue = 'Y', char falseValue = '\0'):
		BoolRowValueCountable(trueValue, falseValue),
		m_order(order),
		m_boolFunction(boolFunction)
	{
//			InitializeValue();
	}
//	virtual const bool& GetObjectValue() const override{return m_security && (m_security->*m_boolFunction)();}

	virtual bool isValueChanged() const override{return m_value != (m_order->*m_boolFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_order->*m_boolFunction)());}
	virtual bool UpdateValue() override{return SetValue((m_order->*m_boolFunction)());}
	virtual bool isObjectValueZero() const override{return !(m_order->*m_boolFunction)();}// == m_emptyValue;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_order->*m_boolFunction)();}
	const Order* m_order;
	BoolFunction m_boolFunction;
};

class TGUI_API OrderUCharFlagRowValue : public FlagRowValue<unsigned char>//, char>
{
public:
	typedef const ValueType& (Order::*UCharFunction)() const;
	OrderUCharFlagRowValue(const Order* const& order, UCharFunction ucharFunction, const ValueType& flag, const char& trueValue = 'Y', const char& falseValue = '\0'):
		FlagRowValue('\0', flag, trueValue, falseValue), m_order(order),m_ucharFunction(ucharFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_order->*m_ucharFunction)();}
	DECLARE_NED_NEW
protected:
	const Order* m_order;
	UCharFunction m_ucharFunction;
};

class TGUI_API OrderStringRowValue : public StringRowValue
{
public:
	typedef const ValueType& (Order::*StringFunction)() const;
	OrderStringRowValue(const Order* const& order, StringFunction stringFunction):m_order(order),m_stringFunction(stringFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_order->*m_stringFunction)();}
	DECLARE_NED_NEW
protected:
	const Order* m_order;
	StringFunction m_stringFunction;
};

class TGUI_API OrderStringPtrRowValue : public StringRowValue
{
public:
	typedef const char* const& (Order::*StringPtrFunction)() const;
	OrderStringPtrRowValue(const Order* const& order, StringPtrFunction stringFunction):m_order(order),m_stringFunction(stringFunction){}
	virtual const ValueType& GetObjectValue() const override;
	DECLARE_NED_NEW
protected:
	const Order* m_order;
	StringPtrFunction m_stringFunction;
	mutable ValueType m_tempValue;
};

class TGUI_API OrderCharPtrRowValue : public CharPtrRowValue
{
public:
	typedef ValueType (Order::*StringPtrFunction)() const;
	OrderCharPtrRowValue(const Order* const& order, StringPtrFunction stringFunction, const bool& caseInsensitive = false):
		CharPtrRowValue(caseInsensitive), m_order(order),m_stringFunction(stringFunction),m_tempValue(""){}
	virtual ValueType const& GetObjectValue() const override;
	DECLARE_NED_NEW
protected:
	const Order* m_order;
	StringPtrFunction m_stringFunction;
	mutable ValueType m_tempValue;
};

class TGUI_API OrderIntRowValue : public IntRowValue
{
public:
	typedef const ValueType& (Order::*IntFunction)() const;
	OrderIntRowValue(const Order* const& order, const bool* comma, IntFunction intFunction, const bool& useEmptyValue = true, const bool& useTick = true):
		IntRowValue(comma, useEmptyValue, useTick),
		m_order(order),
		m_intFunction(intFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_order->*m_intFunction)();}
	DECLARE_NED_NEW
protected:
	const Order* m_order;
	IntFunction m_intFunction;
};

class TGUI_API OrderIntInventoryRowValue : public IntRowValue
{
public:
	typedef const ValueType& (Order::*IntFunction)(const bool& inventoryView) const;
	OrderIntInventoryRowValue(const Order* const& order, const bool& inventoryView, const bool* const& comma, IntFunction intFunction, const bool& useEmptyValue = true, const bool& useTick = true):
		IntRowValue(comma, useEmptyValue, useTick),
		m_order(order),
		m_intFunction(intFunction),
		m_inventoryView(inventoryView){}
	virtual const ValueType& GetObjectValue() const override{return (m_order->*m_intFunction)(m_inventoryView);}
	DECLARE_NED_NEW
protected:
	const Order* m_order;
	IntFunction m_intFunction;
	const bool& m_inventoryView;
};

class TGUI_API OrderUIntRowValue : public UIntRowValue
{
public:
	typedef const ValueType& (Order::*UIntFunction)() const;
	OrderUIntRowValue(const Order* const& order, const bool* const& comma, UIntFunction uintFunction, const bool& useEmptyValue = true, const bool& useTick = true):
		UIntRowValue(comma, useEmptyValue, useTick), m_order(order),m_uintFunction(uintFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_order->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	const Order* m_order;
	UIntFunction m_uintFunction;
};

class TGUI_API OrderUIntVRowValue : public UIntRowValue
{
public:
	typedef ValueType (Order::*UIntFunction)() const;
	OrderUIntVRowValue(const Order* const& order, const bool* const& comma, UIntFunction uintFunction, const bool& useEmptyValue = true, const bool& useTick = true):
		UIntRowValue(comma, useEmptyValue, useTick),
		m_order(order),
		m_uintFunction(uintFunction){}
//	virtual const unsigned int& GetObjectValue() const override{return (m_account->*m_uintFunction)();}
	virtual bool isValueChanged() const override{return m_value != (m_order->*m_uintFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_order->*m_uintFunction)());}
	virtual bool UpdateValue() override{return SetValue((m_order->*m_uintFunction)());}
//	virtual bool isObjectValueEmpty() const override;//{return m_useEmptyValue && (m_account->*m_uintFunction)() == m_emptyValue;}
	virtual bool isObjectValueZero() const override{return !(m_order->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_order->*m_uintFunction)();}
	const Order* m_order;
	UIntFunction m_uintFunction;
};
/*
class TGUI_API OrderLiveIntInventoryRowValue : public OrderIntInventoryRowValue
{
public:
	OrderLiveIntInventoryRowValue(const Order* const& order, const bool& inventoryView, const bool* const& comma, IntFunction intFunction, const bool& useEmptyValue = true, const bool& useTick = true):
		OrderIntInventoryRowValue(order, inventoryView, comma, intFunction, useEmptyValue, useTick)
	{}
	virtual const ValueType& GetObjectValue() const override{return m_order->isDead() ? m_value : (m_order->*m_intFunction)(m_inventoryView);}
	DECLARE_NED_NEW
};
*/
class TGUI_API OrderDirectionRowValue : public UCharRowValue
{
public:
//	typedef OrderDirection (Order::*UIntFunction)() const;
	OrderDirectionRowValue(const Order* const& order)://, const bool& useEmptyValue = true, const bool& useTick = true) :
//		UCharRowValue(true, false),//useEmptyValue, useTick),
		UCharRowValue(false, false),//useEmptyValue, useTick),
		m_order(order)
//		m_uintFunction(uintFunction)
	{}
//	virtual const unsigned int& GetObjectValue() const override{return (m_account->*m_uintFunction)();}
	virtual bool isValueChanged() const override{return m_value != m_order->GetOrderDirection();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue(m_order->GetOrderDirection());}

//	ValueType GetDynamicOrderDirection() const{return m_order->isDead() ? m_value : m_order->GetOrderDirection();}
//	virtual bool UpdateValue() override{return SetValue(GetDynamicOrderDirection());}// m_order->GetOrderDirection());}
	virtual bool UpdateValue() override{return SetValue(m_order->GetOrderDirection());}

//	virtual bool isObjectValueEmpty() const;//{return m_useEmptyValue && (m_account->*m_uintFunction)() == m_emptyValue;}

//	virtual bool isObjectValueZero() const override{return m_order->GetOrderDirection() >= ODIR_Count;}
//	virtual bool isValueZero() const override{return m_value >= ODIR_Count;}
	virtual void toString(std::string& text) const override
	{
		switch(m_value)
		{
			case ODIR_NONE:
//			text += "Dead";
			break;

			case ODIR_CLOSE:
			text += "Close";
			break;

			case ODIR_OPEN:
			text += "Open";
			break;

			case ODIR_ADD:
			text += "Add";
			break;

			default:
			text += "ERR";
			break;
		}
	}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = m_order->GetOrderDirection();}
	const Order* m_order;
};
/*
class TGUI_API OrderPositionSizeRowValue : public IntRowValue
{
public:
	typedef const ValueType& (Position::*IntFunction)() const;
	OrderPositionSizeRowValue(const Order* const& order, const bool* const& comma, IntFunction intFunction)://, const bool& useEmptyValue = true, const bool& useTick = true) :
		IntRowValue(comma, true, false),//useEmptyValue, useTick),
		m_position(order->GetPosition()),
		m_intFunction(intFunction)
	{}
	virtual const ValueType& GetObjectValue() const override{return (m_position->*m_intFunction)();}
//	virtual bool isValueChanged() const override{return m_value != (m_position->*m_intFunction)();}
//	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_position->*m_intFunction)());}
//	virtual bool UpdateValue() override{return SetValue((m_position->*m_intFunction)());}
	DECLARE_NED_NEW
protected:
//	virtual void InitializeValue() override{m_value = (m_position->*m_intFunction)();}
//	const Order* m_order;
	const Position* m_position;
	IntFunction m_intFunction;
};
*/
class TGUI_API OrderUIntRowValueNoComma : public UIntRowValueNoComma
{
public:
	typedef const ValueType& (Order::*UIntFunction)() const;
	OrderUIntRowValueNoComma(const Order* const& order, UIntFunction uintFunction, const bool& useEmptyValue = true, const bool& useTick = false):
		UIntRowValueNoComma(useEmptyValue, useTick), m_order(order),m_uintFunction(uintFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_order->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	const Order* m_order;
	UIntFunction m_uintFunction;
};

class TGUI_API OrderUIntAsStrRowValue : public UIntAsStrRowValue
{
public:
	typedef const ValueType& (Order::*UIntFunction)() const;
	OrderUIntAsStrRowValue(const Order* order, UIntFunction uintFunction):
		m_order(order),
		m_uintFunction(uintFunction)
	{}
	virtual const ValueType& GetObjectValue() const override{return (m_order->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	const Order* m_order;
	UIntFunction m_uintFunction;
};

class TGUI_API OrderUShortRowValue : public UShortRowValue
{
public:
	typedef const ValueType& (Order::*UShortFunction)() const;
	OrderUShortRowValue(const Order* const& order, UShortFunction ushortFunction, const bool& useEmptyValue = true, const bool& useTick = true):
		UShortRowValue(useEmptyValue, useTick), m_order(order),m_ushortFunction(ushortFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_order->*m_ushortFunction)();}
	DECLARE_NED_NEW
protected:
	const Order* m_order;
	UShortFunction m_ushortFunction;
};

class TGUI_API OrderShortRowValue : public ShortRowValue
{
public:
	typedef const ValueType& (Order::*ShortFunction)() const;
	OrderShortRowValue(const Order* const& order, ShortFunction shortFunction, const bool& useEmptyValue = false, const bool& useTick = true):
		ShortRowValue(useEmptyValue, useTick), m_order(order),m_shortFunction(shortFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_order->*m_shortFunction)();}
	DECLARE_NED_NEW
protected:
	const Order* m_order;
	ShortFunction m_shortFunction;
};

class TGUI_API OrderTimeRowValue : public TimeRowValue
{
public:
	typedef const ValueType& (Order::*UIntFunction)() const;
	OrderTimeRowValue(const Order* const& order, const bool* const& showMilliseconds, UIntFunction uintFunction, const bool& useEmptyValue = true, const bool& useTick = false):
		TimeRowValue(showMilliseconds, useEmptyValue, useTick), m_order(order),m_uintFunction(uintFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_order->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	const Order* m_order;
	UIntFunction m_uintFunction;
};

class TGUI_API OrderIpRowValue : public IpRowValue
{
public:
	typedef const ValueType& (Order::*UIntFunction)() const;
	OrderIpRowValue(const Order* const& order, UIntFunction uintFunction, const bool& useEmptyValue = true):
		IpRowValue(useEmptyValue), m_order(order), m_uintFunction(uintFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_order->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	const Order* m_order;
	UIntFunction m_uintFunction;
};

class TGUI_API OrderPriceRowValue : public PriceRowValue
{
public:
	typedef const ValueType& (Order::*PriceFunction)() const;
	OrderPriceRowValue(const Order* const& order, const bool* const& comma, const unsigned char* const& decDigits, const bool* const& truncate, PriceFunction priceFunction, const bool& useEmptyValue = true, const bool& useTick = true):
		PriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick), m_order(order),m_priceFunction(priceFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_order->*m_priceFunction)();}
	DECLARE_NED_NEW
protected:
	const Order* m_order;
	PriceFunction m_priceFunction;
};

class TGUI_API OrderCompactPriceRowValue : public CompactPriceRowValue
{
public:
	typedef const ValueType& (Order::*PriceFunction)() const;
	OrderCompactPriceRowValue(const Order* const& order, const bool* const& comma, const unsigned char* const& decDigits, const bool* const& truncate, PriceFunction priceFunction, const bool& useEmptyValue = true, const bool& useTick = true):
		CompactPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick), m_order(order),m_priceFunction(priceFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_order->*m_priceFunction)();}
	DECLARE_NED_NEW
protected:
	const Order* m_order;
	PriceFunction m_priceFunction;
};

class TGUI_API OrderSignedPriceRowValue : public SignedPriceRowValue
{
public:
	typedef const ValueType& (Order::*SignedPriceFunction)() const;
	OrderSignedPriceRowValue(const Order* const& order, const bool* const& comma, const unsigned char* const& decDigits, const bool* const& truncate, SignedPriceFunction signedPriceFunction, const bool& useEmptyValue = true, const bool& useTick = true):
		SignedPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick), m_order(order),m_signedPriceFunction(signedPriceFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_order->*m_signedPriceFunction)();}
	DECLARE_NED_NEW
protected:
	const Order* m_order;
	SignedPriceFunction m_signedPriceFunction;
};

class TGUI_API OrderCompactSignedPriceRowValue : public CompactSignedPriceRowValue
{
public:
	typedef const ValueType& (Order::*SignedPriceFunction)() const;
	OrderCompactSignedPriceRowValue(const Order* const& order, const bool* const& comma, const unsigned char* const& decDigits, const bool* const& truncate, SignedPriceFunction signedPriceFunction, const bool& useEmptyValue = true, const bool& useTick = true):
		CompactSignedPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick), m_order(order), m_signedPriceFunction(signedPriceFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_order->*m_signedPriceFunction)();}
	DECLARE_NED_NEW
protected:
	const Order* m_order;
	SignedPriceFunction m_signedPriceFunction;
};

class TGUI_API OrderMoneyRowValue : public MoneyRowValue
{
public:
	typedef const ValueType& (Order::*MoneyFunction)() const;
	OrderMoneyRowValue(const Order* const& order, const bool* const& comma, const unsigned char* const& decDigits, const bool* const& truncate, MoneyFunction moneyFunction, const bool& useEmptyValue = true, const bool& useNeutralColor = false, const bool& useTick = true):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_order(order),
		m_moneyFunction(moneyFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_order->*m_moneyFunction)();}
	DECLARE_NED_NEW
protected:
	const Order* m_order;
	MoneyFunction m_moneyFunction;
};

class TGUI_API OrderMoneyInventoryRowValue : public MoneyRowValue
{
public:
	typedef const ValueType& (Order::*MoneyFunction)(const bool& inventoryView) const;
	OrderMoneyInventoryRowValue(const Order* const& order, const bool& inventoryView, const bool* const& comma, const unsigned char* const& decDigits, const bool* const& truncate, MoneyFunction moneyFunction, const bool& useEmptyValue = true, const bool& useNeutralColor = false, const bool& useTick = true):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_order(order),
		m_moneyFunction(moneyFunction),
		m_inventoryView(inventoryView){}
	virtual const ValueType& GetObjectValue() const override{return (m_order->*m_moneyFunction)(m_inventoryView);}
	DECLARE_NED_NEW
protected:
	const Order* m_order;
	MoneyFunction m_moneyFunction;
	const bool& m_inventoryView;
};

class TGUI_API OrderUCharAsStringRowValue : public UCharRowValue
{
public:
	typedef const ValueType& (Order::*UCharFunction)() const;

//	virtual void toString(std::string& text) const;
protected:
	OrderUCharAsStringRowValue(const Order* const& order, UCharFunction ucharFunction, const bool& useEmptyValue = true, const bool& useTick = false):
		UCharRowValue(0, useEmptyValue, useTick), m_order(order),m_ucharFunction(ucharFunction){}

	virtual const ValueType& GetObjectValue() const override{return (m_order->*m_ucharFunction)();}
	const Order* m_order;
	UCharFunction m_ucharFunction;
};

class TGUI_API OrderPegTypeRowValue : public OrderUCharAsStringRowValue
{
public:
	OrderPegTypeRowValue(const Order* const& order, UCharFunction ucharFunction):
		OrderUCharAsStringRowValue(order, ucharFunction, true, false){}
	DECLARE_NED_NEW
	virtual void toString(std::string& text) const override{if(!isValueEmpty())TU_GetPegTypeAsString(text, m_value, "", "ERROR", false);}
};

class TGUI_API OrderTifTypeRowValue : public OrderUCharAsStringRowValue
{
public:
	OrderTifTypeRowValue(const Order* const& order, const bool* const& showMilliseconds)://, UCharFunction ucharFunction):
		OrderUCharAsStringRowValue(order, &Order::GetTifType, false, false),
		m_showMilliseconds(showMilliseconds),
		m_millisecond(0),
		m_monitorTif(false)
	{}
	virtual void toString(std::string& text) const override{TU_GetTifAsString(text, m_value, m_monitorTif, NULL, m_millisecond, *m_showMilliseconds, "ERROR", false);}
/*
	virtual UINT GetHorizontalJustification() const
	{
		switch(m_value)
		{
			case TIF_GTD:
			case TIF_GTT:
			return DT_RIGHT;

			default:
			return DT_CENTER;
		}
//		return m_value == TIF_GTD ? DT_RIGHT : DT_CENTER;
	}
*/
//	virtual short CompareValue(const ValueType& other) const{return m_value < other ? -1 : other < m_value ? 1 : 0;}
	inline static short CompareTif(const RowValue& other, const ValueType& myValue, const unsigned int& myMillisecond, const bool& myMonitorTif)
	{
		const OrderTifTypeRowValue& otherTif = (const OrderTifTypeRowValue&)other;
		return myValue != otherTif.m_value ? myValue < otherTif.m_value ? -1 : 1 :
			myValue != TIF_GTD && myValue != TIF_GTT ? 0 :
			myMillisecond < otherTif.m_millisecond ? -1 :
			myMillisecond > otherTif.m_millisecond ? 1 :

			myMonitorTif != otherTif.m_monitorTif ? myMonitorTif ? -1 : 1 : 0;
	}
	virtual short Compare(const RowValue& other) const override
	{
//		return CompareValue(((const TypedRowValue&)other).m_value);
/*
		const OrderTifTypeRowValue& otherTif = (const OrderTifTypeRowValue&)other;
		return m_value != otherTif.m_value ? m_value < otherTif.m_value ? -1 : 1:
			m_value != TIF_GTD && m_value != TIF_GTT ? 0: 
				m_millisecond < otherTif.m_millisecond ? -1:
				m_millisecond > otherTif.m_millisecond ? 1:

				m_monitorTif != otherTif.m_monitorTif ? m_monitorTif:
				0;
*/
		return CompareTif(other, m_value, m_millisecond, m_monitorTif);
	}
	virtual short CompareAhead(const RowValue& other) const override//{return -((const TypedRowValue&)other).CompareValue(GetObjectValue());}
	{
/*
		const OrderTifTypeRowValue& otherTif = (const OrderTifTypeRowValue&)other;
		const unsigned char tifType = m_order->GetTifType();
		return tifType != otherTif.m_value ? tifType < otherTif.m_value ? -1 : 1:
			tifType != TIF_GTD && m_value != TIF_GTT ? 0: 
				m_order->GetTifMillisecond() < otherTif.m_millisecond ? -1:
				m_order->GetTifMillisecond() > otherTif.m_millisecond ? 1:

				m_order->isMonitorTif() != otherTif.m_monitorTif ? m_order->isMonitorTif():
				0;
*/
		return CompareTif(other, m_order->GetTifType(), m_order->GetTifMillisecond(), m_order->isMonitorTif());
	}

	virtual const ValueType& GetObjectValue() const override{return m_order->GetTifType();}
	virtual bool isValueChanged() const override
	{
		if(m_value != GetObjectValue())
		{
			return true;
		}
		else
		{
			switch(m_value)
			{
				case TIF_GTD:
				case TIF_GTT:
				return m_millisecond != m_order->GetTifMillisecond() || m_monitorTif != m_order->isMonitorTif();
			}
			return false;
		}
	}
/*
	virtual bool SetValue(const ValueType& value)// in future we can add the time when the change happened
	{
		if(m_value != value)
		{
			if(!m_initialized)
			{
				m_initialized = true;
			}
			m_value = value;
			return true;
		}
		return false;
	}
*/
	virtual bool UpdateValue() override
	{
		bool changed = false;
//		return SetValue(GetObjectValue());
		if(m_value != m_order->GetTifType())
		{
			switch(m_value)
			{
				case TIF_GTD:
				case TIF_GTT:
				m_millisecond = 0;
				m_monitorTif = false;

			}
			m_value = m_order->GetTifType();
			changed = true;
		}
//		if(TIF_GTD == m_value)
		switch(m_value)
		{
			case TIF_GTD:
			case TIF_GTT:
			if(m_order->GetTifMillisecond() != m_millisecond)
			{
				m_millisecond = m_order->GetTifMillisecond();
				changed = true;
			}
			if(m_order->isMonitorTif() != m_monitorTif)
			{
				m_monitorTif = m_order->isMonitorTif();
				changed = true;
			}
		}
		return changed;
	}
	virtual void InitValue() override
	{
		InitializeValue();
//		if(!isValueZero())
		m_initialized = true;
	}
	virtual bool isValueEmpty() const override{return m_useEmptyValue && isValueZero();}
	virtual bool isObjectValueEmpty() const override{return m_useEmptyValue && isObjectValueZero();}//GetObjectValue() == m_emptyValue;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_value = m_order->GetTifType();
//		if(TIF_GTD == m_value)
		switch(m_value)
		{
			case TIF_GTD:
			case TIF_GTT:
			m_millisecond = m_order->GetTifMillisecond();
			m_monitorTif = m_order->isMonitorTif();
			break;
		}
	}
	const bool* m_showMilliseconds;
	unsigned int m_millisecond;
	bool m_monitorTif;
};
///////////////
/*
class TGUI_API ExecutionCharPtrRowValue : public CharPtrRowValue
{
public:
	typedef ValueType (Execution::*StringPtrFunction)() const;
	ExecutionCharPtrRowValue(const Execution* execution, StringPtrFunction stringFunction, bool caseInsensitive = false):
		CharPtrRowValue(caseInsensitive), m_execution(execution),m_stringFunction(stringFunction),m_tempValue(""){}
	virtual ValueType const& GetObjectValue() const
	{
		const char* ret = (m_execution->*m_stringFunction)();
		if(ret)
		{
			if(strcmp(m_tempValue, ret))
			{
				m_tempValue = ret;
			}
		}
		else
		{
			m_tempValue = "";
		}
		return m_tempValue;
	}
	DECLARE_NED_NEW
protected:
	const Execution* m_execution;
	StringPtrFunction m_stringFunction;
	mutable ValueType m_tempValue;
};

class TGUI_API ExecutionCharRowValue : public CharRowValue
{
public:
	typedef const ValueType& (Execution::*CharFunction)() const;
	ExecutionCharRowValue(const Execution* execution, CharFunction charFunction, const char& value = '\0', bool useEmptyValue = false, bool useNeutralColor = false, bool useTick = false):
		CharRowValue(value, useEmptyValue, useNeutralColor, useTick), m_execution(execution),m_charFunction(charFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_execution->*m_charFunction)();}
	DECLARE_NED_NEW
protected:
	const Execution* m_execution;
	CharFunction m_charFunction;
};


class TGUI_API ExecutionTwoCharRowValue : public TwoCharRowValue
{
public:
	typedef const char& (Execution::*CharFunction)() const;
	ExecutionTwoCharRowValue(const Execution* execution, CharFunction charFunction, CharFunction charFunction2, const char& value = '\0', const char& value2 = '\0'):
		TwoCharRowValue(value, value2), m_execution(execution),m_charFunction(charFunction),m_charFunction2(charFunction2){}
	virtual const unsigned short& GetObjectValue() const override{m_placeholder = ((unsigned short)(m_execution->*m_charFunction2)() << 8) | (m_execution->*m_charFunction)(); return m_placeholder;}
	DECLARE_NED_NEW
protected:
	const Execution* m_execution;
	CharFunction m_charFunction;
	CharFunction m_charFunction2;
	mutable unsigned short m_placeholder;
};

class TGUI_API ExecutionBoolRowValue : public BoolRowValue
{
public:
	typedef const ValueType& (Execution::*BoolFunction)() const;
	ExecutionBoolRowValue(const Execution* execution, BoolFunction boolFunction, char trueValue = 'Y', char falseValue = '\0'):
		BoolRowValue(trueValue, falseValue), m_execution(execution),m_boolFunction(boolFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_execution->*m_boolFunction)();}
	DECLARE_NED_NEW
protected:
	const Execution* m_execution;
	BoolFunction m_boolFunction;
};


class TGUI_API ExecutionStringRowValue : public StringRowValue
{
public:
	typedef const ValueType& (Execution::*StringFunction)() const;
	ExecutionStringRowValue(const Execution* execution, StringFunction stringFunction):
		m_execution(execution),
		m_stringFunction(stringFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_execution->*m_stringFunction)();}
	DECLARE_NED_NEW
protected:
	const Execution* m_execution;
	StringFunction m_stringFunction;
};

class TGUI_API ExecutionStringPtrRowValue : public StringRowValue
{
public:
	typedef const char* const& (Execution::*StringPtrFunction)() const;
	ExecutionStringPtrRowValue(const Execution* execution, StringPtrFunction stringFunction):
		m_execution(execution),
		m_stringFunction(stringFunction){}
	virtual const ValueType& GetObjectValue() const
	{
		const char* const& ret = (m_execution->*m_stringFunction)();
		if(ret)
		{
			if(strcmp(m_tempValue.c_str(), ret))
			{
				m_tempValue = ret;
			}
		}
		else if(!m_tempValue.empty())
		{
			m_tempValue.clear();
		}
		return m_tempValue;
	}
	DECLARE_NED_NEW
protected:
	const Execution* m_execution;
	StringPtrFunction m_stringFunction;
	mutable ValueType m_tempValue;
};

class TGUI_API ExecutionUInt64RowValue : public UInt64RowValue
{
public:
	typedef const ValueType& (Execution::*UInt64Function)() const;
	ExecutionUInt64RowValue(const Execution* execution, const bool* comma, UInt64Function uint64Function, bool useEmptyValue = true, bool useTick = true):
		UInt64RowValue(comma, useEmptyValue, useTick), m_execution(execution),m_uint64Function(uint64Function){}
	virtual const ValueType& GetObjectValue() const override{return (m_execution->*m_uint64Function)();}
	DECLARE_NED_NEW
protected:
	const Execution* m_execution;
	UInt64Function m_uint64Function;
};

class TGUI_API ExecutionUIntRowValueNoComma : public UIntRowValueNoComma
{
public:
	typedef const ValueType& (Execution::*UIntFunction)() const;
	ExecutionUIntRowValueNoComma(const Execution* execution, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = false):
		UIntRowValueNoComma(useEmptyValue, useTick), m_execution(execution),m_uintFunction(uintFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_execution->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	const Execution* m_execution;
	UIntFunction m_uintFunction;
};

class TGUI_API ExecutionUInt64RowValueNoComma : public UInt64RowValueNoComma
{
public:
	typedef const ValueType& (Execution::*UInt64Function)() const;
	ExecutionUInt64RowValueNoComma(const Execution* execution, UInt64Function uint64Function, bool useEmptyValue = true, bool useTick = true):
		UInt64RowValueNoComma(useEmptyValue, useTick), m_execution(execution),m_uint64Function(uint64Function){}
	virtual const ValueType& GetObjectValue() const override{return (m_execution->*m_uint64Function)();}
	DECLARE_NED_NEW
protected:
	const Execution* m_execution;
	UInt64Function m_uint64Function;
};

class TGUI_API ExecutionIntRowValue : public IntRowValue
{
public:
	typedef const ValueType& (Execution::*IntFunction)() const;
	ExecutionIntRowValue(const Execution* execution, const bool* comma, IntFunction intFunction, bool useEmptyValue = true, bool useTick = true):
		IntRowValue(comma, useEmptyValue, useTick),
		m_execution(execution),
		m_intFunction(intFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_execution->*m_intFunction)();}
	DECLARE_NED_NEW
protected:
	const Execution* m_execution;
	IntFunction m_intFunction;
};


class TGUI_API ExecutionUIntAsStrRowValue : public UIntAsStrRowValue
{
public:
	typedef const ValueType& (Execution::*UIntFunction)() const;
	ExecutionUIntAsStrRowValue(const Execution* execution, UIntFunction uintFunction):
		m_execution(execution),
		m_uintFunction(uintFunction)
	{}
	virtual const ValueType& GetObjectValue() const override{return (m_execution->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	const Execution* m_execution;
	UIntFunction m_uintFunction;
};

class TGUI_API ExecutionUShortRowValue : public UShortRowValue
{
public:
	typedef const ValueType& (Execution::*UShortFunction)() const;
	ExecutionUShortRowValue(const Execution* execution, UShortFunction ushortFunction, bool useEmptyValue = true, bool useTick = true):
		UShortRowValue(useEmptyValue, useTick), m_execution(execution),m_ushortFunction(ushortFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_execution->*m_ushortFunction)();}
	DECLARE_NED_NEW
protected:
	const Execution* m_execution;
	UShortFunction m_ushortFunction;
};

class TGUI_API ExecutionShortRowValue : public ShortRowValue
{
public:
	typedef const ValueType& (Execution::*ShortFunction)() const;
	ExecutionShortRowValue(const Execution* execution, ShortFunction shortFunction, bool useEmptyValue = true, bool useTick = true):
		ShortRowValue(useEmptyValue, useTick), m_execution(execution),m_shortFunction(shortFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_execution->*m_shortFunction)();}
	DECLARE_NED_NEW
protected:
	const Execution* m_execution;
	ShortFunction m_shortFunction;
};

class TGUI_API ExecutionTimeRowValue : public TimeRowValue
{
public:
	typedef const ValueType& (Execution::*UIntFunction)() const;
	ExecutionTimeRowValue(const Execution* execution, const bool* showMilliseconds, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = false):
		TimeRowValue(showMilliseconds, useEmptyValue, useTick), m_execution(execution),m_uintFunction(uintFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_execution->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	const Execution* m_execution;
	UIntFunction m_uintFunction;
};

class TGUI_API ExecutionPriceRowValue : public PriceRowValue
{
public:
	typedef const ValueType& (Execution::*PriceFunction)() const;
	ExecutionPriceRowValue(const Execution* execution, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true):
		PriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick), m_execution(execution),m_priceFunction(priceFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_execution->*m_priceFunction)();}
	DECLARE_NED_NEW
protected:
	const Execution* m_execution;
	PriceFunction m_priceFunction;
};

class TGUI_API ExecutionCompactPriceRowValue : public CompactPriceRowValue
{
public:
	typedef const ValueType& (Execution::*PriceFunction)() const;
	ExecutionCompactPriceRowValue(const Execution* execution, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true):
		CompactPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_execution(execution),
		m_priceFunction(priceFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_execution->*m_priceFunction)();}
	DECLARE_NED_NEW
protected:
	const Execution* m_execution;
	PriceFunction m_priceFunction;
};
*/
class TGUI_API ExecutionUCharAsCharVRowValue : public UCharAsCharRowValue
{
public:
	typedef ValueType (Execution::*UCharFunction)() const;
	ExecutionUCharAsCharVRowValue(const Execution* execution, UCharFunction ucharFunction, const ValueType& value = '\0', bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		UCharAsCharRowValue(value, useEmptyValue, useTick), m_execution(execution),m_ucharFunction(ucharFunction){}
	virtual bool isValueChanged() const override{return m_value != (m_execution->*m_ucharFunction)();}
	virtual short CompareAhead(const RowValue& other) const override{return -((const TypedRowValue&)other).CompareValue((m_execution->*m_ucharFunction)());}
	virtual bool UpdateValue() override{return SetValue((m_execution->*m_ucharFunction)());}
	virtual bool isObjectValueZero() const override{return !(m_execution->*m_ucharFunction)();}// == m_emptyValue;}
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override{m_value = (m_execution->*m_ucharFunction)();}
	const Execution* m_execution;
	UCharFunction m_ucharFunction;
};

class TGUI_API ExecutionBoolRowValueCountable : public BoolRowValueCountable
{
public:
	typedef const ValueType& (Execution::*BoolFunction)() const;
	ExecutionBoolRowValueCountable(const Execution* const& execution, BoolFunction boolFunction, const char& trueValue = 'Y', const char& falseValue = '\0'):
		BoolRowValueCountable(trueValue, falseValue),
		m_execution(execution),
		m_boolFunction(boolFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_execution->*m_boolFunction)();}
	DECLARE_NED_NEW
protected:
	const Execution* m_execution;
	BoolFunction m_boolFunction;
};

class TGUI_API ExecutionUIntRowValue : public UIntRowValue
{
public:
	typedef const ValueType& (Execution::*UIntFunction)() const;
	ExecutionUIntRowValue(const Execution* execution, const bool* comma, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true):
		UIntRowValue(comma, useEmptyValue, useTick), m_execution(execution),m_uintFunction(uintFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_execution->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	const Execution* m_execution;
	UIntFunction m_uintFunction;
};

class TGUI_API ExecutionIntInventoryRowValue : public IntRowValue
{
public:
	typedef const ValueType& (Execution::*IntFunction)(const bool& inventoryView) const;
	ExecutionIntInventoryRowValue(const Execution* execution, const bool& inventoryView, const bool* comma, IntFunction intFunction, bool useEmptyValue = true, bool useTick = true):
		IntRowValue(comma, useEmptyValue, useTick),
		m_execution(execution),
		m_intFunction(intFunction),
		m_inventoryView(inventoryView){}
	virtual const ValueType& GetObjectValue() const override{return (m_execution->*m_intFunction)(m_inventoryView);}
	DECLARE_NED_NEW
protected:
	const Execution* m_execution;
	IntFunction m_intFunction;
	const bool& m_inventoryView;
};

class TGUI_API ExecutionCompactPriceInventoryRowValue : public CompactPriceRowValue
{
public:
	typedef const ValueType& (Execution::*PriceFunction)(const bool& inventoryView) const;
	ExecutionCompactPriceInventoryRowValue(const Execution* execution, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, PriceFunction priceFunction, bool useEmptyValue = true, bool useTick = true):
		CompactPriceRowValue(comma, decDigits, truncate, useEmptyValue, useTick),
		m_execution(execution),
		m_priceFunction(priceFunction),
		m_inventoryView(inventoryView){}
	virtual const ValueType& GetObjectValue() const override{return (m_execution->*m_priceFunction)(m_inventoryView);}
	DECLARE_NED_NEW
protected:
	const Execution* m_execution;
	PriceFunction m_priceFunction;
	const bool& m_inventoryView;
};

class TGUI_API ExecutionMoneyRowValue : public MoneyRowValue
{
public:
	typedef const ValueType& (Execution::*MoneyFunction)() const;
	ExecutionMoneyRowValue(const Execution* execution, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick), m_execution(execution),m_moneyFunction(moneyFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_execution->*m_moneyFunction)();}
	DECLARE_NED_NEW
protected:
	const Execution* m_execution;
	MoneyFunction m_moneyFunction;
};

class TGUI_API ExecutionMoneyInventoryRowValue : public MoneyRowValue
{
public:
	typedef const ValueType& (Execution::*MoneyFunction)(const bool& inventoryView) const;
	ExecutionMoneyInventoryRowValue(const Execution* execution, const bool& inventoryView, const bool* comma, const unsigned char* decDigits, const bool* truncate, MoneyFunction moneyFunction, bool useEmptyValue = true, bool useNeutralColor = false, bool useTick = true):
		MoneyRowValue(comma, decDigits, truncate, useEmptyValue, useNeutralColor, useTick),
		m_execution(execution),
		m_moneyFunction(moneyFunction),
		m_inventoryView(inventoryView){}
	virtual const ValueType& GetObjectValue() const override{return (m_execution->*m_moneyFunction)(m_inventoryView);}
	DECLARE_NED_NEW
protected:
	const Execution* m_execution;
	MoneyFunction m_moneyFunction;
	const bool& m_inventoryView;
};

///////////

class TGUI_API ExtensionTimeRowValue : public TimeRowValue
{
public:
	typedef const ValueType& (ExtensionDll::*UIntFunction)() const;
	ExtensionTimeRowValue(const ExtensionDll* execution, const bool* showMilliseconds, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = false):
		TimeRowValue(showMilliseconds, useEmptyValue, useTick), m_extension(execution),m_uintFunction(uintFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_extension->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	const ExtensionDll* m_extension;
	UIntFunction m_uintFunction;
};

class TGUI_API ExtensionBoolUnknownAsCharRowValue : public BoolUnknownAsCharRowValue
{
public:
	typedef const ValueType& (ExtensionDll::*CharFunction)() const;
//	CharRowValue(const ValueType& value = '\0', bool useEmptyValue = false, bool useNeutralColor = false, bool useTick = false):TypedSignedIntegerRowValue(value, useEmptyValue, useNeutralColor, useTick){}
	ExtensionBoolUnknownAsCharRowValue(const ExtensionDll* execution, CharFunction charFunction, bool useEmptyValue = true, bool useNeutralColor = false):
		BoolUnknownAsCharRowValue('\0', useEmptyValue, useNeutralColor), m_extension(execution),m_charFunction(charFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_extension->*m_charFunction)();}
	DECLARE_NED_NEW
protected:
	const ExtensionDll* m_extension;
	CharFunction m_charFunction;
};

class TGUI_API ExtensionCharPtrRowValue : public CharPtrRowValue
{
public:
	typedef ValueType const& (ExtensionDll::*StringPtrFunction)() const;
	ExtensionCharPtrRowValue(const ExtensionDll* extension, StringPtrFunction stringFunction, bool caseInsensitive = false):
		CharPtrRowValue(caseInsensitive), m_extension(extension),m_stringFunction(stringFunction){}
	virtual ValueType const& GetObjectValue() const override{return (m_extension->*m_stringFunction)();}
	DECLARE_NED_NEW
protected:
	const ExtensionDll* m_extension;
	StringPtrFunction m_stringFunction;
};

class TGUI_API ExtensionCharArrayRowValue : public CharPtrRowValue
{
public:
	typedef ValueType (ExtensionDll::*StringPtrFunction)() const;
	ExtensionCharArrayRowValue(const ExtensionDll* extension, StringPtrFunction stringFunction, bool caseInsensitive = false):
		CharPtrRowValue(caseInsensitive), m_extension(extension),m_stringFunction(stringFunction),m_tempValue(""){}
	virtual ValueType const& GetObjectValue() const override
	{
		const char* ret = (m_extension->*m_stringFunction)();
		if(ret)
		{
			if(strcmp(m_tempValue, ret))
			{
				m_tempValue = ret;
			}
		}
		else
		{
			m_tempValue = "";
		}
		return m_tempValue;
	}

	DECLARE_NED_NEW
protected:
	const ExtensionDll* m_extension;
	StringPtrFunction m_stringFunction;
	mutable ValueType m_tempValue;
};

class TGUI_API ExtensionStringRowValue : public StringRowValue
{
public:
	typedef const ValueType& (ExtensionDll::*StringFunction)() const;
	ExtensionStringRowValue(const ExtensionDll* extension, StringFunction stringFunction):
		m_extension(extension),
		m_stringFunction(stringFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_extension->*m_stringFunction)();}
	DECLARE_NED_NEW
protected:
	const ExtensionDll* m_extension;
	StringFunction m_stringFunction;
};

class TGUI_API ExtensionStringAsCharPtrRowValue : public StringRowValue
{
public:
	typedef const char* (ExtensionDll::*StringFunction)() const;
	ExtensionStringAsCharPtrRowValue(const ExtensionDll* extension, StringFunction stringFunction):
		m_extension(extension),
		m_stringFunction(stringFunction){}
//	virtual const ValueType& GetObjectValue() const override{return (m_extension->*m_stringFunction)();}
	virtual bool isValueChanged() const override{return strcmp(m_value.c_str(), (m_extension->*m_stringFunction)()) != 0;}
	virtual short CompareAhead(const RowValue& other) const override
	{
		int ret = strcmp(((const ExtensionStringAsCharPtrRowValue&)other).m_value.c_str(), (m_extension->*m_stringFunction)());
		return ret < 0 ? 1:
			ret > 0 ? -1:
			0;
	//	return -((const TypedRowValue&)other).CompareValue((m_account->*m_uintFunction)());
	}
	virtual bool UpdateValue() override
	{
		const char* val = (m_extension->*m_stringFunction)();
		if(strcmp(m_value.c_str(), val))
		{
			if(!m_initialized)
			{
				m_initialized = true;
			}
			m_value = val;
			return true;
		}
		return false;
	}
	virtual bool isObjectValueZero() const override
	{
		const char* val = (m_extension->*m_stringFunction)();
		return !val || !*val;
	}
//	virtual bool isValueZero() const;
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_value = (m_extension->*m_stringFunction)();
	}
	const ExtensionDll* m_extension;
	StringFunction m_stringFunction;
};

class TGUI_API ExtensionUIntRowValue : public UIntRowValue
{
public:
	typedef const ValueType& (ExtensionDll::*UIntFunction)() const;
	ExtensionUIntRowValue(const ExtensionDll* extension, const bool* comma, UIntFunction uintFunction, bool useEmptyValue = true, bool useTick = true):
		UIntRowValue(comma, useEmptyValue, useTick), m_extension(extension),m_uintFunction(uintFunction){}
	virtual const ValueType& GetObjectValue() const override{return (m_extension->*m_uintFunction)();}
	DECLARE_NED_NEW
protected:
	const ExtensionDll* m_extension;
	UIntFunction m_uintFunction;
};

class TGUI_API ExtensionVersionRowValue : public VersionRowValue
{
public:
	typedef const ValueType& (ExtensionDll::*UInt64Function)() const;
	ExtensionVersionRowValue(const ExtensionDll* extension, UInt64Function uint64Function, bool useEmptyValue = true, bool useTick = true):
		VersionRowValue(useEmptyValue, useTick), m_extension(extension),m_uint64Function(uint64Function){}
	virtual const ValueType& GetObjectValue() const override{return (m_extension->*m_uint64Function)();}
	DECLARE_NED_NEW
protected:
	const ExtensionDll* m_extension;
	UInt64Function m_uint64Function;
};

class TGUI_API ExtensionUCharRowValue : public UCharRowValue
{
protected:
	ExtensionUCharRowValue(const ExtensionDll* extension, bool useEmptyValue = true, bool useTick = false):
		UCharRowValue(0, useEmptyValue, useTick),
		m_extension(extension){}
	const ExtensionDll* m_extension;
};

class TGUI_API ExtensionErrorRowValue : public ExtensionUCharRowValue
{
public:
//	typedef const unsigned char& (ExtensionDll::*UCharFunction)() const;

	ExtensionErrorRowValue(const ExtensionDll* extension):ExtensionUCharRowValue(extension){}
//	virtual UINT GetHorizontalJustification() const{return DT_LEFT;}
	virtual void toString(std::string& text) const override;
	virtual const ValueType& GetObjectValue() const override{return m_extension->GetError();}
	DECLARE_NED_NEW
};

class TGUI_API ExtensionAutoRowValue : public ExtensionUCharRowValue
{
public:
	ExtensionAutoRowValue(const ExtensionDll* extension):ExtensionUCharRowValue(extension, false){}
//	virtual const ValueType& GetObjectValue() const override{return (m_extension->*m_stringFunction)();}
	unsigned char GetAutoValue() const;//0 - none; 1 - add to Extension window but don't load; 2 - add to Extension window and load
	virtual void toString(std::string& text) const override
	{
		switch(m_value)
		{
			case 1:
			text += 'a';
			break;

			case 2:
			text += 'A';
			break;
		}
	}
	virtual bool isValueChanged() const override{return GetAutoValue() != m_value;}
	virtual short CompareAhead(const RowValue& other) const override
	{
		const unsigned char load = GetAutoValue();
		const unsigned char loadOther = ((const ExtensionAutoRowValue&)other).m_value;
		return load < loadOther ? -1:
			load > loadOther ? 1:
			0;
	}
	virtual bool UpdateValue() override
	{
		const unsigned char load = GetAutoValue();
		if(load != m_value)
		{
			if(!m_initialized)
			{
				m_initialized = true;
			}
			m_value = load;
			return true;
		}
		return false;
	}
	virtual bool isObjectValueZero() const override
	{
		return !GetAutoValue();
	}
//	virtual bool isValueZero() const;
	DECLARE_NED_NEW
protected:
	virtual void InitializeValue() override
	{
		m_value = GetAutoValue();
	}
};

class UIntDataRingVector;

class TGUI_API TakionDataMonitor : public TakionTitleTool
{
public:
	virtual ~TakionDataMonitor();
	virtual const char* GetToolId() const override{return toolDataMonitorId;}
	virtual void toString(std::string& str, unsigned int contentModifier) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual void fromScratch() override;
	virtual void AddToSpecificToolCollection() override;

	virtual void UpdateGraphics() override;

	void UpdateDataGraphics(const Graphics* graphics);
	virtual const Graphics* GetGraphicsAt(unsigned int graphicsOrdinal) const override;
	bool UpdateDataGraphicsColorsCustom(const GraphicsColorCollection* colorCollection);
	bool UpdateDataGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL);
	virtual void UpdateColorsCustom(const GraphicsColorCollection* colorCollection) override;
	virtual void SetCustomColors(const Graphics* graphics, GraphicsColorCollection* colorCollection, const COLORREF* colors, unsigned short colorCount, bool custom, const FilterStringAsNumberArray& title) override;//, const FilterStringAsNumberArray& title, unsigned int colorId) override;

//	virtual bool CanLink() const{return true;}
	static const unsigned int minMilliseconds;
	void SetMilliseconds(unsigned int milliseconds);
	void SetReceivedBytes(bool receivedBytes);
	void SetDataInBytes(bool dataInBytes);
	virtual bool CanCreateTimer() const{return !m_timerStopped;}
	virtual const char* GetConnectionName() const{return NULL;}
	virtual void AppendWindowMenuInfo(std::string& menuText) const override;
protected:
	TakionDataMonitor(const CBitmap* bitmap,
		unsigned int workspace,
		bool pinned = false,
		int minVisibleSize = 15,
//		int minWidth = 100,
		int minWidth = 20,
		int maxWidth = 0,
//		int minHeight = 50,
		int minHeight = 20,
		int maxHeight = 0,
		int minBorderWidth = 2,
		int maxBorderWidth = 2,
		const char* className = "TakionTool",
		int minTitleHeight = 0,
		int maxTitleHeight = 15,
		int titleHeight = 15);
	virtual unsigned int GetNewBytes() const = 0;
	virtual void BeforeDestroy() override;
	virtual void AddMenuItems(CMenu& menu) override;
	virtual void PostAddMenuItems(CMenu& menu) override;
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;

	virtual void OnSuccessfulCreate() override;

	virtual void DoPaintTitle(const RECT& interRect, CDC& dc) override;
	virtual void DoPaintClient(const RECT& interRect, CDC& dc) override;
	virtual void UpdateTitleRects() override;
//	virtual void OnTitleResize();
	virtual void SizeHorizontal(int cx, int cy, int oldX, int oldY) override;
	virtual void SizeVertical(int cx, int cy, int oldX, int oldY) override;
//	virtual void OnBorderResize() override;
	void HorizontalSizeChanged();
	void VerticalSizeChanged();
//	virtual void DoSize(UINT nType, int cx, int cy, int oldX, int oldY);
	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;
//	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
//	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	afx_msg LRESULT OnTime(WPARAM millisecond, LPARAM reserved);
	DECLARE_MESSAGE_MAP()

	unsigned int m_currentMillisecond;

	unsigned int m_totalMaxBytes;
	unsigned int m_maxBytes;
	unsigned int m_prevBytes;

	int m_clientWidth;
	int m_clientOffset;

	int m_clientHeight;

	COLORREF m_colorForeground;
	COLORREF m_colorZeroData;
	unsigned int m_milliseconds;
	bool m_receivedBytes;//sentBytes
	bool m_dataInBytes;//m_dataInBits
	
	void CreateTimer();
	void DestroyTimer();
	void SetStopped(bool stop);
	bool m_timerCreated;
	bool m_timerStopped;

	bool m_clientWidthOdd;
/*
	FontDescription m_fontDescription;
	FontDescription m_fontDescriptionCustom;
	CFont* m_font;
	bool m_fontCustom;
*/
	void UpdateHeight();
	void UpdateByteMap();
	void ClearData();
	virtual void DoUpdateTitle() override;
	typedef std::map<unsigned int, unsigned int, std::greater<unsigned int> > UIntUIntMap;
	UIntUIntMap m_byteMap;
	UIntUIntMap::const_iterator m_byteMapEnd;
	UIntDataRingVector* m_dataVector;
private:
	TakionDataMonitor& operator=(const TakionDataMonitor& other){return *this;}
};

//#define USE_SIMPLE_BROWSER

#ifdef USE_SIMPLE_BROWSER
#include "mshtml.h"
#endif

class TGUI_API TakionHtmlViewer : public TakionTitleTool
{
#ifndef USE_SIMPLE_BROWSER
friend class TakionHtmlView;
#endif
public:
	TakionHtmlViewer(const CBitmap* bitmap,
		unsigned int workspace,
		bool pinned = false,
		int minVisibleSize = 15,
//		int minWidth = 100,
		int minWidth = 20,
		int maxWidth = 0,
//		int minHeight = 50,
		int minHeight = 20,
		int maxHeight = 0,
		int minBorderWidth = 2,
		int maxBorderWidth = 2,
		const char* className = "TakionTool",
		int minTitleHeight = 0,
		int maxTitleHeight = 15,
		int titleHeight = 15);

#ifdef USE_SIMPLE_BROWSER
	virtual ~TakionHtmlViewer();
	bool isSilent() const;//Get silent property
	void SetSilent(bool silent);//Set silent property (if true, dialog and message boxes may not be shown)

	//Create browser in place of dialog control; the dialog control identified by nID will be destroyed, and the browser will take its place
	BOOL CreateFromControl(CWnd *pParentWnd, UINT nID, DWORD dwStyle = WS_CHILD | WS_VISIBLE);

	//Controls
//	void Navigate(LPCTSTR URL);//Navigate to URL

	//Append string to current document; note that the WebBrowser control tolerates poorly formed documents, like:
	// <html><body>....
	// --- no trailing body or html tags
	// <html><body>...</body></html><html><body>...</body></html>...
	// --- multiple documents
	void Write(LPCTSTR string);
	void Clear();//Clear current document
	void NavigateResource(int resource_ID);//Navigate to HTML document resource
	void Refresh();//Refresh contents
	void Stop();//Stop current activity

	//Start printing contents; uses same 'metacharacters' for header and footer as Internet Explorer; see IE Page Setup dialog
	void Print(LPCTSTR header = _T("&w&b&b&p"), LPCTSTR footer = _T("&d &t"));
	void PrintPreview();//Print preview
	bool isBusy() const;//Returns true if browser busy downloading or other activity
	CString GetLocationName() const;//Get name of location currently being browsed (title, if HTML page; UNC path if file)
	READYSTATE GetReadyState() const;//Get browser ready state
	IHTMLDocument2* GetDocument() const;//Get document interface; returns NULL if interface is not available 
								  //(which is the case if you've navigated to something that's NOT an HTML document,
								  //like an Excel spreadsheet, which the WebBrowser control is perfectly willing to host)

	//Events (overridables)

	//Called before navigation begins; URL is destination, frame is frame name ("" if none), post_data is HTTP POST data (NULL if none),
	//and headers are HTTP headers sent to server; return true to cancel navigation, false to continue
	virtual bool OnBeforeNavigate2(CString URL, CString	frame, void* post_data, int post_data_size, CString	headers);
	virtual void OnDocumentComplete(CString URL);//Navigation to document complete; URL is location
	virtual void OnDownloadBegin();//Navigation operation begins
	virtual void OnProgressChange(int progress, int progress_max);// navigation progress update
	virtual void OnDownloadComplete();//Navigation operation completed
	virtual void OnNavigateComplete2(CString URL);//Navigation to hyperlink complete; URL is location (URL = string if NavigateString or NavigateResource are used)
	virtual void OnStatusTextChange(CString text);//Status text has changed
	virtual void OnTitleChange(CString text);//Title has changed
	virtual void OnPrintTemplateInstantiation();//Print template has been instantiated (printing has begun)
	virtual void OnPrintTemplateTeardown();//Print template is being destroyed (printing has completed)		

   //Notifications
	enum NotificationType // Note: SimpleBrowser does NOT support the common notifications (NM_CLICK, etc.)
	{
		BeforeNavigate2,					// set *LRESULT=TRUE to cancel navigation
		DocumentComplete,
		DownloadBegin,
		ProgressChange,
		DownloadComplete,
		NavigateComplete2,
		StatusTextChange,
		TitleChange,
		PrintTemplateInstantiation,
		PrintTemplateTeardown
	};

	class Notification	// All notifications pass this structure
	{
	public:

		Notification(HWND hwnd, UINT ID, NotificationType type);
//		~Notification();
		NMHDR			hdr; //hdr.hwndFrom = SimpleBrowser's HWND hdr.idFrom   = SimpleBrowser's control ID hdr.code     = <NavigationType>

		CString			URL; // BeforeNavigate2 DocumentComplete NavigateComplete2

		CString			frame;				// BeforeNavigate2
		void			*post_data;			// BeforeNavigate2
		int				post_data_size;
		CString			headers;			// BeforeNavigate2

		int				progress;			// ProgressChange
		int				progress_max;		// ProgressChange

		CString			text;				// StatusTextChange
											// TitleChange
	};

	bool ParsePostData(CString post_data,	// parse URL-encoded POST data
		CStringArray &names,				// string into list of names
		CStringArray &values);				// and values; returns true if successful

											//{{AFX_VIRTUAL(SimpleBrowser)
#endif
//	virtual CWnd* GetThreadWindow() const;
//	virtual CWnd* CreateThreadWindow();
	virtual const char* GetToolId() const override{return toolHtmlViewerId;}
	virtual void toString(std::string& str, unsigned int contentModifier) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual void fromScratch() override;
	virtual void AddToSpecificToolCollection() override;
	virtual void UpdateGraphics() override;

	void UpdateHtmlGraphics(const Graphics* graphics);

	virtual const Graphics* GetGraphicsAt(unsigned int graphicsOrdinal) const override;
	bool UpdateDataGraphicsColorsCustom(const GraphicsColorCollection* colorCollection);
	bool UpdateDataGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL);
	virtual void UpdateColorsCustom(const GraphicsColorCollection* colorCollection) override;
	virtual void SetCustomColors(const Graphics* graphics, GraphicsColorCollection* colorCollection, const COLORREF* colors, unsigned short colorCount, bool custom, const FilterStringAsNumberArray& title) override;//, const FilterStringAsNumberArray& title, unsigned int colorId) override;

	virtual bool CanLink() const{return true;}
	CFont* GetSymbolEntryFont() const{return m_font;}
	virtual bool GetCurrentFontParams(std::string& title, FontDescription& fontDescription, FontDescription& fontDescriptionCustom, bool& custom, unsigned int& id) const;
	virtual void SetCustomFont(const FontDescription& fontDescription, bool custom, unsigned int id) override;
	virtual void SetEquitySymbol(const char* symbol, unsigned char basket, bool force, bool addToStockChain) override;
	void SetFontUrl(const FontDescription& fontDescription);
	bool isUseForHelp() const{return m_useForHelp;}
	void SetUseForHelp(const bool use);
	void SetActivateOnNewUrl(const bool activate);
	bool Navigate(const char* url);
//	const std::string& GetCurrentUrl() const{return m_currentUrl;}
	const std::string& GetLinkUrl() const{return m_linkUrl;}
	void SetLinkUrl(const char* url);//{m_currentUrl = url;}

	CString GetLocationURL() const;//Get URL of location currently being browsed
	void GoBack();//Navigate backward one item in the history list
	void GoForward();//Navigate forward one item in the history list
	void GoHome();//Navigate to current home or start page

	typedef std::list<std::string> StringList;
protected:
	DialogTextEntry& DisplayEditUrl();

//	afx_msg LRESULT OnCreateViewer(WPARAM w, LPARAM l);
	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;

//	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
//	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
//	DECLARE_MESSAGE_MAP()

	virtual void BeforeDestroy() override;
	virtual void AddMenuItems(CMenu& menu) override;
	virtual void PostAddMenuItems(CMenu& menu) override;
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;

	virtual bool ProcessKeyDown(unsigned char key, unsigned char modifier, bool repeat, TakionFrame* fromWindow) override;
	void StartTypingSymbol(unsigned char key);
	virtual void AcceptText(const char* text, unsigned int code) override;

	virtual void OnSuccessfulCreate() override;

	virtual void DoPaintTitle(const RECT& interRect, CDC& dc) override;
	virtual void UpdateTitleRects() override;
	virtual void OnTitleResize() override;
//	virtual void SizeHorizontal(int cx, int cy, int oldX, int oldY);
//	virtual void SizeVertical(int cx, int cy, int oldX, int oldY);
	virtual void DoSize(UINT nType, int cx, int cy, int oldX, int oldY);

	void SizeHtmlView();
//	void SetCurrentUrl(const char* url){m_currentUrl = url;}
	void SetTitleUrl();//const char* url);

	FontDescription m_fontDescription;
	FontDescription m_fontDescriptionCustom;
	CFont* m_font;
	bool m_fontCustom;
	bool m_useForHelp;
	bool m_activateOnNewUrl;
//	std::string m_currentUrl;
	std::string m_linkUrl;
	StringList m_linkUrlTokenList;

#ifdef USE_SIMPLE_BROWSER
	void ReleaseBrowserInterfaces();
	virtual void PostNcDestroy();
	afx_msg BOOL PreTranslateMessage(MSG *pMsg);

	void _OnBeforeNavigate2(LPDISPATCH lpDisp,
		VARIANT FAR *URL,
		VARIANT FAR *Flags,
		VARIANT FAR *TargetFrameName,
		VARIANT FAR *PostData,
		VARIANT FAR *Headers,
		VARIANT_BOOL *Cancel);
	void _OnDownloadBegin();
	void _OnProgressChange(long progress, long progress_max);
	void _OnDownloadComplete();
	void _OnDocumentComplete(LPDISPATCH lpDisp, VARIANT FAR* URL);
	void _OnNavigateComplete2(LPDISPATCH lpDisp, VARIANT FAR* URL);
	void _OnStatusTextChange(BSTR bstrText);
	void _OnTitleChange(BSTR bstrText);
	void _OnPrintTemplateInstantiation(LPDISPATCH pDisp);
	void _OnPrintTemplateTeardown(LPDISPATCH pDisp);

	DECLARE_EVENTSINK_MAP()

private:
	CWnd                    _BrowserWindow;     // Browser window
protected:
	IWebBrowser2			*_Browser;          // browser control
	bool					_Ready;				// document ready (initial navigation completed)
private:
	IDispatch               *_BrowserDispatch;  // browser control dispatch interface
	CString					_Content;			// current content set via Write()/Clear()
	void _ContentWrite();
#else
	TakionHtmlView* m_htmlView;
#endif
};

///////////////
class TGUI_API ColumnItem
{
public:
	ColumnItem(Column* column,
		int width,
		unsigned char alignment,
		bool checked,
		bool highlighted,
		bool sorted,
		bool ascending,
		unsigned short secondarySort,
		bool followed,
		bool follows,
		bool use,
		bool globalUse,
		bool alwaysUsed,
		bool inventory):

		m_column(column),
		m_caseInsensitiveName(column->GetName()),
		m_width(width),
		m_alignment(alignment),
		m_checked(checked),
		m_highlighted(highlighted),
		m_sorted(sorted),
		m_ascending(ascending),
		m_secondarySort(secondarySort),
		m_followed(followed),
		m_follows(follows),
		m_alwaysUsed(alwaysUsed),
		m_use(use || alwaysUsed),
		m_globalUse(globalUse || alwaysUsed),
		m_inventory(inventory)
	{
		for(char* cursor = (char*)m_caseInsensitiveName.c_str(); *cursor; ++cursor)
		{
			*cursor = toupper(*cursor);
		}
	}
	Column* const& GetColumn(){return m_column;}
	const Column* const& GetColumn() const{return m_column;}
	bool SetColumn(Column* const& column)
	{
		if(column != m_column)
		{
			m_column = column;
			m_caseInsensitiveName = column->GetName();
			for(char* cursor = (char*)m_caseInsensitiveName.c_str(); *cursor; ++cursor)
			{
				*cursor = toupper(*cursor);
			}
			return true;
		}
		return false;
	}
	const bool& isChecked() const{return m_checked;}
	bool SetChecked(const bool& checked)
	{
		if(checked != m_checked)
		{
			m_checked = checked;
			return true;
		}
		return false;
	}
	const bool& isHighlighted() const{return m_highlighted;}
	bool SetHighlighted(const bool& highlighted)
	{
		if(highlighted != m_highlighted)
		{
			m_highlighted = highlighted;
			return true;
		}
		return false;
	}
	const unsigned char& GetAlignment() const{return m_alignment;}
	bool SetAlignment(const unsigned char& alignment)
	{
		if(alignment != m_alignment)
		{
			m_alignment = alignment;
			return true;
		}
		return false;
	}
	const bool& isSorted() const{return m_sorted;}
	bool SetSorted(const bool& sorted)
	{
		if(sorted != m_sorted)
		{
			m_sorted = sorted;
			return true;
		}
		return false;
	}
	const std::string& GetCaseInsensitiveName() const{return m_caseInsensitiveName;}
	const int& GetWidth() const{return m_width;}
	void SetWidth(const int& width){m_width = width;}
	const unsigned short& GetSecondarySort() const{return m_secondarySort;}
	bool SetSecondarySort(const unsigned short& secondarySort)
	{
		if(secondarySort != m_secondarySort)
		{
			m_secondarySort = secondarySort;
			return true;
		}
		return false;
	}
	const bool& isAscending() const{return m_ascending;}
	bool SetAscending(const bool& ascending)
	{
		if(ascending != m_ascending)
		{
			m_ascending = ascending;
			return true;
		}
		return false;
	}
	void DecrementSecondarySort(){if(m_secondarySort > 1)--m_secondarySort;}

	const bool& isFollowed() const{return m_followed;}
	bool SetFollowed(const bool& followed)
	{
		if(followed != m_followed)
		{
			m_followed = followed;
			return true;
		}
		return false;
	}
	
	const bool& Follows() const{return m_follows;}
	bool SetFollows(const bool& follows)
	{
		if(follows != m_follows)
		{
			m_follows = follows;
			return true;
		}
		return false;
	}

	const bool& isUse() const{return m_use;}
	bool SetUse(const bool& use)
	{
		if(use != m_use && !m_alwaysUsed)
		{
			m_use = use;
			return true;
		}
		return false;
	}
	const bool& isGlobalUse() const{return m_globalUse;}
	bool SetGlobalUse(const bool& globalUse)
	{
		if(globalUse != m_globalUse && !m_alwaysUsed)
		{
			m_globalUse = globalUse;
			return true;
		}
		return false;
	}
	const bool& isAlwaysUsed() const{return m_alwaysUsed;}
	const bool& isInventory() const{return m_inventory;}
protected:
	Column* m_column;
	std::string m_caseInsensitiveName;
	int m_width;
	unsigned char m_alignment;
	bool m_checked;
	bool m_highlighted;
	bool m_sorted;
	bool m_ascending;
	unsigned short m_secondarySort;
	bool m_followed;
	bool m_follows;
	bool m_alwaysUsed;
	bool m_use;
	bool m_globalUse;
	bool m_inventory;
};

class TGUI_API ListBoxColumn : public ListBoxBoldItem//ListBoxOwnerDraw
{
public:
	typedef Chain<unsigned short> UShortChain;
#if (_MSC_VER > 1600)
	typedef std::unordered_set<unsigned short> UShortSet;
#else
	typedef std::hash_set<unsigned short> UShortSet;
#endif
	ListBoxColumn(bool global);
	virtual const char* GetItemName(const void* item) const override;
	void SetSortInfo(const char* toolId, bool sortable, unsigned short sortId, const UShortChain* chain, unsigned short followedId);

	virtual COLORREF GetBkColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override;
	virtual COLORREF GetStringColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override;
	virtual COLORREF GetSelectedBkColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override;

	const COLORREF& GetHighlightColor() const{return m_highlightColor;}
	void SetHighlightColor(const COLORREF& color){m_highlightColor = color;}
	const COLORREF& GetRedColor() const{return m_redColor;}
	void SetRedColor(const COLORREF& color){m_redColor = color;}
	const COLORREF& GetInventoryColor() const{return m_inventoryColor;}
	void SetInventoryColor(const COLORREF& color){m_inventoryColor = color;}
	const bool& isSortable() const{return m_sortable;}
	const bool& isExpanded() const{return m_expanded;}
	void SetExpanded(bool expanded);

	void SetSortedItem(const int& sortedItem){m_sortedItem = sortedItem;}
	void SetFollowedItem(const int& followedItem){m_followedItem = followedItem;}

	void InvalidateFollowedItemBox();
	void InvalidateFollowingItemBoxes();

	void SetSortUnderMouse(int i);
	void ToggleSortAndInvalidate(unsigned int i);
	bool ToggleSortAt(unsigned int i);

	void SetAscendingUnderMouse(int i);
	void ToggleAscendingAndInvalidate(unsigned int i);
	bool ToggleAscendingAt(unsigned int i);

	void SetFollowedUnderMouse(int i);
	void ToggleFollowedAndInvalidate(unsigned int i);
	bool ToggleFollowedAt(unsigned int i);

	void SetFollowingUnderMouse(int i);
	void ToggleFollowingAndInvalidate(unsigned int i);
	bool ToggleFollowingAt(unsigned int i);

	void SetUseUnderMouse(int i);
	void ToggleUseAndInvalidate(unsigned int i);
	bool ToggleUseAt(unsigned int i);

	void SetSecondarySortUnderMouse(int i);
	void ToggleSecondarySortAndInvalidate(unsigned int i);
	bool ToggleSecondarySortAt(unsigned int i);

	void SetRadioUnderMouse(int i, unsigned char alignment);
	void SetRadioAndInvalidate(unsigned int i, unsigned char alignment, bool notify);
	bool SetItemAtRadioChecked(unsigned int i, unsigned char alignment);
	void ToggleRadioAndInvalidate(unsigned int i, unsigned char alignment);
	bool ToggleRadioAt(unsigned int i, unsigned char alignment);
	bool BottomEmpty(bool notify);
	bool AlphabetizeEmpty(bool notify);
//	CFont* GetFontBold() const{return m_fontBold;}
//	int GetItemBold() const{return m_itemBold;}
	const UShortChain& GetSortChain() const{return m_sortChain;}
	UShortChain& GetSortChain(){return m_sortChain;}
	bool AddColumnToSortChain(ColumnItem* item, unsigned int ordinal);
	bool RemoveColumnFromSortChain(ColumnItem* item, unsigned int ordinal);
	bool ClearColumnsFromSortChain();
	const unsigned short& GetSortId() const{return m_sortId;}
	bool SetSortId(const unsigned short& sortId)
	{
		if(sortId != m_sortId)
		{
			m_sortId = sortId;
			return true;
		}
		return false;
	}
	const unsigned short& GetFollowedId() const{return m_followedId;}
	bool SetFollowedId(const unsigned short& followedId)
	{
		if(followedId != m_followedId)
		{
			m_followedId = followedId;
			return true;
		}
		return false;
	}
	const int& GetColumnNameWidth() const{return m_columnNameWidth;}
	void SetColumnNameWidth(int width);
	void SetColumnNameWidthToColumnToolTips();
	const int& GetExpandedWidth()const{return m_expandedWidth;}
	void SetExpandedWidth(int width);
	virtual void UpdateColumnToolTipsHorizontalBounds() override;
	const bool& isColumnNameTipsAdjustable() const{return m_columnNameTipsAdjustable;}
	void SetColumnNameTipsAdjustable(const bool& adjustable){m_columnNameTipsAdjustable = adjustable;}
	void UpdateItemsUnderMouse(){UpdateItemsUnderMouse(m_mousePos);}

	const bool& isGlobal() const{return m_global;}

	void SetUseRange(unsigned int start, unsigned int end, bool use, bool notify);
	void UseRange(bool use, bool notify);
	void SetUseAll(bool use, bool notify);

	void SetFollowRange(unsigned int start, unsigned int end, bool use, bool notify);
	void FollowRange(bool use, bool notify);
	void SetFollowAll(bool use, bool notify);

	void SetSelectedToUsedRange(unsigned int start, unsigned int end, bool selectedToUsed, bool notify);

	void SelectedToUsedRange(bool selectedToUsed, bool notify);
	void SetSelectedToUsedAll(bool selectedToUsed, bool notify);

	void SetFollowingItemSet(const UShortSet& other);
	void ClearFollowingItemSet();
	void AddFollowingItem(unsigned short id){m_followingItemSet.insert(id);}
	void RemoveFollowingItem(unsigned short id){m_followingItemSet.erase(id);}
protected:
	void InvalidateItemUse(unsigned int i);
	void UpdateItemsUnderMouse(CPoint point);
	void InitSortable();
	virtual void ListBoxCreated() override;
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;
	virtual void DestroyItem(const void* item) const override;
	virtual void DoDrawItem(const DRAWITEMSTRUCT* lpDrawItemStruct, const CRect& drawItemRect) override;
	virtual void AddMenuItems(CMenu& menu) override;
	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;

	virtual bool isItemChecked(const void* item) const override;
	virtual void SetItemChecked(void* item, unsigned int i, bool checked) override;
	virtual void ItemMoved(unsigned int from, unsigned int to) override;
	virtual void OnItemSelected() override
	{
		ListBoxBoldItem::OnItemSelected();
//		UpdateToolTipTexts();
		UpdateCheckable();
		UpdateItemsUnderMouse();
	}
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);

	DECLARE_MESSAGE_MAP()

	virtual void MouseLeft() override;

	virtual bool GetToolTipInfo(unsigned int ordinal, const void* item, std::string& tooltipText, int& left, int& right) const override;
	virtual void DoCreateColumnToolTips() override;

	void DoCreateDestroySortableColumnToolTips(bool create);
	std::string m_toolId;
	int m_columnNameWidth;
	int m_expandedWidth;
	COLORREF m_highlightColor;
	COLORREF m_redColor;
	COLORREF m_inventoryColor;
	int m_sortableWidth;
	int m_sortedItem;
	unsigned short m_sortId;

	int m_followedItem;
	unsigned short m_followedId;

	bool m_sortable;
	bool m_expanded;

//	CFont* m_fontBold;

	char m_alignmentUnderMouse;
	char m_alignmentPressed;
	int m_radioUnderMouse;
	int m_radioPressed;

	int m_sortUnderMouse;
	int m_sortPressed;
	int m_ascendingUnderMouse;
	int m_ascendingPressed;

	int m_useUnderMouse;
	int m_usePressed;

	int m_followedUnderMouse;
	int m_followedPressed;

	int m_followingUnderMouse;
	int m_followingPressed;

	int m_secondarySortUnderMouse;
	int m_secondarySortPressed;
	UShortChain m_sortChain;

	unsigned char m_pressedProperty;

	bool m_own;
	bool m_columnNameTipsAdjustable;

	bool m_global;

	bool m_sortableToolTipsCreated;

	UShortSet m_followingItemSet;
};

class TGUI_API Row
{
public:
	static const unsigned __int64 uint64Zero;
	virtual ~Row();
	virtual const void* GetBaseObject() const = 0;//{return m_object;}
	virtual bool Lock(bool wait) const{return true;}
//	virtual void LockWait() const{}
	virtual void Unlock() const{}
	virtual RowValue* CreateCell(unsigned short id){return NULL;}
	virtual bool DestroyCell(unsigned short id);//{return NullifyRowValue(id);}
	virtual bool PaintCell(CDC& dc, const Column* column, const CRect& rect, UINT verticalJustification, int horizontalOffset) const;
	virtual bool GetPaintTextInfo(unsigned short columnId, std::string& text, COLORREF& color) const{return false;}//, UINT& horizontalJustification) const{return false;}
	virtual bool CellToString(std::string& info, unsigned short columnId) const{drawColor = 0xFFFFFFFF; return GetPaintTextInfo(columnId, info, drawColor);}//, drawHorizontalJustification);}
	virtual COLORREF GetRowColor() const{return 0xFFFFFFFF;}
	virtual COLORREF GetRowBkColor() const{return 0xFFFFFFFF;}
	virtual COLORREF GetCellColor(unsigned short columnId) const{return 0xFFFFFFFF;}
	virtual COLORREF GetCellBkColor(unsigned short columnId) const{return 0xFFFFFFFF;}
	void NullifyTick();
	const RowValue* GetRowValue(unsigned short id) const{return id < m_columnCount ? m_rowValue[id] : NULL;}
	RowValue* GetRowValue(unsigned short id){return id < m_columnCount ? m_rowValue[id] : NULL;}
	virtual void Initialize();
	virtual const unsigned __int64& GetRowNumericSymbol() const{return uint64Zero;}
	virtual const char* GetRowSecuritySymbol(const CPoint* point = NULL) const{return NULL;}
	virtual const PositionData* GetRowPosition(const CPoint* point = NULL) const{return NULL;}
	virtual const Account* GetRowAccount() const{return NULL;}
#ifdef FIRM_VALUES
	virtual const AccountAggregator* GetRowAccountAggregator() const{return NULL;}
#endif
	virtual bool isSelected() const{return false;}
	virtual bool isBkColorOverrideSelection(unsigned short id) const{return false;}
	virtual const char* GetStringValue(unsigned short id) const{const RowValue* rowValue = GetRowValue(id); return rowValue ? rowValue->GetStringValue() : NULL;}
	virtual const unsigned int GetUIntValue(unsigned short id) const{const RowValue* rowValue = GetRowValue(id); return rowValue ? rowValue->GetUIntValue() : 0;}
	virtual const unsigned __int64 GetUInt64Value(unsigned short id) const{const RowValue* rowValue = GetRowValue(id); return rowValue ? rowValue->GetUInt64Value() : 0;}
	virtual const int GetIntValue(unsigned short id) const{const RowValue* rowValue = GetRowValue(id); return rowValue ? rowValue->GetIntValue() : 0;}
	virtual Price GetPriceValue(unsigned short id) const{const RowValue* rowValue = GetRowValue(id); return rowValue ? rowValue->GetPriceValue() : Price::priceZero;}
	void ApplyPosition(unsigned short id, const PositionData* position)
	{
		RowValue* rowValue = GetRowValue(id);
		if(rowValue)rowValue->SetPosition(position);
	}
#ifdef SECONDARY_ROWS
	virtual bool isExpandable() const{return false;}
	virtual bool isExpanded() const{return false;}
	virtual bool SetExpanded(const bool expanded){return false;}
	virtual bool isSecondary() const{return false;}
	virtual bool isPrimary() const{return true;}
	virtual Row* GetParentRow(){return NULL;}
	virtual const Row* GetParentRow() const{return NULL;}
	bool ToggleExpanded(){return SetExpanded(!isExpanded());}
#endif
	virtual bool isPotential() const{return false;}
protected:
	Row(unsigned short columnCount);//void* object):
	virtual void AdjustColor(const Column* column) const{}
	bool SetRowValue(unsigned short id, RowValue* value);
//	bool NullifyRowValue(unsigned short id);
	unsigned short m_columnCount;
	RowValue** m_rowValue;
//Fields for drawing
//Can be a problem if somehow the drawing is done using multithreading. Should not be the case.
	static std::string drawText;
	static COLORREF drawColor;
	static COLORREF bkColor;
	static UINT drawHorizontalJustification;
	static char num[44];
private:
	Row(const Row& other);
	Row& operator=(const Row& other);
};

//typedef std::map<unsigned short, bool> UseChangeMap;
typedef CMap<unsigned short, const unsigned short&, unsigned char, const unsigned char&> UseChangeMap;//unsigned char - filter: 1 - do not use in window; 2 - use in window; 4 - do not use globally; 8 - use globally

class RowWindow;

class TGUI_API Columns
{
friend class RowWindow;
friend class RowWindowSortable;
friend class DialogColumns;
//friend class RowWindowSortable;
public:
	virtual ~Columns();
//	virtual const char* GetToolId() const{return "";}
	typedef std::map<PointLocatorInt, Column*, lessPointLocator<int> > ColumnMap;
	typedef ColumnMap::iterator ColumnIterator;
	typedef ColumnMap::const_iterator ColumnConstIterator;
	typedef std::vector<ColumnIterator> ColumnIteratorVector;
#if (_MSC_VER > 1600)
	typedef std::unordered_set<unsigned short> UShortSet;
#else
	typedef std::hash_set<unsigned short> UShortSet;
#endif
	typedef std::list<unsigned short> UShortList;
	typedef UShortList::const_iterator UShortListConstIterator;

	const unsigned short& GetCellCount() const{return m_cellCount;}
	const unsigned short& GetColumnCount() const{return m_columnCount;}
	const unsigned short& GetColumnVectorCount() const{return m_cellCount;}//(unsigned short)m_columnVector.size();}
	ColumnIterator FindColumn(int x){return m_columnMap.find(PointLocatorInt(x));}
	ColumnConstIterator FindColumn(int x) const{return m_columnMap.find(PointLocatorInt(x));}
	Column* FindColumnPtr(int x)
	{
		ColumnIterator found = m_columnMap.find(PointLocatorInt(x));
		return found == m_columnEnd ? NULL : found->second;
	}
	const Column* FindColumnPtr(int x) const
	{
		ColumnConstIterator found = m_columnMap.find(PointLocatorInt(x));
		return found == m_columnEnd ? NULL : found->second;
	}

	Column* FindScrolledColumnPtr(int x){return FindColumnPtr(x + m_columnScrollOffset);}
	const Column* FindScrolledColumnPtr(int x) const{return FindColumnPtr(x + m_columnScrollOffset);}

	const ColumnIterator& GetColumnBegin(){return m_columnBegin;}
	const ColumnIterator& GetColumnEnd(){return m_columnEnd;}
	const ColumnConstIterator& GetColumnBegin() const{return m_columnBegin;}
	const ColumnConstIterator& GetColumnEnd() const{return m_columnEnd;}
	Column* GetColumnById(unsigned short id) const{return id < m_cellCount && m_columnVector[id] != m_columnEnd ? m_columnVector[id]->second : NULL;}
//	Column* GetColumnById(unsigned short id) const{return id < m_columnCount && m_columnVector[id] != m_columnEnd ? m_columnVector[id]->second : NULL;}
	bool isToCreateCell(unsigned short id) const{const Column* column = GetColumnById(id); return column && column->isToCreateCell();}
	const ColumnIterator& GetColumnIteratorById(unsigned short id) const{return id < m_cellCount ? m_columnVector[id] : m_columnEnd;}
//	const ColumnIterator& GetColumnIteratorById(unsigned short id) const{return id < m_columnCount ? m_columnVector[id] : m_columnEnd;}
	const ColumnIterator& GetColumnIteratorEnd() const{return m_columnEnd;}
/*
	virtual const Columns* GetExecutionColumns() const{return this;}
	virtual const Columns* GetOrderColumns() const{return this;}
	virtual const Columns* GetPositionColumns() const{return this;}
*/
	unsigned short GetSortId() const{return m_columnSort == m_columnEnd ? 0xFFFF : m_columnSort->second->GetId();}
//	bool isSortAscending() const{return m_sortAscending;}
	bool isSortAscending() const{return m_columnSort != m_columnEnd && m_columnSort->second->isAscending();}
	bool isColumnSortAscending(unsigned short id) const
	{
		const Column* column = GetColumnById(id);
		return column && column->isAscending();
	}

	typedef std::vector<ColumnItem> ColumnItemVector;

	bool ArrangeColumns(ColumnItemVector& columnItemVector, unsigned short sortId, unsigned short followedId);

	typedef Chain<unsigned short> UShortChain;

	const UShortChain* GetSortChain() const{return &m_sortChain;}
	bool BelongsToSortChain(unsigned short id) const{return m_sortChain.Contains(id);}
	bool BelongToSortChain(const UseChangeMap& useChangeMap) const
	{
		for(const UseChangeMap::CPair* p = useChangeMap.PGetFirstAssoc(); p; p = useChangeMap.PGetNextAssoc(p))
		{
			if(m_sortChain.Contains(p->key))
			{
				return true;
			}
		}
		return false;
	}

	bool isColumnSort(const unsigned short& columnId) const{return columnId != 0xFFFF && (columnId == GetSortId() || BelongsToSortChain(columnId));}

	bool isInventoryColumnInSortChain() const
	{
		if(!m_sortChain.isEmpty())
		{
			const UShortChain::List& sortList = m_sortChain.GetList();
			for(UShortChain::ListConstIterator it = sortList.begin(), itend = sortList.end(); it != itend; ++it)
			{
				if(isInventoryColumnId(*it))
				{
					return true;
				}
			}
		}
		return false;
	}
	void ClearSortChain(){m_sortChain.Clear();}
	bool AddToSortChain(unsigned short sortId){return !m_sortChain.Contains(sortId) && m_sortChain.AddChainItem(sortId, true);}
	bool SetSortChain(const UShortChain& other)
	{
		if(m_sortChain != other)
		{
			m_sortChain = other;
			return true;
		}
		return false;
	}
	void ColumnSortInfoToString(std::string& info) const
	{
		char num[33];
		unsigned short id = GetSortId();
		info += U_UnsignedNumberToStrNoDecDigits(id, num, sizeof(num));
		const Column* column = GetColumnById(id);
		if(column)
		{
			info += '-';
			info += column->GetNameStr();
		}
		if(!m_sortChain.isEmpty())
		{
			const UShortChain::List& sortList = m_sortChain.GetList();
			for(UShortChain::ListConstIterator it = sortList.begin(), itend = sortList.end(); it != itend; ++it)
			{
				info += '+';
				id = *it;
				info += U_UnsignedNumberToStrNoDecDigits(id, num, sizeof(num));
				column = GetColumnById(id);
				if(column)
				{
					info += '-';
					info += column->GetNameStr();
				}
			}
		}
	}
//	virtual void InvalidateColumnRect(const ColumnIterator& cit, bool secondary){}
	typedef std::set<unsigned short> UseChangeSet;
	bool UpdateColumnUse(const UseChangeMap& useChangeMap);//, bool global);
//	virtual bool DoUpdateColumnUse(const UseChangeSet& use, const UseChangeSet& unuse){return false;}
	bool UnuseUnselColumns();

	bool AddColumn(const char* name,
		unsigned short id,
		int width,
		unsigned char useTick,// = 0,
		bool sortable,// = true,
		bool defaultSortAscending,// = false,
		const char* tooltip,// = NULL,
		bool use,// = true,
		bool globalUse,// = true,
		bool createsCell,// = true,
		unsigned char followable,// = 1,
		bool alwaysUsed,// = false,
		bool paintText,// = true,
		bool useDefaultColor,
		UINT defaultHorizontalJustification);// = false);
	bool AddColumn(const Column* columnTemplate);//, const int columnMinWidth);
//	int MoveColumn();//ColumnIterator from, ColumnIterator to, CRect& rect, bool& columnScrollOffsetChanged, ColumnIterator& toResult);
//	int ResizeColumn(int x);//int width, CRect& r, const int columnMinWidth, const int columnScrollOffset);//, int& start);
	static const int minColumnWidthVisible;
	static const unsigned short maxShortNumber;//= 0xFFFF;

	virtual void InvalidateColumnRect(const ColumnIterator& cit) const = 0;
	virtual bool isSortable() const{return false;}
	virtual bool isScrollable() const{return true;}
	virtual bool UpdateColumnUsage(const UseChangeSet& use, const UseChangeSet& unuse) = 0;
	virtual void InvalidateDataAtColumn(const unsigned short id) const = 0;
	virtual void AssignDefaultSortColumn(const bool setSortChain) = 0;

	const UShortSet& GetFollowingColumns() const{return m_followingColumns;}
	bool hasFollowingColumn() const{return !m_followingColumns.empty();}
	const unsigned short& GetFollowedId() const{return m_followedId;}
	void SetFollowedId(unsigned short followedId);
#ifdef SECONDARY_ROWS
	virtual bool isSecondary() const{return false;}
//	const unsigned short& GetEffectiveFollowedId(const bool& showPlusMinusColor) const{return showPlusMinusColor && hasFollowingColumn() ? m_followedId : maxShortNumber;}
	virtual int GetTotalRowHeight() const{return 0;}
	virtual int GetTotalRowHeightMax() const{return 0;}
#endif
	const unsigned short& GetEffectiveFollowedId() const{return m_showPlusMinusColor && hasFollowingColumn() ? m_followedId : maxShortNumber;}
	typedef CMap<unsigned short, const unsigned short&, unsigned char, const unsigned char&> InventoryColumnMap;
	bool isInventoryColumn(const unsigned short& columnId) const{return m_inventoryColumnArray && isInventoryColumnId(columnId);}
	const InventoryColumnMap* const& GetInventoryColumnMap() const{return m_inventoryColumnMap;}
	unsigned short GetInventoryColumnCount() const{return m_inventoryColumnMap ? (unsigned short)m_inventoryColumnMap->GetCount() : 0;}

	virtual void InvalidateInventoryColumns() const;

	ColumnIterator GetColumnAtPoint(const CPoint& point){return point.y >= m_columnRect.top && point.y < m_columnRect.bottom ? m_columnMap.find(PointLocatorInt(point.x)) : m_columnEnd;}
	const CRect& GetColumnRect() const{return m_columnRect;}
	CRect& GetColumnRect(){return m_columnRect;}

	const CRect& GetRowRect() const{return m_rowRect;}
	CRect& GetRowRect(){return m_rowRect;}

	void UnhighlightColumn();

	const int& GetColumnHeight() const{return m_columnHeight;}
	const unsigned short& GetSavedBuiltInColumnCount() const{return m_savedBuiltInColumnCount;}
	const unsigned short& GetSavedNoOptionBuiltInColumnCount() const{return m_savedNoOptionBuiltInColumnCount;}

//	const int& GetColumnMinHeight() const{return m_columnMinHeight;}
//	const int& GetColumnMaxHeight() const{return m_columnMaxHeight;}

	virtual bool SetColumnIndentation(int indentation);
	const int& GetColumnMinIndentation() const{return m_columnMinIndentation;}
	const int& GetColumnMaxIndentation() const{return m_columnMaxIndentation;}
	const int& GetColumnIndentation() const{return m_columnIndentation;}
	const int& GetColumnLeftOffset() const{return m_columnLeftOffset;}
	const int& GetColumnScrollOffset() const{return m_columnScrollOffset;}
	inline void GetColumnCellRect(const PointLocatorInt& pl, CRect& rect) const
	{
		rect.left = pl.GetStart() - m_columnScrollOffset;
		rect.top = m_columnRect.top;
		rect.right = pl.GetEnd() - m_columnScrollOffset;
		rect.bottom = m_columnRect.bottom;
	}

	virtual RowWindow* GetRowWindow() = 0;
	virtual const RowWindow* GetRowWindow() const = 0;

	bool GetDataRectAtColumn(unsigned short id, CRect& rect) const;
	void UpdateColumnsInventoryView();

	bool isInventoryColumnId(const unsigned short& columnId) const{return columnId < m_columnCount && m_inventoryColumnArray[columnId];}
	void AddInventoryColumn(unsigned short columnId, unsigned char columnType);//columnType = 1 if row total cumulative

	void InvalidateCellIfVisible(CRect& rowRect, unsigned short columnId) const;
	void InvalidateFollowingCells(CRect& rowRect) const;

	const int& GetColumnInvisibleWidth() const{return m_columnInvisibleWidth;}
	const int& GetColumnMinWidth() const{return m_columnMinWidth;}

	void UpdateColumnUseTickRects();
	void UpdateColumnUseTickRectsHeight();

	const unsigned int& GetRowTextHeight() const{return m_rowTextHeight;}
	const unsigned int& GetLineHeight() const{return m_lineHeight;}
	const int& GetRowOffsetX() const{return m_rowOffsetX;}
	const int& GetRowOffsetY() const{return m_rowOffsetY;}
	int CalculateExtraRowHeight(unsigned char spacing, int height) const;
	int CalculateExtraRowWidth(unsigned char spacing, int height) const;
	void SetFontRow(const FontDescription& fontDescription);
	bool SetCustomRowFont(const FontDescription& fontDescription, bool custom);

	int UpdatePageSize(const int currentScrollPos, int& scrollPos, ColumnIterator& columnFirstVisible);
	void UpdateColumnLastVisible();
	bool ScrollColumns(ColumnIterator& firstVisible, UINT nCode, unsigned short nPos, CScrollBar* pScrollBar, HWND hwnd);//, char& forceDirection);
	void UpdateColumnRightmostFirst();
	int GetMaxScroll() const{return m_columnRightmostFirst == m_columnEnd ? 0 : m_columnRightmostFirst->first.GetStart();}
	int GetTotalColumnWidth() const{return m_columnLast == m_columnEnd ? 0 : m_columnLast->first.GetEnd();}
//	ColumnIterator GetRightmostFirstColumn() const{return m_columnCount > m_pageSize ? m_columnIteratorVector[m_columnCount - m_pageSize] : m_columnCount ? m_columnIteratorVector[0] : m_columnEnd;}
	const int& GetLastPageWidth() const{return m_lastPageWidth;}
	const unsigned short& GetPageSize() const{return m_pageSize;}

	virtual void SetShowPlusMinusColor(bool showPlusMinusColor) = 0;

#ifdef SECONDARY_ROWS
	virtual const bool& isShowPlusMinusColor(bool secondary) const{return m_showPlusMinusColor;}
#else
	const bool& isShowPlusMinusColor() const{return m_showPlusMinusColor;}
#endif

//	COLORREF GetFollowedColor(const Row* row, const Column* column, bool neutral) const;
	const bool& isShowPlusMinusColorProper() const{return m_showPlusMinusColor;}
	virtual bool isPlusMinusable() const{return true;}
protected:
	Columns(int columnLeftOffset, int columnMaxIndentation, int columnIndentation);

	void DrawColumns(const RECT& rcPaint, CDC& dc, bool active);

	bool UpdateOnMouseMove(UINT nFlags, CPoint point);
	bool UpdateOnPressedMouseMove(UINT nFlags, int x);
	bool UpdateOnLButtonDown(UINT nFlags, int x);
	bool UpdateOnLButtonUp(UINT nFlags, CPoint point);
	bool UpdateOnColumnDrag(int diff, UINT scrollCode);

	int MoveColumn();//ColumnIterator from, ColumnIterator to, CRect& rect, bool& columnScrollOffsetChanged, ColumnIterator& toResult);
	virtual int ResizeColumn(int x);
	bool SetRowWindowCursor();

	virtual bool ScrollHorizontalThumbTrack(ColumnIterator& firstVisible, unsigned short nPos, const unsigned short prevPos);

	virtual bool UpdateColumnRect(const int clientLeft, const int clientRight);

	bool UpdateDataRight(bool redrawFocus = true);

	void DoCreateColumnToolTips();

	void ResetActionColumns()
	{
		m_columnInsertion
			= m_columnDragged
			= m_columnPressed
			= m_columnResizing
			= m_columnEnd;
		m_indentationMove = false;
	}
	void ResetColumns()
	{
		ResetActionColumns();
		m_columnFirstVisible = m_columnBegin;
		m_columnLastVisible
			= m_columnRightmostFirst
			= m_columnSort
			= m_columnEnd;
		m_followingColumns.clear();
		UpdateFollowingColumnsIterators();
	}
	void UpdateColumnIterators()
	{
		m_columnBegin = m_columnMap.begin();
		m_columnLast = m_columnEnd;// = m_columnMap.end();
		if(m_columnBegin != m_columnEnd)
		{
			--m_columnLast;
		}
//		m_columnFirstVisible = m_columnBegin;
	}

	void UpdateColumnsOnArrange();

	ColumnIteratorVector m_columnVector;
	ColumnIteratorVector m_columnIteratorVector;
	ColumnMap m_columnMap;
	ColumnIterator m_columnBegin;
	ColumnIterator m_columnEnd;
	ColumnIterator m_columnLast;
	ColumnIterator m_columnFirstVisible;
	ColumnIterator m_columnLastVisible;
	ColumnIterator m_columnRightmostFirst;
	unsigned short m_columnCount;
	unsigned short m_cellCount;
	unsigned int m_columnTooltipCount;

	ColumnIterator m_columnHighlighted;
	ColumnIterator m_columnResize;
	ColumnIterator m_columnResizing;
	ColumnIterator m_columnPressed;
	ColumnIterator m_columnDragged;
	ColumnIterator m_columnInsertion;

	ColumnIterator m_columnSort;
	
	bool SetColumnIndentationCursor();//int indentation);
	bool m_indentationMove;

	unsigned short m_followedId;
	UShortSet m_followingColumns;
	UShortSet::const_iterator m_followingColumnsBegin;
	UShortSet::const_iterator m_followingColumnsEnd;
	void UpdateFollowingColumnsIterators()
	{
		m_followingColumnsBegin = m_followingColumns.begin();
//		m_followingColumnsEnd = m_followingColumns.end();
	}
/*
	virtual bool UpdateSortChain(ColumnIterator columnPressed, bool shift, bool ctrl, bool alt){return false;}
	virtual bool RemoveColumnFromSortChain(Column* column){return false;}
	virtual bool AddColumnToSortChain(Column* column){return false;}
	virtual bool ClearColumnsFromSortChain(){return false;}
*/
	bool UpdateSortChain(ColumnIterator columnPressed, bool shift, bool ctrl, bool alt);
	bool RemoveColumnFromSortChain(Column* column);
	bool AddColumnToSortChain(Column* column);
	bool ClearColumnsFromSortChain();

	void DestroyColumns();

	UShortChain m_sortChain;

//	bool m_secondary;
//	RowWindow* m_rowWindow;
	void CreateInventoryColumnStorage();
	bool* m_inventoryColumnArray;
	InventoryColumnMap* m_inventoryColumnMap;
	CRect m_columnRect;
	CRect m_columnInsertionRect;
	CRect m_columnIndentationRect;
	CRect m_rowRect;

	int m_columnMinHeight;
	int m_columnMaxHeight;
	int m_columnHeight;

	int m_columnMinIndentation;
	int m_columnMaxIndentation;
	int m_columnIndentation;
	int m_columnLeftOffset;
	int m_columnScrollOffset;
	int m_columnResizeXOffset;
	int m_columnDragOffset;
	int m_columnDragInitX;

	int m_columnMinWidth;
	int m_columnInvisibleWidth;
	int m_columnBorderSize;
	int m_columnResizeOffset;
	int m_columnSortTriangleSize;
	int m_columnInsertionWidth;

	int m_lastPageWidth;
	unsigned short m_pageSize;

	unsigned short m_savedBuiltInColumnCount;
	unsigned short m_savedNoOptionBuiltInColumnCount;

	void DestroyColumnUseTickRects();
	typedef std::list<CRect> RectList;
	RectList* m_tickRectList;

	void UpdateDataGraphicsFont(const Graphics* graphics);
	void UpdateRowMetrics();
	unsigned int m_rowTextHeight;
	unsigned int m_lineHeight;
	int m_rowOffsetX;
	int m_rowOffsetY;
	unsigned char m_rowHorizontalSpacing;
	unsigned char m_rowVerticalSpacing;
	FontDescription m_fontDescriptionRow;
	FontDescription m_fontDescriptionRowCustom;
	CFont* m_fontRow;
	bool m_fontRowCustom;

	bool m_showPlusMinusColor;
};

#ifdef SECONDARY_ROWS

class TGUI_API CommandToggleExpansion : public Command
{
public:
	CommandToggleExpansion():Command("ToggleExpansion", CC_NAVIGATE){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL);
	virtual bool isToggleCommand() const{return true;}
};

class TGUI_API CommandExpandSelectedRows : public CommandNavigateNonCommandBox
{
public:
	CommandExpandSelectedRows(bool expand):CommandNavigateNonCommandBox("CollapseSelectedRows", "ExpandSelectedRows", expand){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL);
//	virtual bool isApplicableToCommandBox() const{return false;}
};

class TGUI_API CommandExpandAllRows : public CommandNavigateNonCommandBox
{
public:
	CommandExpandAllRows(bool expand):CommandNavigateNonCommandBox("CollapseAllRows", "ExpandAllRows", expand){}
	virtual void Invoke(TakionTool* activeTool, TakionTool* activeCommandTool, bool repeat, bool aggregate = false, const CommandInfo* commandInfo = NULL);
};

class TGUI_API SecondaryColumns : public Columns
{
friend class RowWindow;
public:
	SecondaryColumns(RowWindow* window, int columnLeftOffset, int columnMaxIndentation, int columnIndentation);
//	virtual ~SecondaryColumns();
	virtual bool isSecondary() const override{return true;}
	virtual void InvalidateColumnRect(const ColumnIterator& cit) const override;
	virtual bool isSortable() const;
	virtual bool isScrollable() const;
	virtual bool UpdateColumnUsage(const UseChangeSet& use, const UseChangeSet& unuse) override;
	virtual void InvalidateDataAtColumn(const unsigned short id) const override;
//	virtual const char* GetRowToolId() const override;
	virtual void AssignDefaultSortColumn(const bool setSortChain) override;
	virtual RowWindow* GetRowWindow(){return m_rowWindow;}
	virtual const RowWindow* GetRowWindow() const{return m_rowWindow;}
	int GetResizorPos(){return m_secondaryColumnResizor.GetPos();}
//	int GetIndentationResizorPos(){return m_indentationResizor.GetPos();}
	const bool& is2ndRowsVisible() const{return m_2ndRowsVisible;}
	virtual bool UpdateColumnRect(const int clientLeft, const int clientRight) override;
	const bool& isScrollBySecondaryColumnsPossible() const{return m_scrollBySecondaryColumnsPossible;}
	const bool& isScrollBySecondaryColumns() const{return m_scrollBySecondaryColumns;}
	virtual void SetShowPlusMinusColor(bool showPlusMinusColor) override;
protected:
	void UpdateResizorLimitsAndPositions();
	void UpdateResizorPos();
	void UpdateMaxBorder();
	RowWindow* m_rowWindow;
	VerticalResizor m_secondaryColumnResizor;
//	HorizontalResizor m_indentationResizor;
	bool m_2ndRowsVisible;

	virtual bool ScrollHorizontalThumbTrack(ColumnIterator& firstVisible, unsigned short nPos, const unsigned short prevPos) override;

	void ResetSecondaryScrollValues()
	{
		m_scrollBySecondaryColumnsPossible = false;
		m_scrollBySecondaryColumns = false;
		m_scrollLeapOrdinal = 0;
		m_secondaryScrollLeap = 0;
	}

	bool m_dblclkExpand;
	bool m_scrollBySecondaryColumnsPossible;
	bool m_scrollBySecondaryColumns;
	unsigned short m_scrollLeapOrdinal;
	short m_secondaryScrollLeap;
};

#endif

class TGUI_API RowWindow : public TakionTitleTool, public Columns
{
friend class Columns;
public:
	virtual ~RowWindow();
//	static const int columnBorderSize;
//	typedef CMap<unsigned short, unsigned short, Column*, Column*> ColumnIdMap;
//	typedef std::vector<Column*> ColumnVector;
	static const bool boolFalse;
	static const unsigned int uintZero;
	static const COLORREF colorrefZero;
	static const unsigned short ushortZero;//= 0;

	typedef std::list<Row*> RowList;
	typedef std::set<Row*> RowSet;
/*
	virtual unsigned int GetGraphicsColorCollectionCount() const
	{
		return TakionTitleTool::GetGraphicsColorCollectionCount() + (
#ifdef SECONDARY_ROWS
			GetSecondaryToolId() ? 3:
#endif
			2);//Title, Border, Column, Data
	}
*/
	virtual const Graphics* GetGraphicsAt(unsigned int graphicsOrdinal) const override;

	void ColumnListRowToString(std::string& info, const Row* row, const UShortListConstIterator& columnIdListBegin, const UShortListConstIterator& columnIdListEnd, const char delimiter) const;
	void ColumnListCopyRowsToString(std::string& info, bool selected, bool firstRowColumnNames, const UShortListConstIterator& columnIdListBegin, const UShortListConstIterator& columnIdListEnd, const char delimiter) const;
	void ColumnListCopyRowsToClipboard(bool selected, bool firstRowColumnNames, const UShortList& columnIdList, const char delimiter) const;
//	virtual void AddRow(Row* row) = 0;
	void PutColumnTipsToClipboard(bool includeIds) const;
	void ColumnTipsToString(std::string& tips, bool includeIds) const;
	virtual void RowToString(std::string& info, const Row* row) const;
	void RowToLog(std::string& info, const Row* row, unsigned int maxColumns = 0xFFFFFFFF) const;
	void RowToLogAsVisible(std::string& info, const Row* row, unsigned int maxColumns) const;
	virtual bool CellToString(std::string& info, const Row* row, unsigned short columnId) const;
	virtual void toString(std::string& str, unsigned int contentModifier) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual void fromScratch() override;
	virtual const void* GetGraphicsTabInitInfo(const CPoint& point) const override;
	virtual void UpdateGraphics() override;
	virtual void UpdateDataGraphics(const Graphics* graphics);
	virtual void AddToSpecificToolCollection() override;

	virtual unsigned short GetColumnIdOffsetForSavedVersion(unsigned short id) const{return id;}

	virtual unsigned short GetAdjustedAdditionalColumnId(unsigned short id, const unsigned short builtInColumnCount, const unsigned __int64& version) const{return id;}

	virtual void UpdateColorsCustom(const GraphicsColorCollection* colorCollection) override;

	void UpdateColumnGraphics(const Graphics* graphics);
	bool UpdateColumnGraphicsColorsCustom(const GraphicsColorCollection* colorCollection);
	bool UpdateColumnGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL);
	void UpdateColumnLightDarkColors();

	virtual bool UpdateDataGraphicsColorsCustom(const GraphicsColorCollection* colorCollection);
	virtual bool UpdateDataGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL);

	virtual bool CanShowRowCount() const override{return true;}

	virtual void DestroyRows();
	virtual void RepaintOnPopulation(bool resetToTop){}

	void DestroyRowsAndRepaint()
	{
//		DestroyRows();
		ClearAll();
		if(m_hWnd)RepaintOnPopulation(true);
	}

	virtual void ClearAll(){DestroyRows();}

	virtual bool PasteStocksFromClipboard(bool replace);
	virtual void StockToString(std::string& info, const Row* row) const;
	virtual unsigned short GetSymbolColumn() const{return 0xFFFF;}

	virtual unsigned short GetAdditionalColumnCount() const{return 0;}
	virtual unsigned short GetBuiltInColumnCount() const = 0;
#ifndef TAKION_NO_OPTIONS
	virtual
#endif
		unsigned short GetNoOptionBuiltInColumnCount() const{return GetBuiltInColumnCount();}

	int CalculateExtraColumnHeight(unsigned char spacing, int height) const;
	int CalculateExtraColumnWidth(unsigned char spacing, int height) const;

//	bool ArrangeColumns(ColumnItemVector& columnItemVector, unsigned short sortId, unsigned short followedId);

	virtual void CopyRowsToClipboard(bool selected) const;

	virtual void UpdateShowTooltips();

	virtual bool GetCurrentFontParams(std::string& title, FontDescription& fontDescription, FontDescription& fontDescriptionCustom, bool& custom, unsigned int& id) const;
	virtual void SetCustomFont(const FontDescription& fontDescription, bool custom, unsigned int id) override;
	virtual void SetCustomColors(const Graphics* graphics, GraphicsColorCollection* colorCollection, const COLORREF* colors, unsigned short colorCount, bool custom, const FilterStringAsNumberArray& title) override;//, const FilterStringAsNumberArray& title, unsigned int colorId) override;

	virtual void ActiveToolAppActivated(bool activated);
	virtual int GetScrollHorizontalOffset() const;
	virtual int GetScrollVerticalOffset() const;

	virtual void InvalidateTotalRowRect() const{}
	virtual void InvalidateTotalRowSubRect(const int left, const int right) const{}
	virtual const CRect* GetTotalRowRectPtr() const{return NULL;}
	virtual void SortData(bool scrollToTop = true){}

	int UpdateDataLeft();
/*
	typedef std::set<unsigned short> UseChangeSet;
	bool UpdateColumnUse(const UseChangeMap& useChangeMap);//, bool global);
*/
//	virtual bool DoUpdateSecondaryColumnUse(const UseChangeSet& use, const UseChangeSet& unuse){return false;}
	virtual bool CanDragClient(UINT nFlags, CPoint point) const;
//Rows
	virtual Row* NewRow(const void* object){return NULL;}
	virtual Row* CreateRow(const void* object, bool potential){return NULL;}
	void UndrawFocus() const;
	void DrawFocus() const;
	void RedrawFocus() const;
	void RedrawFocusConditionally() const;
	unsigned char RedrawFocusUnderMouse(UINT nFlags, const CPoint& point);

	Row* GetRowAtPoint(int y, size_t& ord) const;
	size_t GetVisibleRowOrdAtPoint(int y) const;
	size_t GetRowOrdAtPoint(int y) const;

	size_t GetVisibleRowOrdAtPoint(const CPoint& point) const;
	size_t GetRowOrdAtPoint(const CPoint& point) const;
	virtual Row* GetRowAt(size_t ord) const = 0;//{return NULL;}
	virtual size_t FindRow(const Row* row) const = 0;
	Row* GetRowAtPoint(const CPoint& point, size_t& ordinal) const;
	Row* GetSelectedRow() const{return GetRowAt(m_rowSelectedOrd);}

	Row* GetRowExpandAtPoint(const CPoint& point, size_t& ord) const;
	size_t GetVisibleRowExpandOrdAtPoint(const CPoint& point) const;

	virtual size_t GetRowCount() const = 0;//{return 0;}
	virtual size_t GetDisplayedRowCount() const{return GetRowCount();}
	virtual size_t GetPotentialRowCount() const{return GetRowCount();}
	virtual size_t GetSelectedOrAllRowCount() const{return GetRowCount();}
	virtual size_t GetSelectedRowCount() const{return 0;}
	virtual Row* GetSingleSelectedRow() const{return NULL;}
	virtual size_t GetRowFirstVisibleOrd() const{return m_verticalScrollInfo.nPos;}
	virtual size_t GetRowLastVisibleOrd() const;//returns row count if all visible
	virtual bool isMultiSelect() const{return false;}
	size_t GetRowSelectedOrd() const{return m_rowSelectedOrd;}
	size_t GetLastVisibleRowOrd() const;
	bool GetRowsRect(size_t from, size_t to, CRect& rect) const;
	bool GetRowRect(size_t ord, CRect& rect) const;
	bool GetRowExpandRect(size_t ord, CRect& rect, const int maxWidth) const;
	bool GetRowFocusRect(size_t ord, CRect& rect) const;
	void InvalidateRow(size_t ord);
//End Rows
	const unsigned char* GetDecDigits() const{return &m_decDigits;}
	void SetDecDigits(unsigned char decDigits);

	const unsigned char* GetDecDigitsMoney() const{return &m_decDigitsMoney;}
	void SetDecDigitsMoney(unsigned char decDigits);

	const bool* isShowMilliseconds() const{return &m_showMilliseconds;}
	void SetShowMilliseconds(const bool show);

	const bool* isCommaPrice() const{return &m_commaPrice;}
	void SetCommaPrice(const bool comma);

	const bool* isCommaSize() const{return &m_commaSize;}
	void SetCommaSize(const bool comma);

	const bool* isCommaMoney() const{return &m_commaMoney;}
	void SetCommaMoney(const bool comma);

	const bool* isCommaVolume() const{return &m_commaVolume;}
	void SetCommaVolume(const bool comma);

	const bool* isTruncatePrice() const{return &m_truncatePrice;}
	void SetTruncatePrice(const bool truncate);

	const bool* isTruncateMoney() const{return &m_truncateMoney;}
	void SetTruncateMoney(const bool truncate);

	static const bool staticShowSizeInShares = false;
	virtual const bool* isShowSizeInShares() const{return &staticShowSizeInShares;}

	const unsigned char& GetToolTipFilter() const{return m_tooltipFilter;}
	void SetToolTipFilter(const unsigned char filter);
	void ToggleToolTipFilter(const unsigned char flag);

	bool isGridVertical() const{return m_gridVertical;}
	bool isGridHorizontal() const{return m_gridHorizontal;}
	void SetGridVertical(bool gridVertical);
	void SetGridHorizontal(bool gridHorizontal);

	static const unsigned char borrowOrderPriceDecDigits;
	static const unsigned char betaDecDigits;

	virtual void ScrollLine(bool up, unsigned char modifier) override;
	virtual void ScrollPage(bool up, unsigned char modifier) override;
	virtual void ScrollToExtreme(bool up, unsigned char modifier) override;
	virtual void ScrollHorizontally(bool left, unsigned char modifier) override;
	virtual void CopySelection() const override;
	void ScrollWindowAndSelection(int lines);

	void SetFontColumn(const FontDescription& fontDescription);

	CFont* GetColumnFont(){return m_fontColumn;}
	const COLORREF& GetNeutralColor() const{return m_neutralColor;}
	const COLORREF& GetPositiveColor() const{return m_positiveColor;}
	const COLORREF& GetNegativeColor() const{return m_negativeColor;}

	virtual const COLORREF& GetInvalidColor() const{return colorrefZero;}
	virtual COLORREF GetColorVeryGood() const{return 0;}
	virtual COLORREF GetColorVeryBad() const{return 0;}
	virtual COLORREF GetColorVeryGoodBk() const{return 0;}
	virtual COLORREF GetColorVeryBadBk() const{return 0;}
	virtual const COLORREF* GetThermographRedColors() const{return NULL;}
	virtual const COLORREF* GetThermographGreenColors() const{return NULL;}
	virtual void SetShowPlusMinusColor(bool showPlusMinusColor) override;
//	const bool& isShowPlusMinusColor() const{return m_showPlusMinusColor;}
//	virtual bool isPlusMinusable() const{return true;}
	virtual void PaintTick(CDC& dc, const Column* column, const RowValue* rowValue, const CRect& rect) const{}

	virtual bool HasDoubleClickAction() const{return true;}
	virtual bool RowHasSecuritySymbol() const{return true;}
	virtual bool HasTopActiveMenu() const{return RowHasSecuritySymbol();}
	virtual bool HasPriceColumns() const{return true;}
	virtual bool HasSizeColumns() const{return true;}
	virtual bool HasMoneyColumns() const{return true;}
	virtual bool HasVolumeColumns() const{return false;}
	virtual bool HasMillisecondColumns() const{return false;}
//	virtual bool RowHasAccountName() const{return false;}
	virtual void UpdateTitleGraphics(const Graphics* graphics) override;
	const CRect& GetDataRect() const{return m_dataRect;}
	const CRect& GetExpandRect() const{return m_expandRect;}
	const CRect& GetDataAndExpandRect() const{return m_dataAndExpandRect;}
//	void InvalidateCellIfVisible(CRect& rowRect, unsigned short columnId);
//	void InvalidateFollowingCells(CRect& rowRect);
	void InvalidateDataRect() const{::InvalidateRect(m_hWnd, &m_dataRect, FALSE);}
	void InvalidateDataRectIfValid() const{if(m_hWnd)::InvalidateRect(m_hWnd, &m_dataRect, FALSE);}
	void InvalidateExpandRect() const{::InvalidateRect(m_hWnd, &m_expandRect, FALSE);}
	virtual void InvalidateDataAndExpandRect();//{InvalidateRect(&m_dataAndExpandRect, FALSE);}
	void InvalidateDataAndExpandRectIfValid(){if(m_hWnd)InvalidateDataAndExpandRect();}

	virtual TakionIterator* CreateRowIterator() const = 0;
	virtual Row* GetNextRow(TakionIterator* it) const = 0;

	virtual TakionIterator* CreateSelectedRowIterator() const{return NULL;}
	virtual Row* GetNextSelectedRow(TakionIterator* it) const{return NULL;}

	virtual TakionIterator* CreateDefaultRowIterator() const{return CreateRowIterator();}
	virtual Row* GetDefaultNextRow(TakionIterator* it) const{return GetNextRow(it);}

	void SelectOrdinal(size_t ord);

	const bool& isUseHorizontalScroll() const{return m_useHorizontalScroll;}
	void SetUseHorizontalScroll(bool use);

	const bool& isUseVerticalScroll() const{return m_useVerticalScroll;}
	void SetUseVerticalScroll(bool use);
	bool SetFirstVisibleColumn(ColumnIterator firstVisible, UINT nCode = SB_LINELEFT);
	void SetFirstVisibleRow(unsigned int ord, bool selectedSame = true);
	void SetLastVisibleRow(unsigned int ord, bool selectedSame = true);

	virtual bool CanHavePrefix() const override{return true;}
	virtual bool CanScrollVertically() const{return true;}
	void SetScrollDown(bool down);
	void SetHideSelection(unsigned char hideSelection);
	const bool& isBottomBase() const{return m_bottomBase;}

	enum HideSelection : unsigned char
	{
		HIDE_SEL_NEVER,
		HIDE_SEL_ALWAYS,
		HIDE_SEL_INACTIVE
	};
	const unsigned char& GetHideSelection() const{return m_hideSelection;}
	bool ShouldDrawSelection() const
	{
		switch(m_hideSelection)
		{
			case HIDE_SEL_INACTIVE:
			return m_activeTool;

			case HIDE_SEL_NEVER:
			return true;

			default:
			return false;
		}
	}

	void UpdateColumnToolTips(
#ifdef SECONDARY_ROWS
		unsigned char flags//1 - primary; 2 - secondary
#endif
		);
	virtual int GetHourRectLeft() const;
	COLORREF GetFollowedColor(const Row* row, const Column* column, bool neutral
#ifdef SECONDARY_ROWS
		, bool secondary
#endif
		) const;
//	const UShortSet& GetFollowingColumns() const{return m_followingColumns;}
//	bool hasFollowingColumn() const{return !m_followingColumns.empty();}
//	unsigned short GetFollowedId() const{return m_followedId;}
//	void SetFollowedId(unsigned short followedId);

	bool SetNewLineSoundFileName(const std::string& fileName);
	void ToggleNewLineSoundFileName(const std::string& fileName);
	const std::string& GetNewLineSoundFileName() const{return m_newLineSoundFileName;}
	unsigned int GetSoundFileCount() const;
	bool PlayNewLineSound() const;
	virtual bool CanPlayNewLineSound() const{return true;}

	virtual void UnuseUnselectedColumns() override;
/*
	inline void GetPrimaryColumnRect(const PointLocatorInt& pl, CRect& rect) const
	{
		rect.left = pl.GetStart() - m_columnScrollOffset;
		rect.top = m_columnRect.top;
		rect.right = pl.GetEnd() - m_columnScrollOffset;
		rect.bottom = m_columnRect.bottom;
	}
*/
	virtual void InvalidateDataAtColumn(const unsigned short id) const override;
/*
	virtual void InvalidateColumnRect(const PointLocatorInt& pl) const
	{
		CRect rect;
		GetColumnRect(pl, rect);
		::InvalidateRect(m_hWnd, &rect, FALSE);
	}
*/
	virtual bool DoUpdateColumnUse(const UseChangeSet& use, const UseChangeSet& unuse
#ifdef SECONDARY_ROWS
		, bool secondary
#endif
		){return false;}

	virtual bool UpdateColumnUsage(const UseChangeSet& use, const UseChangeSet& unuse) override
	{
		return DoUpdateColumnUse(use, unuse
#ifdef SECONDARY_ROWS
			, false
#endif
			);
	}

	virtual void InvalidateColumnRect(const ColumnIterator& cit) const override
	{
		CRect rect;
		GetColumnCellRect(cit->first, rect);
		::InvalidateRect(m_hWnd, &rect, FALSE);
	}

	const int& GetColumnTextHeight() const{return m_columnTextHeight;}
	const int& GetColumnOffsetX() const{return m_columnOffsetX;}
	const int& GetColumnOffsetY() const{return m_columnOffsetY;}

//	virtual const char* GetRowToolId() const{return GetToolId();}
	virtual RowWindow* GetRowWindow(){return this;}
	virtual const RowWindow* GetRowWindow() const{return this;}

	void FlashTicks(unsigned int currentDayMillisecond);

#ifdef SECONDARY_ROWS

friend class SecondaryColumns;

	virtual void InvalidatePrimaryOrSecondaryRows(size_t endRow, bool secondary, unsigned short columnId = 0xFFFF) const = 0;

	virtual const bool& isShowPlusMinusColor(bool secondary) const override{return secondary && m_secondaryColumns ? m_secondaryColumns->m_showPlusMinusColor : m_showPlusMinusColor;}

	bool SetSecondaryFirstVisibleColumn(ColumnIterator firstVisible, UINT nCode);

	virtual void DestroySecondaryRows(){}
	virtual bool RemoveNotBelongingSecondaryRows(bool removePotential){return false;}
	virtual void PopulateSecondaryRows(bool remove){}

	SecondaryColumns* const& GetSecondaryColumns(){return m_secondaryColumns;}
	const SecondaryColumns* const& GetSecondaryColumns() const{return m_secondaryColumns;}

	void InvalidateSecondaryCellIfVisible(CRect& rowRect, unsigned short columnId) const
	{
		if(m_secondaryColumns)m_secondaryColumns->InvalidateCellIfVisible(rowRect, columnId);
	}
//	bool isScrollBySecondaryColumnsPossible() const{return m_scrollBySecondaryColumnsPossible;}
//	bool isScrollBySecondaryColumns() const{return m_scrollBySecondaryColumns;}

	void Set2ndRowsNewVisible(const bool visible);
	const bool& is2ndRowsVisible() const{return m_secondaryColumns ? m_secondaryColumns->is2ndRowsVisible() : boolFalse;}

#if (_MSC_VER > 1600)
	typedef std::unordered_set<Row*> RowHashSet;
#else
	typedef std::hash_set<Row*> RowHashSet;
#endif
	bool ExpandRows(const RowHashSet& rowHashSet, const bool expand);
	virtual bool ExpandRow(Row* row){return false;}
	virtual bool CollapseRow(Row* row){return false;}

	virtual void ExpandSelectedRows(const bool expand);
	virtual void ExpandAllRows(const bool expand);

	virtual void ToggleExpandedSelectedRow();

	virtual const char* GetSecondaryToolId() const{return NULL;}
	bool GetSecondaryGraphicsName(std::string& graphicsName) const
	{
		const char* secondaryToolId = GetSecondaryToolId();
		if(secondaryToolId)
		{
			graphicsName += GetToolId();
			graphicsName += secondaryToolId;
			return true;
		}
		return false;
	}
//	virtual const char* GetSecondaryColumnsMenuName()) const{return "2nd Rows";}
	virtual void UpdateSecondaryDataGraphics(const Graphics* graphics);

	bool UpdateSecondaryDataGraphicsColorsCustom(const GraphicsColorCollection* colorCollection);
	bool UpdateSecondaryDataGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL);

	virtual unsigned short GetSecondaryAdditionalColumnCount() const{return 0;}
	virtual unsigned short GetSecondaryBuiltInColumnCount() const{return 0;}
#ifndef TAKION_NO_OPTIONS
	virtual
#endif
		unsigned short GetSecondaryNoOptionBuiltInColumnCount() const{return GetSecondaryBuiltInColumnCount();}

	virtual unsigned short GetSecondaryColumnIdOffsetForSavedVersion(unsigned short id) const{return id;}

//	void InvalidatePrimaryOrSecondaryRowRects(CRect rect, const bool secondary);

	void InvalidateSecondaryColumnRect(const ColumnIterator& cit) const
	{
		if(m_secondaryColumns)
		{
			CRect rect;
			m_secondaryColumns->GetColumnCellRect(cit->first, rect);
			::InvalidateRect(m_hWnd, &rect, FALSE);
		}
	}
	bool UpdateSecondaryColumnUse(const UseChangeMap& useChangeMap){return m_secondaryColumns && m_secondaryColumns->UpdateColumnUse(useChangeMap);}
	virtual void UnuseUnselectedSecondaryColumns() override;
//	ColumnIterator GetSecondaryColumnAtPoint(const CPoint& point){return m_secondaryColumns ? point.y >= m_secondaryColumnRect.top && point.y < m_secondaryColumnRect.bottom ? m_secondaryColumns->FindColumn(point.x) : m_secondaryColumns->GetColumnEnd() : m_columnEnd;}
	ColumnIterator GetSecondaryColumnAtPoint(const CPoint& point){return m_secondaryColumns && point.y >= m_secondaryColumns->m_columnRect.top && point.y < m_secondaryColumns->m_columnRect.bottom ? m_secondaryColumns->FindColumn(point.x) : m_secondaryColumns->GetColumnEnd();}
	inline void InvalidateSecondaryColumnRect(const PointLocatorInt& pl) const
	{
		if(m_secondaryColumns)
		{
			CRect rect;
			m_secondaryColumns->GetColumnCellRect(pl, rect);
			::InvalidateRect(m_hWnd, &rect, FALSE);
		}
	}

	const unsigned short& GetSecondaryCellCount() const{return m_secondaryColumns ? m_secondaryColumns->GetCellCount() : ushortZero;}
	const unsigned short& GetSecondaryColumnCount() const{return m_secondaryColumns ? m_secondaryColumns->GetColumnCount() : ushortZero;}
	const unsigned short& GetSecondaryColumnVectorCount() const{return m_secondaryColumns ? m_secondaryColumns->GetColumnVectorCount() : ushortZero;}//(unsigned short)m_columnVector.size();}

	const CRect* GetSecondaryColumnRect() const{return m_secondaryColumns ? &m_secondaryColumns->m_columnRect : NULL;}
	inline void GetSecondaryColumnRect(const PointLocatorInt& pl, CRect& rect) const
	{
		if(m_secondaryColumns)m_secondaryColumns->GetColumnCellRect(pl, rect);
		else rect.left = rect.top = rect.right = rect.bottom = 0;
	}
	bool GetDataRectAtSecondaryColumn(unsigned short id, CRect& rect) const;
	void InvalidateDataAtSecondaryColumn(unsigned short id);
	unsigned short GetSecondarySortId() const{return m_secondaryColumns ? m_secondaryColumns->GetSortId() : 0xFFFF;}
	bool isSecondarySortAscending() const{return m_secondaryColumns && m_secondaryColumns->isSortAscending();}
	bool isSecondaryColumnSortAscending(unsigned short id) const{return m_secondaryColumns && m_secondaryColumns->isColumnSortAscending(id);}
	const UShortChain* GetSecondarySortChain() const{return m_secondaryColumns ? m_secondaryColumns->GetSortChain() : NULL;}
	const UShortSet* GetSecondaryFollowingColumns() const{return m_secondaryColumns ? &m_secondaryColumns->GetFollowingColumns() : NULL;}
	bool hasSecondaryFollowingColumn() const{return m_secondaryColumns && m_secondaryColumns->hasFollowingColumn();}
	unsigned short GetSecondaryFollowedId() const{return m_secondaryColumns ? m_secondaryColumns->GetFollowedId() : 0xFFFF;}
	void SetSecondaryFollowedId(unsigned short followedId){if(m_secondaryColumns)m_secondaryColumns->SetFollowedId(followedId);}

	ColumnIterator GetSecondaryColumnBegin(){return m_secondaryColumns ? m_secondaryColumns->GetColumnBegin() : m_columnEnd;}
	ColumnIterator GetSecondaryColumnEnd(){return m_secondaryColumns ? m_secondaryColumns->GetColumnEnd() : m_columnEnd;}
	ColumnConstIterator GetSecondaryColumnBegin() const{return m_secondaryColumns ? m_secondaryColumns->GetColumnBegin() : m_columnEnd;}
	ColumnConstIterator GetSecondaryColumnEnd() const{return m_secondaryColumns ? m_secondaryColumns->GetColumnEnd() : m_columnEnd;}

	Column* FindSecondaryColumnPtr(int x){return m_secondaryColumns ? m_secondaryColumns->FindColumnPtr(x) : NULL;}
	Column* FindSecondaryColumnPtr(int x) const{return m_secondaryColumns ? m_secondaryColumns->FindColumnPtr(x) : NULL;}

	Column* FindSecondaryScrolledColumnPtr(int x){return FindSecondaryColumnPtr(x + m_columnScrollOffset);}
	const Column* FindSecondaryScrolledColumnPtr(int x) const{return FindSecondaryColumnPtr(x + m_columnScrollOffset);}

	bool isSecondaryInventoryColumn(const unsigned short& columnId) const{return m_secondaryColumns && m_secondaryColumns->isInventoryColumn(columnId);}
	const unsigned short& GetSecondarySavedBuiltInColumnCount() const{return m_secondaryColumns ? m_secondaryColumns->m_savedBuiltInColumnCount : ushortZero;}
	const unsigned short& GetSecondarySavedNoOptionBuiltInColumnCount() const{return m_secondaryColumns ? m_secondaryColumns->m_savedNoOptionBuiltInColumnCount : ushortZero;}
	void UpdateYOffset();
//#else
//	unsigned short GetEffectiveFollowedId() const{return m_showPlusMinusColor && hasFollowingColumn() ? m_followedId : 0xFFFF;}
#endif

	unsigned int GetNextMenuId() const;
/*
	typedef CMap<unsigned short, const unsigned short&, unsigned char, const unsigned char&> InventoryColumnMap;
	bool isInventoryColumn(const unsigned short& columnId) const{return m_inventoryColumnArray && isInventoryColumnId(columnId);}
	const InventoryColumnMap* const& GetInventoryColumnMap() const{return m_inventoryColumnMap;}
	unsigned short GetInventoryColumnCount() const{return m_inventoryColumnMap ? (unsigned short)m_inventoryColumnMap->GetCount() : 0;}
*/
	void UpdateUseTickRects();
	void UpdateUseTickRectsHeight();
	void DestroyUseTickRects();

	virtual void InvalidateInventoryColumns() const override;

	const unsigned int& GetRowHeight() const{return m_rowHeight;}
	const CRect& GetFocusRect() const{return m_focusRect;}
	bool isFocusRectEmpty() const{return m_focusRect.top == m_focusRect.bottom;}

#ifdef SECONDARY_ROWS
	virtual int GetTotalRowHeight() const{return m_totalRowHeight;}
	virtual int GetTotalRowHeightMax() const{return m_totalRowHeightMax;}
#else
	const int& GetTotalRowHeight() const{return m_totalRowHeight;}
	const int& GetTotalRowHeightMax() const{return m_totalRowHeightMax;}
#endif

	void SetNamedFilter(SymbolFilter* filter, const std::string& name);
	const std::string& GetNamedFilterName() const{return m_namedFilterName;}
	const SymbolFilter* GetNamedFilter() const{return m_namedFilter;}
	virtual SymbolFilter* GetFilterCopy() const{return NULL;}
	virtual const TakionFilter* GetTakionNamedFilter() const override{return m_namedFilter;}
	virtual void SetTakionNamedFilter(TakionFilter* filter, const std::string& name) override{SetNamedFilter((SymbolFilter*)filter, name);}
	virtual void NullifyNamedFilter() override;
	virtual unsigned char GetNativeFilterType() const{return 0xFF;}
	virtual bool HasNamedFiltering() const override{return GetNativeFilterType() != 0xFF;}

protected:
	RowWindow(const CBitmap* bitmap,
		unsigned int workspace,
		bool pinned = false,
		int minVisibleSize = 15,
		int minWidth = 20,
		int maxWidth = 0,
		int minHeight = 20,
		int maxHeight = 0,
		int minBorderWidth = 2,
		int maxBorderWidth = 2,
		const char* className = "TakionTool",
		int minTitleHeight = 0,
		int maxTitleHeight = 15,
		int titleHeight = 15);

	virtual void TitleFontChanged() override;
	virtual void AppendWindowMenuInfo(std::string& menuText) const override;
	virtual void GetAdditionalTitleInfo(std::string& text) const override;

//	bool isInventoryColumnId(const unsigned short& columnId) const{return columnId < m_columnCount && m_inventoryColumnArray[columnId];}
	virtual void UpdateInventoryView() override;

	virtual void BackgroundColorChanged(){}

	virtual void PasteStocksFromString(const char* cursor, size_t size, bool replace){}

	virtual void OnTimeRectUpdated() override;

//	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) override;
	virtual BOOL PreTranslateMessage(MSG* pMsg) override;

	virtual void BeforeRowsScrolled(int lines){}
	virtual void RowsScrolled(int lines){}

	virtual void DisplayClientMenu(UINT nFlags, CPoint point) override;

	virtual void OnSetActiveTool() override;

	virtual void LineSelected(){}
	virtual void LineRightSelected(){}

	virtual void DataRightUpdated(
#ifdef SECONDARY_ROWS
		bool secondary
#endif
		){}

	bool AdjustSelected();

	void UpdateColumnMetrics();

	void ScrollOnResizeColumn(int diff, CRect& r, int start
#ifdef SECONDARY_ROWS
		, bool secondary
#endif
	);// const;

	void PaintColumn(CDC& dc,
		const CRect& columnRect,
		ColumnIterator it,
		const int columnBorderSize,
		const int columnSortTriangleSize,
		const bool activeWnd,
		const bool sorted,
		const bool highlighted,
		const bool dragged,
		const bool pressed) const;

	void DoPaint(const RECT& rcPaint, CDC& dc);

	virtual void DoPaintTitle(const RECT& interRect, CDC& dc) override;

	virtual void UpdateTitleRects() override;
	virtual void SizeHorizontal(int cx, int cy, int oldX, int oldY) override;
	virtual void SizeVertical(int cx, int cy, int oldX, int oldY) override;
	virtual void DoPaintClient(const RECT& interRect, CDC& dc) override;
	virtual size_t DoPaintData(CDC& dc, size_t startRow, size_t endRow, const ColumnConstIterator& startColumn, const ColumnConstIterator& endColumn, const int left, const int right, bool paintExpand
#ifdef SECONDARY_ROWS
		, const bool secondary
#endif
		) const = 0;
	virtual void DrawDataAdditional(const CRect& rcPaint, CDC& dc){}
//	void PaintOneRow(const Row* row, CDC& dc, CRect& rect, const ColumnConstIterator& startColumn, const ColumnConstIterator& endColumn, const int columnScrollOffset) const;
	void PaintOneRow(const Row* row, CDC& dc, CRect& rect, const ColumnConstIterator& startColumn, const ColumnConstIterator& endColumn, const Columns* columns) const;
	virtual void BeforeDestroy() override;
	virtual void AfterDestroy() override;
	virtual void DoActivate(UINT state, bool minimized) override;//, CWnd* pWndOther) override;
	virtual void MouseLeft() override;
	virtual bool ClientSetCursor() override;
	virtual void ScrollOnTitleResize(int scrollAmount) override;
	virtual void OnTitleResize() override;
	virtual bool ResizeMouseArea(const CPoint& point, bool locked) override;
	virtual void PreSuccessfulCreate() override;
	virtual void OnSuccessfulCreate() override;
	virtual void CreateAdditionalColumns(){}
	virtual bool ResizeBorder(int borderWidth) override;
	virtual void OnMouseForcedReleaseCapture() override;

	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;
	virtual void PreAddMenuItems(CMenu& menu) override;
	virtual void AddMenuItems(CMenu& menu) override;
	virtual void PostAddMenuItems(CMenu& menu) override;
	virtual void AddRowPropertiesMenuItems(CMenu& popupMenu) override;
	virtual void PostAddRowPropertiesMenuItems(CMenu& popupMenu) override;
	void AddNamedFilterMenu(CMenu& menu) const;

	bool PaintCell(const Row* row, CDC& dc, const Column* column, const CRect& rect, UINT verticalJustification, const int rowOffsetX) const;

	virtual unsigned char UpdateResizeCursor(const CPoint& point, bool locked) override;
	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;
//	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
//	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnVScroll(UINT nCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnHScroll(UINT nCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	DECLARE_MESSAGE_MAP()

	void UpdateHorizontalScroll();
/*
#ifdef SECONDARY_ROWS
		unsigned char flags//1 - primary; 2 - secondary
#endif
		);
*/
	void UpdateVerticalScroll();

//Columns

	HCURSOR m_cursorResizeColumn;
	HCURSOR m_cursorResizeColumnRight;
	HCURSOR m_cursorResizeColumnLeft;
	HCURSOR m_cursorResizeColumnIndentation;
	HCURSOR m_cursorResizeColumnIndentationRight;
	HCURSOR m_cursorResizeColumnIndentationLeft;
	HCURSOR m_cursorDragColumn;

	int m_columnTextHeight;
	int m_columnOffsetX;
	int m_columnOffsetY;
	unsigned char m_columnHorizontalSpacing;
	unsigned char m_columnVerticalSpacing;

	FontDescription m_fontDescriptionColumn;
	FontDescription m_fontDescriptionColumnCustom;
	CFont* m_fontColumn;
	CFont* m_fontColumnSecondary;
	bool m_fontColumnCustom;

	COLORREF m_columnColorActive;
	COLORREF m_columnColorInactive;

	COLORREF m_columnColorActiveLight;
	COLORREF m_columnColorActiveDark;
	COLORREF m_columnColorInactiveLight;
	COLORREF m_columnColorInactiveDark;

	COLORREF m_columnColorTextActive;
	COLORREF m_columnColorTextInactive;

	COLORREF m_columnColorInventoryTextActive;
	COLORREF m_columnColorInventoryTextInactive;

	COLORREF m_columnColorHighlight;
	COLORREF m_columnColorHighlightLight;
	COLORREF m_columnColorHighlightDark;

	COLORREF m_columnColorDrag;
	COLORREF m_columnColorDragLight;
	COLORREF m_columnColorDragDark;

	COLORREF m_columnColorSort;
	COLORREF m_columnColorSortLight;
	COLORREF m_columnColorSortDark;

	COLORREF m_columnColorInsert;

	COLORREF m_sizeRectColor;

	VerticalResizor m_columnResizor;

	short m_accumulatedWheel;

	virtual void OnTopResized();
	virtual void OnTopResizing(int scrollAmount);

	CRect m_dataRect;
	CRect m_expandRect;
	CRect m_dataAndExpandRect;
	CRect m_sizeRect;

	CRect m_countRect;
//	CRect m_titleTextRect;
	int m_countWidth;

	mutable CRect m_focusRect;
	mutable bool m_focusDrawn;
/*
	int m_columnMinWidth;
	int m_columnInvisibleWidth;
	int m_columnBorderSize;
	int m_columnResizeOffset;
	int m_columnSortTriangleSize;
	int m_columnInsertionWidth;
*/
	CScrollBar m_horizontalScrollBar;
	SCROLLINFO m_horizontalScrollInfo;
	bool m_useHorizontalScroll;
	bool m_horizontalScrollVisible;
	int m_horizontalScrollSize;

	CScrollBar m_verticalScrollBar;
	SCROLLINFO m_verticalScrollInfo;
	bool m_useVerticalScroll;
	bool m_verticalScrollVisible;
	int m_verticalScrollSize;

	bool CanScrollColumnsRight() const;
	void SetColumnDragTimer(DragTimerDirection direction);
	DragTimerDirection m_columnDragTimerDirection;
	unsigned int m_columnDragTimerMillisecond;
	void UpdateColumnDragTimerDelayFactor(unsigned int distance);
	unsigned int m_columnDragTimerCount;
	unsigned int m_columnDragTimerDelayFactorMax;
	unsigned int m_columnDragTimerDelayFactor;
	unsigned int m_columnDragTimerDelayDistance;

//Rows
//	virtual void AdjustFirstVisibleRow(int lines) = 0;
	virtual void UpdateRowsFit();
	void DoUpdateRowsFit(unsigned int rowsFit, unsigned int lastVisibleRowOrd);
	virtual void HorizontalScrollVisibilityChanged();

//	size_t m_rowFirstVisibleOrd;
//	size_t m_rowLastVisibleOrd;
	size_t m_rowSelectedOrd;
	unsigned int m_rowsFit;
	bool m_rowsFitPartial;
	bool m_bottomBase;
	unsigned char m_hideSelection;
	void UpdateDataRectHeight(bool redrawFocus = true, bool bottomMoving = true);
	unsigned int m_dataRectHeight;
	int m_dataRight;
	int m_totalRowHeightMax;
	int m_totalRowHeight;

	bool UpdateRowHeight();
	unsigned int m_rowHeight;

	int m_lineSoundMenuWidth;
/*
	void UpdateRowMetrics();
	unsigned int m_rowTextHeight;
	int m_rowOffsetX;
	int m_rowOffsetY;
	unsigned char m_rowHorizontalSpacing;
	unsigned char m_rowVerticalSpacing;
	FontDescription m_fontDescriptionRow;
	FontDescription m_fontDescriptionRowCustom;
	CFont* m_fontRow;
	bool m_fontRowCustom;
*/
	virtual void InvalidateShowMilliseconds() const;
	virtual void InvalidateCommaPriceColums() const;
	virtual void InvalidateCommaSizeColums() const;
	virtual void InvalidateCommaMoneyColums() const;
	virtual void InvalidateCommaVolumeColums() const;

	unsigned char m_decDigits;
	unsigned char m_decDigitsMoney;
	bool m_showMilliseconds;

	virtual void NamedFilterAdded(SymbolFilter* filter, const std::string& name) override;
	virtual void NamedFilterChanged(SymbolFilter* filter) override;
	virtual void NamedFilterRenamed(SymbolFilter* filter, const std::string& name) override;
	virtual void NamedFilterDeleted(SymbolFilter* filter) override;
	virtual void AllNamedFiltersDeleted() override;
	virtual void RefreshNamedFilters() override;
	void UpdateNamedFiltering();
	virtual void DoApplyFilter(const TakionFilter& filter, bool forceFilterChanged){}

	std::string m_namedFilterName;
	SymbolFilter* m_namedFilter;

	bool m_commaPrice;
	bool m_commaSize;
	bool m_commaMoney;
	bool m_commaVolume;

	bool m_truncatePrice;
	bool m_truncateMoney;

	bool m_focusToRightEnd;

	COLORREF m_neutralColor;
	COLORREF m_positiveColor;
	COLORREF m_negativeColor;
//	bool m_showPlusMinusColor;

	virtual void RowLeftClicked(Row* row, size_t ord, const CPoint& point){}
	virtual void RowDoubleClicked(Row* row, size_t ord, const CPoint& point){}
	virtual void AddDoubleClickActionMenuItems(CMenu& menu){}
	bool m_dblclkPopulateActiveCommandWindow;
//	bool m_dblclkMakeAccountCurrent;

	virtual void RowExpandLeftPrssed(Row* row, size_t ord, const CPoint& point){}
	void SetExpandRowPressed(Row* const row);
	Row* m_expandRowPressed;
	Row* m_rowLeftClicked;
	Row* m_rowDoubleClicked;

	void DestroyToolTip();
	bool CreateToolTip();
	void CreateColumnToolTips();
	void DestroyColumnToolTips();
//	void DoCreateColumnToolTips();
	void DoDestroyColumnToolTips();
	CToolTipCtrl* m_toolTip;
	unsigned char m_tooltipFilter;
	static const unsigned int columnTipsStartId = 1000;

	bool m_gridVertical;
	bool m_gridHorizontal;
	COLORREF m_colorGridVertical;
	COLORREF m_colorGridHorizontal;

	void PopulateCommandToolWithPositionData(const PositionData* position) const;
	virtual void SecurityDoubleClicked(UINT nFlags, const CPoint& point);
	std::string m_leftClickedSecuritySymbol;

	std::string m_newLineSoundFileName;
//	const char* m_newLineSoundFileContent;
	StringOrderedSet* m_soundFileSet;

/*
	void AddInventoryColumn(unsigned short columnId, unsigned char columnType);//columnType = 1 if row total cumulative
	bool* m_inventoryColumnArray;
	InventoryColumnMap* m_inventoryColumnMap;
*/
	virtual void AssignDefaultSortColumn(const bool setSortChain) override;

	virtual void UpdateTotalRectOnResizeSecondaryColumn(){}

#ifdef SECONDARY_ROWS
	virtual void CreateSecondaryAdditionalColumns(){}
	virtual void DoUpdateSecondaryDataGraphicsColorsCustom(const GraphicsColorCollection* colorCollection){}
	virtual void DoUpdateSecondaryDataGraphicsColors(const Graphics* graphics){}
	virtual void UpdateSecondaryRowColors(){}

	static const unsigned int secondaryColumnTipsStartId = 1600;
	virtual void AddSecondaryRowMenuItems(CMenu& menu){}
	void RepaintHorizontalGrid(int diff, CRect& rectToScroll, const bool secondary) const;
	void AssignSecondaryDefaultSortColumn(const bool setSortChain);
	void AddSecondaryInventoryColumn(unsigned short columnId, unsigned char columnType)//columnType = 1 if row total cumulative
	{
		if(m_secondaryColumns)m_secondaryColumns->AddInventoryColumn(columnId, columnType);
	}
	bool isSecondaryInventoryColumnId(const unsigned short& columnId) const{return m_secondaryColumns && m_secondaryColumns->isInventoryColumnId(columnId);}
	void DoDestroySecondaryColumnToolTips();
//	void DoCreateSecondaryColumnToolTips();
	virtual void ScrollPrimaryAndSecondaryDataHorizontally(size_t endRow, int diff, CRect& rectToScroll, const CRect* rectClip, CRect& secondaryRectToScroll, const CRect* secondaryRectClip) const = 0;
	virtual void ScrollPrimaryOrSecondaryDataHorizontally(size_t endRow, int diff, CRect& rectToScroll, const CRect* rectClip, CRect* rectToRepaint, const bool secondary) const = 0;
	virtual void FlashRowTicks(size_t endRow) = 0;
	void FlashOneRowTicks(CRect rect, const bool secondary);
	void ScrollRowHorizontally(size_t i, int diff, CRect& rectToScroll, const CRect* rectClip, CRect* rectToRepaint) const;
	void ScrollRowHorizontally(size_t i, int diff, CRect& rectToScroll, const CRect* rectClip) const;
	virtual void ScrollTotalRowHorizontally(int diff, CRect& rectToScroll, const CRect* rectClip, CRect* rectToRepaint) const{}
	virtual void OnSecondaryVisibilityChange(const bool visible){}
	void SetScrollBySecondaryColumns(const bool scrollBySecondaryColumns);
	SecondaryColumns* m_secondaryColumns;
/*
	bool m_dblclkExpand;
	bool m_scrollBySecondaryColumnsPossible;
	bool m_scrollBySecondaryColumns;
	unsigned short m_scrollLeapOrdinal;
	short m_secondaryScrollLeap;
*/
#endif
//Can be a problem if somehow the drawing is done using multithreading. Should not be the case.
	static std::string drawText;
	static COLORREF drawColor;
	static COLORREF bkColor;
	static UINT drawHorizontalJustification;
private:
	RowWindow& operator=(const RowWindow& other){return *this;}
};

class TGUI_API ColumnInfo
{
public:
	ColumnInfo(const char* toolId,
		bool sortable,
		unsigned short sortId,
		unsigned short columnCount,
#ifndef TAKION_NO_OPTIONS
		unsigned short noOptionColumnCount,
#endif
		unsigned short followedId,
		unsigned short baseColumnCount = 0,
		unsigned short savedBaseColumnCount = 0);
	ColumnInfo(const ColumnInfo& other);
	~ColumnInfo();
	ColumnInfo& operator=(const ColumnInfo& other);
	const std::string& GetToolId() const{return m_toolId;}
	void SetToolId(const char* const& toolId){m_toolId = toolId;}
//	typedef std::map<unsigned short, bool> UseChangeMap;
	void CopyColumnInfo(const ColumnInfo& other, UseChangeMap& useChangeMap, unsigned char filter);//filter: 1 - window, 2 - global
	bool AddColumn(const char* name,
		unsigned short id,
		int width,
		unsigned char useTick = 0,
		bool sortable = true,
		bool defaultSortAscending = false,
		const char* tooltip = NULL,
		unsigned char alignment = 0,
		unsigned short secondarySort = 0,
		bool createsCell = true,
		unsigned char followable = 1,
		bool alwaysUsed = false,
		bool paintText = true,
		bool useDefaultColor = false,
		UINT defaultHorizontalJustification = DT_RIGHT,
		bool use = true,
		bool globalUse = true);
	const Column* GetColumnAt(unsigned short i) const{return i < m_columnCount ? m_columnById[i] : NULL;}
	Column* GetColumnAt(unsigned short i){return i < m_columnCount ? m_columnById[i] : NULL;}
	void DestroyColumn(unsigned short id);
	void DestroyAllColumns();
	const unsigned short& GetColumnCount() const{return m_columnCount;}
#ifndef TAKION_NO_OPTIONS
	const unsigned short& GetNoOptionColumnCount() const{return m_noOptionColumnCount;}
#endif

	const unsigned short& GetBaseColumnCount() const{return m_baseColumnCount;}
	const unsigned short& GetSavedBaseColumnCount() const{return m_savedBaseColumnCount;}
	void SetSavedBaseColumnCount(const ColumnInfo* baseColumnInfo)
	{
		if(baseColumnInfo->m_savedBuiltInColumnCount && baseColumnInfo->m_savedBuiltInColumnCount < m_savedBaseColumnCount)
		{
			m_savedBaseColumnCount = baseColumnInfo->m_savedBuiltInColumnCount;
		}
	}

	const unsigned short& GetSavedBuiltInColumnCount() const{return m_savedBuiltInColumnCount;}

	const Column* const* const& GetColumnById() const{return m_columnById;}
	Column** const& GetColumnById(){return m_columnById;};
	const Column* const* const& GetColumnSequence() const{return m_columnSequence;}
	Column** const& GetColumnSequence(){return m_columnSequence;}

	const bool& isSortable() const{return m_sortable;}
	const unsigned short& GetSortId() const{return m_sortId;}
	void SetSortId(const unsigned short& sortId){m_sortId = sortId;}

	const unsigned short& GetFollowedId() const{return m_followedId;}
	void SetFollowedId(const unsigned short& followedId){m_followedId = followedId;}

	typedef Chain<unsigned short> UShortChain;
	void ClearSortChain(){m_sortChain.Clear();}
	bool AddToSortChain(unsigned short sortId){return !m_sortChain.Contains(sortId) && m_sortChain.AddChainItem(sortId, true);}
	bool SetSortChain(const UShortChain& other)
	{
		if(m_sortChain != other)
		{
			m_sortChain = other;
			return true;
		}
		return false;
	}
	const UShortChain& GetSortChain() const{return m_sortChain;}
	void InitSavedBuiltInColumnCount(const ColumnArraySetting& columnArraySetting);
	void Init(const ColumnArraySetting& columnArraySetting);
	const unsigned short& GetFilledColumnCount() const{return m_filledColumnCount;}
	void SetFilledColumnCount(const unsigned short& count){m_filledColumnCount = count;}
protected:
	void NullifyColumnSequence()
	{
		const unsigned int length = sizeof(Column*) * m_columnCount;
		memset(m_columnSequence, 0, length);
		m_filledColumnCount = 0;
	}
	std::string m_toolId;
	bool m_sortable;
	unsigned short m_sortId;
	unsigned short m_columnCount;
#ifndef TAKION_NO_OPTIONS
	unsigned short m_noOptionColumnCount;
#endif
	unsigned short m_savedBuiltInColumnCount;
	unsigned short m_filledColumnCount;
	Column** m_columnById;
	Column** m_columnSequence;
	UShortChain m_sortChain;
	unsigned short m_followedId;
	unsigned short m_baseColumnCount;
	unsigned short m_savedBaseColumnCount;
};

class TGUI_API TakionSettingEventSound : public TakionSettingPageBase
{
public:
	TakionSettingEventSound(TakionMainWnd* mainWnd, TakionSettingTabDialog* parentTab);
	virtual HWND GetFirstTabControl() const{return m_ListBoxEventSound.m_hWnd;}
	virtual void UpdateSettings();
protected:
//	virtual void Resize(bool widthChanged = true, bool heightChanged = true);
	virtual void SettingPageDestroyed();
	ListBoxEventSound m_ListBoxEventSound;
	UnsignedNumberTypeSpin<unsigned int> m_SpinPurgeMillisecond;
	CStatic m_StaticPurgeMillisecond;
	CButton m_CheckBoxDisableAll;

	EditNoContext m_EditSearch;
	CButton m_ButtonSearch;

	virtual BOOL OnInitDialog();
	virtual void DoDataExchange(CDataExchange* pDX);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);

	afx_msg void OnDisableAll();

	afx_msg LRESULT OnSpinChange(WPARAM spinId, LPARAM l);
	afx_msg void OnSearchChange();
	afx_msg void OnSearch();
	DECLARE_MESSAGE_MAP()

	bool SearchItems();
	unsigned char ProcessKeyInSearch(MSG* pMsg);
	CString m_searchStr;
	bool m_searchDone;

	bool m_allSoundsDisabled;

//	VHResizeControlHorizontalFraction* m_resizeControl;
};

class TGUI_API ListBoxAlertPosition : public ListBoxColorTime
{
friend class TakionSettingAlertPosition;
public:
	enum LbAlertPositionMode : unsigned char
	{
		APM_NONE,
		APM_USE,
		APM_POPUP,

		APM_Count
	};
	ListBoxAlertPosition(TakionSettingAlertPosition* dlg, const bool& milliseconds, const char* const& name):
		ListBoxColorTime(true, milliseconds, name),
		m_dlg(dlg),
		m_itemPressed(-1),
		m_itemUnderMouse(-1),
		m_itemMode(0),
		m_timeLeftBorder(0),
		m_timeRightBorder(0),
		m_popupLeftBorder(0),
		m_colorHighlight(RGB(128, 128, 255)),
		m_colorHighlightLight(UGUI_CalculateLightColor(m_colorHighlight, 25)),
		m_colorHighlightDark(UGUI_CalculateDarkColor(m_colorHighlight, 25))
	{
		m_checkOnDoubleClick = false;
	}
/*
	virtual void GetSelectionItemRect(const DRAWITEMSTRUCT* lpDrawItemStruct, CRect& drawItemRect) const
	{
		drawItemRect = lpDrawItemStruct->rcItem;
		drawItemRect.left += m_itemHeight + m_itemHeight;
		drawItemRect.right -= m_itemHeight + m_itemHeight;
	}
*/
	virtual void GetFocusItemRect(const DRAWITEMSTRUCT* lpDrawItemStruct, CRect& drawItemRect) const override
	{
		drawItemRect.left = m_timeLeftBorder;
		drawItemRect.right = m_popupLeftBorder;
		drawItemRect.top = lpDrawItemStruct->rcItem.top;
		drawItemRect.bottom = lpDrawItemStruct->rcItem.bottom;
//		GetDrawItemRect(lpDrawItemStruct, drawItemRect);
	}
	int CalculateKeyUnderMouse(CPoint point, unsigned char& mode) const;
	virtual bool HasItemToolTips() const{return false;}

	const int& GetItemUnderMouse() const{return m_itemUnderMouse;}
	const unsigned char& GetItemMode() const{return m_itemMode;}
	void InvalidateKey(){InvalidateKey(m_itemUnderMouse, m_itemMode);}
	void InvalidateCurrentKey(const int index){InvalidateKey(index, m_itemMode);}
	virtual void GetDrawItemRectOffsets(int& left, int& right, int itemHeight = 0) const override;
protected:
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	DECLARE_MESSAGE_MAP()

	virtual void AddMenuItems(CMenu& menu) override;
//	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;

//	virtual bool CanAddItem() const override;
	virtual int AddItemOnMenuCommand(int before) override;
//	virtual bool CanFindItem() const override;
	virtual int FindItemOnMenuCommand() override;
//	virtual bool CanRemoveSelectedItem() const{return GetCurSel() >= 0;}
//	virtual bool CanClearItems() const{return m_itemCount > 0;}
	virtual bool RemoveSelectedItemOnMenuCommand(int sel) override;
	virtual bool ClearItemsOnMenuCommand() override;

	virtual void DoCreateColumnToolTips() override;
	virtual void UpdateColumnToolTipsHorizontalBounds() override;

	virtual void MouseLeft() override;
	virtual void DoDrawItem(const DRAWITEMSTRUCT* lpDrawItemStruct, const CRect& drawItemRect) override;
	void SetKeyUnderMouse(const int itemUnderMouse, const unsigned char mode);
	void InvalidateKey(const int index, const unsigned char mode);
	void CalculateBorders();
	virtual void ListBoxCreated() override
	{
		ListBoxColorTime::ListBoxCreated();
		m_itemPressed = -1;
		m_itemUnderMouse = -1;
		m_itemMode = APM_NONE;
		CalculateBorders();
	}
	virtual void SizeChanged(bool horizontalChange, bool verticalChange) override
	{
		ListBoxColorTime::SizeChanged(horizontalChange, verticalChange);
		if(horizontalChange)
		{
			CalculateBorders();
		}
	}
	TakionSettingAlertPosition* m_dlg;

	int m_itemPressed;
	int m_itemUnderMouse;
	unsigned char m_itemMode;

	int m_timeLeftBorder;
	int m_timeRightBorder;
	int m_popupLeftBorder;

	COLORREF m_colorHighlight;
	COLORREF m_colorHighlightLight;
	COLORREF m_colorHighlightDark;
};


class TGUI_API TakionSettingAlertPosition : public TakionSettingPageBase
{
friend class ListBoxAlertPosition;
public:
	TakionSettingAlertPosition(TakionMainWnd* mainWnd, TakionSettingTabDialog* parentTab);
	virtual HWND GetFirstTabControl() const override {return m_SpinTime.m_hWnd;}
	virtual void UpdateSettings() override;
//	typedef std::map<std::string, ColumnInfo*> ColumnInfoMap;
protected:
	void AddTime();
	void FindTime();
	void RemoveTime(int sel);
	void ClearTime();
//	virtual void Resize(bool widthChanged = true, bool heightChanged = true);
	TimeSpin m_SpinTime;
	ListBoxAlertPosition m_ListBoxColorTime;
	CButton m_ButtonFindTime;
	ButtonText m_ButtonColor;
	CButton m_CheckBoxPopup;
	CButton m_ButtonAddTime;
	CButton m_ButtonRemoveTime;
	CButton m_ButtonClearTime;

	CButton m_CheckBoxUseAlert;
	CButton m_CheckBoxAllAccounts;
	CButton m_CheckBoxAlertPin;

	CButton m_CheckBoxSymbolExclude;
	ValidEdit m_EditSymbol;
	CStatic m_StaticSymbol;
	ListBoxSymbolChecked m_ListBoxSymbol;
	CButton m_ButtonSymbolFind;
	CButton m_ButtonSymbolAdd;
	CButton m_ButtonSymbolRemove;
	CButton m_ButtonSymbolClear;

	virtual BOOL OnInitDialog() override;
	virtual void DoDataExchange(CDataExchange* pDX) override;
	virtual BOOL PreTranslateMessage(MSG* pMsg) override;

//	virtual void Entering() override;
	virtual void ToolTipsEnabled(bool enable) override;

	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnSelchangeColorTime();
	afx_msg void OnDblclkTime();
	afx_msg void OnUseAlert();
	afx_msg void OnTimeFind();
	afx_msg void OnColor();
	afx_msg void OnTimeAdd();
	afx_msg void OnTimeRemove();
	afx_msg void OnTimeClear();
	afx_msg void OnExclude();

//	afx_msg LRESULT OnSpinChange(WPARAM spinId, LPARAM l);
	afx_msg void OnSelchangeSymbol();
//	afx_msg LRESULT OnSelchangeSymbol(WPARAM w, LPARAM l);

//	afx_msg void OnSymbolUpdate();
	afx_msg void OnSymbolChange();
	afx_msg void OnSymbolFind();
	afx_msg void OnSymbolAdd();
	afx_msg void OnSymbolRemove();
	afx_msg void OnSymbolClear();
	afx_msg void OnSymbolCopy();
	afx_msg void OnSymbolPaste();

	afx_msg LRESULT OnListBoxChecked(WPARAM w, LPARAM l);

	afx_msg LRESULT OnListBoxIncludeExclude(WPARAM w, LPARAM l);
	afx_msg LRESULT OnListBoxFind(WPARAM w, LPARAM l);
	afx_msg LRESULT OnListBoxRemove(WPARAM w, LPARAM l);
	afx_msg LRESULT OnListBoxClear(WPARAM w, LPARAM l);
	afx_msg LRESULT OnListBoxCopy(WPARAM w, LPARAM l);
	afx_msg LRESULT OnListBoxPaste(WPARAM w, LPARAM l);
	DECLARE_MESSAGE_MAP()
	void SetTimesModified();
	void SetExclusionsModified();
	void EnableAddSymbolButtons();
	void AddSymbol(bool checked);
	void DoAddSymbol(const char* symbol, bool checked);
	bool m_timesModified;
	bool m_exclusionsModified;
};

class TGUI_API TakionSettingColumn : public TakionSettingPageBase
{
public:
	TakionSettingColumn(TakionMainWnd* mainWnd, TakionSettingTabDialog* parentTab
#ifdef SECONDARY_ROWS
		, bool secondary = false
#endif
		);
	virtual HWND GetFirstTabControl() const{return m_ListBoxColumnInfoType.m_hWnd;}
	virtual void UpdateSettings();
	typedef std::map<std::string, ColumnInfo*> ColumnInfoMap;
protected:
//	virtual void Entering() override;
	virtual void ToolTipsEnabled(bool enable) override;

	virtual void DoApplyInitInfo() override;
	ListBoxColumnInfoType m_ListBoxColumnInfoType;
	ListBoxColumn m_ListBoxColumn;
	EditNoContext m_EditSearch;
	CButton m_ButtonSearch;
	CButton m_CheckBoxUnuseUnselected;
	virtual BOOL OnInitDialog();
	virtual void DoDataExchange(CDataExchange* pDX);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnSearchChange();
	afx_msg void OnSearch();
	afx_msg void OnSelchangeColumnInfoType();
//	afx_msg void OnSelchangeColumn();
	afx_msg void OnUnuseUnselected();
	afx_msg LRESULT OnColumnMove(WPARAM w, LPARAM l);
	afx_msg LRESULT OnColumnModified(WPARAM w, LPARAM l);
	DECLARE_MESSAGE_MAP()

	bool UpdateCurrentColumnInfo();
	ColumnInfo* m_currentColumnInfo;
	bool m_currentColumnInfoModified;
	ColumnInfoMap m_modifiedColumnInfoMap;
	std::string m_searchString;
	bool m_searchDone;
#ifdef SECONDARY_ROWS
	bool m_secondary;
#endif
};

class TGUI_API DialogColumns : public DialogReset
{
public:
	DialogColumns(TakionMainWnd* mainWnd, bool toDestroyOnFocus = false, RowWindow* receipient = NULL, CWnd* parent = NULL);
	void Display(
#ifdef SECONDARY_ROWS
		bool secondary,
#endif
		RowWindow* receipient, unsigned int code, CWnd* parent, const CPoint& mousePoint);
	RowWindow* GetRowWindow(){return m_rowWindow;}
	const RowWindow* GetRowWindow() const{return m_rowWindow;}
#ifdef SECONDARY_ROWS
	Columns* GetColumns(){return m_columns;}
	const Columns* GetColumns() const{return m_columns;}
	const bool& isSecondary() const{return m_secondary;}
#endif
	virtual bool DoReset() override;
	virtual bool isChanged() const override;
	virtual HWND GetFirstTabControl() const override;
/*
	void SetReceipient(RowWindow* const& receipient, const bool& secondary)
	{
		m_rowWindow = receipient;
		m_secondary = secondary;
		if(m_secondary)m_columns = m_rowWindow->GetSecondaryColumns();
		else m_columns = m_rowWindow;
	}
*/
//	void SetFont(CFont* font);
protected:
	virtual void DoDataExchange(CDataExchange* pDX) override;
	virtual void DoApply() override;
	virtual BOOL OnInitDialog() override;
	virtual BOOL PreTranslateMessage(MSG* pMsg) override;
	virtual void Resize(bool widthChanged = true, bool heightChanged = true) override;
	virtual void FinishDialog(int result) override;
	virtual void BeforeShow() override;
//	afx_msg void OnGetMinMaxInfo(MINMAXINFO* lpMMI);
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
//	afx_msg void OnReset();
	afx_msg void OnExpand();
	afx_msg void OnSearch();
	afx_msg void OnSearchChange();
//	afx_msg void OnSelchangeColumn();
	afx_msg LRESULT OnColumnMove(WPARAM w, LPARAM l);
	afx_msg LRESULT OnColumnModified(WPARAM w, LPARAM l);
/*
	afx_msg LRESULT OnColumnChecked(WPARAM w, LPARAM l);
	afx_msg LRESULT OnColumnRangeChecked(WPARAM w, LPARAM l);
	afx_msg LRESULT OnColumnAlignmentChange(WPARAM w, LPARAM l);
	afx_msg LRESULT OnSecondarySortChange(WPARAM w, LPARAM l);
	afx_msg LRESULT OnSortChange(WPARAM w, LPARAM l);
	afx_msg LRESULT OnAscendingChange(WPARAM w, LPARAM l);
*/
	DECLARE_MESSAGE_MAP()

//	void EnableOkButton();
//	virtual void DoEnableOkButton(bool enable);

	virtual void ToolTipsEnabled(bool enable) override;
	ListBoxColumn m_ListBoxColumn;
//	ListBoxFont m_ListBoxFont;
//	EditNoContext m_EditFontSample;
/*
	CButton m_ButtonOk;
	CButton m_ButtonCancel;
	CButton m_ButtonApply;
	CButton m_ButtonReset;
*/
	EditNoContext m_EditSearch;
	CButton m_ButtonSearch;
	CButton m_ButtonExpand;

//	CFont* m_fontBold;

	RowWindow* m_rowWindow;
	Column* m_columnToSelect;
	int m_columnIndexToSelect;
	int m_lbWidth;
	int m_lbExpandedWidth;
	int m_lbHeight;
	int m_lbBorderSize;
	int m_controlHeight;
	int m_controlWidth;
	int m_clientWidth;
	int m_buttonWidth;
	int m_buttonHeight;
	std::string m_searchString;
#ifdef SECONDARY_ROWS
	Columns* m_columns;
	bool m_secondary;
#endif
	bool m_expanded;
	bool m_searchDone;
	void MoveControls(bool moveDialog);
};

class RowRingVector;

class TGUI_API RowWindowScrollable : public RowWindow
{
public:
	virtual ~RowWindowScrollable();
//	typedef RingVectorOwn<Row*> RowVector;
	virtual Row* AddRow(Row* row, bool prepend, bool repaint);
	virtual Row* NewRow(const void* object);//returns non-NULL if the row added
	virtual void toString(std::string& str, unsigned int contentModifier) const;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier);
	virtual void DestroyRows() override;
	virtual size_t GetRowCount() const override;
	virtual size_t GetRowLastVisibleOrd() const override;//returns row count
	virtual Row* GetRowAt(size_t ord) const override;
	virtual size_t FindRow(const Row* row) const override;
//	virtual void AppendRow(Row* row);
	const unsigned int& GetCap() const{return m_cap;}
	void SetCap(const unsigned int cap);
	virtual TakionIterator* CreateRowIterator() const;
	virtual Row* GetNextRow(TakionIterator* it) const;
	virtual bool CanScrollVertically() const{return m_cap != 0;}
//	virtual void UpdateColumnUse(const UseChangeMap& useChangeMap, bool global);
#ifdef SECONDARY_ROWS
	virtual void InvalidatePrimaryOrSecondaryRows(size_t endRow, bool secondary, unsigned short columnId = 0xFFFF) const override;
#endif
protected:
	RowWindowScrollable(const CBitmap* bitmap, unsigned int workspace, bool pinned = false);
	virtual bool DoUpdateColumnUse(const UseChangeSet& use, const UseChangeSet& unuse
#ifdef SECONDARY_ROWS
		, bool secondary
#endif
		) override;
#ifdef SECONDARY_ROWS
	virtual void ScrollPrimaryAndSecondaryDataHorizontally(size_t endRow, int diff, CRect& rectToScroll, const CRect* rectClip, CRect& secondaryRectToScroll, const CRect* secondaryRectClip) const override;
	virtual void ScrollPrimaryOrSecondaryDataHorizontally(size_t endRow, int diff, CRect& rectToScroll, const CRect* rectClip, CRect* rectToRepaint, const bool secondary) const override;
	virtual void FlashRowTicks(size_t endRow) override;
#endif
//	virtual bool DoUpdateSecondaryColumnUse(const UseChangeSet& use, const UseChangeSet& unuse) override;
	virtual size_t DoPaintData(CDC& dc, size_t startRow, size_t endRow, const ColumnConstIterator& startColumn, const ColumnConstIterator& endColumn, const int left, const int right, bool paintExpand
#ifdef SECONDARY_ROWS
		, const bool secondary
#endif
		) const override;
	virtual void UpdateRowsFit() override;
	virtual void AddRowsOnResize(unsigned int additionalRows){}
	virtual void PostAddMenuItems(CMenu& menu) override;
//	virtual void AdjustFirstVisibleRow(int lines);
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;

//	afx_msg void OnVScroll(UINT nCode, UINT nPos, CScrollBar* pScrollBar);
	DECLARE_MESSAGE_MAP()

	RowRingVector* m_rowVector;

	unsigned int m_cap;
};

class DialogScrollerCap : public DialogUInt<unsigned int>
{
public:
	DialogScrollerCap(MainMessageLoopWnd* const& mainWnd, const ValueType& maxValue, const bool& toDestroyOnFocus):
		DialogUInt(mainWnd, maxValue, 0, 60, 60, 60,
			0,//const int& titleWidth,
			NULL,//const char* const& title,
			10,//const int& captonHeight,
			"Line Count",//const char* const& caption,
			toDestroyOnFocus, NULL, NULL),
		m_scrollerWindow(NULL)
	{
		m_SpinValue.AddSpinCell(1, false);
		m_SpinValue.AddSpinCell(10, false);
		m_SpinValue.AddSpinCell(1000, true);
		m_SpinValue.AddSpinCell(100, true);
	}
	void Display(RowWindowScrollable* const scrollerWindow,
		const unsigned int& code,
		const ValueType& value,
		const CPoint& mousePoint,
		const char* const& title = NULL,
		const char* const& caption = NULL,
		const unsigned int& notificationId = 0)
	{
		m_scrollerWindow = scrollerWindow;
		DialogUInt::Display(m_scrollerWindow, code, m_scrollerWindow, value, m_maxValue, m_minValue, mousePoint, title, caption, notificationId);
	}
	
protected:
	virtual void DoApply()
	{
		m_value = m_currentValue;
		m_scrollerWindow->SetCap(m_value);
	}

	RowWindowScrollable* m_scrollerWindow;
};

class DialogUnsignedPercent : public DialogUInt<unsigned int>
{
public:
	DialogUnsignedPercent(MainMessageLoopWnd* const& mainWnd, const ValueType& maxValue, const bool& toDestroyOnFocus):
		DialogUInt(mainWnd, maxValue, 0, 60, 60, 60,
			0,//const int& titleWidth,
			NULL,//const char* const& title,
			10,//const int& captonHeight,
			"Close Price %",//const char* const& caption,
			toDestroyOnFocus, NULL, NULL, 2)
	{
		m_SpinValue.AddSpinCell(1, false);
		m_SpinValue.AddSpinCell(10, false);
		if(maxValue > 9)m_SpinValue.AddSpinCell(1000, true);
		m_SpinValue.AddSpinCell(100, true);
	}
	void Display(TakionFrame* const receipient,
		const unsigned int& code,
		CWnd* const& parent,
		const Price& value,
		const Price& maxValue,
		const Price& minValue,
		const CPoint& mousePoint,
		const char* const& title = NULL,
		const char* const& caption = NULL,
		const unsigned int& notificationId = 0)
	{
		DialogUInt::Display(receipient,
			code,
			parent,
			value.GetDollars() * 100 + value.GetDollarFraction() / (Price::divider / 100),
			maxValue.GetDollars() * 100 + maxValue.GetDollarFraction() / (Price::divider / 100),
			minValue.GetDollars() * 100 + minValue.GetDollarFraction() / (Price::divider / 100),
			mousePoint,
			title,
			caption,
			notificationId);
	}
};

class DialogSignedPercent : public DialogInt<int>
{
public:
	DialogSignedPercent(MainMessageLoopWnd* const& mainWnd, const ValueType& maxValue, const ValueType& minValue, const bool& toDestroyOnFocus):
		DialogInt(mainWnd, maxValue, minValue, 60, 60, 60,
			0,//const int& titleWidth,
			NULL,//const char* const& title,
			10,//const int& captonHeight,
			"Close Price %",//const char* const& caption,
			toDestroyOnFocus, NULL, NULL, 2)
	{
		m_SpinValue.AddSpinCell(1, false);
		m_SpinValue.AddSpinCell(10, false);
		if(maxValue > 9)m_SpinValue.AddSpinCell(1000, true);
		m_SpinValue.AddSpinCell(100, true);
	}
	void Display(TakionFrame* const receipient,
		const unsigned int& code,
		CWnd* const& parent,
		const SignedPrice& value,
		const SignedPrice& maxValue,
		const SignedPrice& minValue,
		const CPoint& mousePoint,
		const char* const& title = NULL,
		const char* const& caption = NULL,
		const unsigned int& notificationId = 0)
	{
		DialogInt::Display(receipient,
			code,
			parent,
			value.GetDollars() * 100 + value.GetDollarFraction() / (SignedPrice::divider / 100),
			maxValue.GetDollars() * 100 + maxValue.GetDollarFraction() / (SignedPrice::divider / 100),
			minValue.GetDollars() * 100 + minValue.GetDollarFraction() / (SignedPrice::divider / 100),
			mousePoint,
			title,
			caption,
			notificationId);
	}
};

class TGUI_API RowWindowScrollableFitAccount : public RowWindowScrollable
{
public:
	const Account* GetAccount() const{return m_account;}
	virtual void CurrentAccountChanged(const Account* currentAccount);
	void SetAccount(const Account* account);
	virtual void toString(std::string& str, unsigned int contentModifier) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual void fromScratch() override;
	virtual void CurrentAccountLoaded() override;
	virtual void AllAccountsLoaded() override;
	virtual void LoggedToExecutor() override;
	unsigned short GetHistoryLoadCode() const{return m_historyLoadCode;}
	virtual void ConnectionDisconnected(unsigned int ipAddress, unsigned short port, unsigned int ipBindAddress, unsigned short bindPort, unsigned char connectionType, const char* connectionName) override;
	virtual void ConnectionConnected(unsigned int ipAddress, unsigned short port, unsigned int ipBindAddress, unsigned short bindPort, unsigned char connectionType, const char* connectionName) override;
protected:
	RowWindowScrollableFitAccount(const CBitmap* bitmap, unsigned int workspace, bool pinned = false):
		RowWindowScrollable(bitmap, workspace, pinned),
		m_account(NULL),
		m_historyLoadCode(0)
	{
	}
	virtual void AccountChanged(){}
	const Account* m_account;
	unsigned short m_historyLoadCode;
};

class ScrollerSecurity;

class TGUI_API SecurityScrollerWindow : public RowWindowScrollableFitAccount, public Observer
{
public:
	virtual ~SecurityScrollerWindow();
//	virtual bool isPlusMinusable() const{return false;}
//	virtual void RowToString(std::string& info, const Row* row) const;

	virtual bool isTimeFrameInMinutes() const override{return m_timeFrameInMinutes;}
//	virtual bool isUseTimeFrameInMinutes() const{return m_useTimeFrameInMinutes;}
	virtual unsigned short GetTimeFrameInSeconds() const override{return m_timeFrameInSecondsValue;}
	void SetTimeFrameInMinutes(bool timeFrameInMinutes);
	void UpdateEquityTimeFrame();

	const COLORREF& GetColorNotLoaded() const{return m_colorNotLoaded;}
	const COLORREF& GetColorDisconnected() const{return m_colorDisconnected;}

	virtual COLORREF GetBkColor() const override{return m_marketSorterConnected ? m_marketSorterLoaded ? m_backgroundColor : m_colorNotLoaded : m_colorDisconnected;}
	virtual void SetMarketSorterConnected(bool connected);
	void SetMarketSorterLoaded(bool loaded);

	virtual void toString(std::string& str, unsigned int contentModifier) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual void fromScratch() override;
	virtual void AddToSpecificToolCollection() override;

	virtual void UpdateDataGraphics(const Graphics* graphics) override;
	virtual bool UpdateDataGraphicsColorsCustom(const GraphicsColorCollection* colorCollection) override;
	virtual bool UpdateDataGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL) override;

	const unsigned short& GetTimeFrame() const{return m_timeFrame;}

	virtual bool CanShowTotalCount() const override{return true;}
//	virtual Row* CreateRow(const void* object, bool potential);

//	typedef void (HiLoScrollerRow::*FnPaintInfo)(std::string& text, COLORREF& color, UINT& horizontalJustification) const;
//	bool AddHiLoScrollerFunctions(unsigned short id, FnPaintInfo fnPaint);
//	inline const FnPaintInfo& GetFnPaintInfo(unsigned short id) const{return m_paintInfoFunction[id];}

	unsigned char ScrollerSecurityBelongs(const SecurityChartRow* row) const;//should be called inside lock

	bool NoteBelongsByTextFilter(const char* note) const;
	bool SecurityBelongsByTextFilter(const Security* security) const;

	virtual bool SecurityBelongs(const SecurityChartRow* security) const = 0;
	virtual bool SecurityPotentiallyBelongs(const Security* security) const;

	virtual ScrollerSecurity* CreateSecurity(const Security* security, Position* position, bool potential) = 0;
	virtual void NewSecurity(const Security* security);

	virtual void UpdateTitleGraphics(const Graphics* graphics) override;
	const unsigned int& GetHiCount() const{return m_hiCount;}
	const unsigned int& GetLoCount() const{return m_loCount;}

	void IncrementHiCount();
	void DecrementHiCount();
	void IncrementLoCount();
	void DecrementLoCount();

	void IncrementDisplayedCount(int hiloCount);
	void DecrementDisplayedCount(int hiloCount);

	virtual void HighReached(const ScrollerSecurity* scrollerSecurity, bool dayHighReached){}
	virtual void LowReached(const ScrollerSecurity* scrollerSecurity, bool dayLowReached){}

	virtual void UpdatedBecameFilteredIn(ScrollerSecurity* scrollerSecurity){}
	virtual void UpdatedBecameFilteredOut(ScrollerSecurity* scrollerSecurity){}

	virtual size_t GetDisplayedRowCount() const override{return m_displayedCount;}
	virtual size_t GetPotentialRowCount() const override{return m_securityMap.GetCount();}

	virtual bool HasMillisecondColumns() const override{return true;}

	virtual bool GetLastSecuritySymbol(std::string& symbol) const override;

	virtual int GetHourRectLeft() const override;

	void DestroyRowsAndSecurities();

	typedef CMap<const Security*, const Security* const&, ScrollerSecurity*, ScrollerSecurity* const&> SecurityMap;
	virtual bool isAffectedByOddLotPrints() const override{return true;}

	virtual void AppendWindowMenuInfo(std::string& menuText) const override;
	virtual void GetTimeFrameAsString(std::string& str) const{}

	void RemoveScrollerSecurity(ScrollerSecurity* row);

	unsigned int GetNextMenuId() const;

	void TokenExpressionAdded(const TokenExpressionCollection* const expression);
	void TokenExpressionRemoved(const TokenExpressionCollection* const expression);
	void TokenExpressionChanged(const TokenExpressionCollection* const expression);
	bool SetTokenExpression(const TokenExpressionCollection* const expression);
	bool SetTokenExpressionByName(const char* name);
protected:
	SecurityScrollerWindow(const CBitmap* bitmap, unsigned int workspace, bool pinned = false);

	virtual void TitleFontChanged() override;

	virtual void DoUpdateTitle() override;
	virtual void GetAdditionalTitleInfo(std::string& text) const override;

	virtual void NextDayStarted() override;

	virtual void DisplayFilter() = 0;

	virtual void DestroySecurities();
//	virtual void AddRowsOnResize(unsigned int additionalRows);
	virtual void BeforeDestroy() override;
	virtual void AccountChanged() override;
	virtual void CurrentAccountLoaded() override;
	virtual void CurrentAccountConstraintsLoaded() override;
	virtual void AddMenuItems(CMenu& menu) override;
	virtual void PostAddRowPropertiesMenuItems(CMenu& popupMenu) override;
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;

	virtual void DoPaintTitle(const RECT& interRect, CDC& dc) override;
	virtual void UpdateTitleRects() override;
	virtual void OnTitleResize() override;
	virtual void SizeHorizontal(int cx, int cy, int oldX, int oldY) override;

	bool UpdateTimeFrame(unsigned short minutes);
	bool DoUpdateTimeFrame();
	virtual void Repopulate(){}
//	virtual void UpdatePopulation();
	void UpdatePopulation();

	void UpdateAccountInfo();

	void ProcessScrollerSecurityBelonging(ScrollerSecurity* row, unsigned char belongs);
	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;

//	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
//	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
//	DECLARE_MESSAGE_MAP()

//	void DoSecurityNoteAdded(const unsigned __int64& symbol, const std::string& note);
//	void DoSecurityNoteRemoved(const unsigned __int64& symbol, bool potentiallyBelongs);

	void HandleSecurityNote(const unsigned __int64& symbol, bool potentiallyBelongs);

	virtual void SecurityNoteAdded(const unsigned __int64& symbol, const std::string& note) override;
	virtual void SecurityNoteRemoved(const unsigned __int64& symbol) override;
	virtual void SecurityNotesCleared() override;
//	virtual void SecurityNotesClearDone() override;
	virtual void SecurityNotesReplaced(const std::map<unsigned __int64, std::string, lessUIntAsStr<unsigned __int64> >& newNotes, bool clearOld) override;
//	virtual void SecurityNotesReplacementDone() override;

	bool AssignTokenExpressionByName(const char* name);
	void PopulateByTokenExpression();
	const TokenExpressionCollection* m_textFilter;
	std::string m_textFilterName;

	int m_potentialCountWidth;
	CRect m_potentialCountRect;
	CRect m_hiRect;
	CRect m_xRect;
	CRect m_loRect;
	int m_hiloWidth;
	int m_xWidth;
	void ResetHiLoCount();
	unsigned int m_hiCount;
	unsigned int m_loCount;
	unsigned int m_displayedCount;

	bool m_marketSorterConnected;
	bool m_marketSorterLoaded;
	COLORREF m_colorDisconnected;
	COLORREF m_colorNotLoaded;
	unsigned short m_timeFrame;

	bool m_timeFrameInMinutes;
//	bool m_useTimeFrameInMinutes;
	unsigned short m_timeFrameInSecondsValue;

	SecurityMap m_securityMap;
};

class TGUI_API PotentialSecurityChartRow : public SecurityChartRow
{
public:
	virtual bool Lock(bool wait) const;
//	virtual void LockWait() const;
	virtual void Unlock() const;

//	bool Update();
	void Update();

	virtual unsigned char Belongs() const{return 2;}//0 - does not belong ever; 1 - potentially belongs; 2 - belongs
	virtual bool FiltersIn() const{return true;}//does not check foe "does not belong ever"; false - potentially belongs; true - belongs

//	virtual bool isUseOddLotPrints() const{return m_scrollerWindow->isUseOddLotPrints();}
	virtual void Initialize();//should be called only inside a lock
	const bool& isPotential() const{return m_potential;}
	void SetPotential(const bool& potential){m_potential = potential;}
/*
	const bool& isHighReached() const{return m_highReached;}
//	DECLARE_NED_NEW
//	bool isUseTimeFrameInMinutes() const{return m_scrollerWindow->isUseTimeFrameInMinutes();}
	unsigned short GetTimeFrameInSeconds() const{return m_scrollerWindow->GetTimeFrameInSeconds();}
	const SecurityScrollerWindow* const& GetSecurityScrollerWindow() const{return m_scrollerWindow;}
	SecurityScrollerWindow* const& GetSecurityScrollerWindow(){return m_scrollerWindow;}
*/
protected:
	PotentialSecurityChartRow(const Security* security, const Position* position, unsigned short timeFrame, unsigned short timeFrameInSeconds, bool potential);// = false);
	virtual void BecameFilteredIn(){}
	virtual void BecameFilteredOut(){}
	virtual void Notify(const Message* message, const Observable* from, const Message* info = NULL) override;
	bool m_potential;
/*
	virtual void IncrementHiCount();
	virtual void DecrementHiCount();
	virtual void IncrementLoCount();
	virtual void DecrementLoCount();
	virtual void LowReached(bool dayLowReached) override;
	virtual void HighReached(bool dayHighReached) override;
	SecurityScrollerWindow* m_scrollerWindow;
	bool m_highReached;
*/
};

class TGUI_API ScrollerSecurity : public PotentialSecurityChartRow
{
public:
//	virtual bool Lock(bool wait) const;
//	virtual void Unlock() const;

//	virtual bool Update();//return

	virtual unsigned char Belongs() const override;//0 - does not belong ever; 1 - potentially belongs; 2 - belongs
	virtual bool FiltersIn() const override;//does not check foe "does not belong ever"; false - potentially belongs; true - belongs

	virtual bool isUseOddLotPrints() const{return m_scrollerWindow->isUseOddLotPrints();}

//	virtual void Initialize();//should be called only inside a lock
//	const bool& isPotential() const{return m_potential;}
//	void SetPotential(const bool& potential){m_potential = potential;}

	const bool& isHighReached() const{return m_highReached;}
//	DECLARE_NED_NEW
//	bool isUseTimeFrameInMinutes() const{return m_scrollerWindow->isUseTimeFrameInMinutes();}
//	unsigned short GetTimeFrameInSeconds() const{return m_scrollerWindow->GetTimeFrameInSeconds();}
	const SecurityScrollerWindow* const& GetSecurityScrollerWindow() const{return m_scrollerWindow;}
	SecurityScrollerWindow* const& GetSecurityScrollerWindow(){return m_scrollerWindow;}
protected:
	ScrollerSecurity(SecurityScrollerWindow* parent, const Security* security, Position* position, bool potential = false);

	virtual void BecameFilteredIn() override;
	virtual void BecameFilteredOut() override;

//	virtual void Notify(const Message* message, const Observable* from, const Message* info = NULL) override;
	virtual void IncrementHiCount();
	virtual void DecrementHiCount();
	virtual void IncrementLoCount();
	virtual void DecrementLoCount();
	virtual void LowReached(bool dayLowReached) override;
	virtual void HighReached(bool dayHighReached) override;

//	bool m_potential;
	bool m_highReached;
	SecurityScrollerWindow* m_scrollerWindow;
};

class HiLoScrollerRow;

class TGUI_API HiLoScroller : public SecurityScrollerWindow
{
public:
	virtual const char* GetToolId() const override{return toolHiLoScrollerId;}
//	virtual bool isPlusMinusable() const{return false;}
	virtual void RowToString(std::string& info, const Row* row) const override;

//	virtual COLORREF GetBkColor() const{return m_marketSorterConnected ? m_marketSorterLoaded ? m_bkColor : m_colorNotLoaded : m_colorDisconnected;}

	enum ColumnId : unsigned short
	{
		HLS_SYMBOL,
		HLS_HILO_COUNT,
		HLS_HILO_COUNT_REPEAT,
		HLS_TIME,
		HLS_PRICE,
		HLS_BID,
		HLS_ASK,
		HLS_VOLUME,
		HLS_DAY_VOLUME,
		HLS_LOW_PRICE,
		HLS_HIGH_PRICE,
		HLS_FIRST_PRICE,
		HLS_LOW_ATOMIC_PRICE,
		HLS_HIGH_ATOMIC_PRICE,
		HLS_LAST_PRICE,
		HLS_LOW_ATOMIC_STEP,
		HLS_HIGH_ATOMIC_STEP,
		HLS_NET_CHANGE,
		HLS_RANGE,

		HLS_HI_COUNT_TOTAL,
		HLS_LO_COUNT_TOTAL,
		HLS_HI_COUNT_REPEAT_TOTAL,
		HLS_LO_COUNT_REPEAT_TOTAL,

		HLS_DAY_NET_CHANGE,
		HLS_DAY_NET_PERCENT_CHANGE,

		HLS_RSI_MH,
		HLS_RSI_DAYS,

		HLS_LAST_SIZE,
		HLS_NEWS_COUNT,
		HLS_NEWS_DATETIME,

		HLS_YEST_AFTER_MARKET_NEWS_COUNT,

		HLS_MODE,

		HLS_NET_PERCENT_CHANGE,
		HLS_DAY_NET_TCLOSE_PERCENT_CHANGE,

		HLS_DAY_NET_TCLOSE_CHANGE,

		HLS_DAY_BID_NET_CHANGE,
		HLS_DAY_ASK_NET_CHANGE,
		HLS_DAY_BID_NET_PERCENT,
		HLS_DAY_ASK_NET_PERCENT,

		HLS_T_BID_NET_CHANGE,
		HLS_T_ASK_NET_CHANGE,
		HLS_T_BID_NET_PERCENT,
		HLS_T_ASK_NET_PERCENT,

		HLS_COLUMN_COUNT
	};
	virtual unsigned short GetBuiltInColumnCount() const override{return HLS_COLUMN_COUNT;}
//	virtual void ApplyFilter(const TakionFilter& filter) override;
	virtual void toString(std::string& str, unsigned int contentModifier) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual void fromScratch() override;
	virtual void AddToSpecificToolCollection() override;
	
	virtual void UpdateDataGraphics(const Graphics* graphics) override;
	virtual bool UpdateDataGraphicsColorsCustom(const GraphicsColorCollection* colorCollection) override;
	virtual bool UpdateDataGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL) override;

	virtual bool HasVolumeColumns() const override{return true;}
	virtual bool HasMoneyColumns() const override{return false;}
//	virtual void UpdatedBecameFilteredIn(ScrollerSecurity* scrollerSecurity);
//	virtual void UpdatedBecameFilteredOut(ScrollerSecurity* scrollerSecurity);

	virtual void SetMarketSorterConnected(bool connected) override;

	typedef void (HiLoScrollerRow::*FnPaintInfo)(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	bool AddHiLoScrollerFunctions(unsigned short id, FnPaintInfo fnPaint);
	inline const FnPaintInfo& GetFnPaintInfo(const unsigned short& id) const{return id < HLS_COLUMN_COUNT ? m_paintInfoFunction[id] : NULL;}

	virtual bool SecurityBelongs(const SecurityChartRow* security) const override;
	virtual bool SecurityPotentiallyBelongs(const Security* security) const override;

	virtual void HighReached(const ScrollerSecurity* scrollerSecurity, bool dayHighReached) override;
	virtual void LowReached(const ScrollerSecurity* scrollerSecurity, bool dayLowReached) override;

	virtual Row* CreateRow(const void* object, bool potential);

	const bool& isUseAtomicPrice() const{return m_filter.isUseAtomicPrice();}
	const bool& isOddLotPrints() const{return m_filter.isOddLotPrints();}
	const bool& isPrintJumpMode() const{return m_filter.isPrintJumpMode();}
	void CalculateAtomicPrice(const Price& stockPrice, Price& atomicPrice) const;
	COLORREF GetColorHigh() const{return m_colorHigh;}
	COLORREF GetColorLow() const{return m_colorLow;}
	virtual bool HasLastSymbolCommands() const override{return true;}
	virtual void GetTimeFrameAsString(std::string& str) const override;
//RSI Minutes
	const bool& isRsiMhCalculate() const{return m_filter.isRsiMhCalculate();}
	const unsigned short& GetRsiMhPriorPointCount() const{return m_filter.GetRsiMhPriorPointCount();}
	const unsigned short& GetRsiMhPeriodLength() const{return m_filter.GetRsiMhPeriodLength();}//in minutes
	const unsigned short& GetRsiMhPeriodCount() const{return m_filter.GetRsiMhPeriodCount();}
	const unsigned short& GetRsiMhStartMinute() const{return m_filter.GetRsiMhStartMinute();}
	const bool& isRsiMhTodayOnly() const{return m_filter.isRsiMhTodayOnly();}
	const bool& isRsiMhPostMarket() const{return m_filter.isRsiMhPostMarket();}
//RSI Days
	const bool& isRsiDaysCalculate() const{return m_filter.isRsiDaysCalculate();}
	const unsigned short& GetRsiDaysPriorPointCount() const{return m_filter.GetRsiDaysPriorPointCount();}
	const unsigned short& GetRsiDaysPeriodLength() const{return m_filter.GetRsiDaysPeriodLength();}//in days
	const unsigned short& GetRsiDaysPeriodCount() const{return m_filter.GetRsiDaysPeriodCount();}
	const unsigned short& GetRsiDaysStartMinute() const{return m_filter.GetRsiDaysStartMinute();}
	const bool& isRsiDaysPostMarket() const{return m_filter.isRsiDaysPostMarket();}

	virtual void GetAdditionalTitleInfo(std::string& text) const override;
//	virtual void AppendWindowMenuInfo(std::string& menuText) const override;
#ifdef _DEBUG
	bool CheckIntegrityOfAllAtomicPrices() const;
#endif
	virtual SymbolFilter* GetFilterCopy() const override;
	virtual unsigned char GetNativeFilterType() const override{return m_filter.isA();}
	virtual const TakionFilter* GetFilter() const override{return &m_filter;}
protected:
	HiLoScroller(const CBitmap* bitmap, unsigned int workspace, bool pinned = false);

	virtual void NextDayStarted() override;
	virtual void DisplayFilter() override;
	virtual void BeforeDestroy() override;
	virtual void AccountChanged() override;
	virtual void AddRowPropertiesMenuItems(CMenu& popupMenu) override;
	virtual void AddMenuItems(CMenu& menu) override;
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;
	virtual void LineSelected() override;
	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;

//	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
//	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
//	DECLARE_MESSAGE_MAP()

	void UpdateRsiMhParams();
	void UpdateRsiDaysParams();

//	bool UpdateAtomicPriceSettings();
	void UpdateAtomicPriceSettings();

	FnPaintInfo m_paintInfoFunction[HLS_COLUMN_COUNT];

	HiLoScrollerFilter m_filter;
	virtual void DoApplyFilter(const TakionFilter& filter, bool forceFilterChanged) override;

	COLORREF m_colorHigh;
	COLORREF m_colorLow;

	bool m_selectedActive;
};

class TGUI_API HiLoScrollerSecurity : public ScrollerSecurity
{
public:
	HiLoScrollerSecurity(HiLoScroller* parent, const Security* security, Position* position, bool potential = false);

	virtual void Initialize();//should be called only inside a lock

	DECLARE_NED_NEW

	const Price& GetLoAtom() const{return m_loAtom;}
	const Price& GetHiAtom() const{return m_hiAtom;}

	const Price& GetLoAtomicPrice() const{return m_loAtomicPrice;}
	const Price& GetHiAtomicPrice() const{return m_hiAtomicPrice;}
	const bool& isUseAtomicPrice() const{return m_useAtomicPrice;}
	void SetUseAtomicPrice(bool use);
	const bool& isOddLotPrints() const{return m_oddLotPrints;}
	void SetOddLotPrints(bool oddLotPrints);
	const bool& isPrintJumpMode() const{return m_printJumpMode;}
	void SetPrintJumpMode(bool printJumpMode);
	const unsigned short& GetAtomicLoMinute() const{return m_atomicLoMinute;}
	const unsigned short& GetAtomicHiMinute() const{return m_atomicHiMinute;}
	const Price& GetPrevPriceAtomic() const{return m_prevPriceAtomic;}
	const Price& GetLastPriceAtomic() const{return m_lastPriceAtomic;}

	unsigned int GetMode() const
	{
		unsigned int mode = 0;
		if(m_useAtomicPrice)
		{
			char* c = (char*)&mode;
			*c = 'A';
			if(m_oddLotPrints)*++c = 'O';
			if(m_printJumpMode)*++c = 'J';
		}
		return mode;
	}
	virtual bool InitializeChart(bool fromConstructor = false) override;
	virtual bool SetTimeFrame(unsigned short minutes, unsigned short timeFrameInSeconds) override;
	virtual void AddPrint(const Price& price, unsigned int size, char marketCenterId, unsigned char printFlags) override;
	virtual bool SetCurrentMinute(unsigned short currentMinute, bool fromServer) override;
	virtual bool SetEndChartMinute(unsigned short endChartMinute, bool fromServer) override;
	
	void UpdateAtomicPriceSettings();

	virtual void NextDayReset() override;
	void GetSecurityLastPrice(Price& price) const;
#ifdef _DEBUG
	bool CheckIntegrityOfAtomicPrices() const;
#endif
protected:
	void InitializeAtomicPrice();

	void SetLowAndHighAtomicPrice()
	{
		Price price;
		GetSecurityLastPrice(price);
		SetLowAndHighAtomicPrice(price, price, 0, 0);
	}
	void SetLowAndHighAtomicPrice(const Price& lowPrice, const Price& highPrice, const unsigned short& atomicLoMinute, const unsigned short& atomicHiMinute)
	{
		SetLoAtomicPrice(lowPrice);
		m_atomicLoMinute = atomicLoMinute;
		SetHiAtomicPrice(highPrice);
		m_atomicHiMinute = atomicHiMinute;
	}
	void AdjustTimeFrameHiLoMinute();

	void UpdateAtom();
	void UpdateAtomicMinute();
	void SetLoAtomicPrice(const Price& price);
	void SetHiAtomicPrice(const Price& price);
	virtual void LowReached(bool dayLowReached) override;
	virtual void HighReached(bool dayHighReached) override;
	Price m_loAtom;
	Price m_hiAtom;
	Price m_loAtomicPrice;
	Price m_hiAtomicPrice;
	unsigned short m_atomicLoMinute;
	unsigned short m_atomicHiMinute;
	bool m_useAtomicPrice;
	bool m_oddLotPrints;
	bool m_printJumpMode;
	Price m_prevPriceAtomic;
	Price m_lastPriceAtomic;
};



class TGUI_API ScrollerRow : public Row
{
public:
	virtual const void* GetBaseObject() const{return NULL;}
protected:
	ScrollerRow(unsigned short columnCount):Row(columnCount){}
};

class TGUI_API HiLoScrollerRow : public ScrollerRow
{
public:
	HiLoScrollerRow(HiLoScroller* parent, HiLoScrollerSecurity* security);
//	virtual const void* GetBaseObject() const{return NULL;}
	virtual bool GetPaintTextInfo(unsigned short columnId, std::string& text, COLORREF& color) const override;//, UINT& horizontalJustification) const override;
	virtual const char* GetRowSecuritySymbol(const CPoint* point = NULL) const override;
	virtual const unsigned __int64& GetRowNumericSymbol() const override;
	virtual COLORREF GetRowColor() const override;
	virtual COLORREF GetCellColor(unsigned short columnId) const override;
	virtual COLORREF GetCellBkColor(unsigned short columnId) const override;
	virtual RowValue* CreateCell(unsigned short id) override;
	const bool& isHighReached() const{return m_highReached;}
	const COLORREF& GetRsiMhBkColor() const{return m_rsiMhBkColor;}
	const COLORREF& GetRsiMhFgColor() const{return m_rsiMhFgColor;}
	const COLORREF& GetRsiDaysBkColor() const{return m_rsiDaysBkColor;}
	const COLORREF& GetRsiDaysFgColor() const{return m_rsiDaysFgColor;}
protected:
	HiLoScroller* m_hiLoScroller;
	bool m_highReached;
	COLORREF m_rsiMhBkColor;
	COLORREF m_rsiMhFgColor;
	COLORREF m_rsiDaysBkColor;
	COLORREF m_rsiDaysFgColor;
};

class PositionManagerRow;

enum PosManMessageType : unsigned char
{
	PMT_ADMIN,
	PMT_COMMAND,
	PMT_INFO,
	PMT_ORDER_BLOCKED,
	PMT_ORDER_SENT_BUY,
	PMT_ORDER_SENT_SELL,
	PMT_ORDER_SENT_SHORT,
	PMT_ORDER_SENT_BORROW,
	PMT_ORDER_EXECUTED_BUY_OPENED,
	PMT_ORDER_EXECUTED_BUY,
	PMT_ORDER_EXECUTED_BUY_CLOSED,
	PMT_ORDER_EXECUTED_SELL_OPENED,
	PMT_ORDER_EXECUTED_SELL,
	PMT_ORDER_EXECUTED_SELL_CLOSED,
	PMT_ORDER_EXECUTED_SHORT_OPENED,
	PMT_ORDER_EXECUTED_SHORT,
	PMT_ORDER_EXECUTED_SHORT_CLOSED,
	PMT_ORDER_EXECUTED_BORROW,
	PMT_ORDER_CANCEL,

	PMT_ALERT,

	PMT_ORDER_CANCEL_REJECTED,

	PMT_COUNT
};

class TGUI_API PosManMessage
{
public:
	PosManMessage(const unsigned int& millisecond = 0,
		const unsigned __int64& numericSymbol = 0,
		const char* const& symbol = NULL,
		const Price& bid = Price(0, 0),
		const Price& ask = Price(0, 0),
		const unsigned int& bidSize = 0,
		const unsigned int& askSize = 0,
		const unsigned int& printPrice = 0,
		const unsigned int& printSize = 0,
		const unsigned int& posPrice = 0,
		const int& posSize = 0,
		const unsigned int& posInventoryPrice = 0,
		const int& posInventorySize = 0,
		const unsigned int& lastExecPrice = 0,
		const int& lastExecSize = 0,
		const unsigned int& lastExecMmid = 0,
		const unsigned short& roundLot = 100,
		const std::string& message = "",
		const PosManMessageType& type = PMT_ADMIN,
		const std::string* const& inventoryMessage = NULL,
		const PosManMessageType& inventoryType = PMT_COUNT):

		m_numericSymbol(numericSymbol),
		m_bid(bid),
		m_ask(ask),
		m_bidSize(bidSize),
		m_askSize(askSize),
		m_printPrice(printPrice),
		m_printSize(printSize),
		m_posPrice(posPrice),
		m_posSize(posSize),
		m_posInventoryPrice(posInventoryPrice),
		m_posInventorySize(posInventorySize),
		m_lastExecPrice(lastExecPrice),
		m_lastExecSize(lastExecSize),
		m_lastExecMmid(lastExecMmid),
		m_millisecond(millisecond),
		m_roundLot(roundLot),
		m_symbol(NULL),//symbol ? symbol : ""),
		m_message(message),
		m_type(type),
		m_inventoryMessage(inventoryMessage ? *inventoryMessage : message),
		m_inventoryType(inventoryType == PMT_COUNT ? type : inventoryType)
	{
		U_ReplaceText(m_symbol, symbol);// ? symbol : (const char*)&numericSymbol);
	}
	PosManMessage(const PosManMessage& other):
		m_numericSymbol(other.m_numericSymbol),
		m_bid(other.m_bid),
		m_ask(other.m_ask),
		m_bidSize(other.m_bidSize),
		m_askSize(other.m_askSize),
		m_printPrice(other.m_printPrice),
		m_printSize(other.m_printSize),
		m_posPrice(other.m_posPrice),
		m_posSize(other.m_posSize),
		m_posInventoryPrice(other.m_posInventoryPrice),
		m_posInventorySize(other.m_posInventorySize),
		m_lastExecPrice(other.m_lastExecPrice),
		m_lastExecSize(other.m_lastExecSize),
		m_lastExecMmid(other.m_lastExecMmid),
		m_millisecond(other.m_millisecond),
		m_roundLot(other.m_roundLot),
		m_symbol(NULL),//symbol ? symbol : ""),
		m_message(other.m_message),
		m_type(other.m_type),
		m_inventoryMessage(other.m_inventoryMessage),
		m_inventoryType(other.m_inventoryType)
	{
		U_ReplaceText(m_symbol, other.m_symbol);
	}
	~PosManMessage()
	{
		U_ReplaceText(m_symbol, NULL);
	}
	PosManMessage& operator=(const PosManMessage& other)
	{
		m_numericSymbol = other.m_numericSymbol;
		m_bid = other.m_bid;
		m_ask = other.m_ask;
		m_bidSize = other.m_bidSize;
		m_askSize = other.m_askSize;
		m_printPrice = other.m_printPrice;
		m_printSize = other.m_printSize;
		m_posPrice = other.m_posPrice;
		m_posSize = other.m_posSize;
		m_posInventoryPrice = other.m_posInventoryPrice;
		m_posInventorySize = other.m_posInventorySize;
		m_lastExecPrice = other.m_lastExecPrice;
		m_lastExecSize = other.m_lastExecSize;
		m_lastExecMmid = other.m_lastExecMmid;
		m_millisecond = other.m_millisecond;
		m_roundLot = other.m_roundLot;
		m_message = other.m_message;
		m_type = other.m_type;
		m_inventoryMessage = other.m_inventoryMessage;
		m_inventoryType = other.m_inventoryType;
		U_ReplaceText(m_symbol, other.m_symbol);
		return *this;
	}
	const unsigned int& GetMillisecond() const{return m_millisecond;}
	const unsigned __int64& GetNumericSymbol() const{return m_numericSymbol;}
	const Price& GetBid() const{return m_bid;}
	const Price& GetAsk() const{return m_ask;}
	const unsigned int& GetBidSize() const{return m_bidSize;}
	const unsigned int& GetAskSize() const{return m_askSize;}
	const unsigned int& GetPrintPrice() const{return m_printPrice;}
	const unsigned int& GetPrintSize() const{return m_printSize;}
	const unsigned int& GetPosPrice() const{return m_posPrice;}
	const int& GetPosSize() const{return m_posSize;}
	const unsigned int& GetPosInventoryPrice() const{return m_posInventoryPrice;}
	const int& GetPosInventorySize() const{return m_posInventorySize;}
	const unsigned int& GetLastExecPrice() const{return m_lastExecPrice;}
	const int& GetLastExecSize() const{return m_lastExecSize;}
	const unsigned int& GetLastExecMmid() const{return m_lastExecMmid;}
	const unsigned short& GetRoundLot() const{return m_roundLot;}
//	const std::string& GetSymbol() const{return m_symbol;}
	const char* GetSymbol() const{return m_symbol;}// ? m_symbol : (const char*)&m_numericSymbol; }
	const std::string& GetMessageText() const{return m_message;}
	const PosManMessageType& GetType() const{return m_type;}
	const std::string& GetInventoryMessageText() const{return m_inventoryMessage;}
	const PosManMessageType& GetInventoryType() const{return m_inventoryType;}
protected:
	unsigned __int64 m_numericSymbol;
	Price m_bid;
	Price m_ask;
	unsigned int m_bidSize;
	unsigned int m_askSize;
	unsigned int m_printPrice;
	unsigned int m_printSize;
	unsigned int m_posPrice;
	int m_posSize;
	unsigned int m_posInventoryPrice;
	int m_posInventorySize;
	unsigned int m_lastExecPrice;
	int m_lastExecSize;
	unsigned int m_lastExecMmid;
	unsigned int m_millisecond;
	unsigned short m_roundLot;
//	U_RepresentStringAsUnsignedNumber<unsigned __int64>(symbol, sizeof(unsigned __int64) - 1))
//	std::string m_symbol;
	char* m_symbol;
	std::string m_message;
	PosManMessageType m_type;
	std::string m_inventoryMessage;
	PosManMessageType m_inventoryType;
};

class TGUI_API PositionManagerWindow : public RowWindowScrollableFitAccount, public Observer
{
public:
	virtual const char* GetToolId() const override{return toolPositionManagerId;}
	virtual bool isPlusMinusable() const override{return false;}
	virtual void RowToString(std::string& info, const Row* row) const override;
	Row* AddMessage(const PosManMessage& pm);
	Row* AddTickMessage(unsigned int millisecond,
		const unsigned __int64& numericSymbol,
		const char* symbol,
		const Price& bid,
		const Price& ask,
		unsigned int bidSize,
		unsigned int askSize,
		unsigned int printPrice,
		unsigned int printSize,
		unsigned int posPrice,
		int posSize,
		unsigned int inventoryPosPrice,
		int inventoryPosSize,
		unsigned int lastExecPrice,
		int lastExecSize,
		unsigned int lastExecMmid,
		unsigned int roundLot,
		unsigned char goodbad,
		unsigned char inventoryGoodbad,
		const std::string& message);
//		const std::string* inventoryMessage = NULL);

	enum ColumnId : unsigned short
	{
		PM_TIME,
		PM_SYMBOL,
		PM_MESSAGE,
		PM_INSIDE_MARKET,
		PM_INSIDE_SIZE,
		PM_PRINT_PRICE,
		PM_PRINT_SIZE,
		PM_POS_PRICE,
		PM_POS_SIZE,
		PM_LAST_EXEC_PRICE,
		PM_LAST_EXEC_SIZE,
		PM_LAST_EXEC_MMID,

		PM_COLUMN_COUNT
	};
	virtual unsigned short GetBuiltInColumnCount() const override{return PM_COLUMN_COUNT;}
	virtual void toString(std::string& str, unsigned int contentModifier) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual void fromScratch() override;
	virtual void AddToSpecificToolCollection() override;
	virtual void UpdateDataGraphics(const Graphics* graphics) override;

	virtual bool UpdateDataGraphicsColorsCustom(const GraphicsColorCollection* colorCollection) override;
	virtual bool UpdateDataGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL) override;

	virtual bool HasMoneyColumns() const override{return false;}
	virtual bool HasMillisecondColumns() const override{return true;}

	virtual Row* CreateRow(const void* object, bool potential) override;

	typedef void (PositionManagerRow::*FnPaintInfo)(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;

	bool AddPositionManagerFunctions(unsigned short id, FnPaintInfo fnPaint);

	inline const FnPaintInfo& GetFnPaintInfo(const unsigned short& id) const{return id < PM_COLUMN_COUNT ? m_paintInfoFunction[id] : NULL;}
	void Populate();

	const bool& isShowFocusTaken() const{return m_showFocusTaken;}
	void SetShowFocusTaken(const bool showFocusTaken);

	void SetShowSizeInShares(bool sizeInShares);
	virtual const bool* isShowSizeInShares() const{return &m_sizeInShares;}

	const unsigned char& GetReportMovesLevel() const{return m_reportMovesLevel;}
	void SetReportMovesLevel(unsigned char level);
	void ToggleReportMovesLevel(MoveReportLevel level);
	const COLORREF* GetColorInfo(unsigned char i) const{return i < PMT_COUNT ? m_colorInfo + i : NULL;}
	const COLORREF& GetColorGood() const{return m_colorGood;}
	const COLORREF& GetColorBad() const{return m_colorBad;}
	const COLORREF& GetColorPrintGood() const{return m_colorPrintGood;}
	const COLORREF& GetColorPrintBad() const{return m_colorPrintBad;}
	const COLORREF& GetColorPrintSame() const{return m_colorPrintSame;}
	const COLORREF& GetColorPrintOddGood() const{return m_colorPrintOddGood;}
	const COLORREF& GetColorPrintOddBad() const{return m_colorPrintOddBad;}
	const COLORREF& GetColorPrintOddSame() const{return m_colorPrintOddSame;}
	virtual COLORREF GetColorVeryGood() const override{return m_colorVeryGood;}
	virtual COLORREF GetColorVeryBad() const override{return m_colorVeryBad;}
	virtual bool hasInventoryView() const override{return true;}
protected:
	PositionManagerWindow(const CBitmap* bitmap, unsigned int workspace, bool pinned = false);

	afx_msg void OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu);
	afx_msg void OnExitMenuLoop(BOOL bIsTrackPopupMenu);
	DECLARE_MESSAGE_MAP()

	virtual void OnSuccessfulCreate() override;
	virtual void AddRowsOnResize(unsigned int additionalRows) override;
	virtual void BeforeDestroy() override;
	virtual void AccountChanged() override;
	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;
	virtual void AddRowPropertiesMenuItems(CMenu& popupMenu) override;
	virtual void AddMenuItems(CMenu& menu) override;
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;
	FnPaintInfo m_paintInfoFunction[PM_COLUMN_COUNT];

	virtual void InvalidateShowMilliseconds() const override;
	virtual void InvalidateCommaPriceColums() const override;
	virtual void InvalidateCommaSizeColums() const override;

	virtual void UpdateInventoryView();
//	COLORREF m_colorOrderError;
//	COLORREF m_colorInfo;
//	COLORREF m_colorCommandError;
	COLORREF m_colorInfo[PMT_COUNT];
	COLORREF m_colorGood;
	COLORREF m_colorBad;
	COLORREF m_colorVeryGood;
	COLORREF m_colorVeryBad;
	COLORREF m_colorPrintGood;
	COLORREF m_colorPrintBad;
	COLORREF m_colorPrintSame;
	COLORREF m_colorPrintOddGood;
	COLORREF m_colorPrintOddBad;
	COLORREF m_colorPrintOddSame;

	HMENU m_menuExclude;

	unsigned char m_reportMovesLevel;//0 - none, 1 - moves, 2 - joins, 3 - all
	bool m_showFocusTaken;

	bool m_sizeInShares;
};

class TGUI_API PositionManagerRow : public Row
{
public:
	virtual ~PositionManagerRow();
	virtual const void* GetBaseObject() const override{return NULL;}
	virtual bool PaintCell(CDC& dc, const Column* column, const CRect& rect, UINT verticalJustification, int horizontalOffset) const override;//, unsigned char horizontalAlignment) const;
	virtual bool GetPaintTextInfo(unsigned short columnId, std::string& text, COLORREF& color) const override;//, UINT& horizontalJustification) const override;

//	virtual RowValue* CreateCell(unsigned short id) override;

	virtual bool isTickRow() const{return false;}
	virtual unsigned char GetType() const{return PMT_ADMIN;}
	virtual unsigned char GetInventoryType() const{return PMT_ADMIN;}
	const std::string& GetMessage() const{return m_message;}
	virtual const std::string& GetInventoryMessage() const{return m_message;}
	virtual unsigned char GetGoodBad() const{return 0;}
	virtual unsigned char GetInventoryGoodBad() const{return 0;}

	const Price& GetPosPrice() const{return m_posPrice;}
	const int& GetPosSize() const{return m_posSize;}
	virtual const Price& GetInventoryPosPrice() const{return Price::priceZero;}
	virtual int GetInventoryPosSize() const{return 0;}

	virtual unsigned char GetGoodBadInv(const bool& inventoryView) const{return inventoryView ? GetInventoryGoodBad() : GetGoodBad();}
	const std::string& GetMessageInv(const bool& inventoryView) const{return inventoryView ? GetInventoryMessage() : m_message;}
	unsigned char GetTypeInv(const bool& inventoryView) const{return inventoryView ? GetType() : GetInventoryType();}
	const Price& GetPosPriceInv(const bool& inventoryView) const{return inventoryView ? GetInventoryPosPrice() : m_posPrice;}
	int GetPosSizeInv(const bool& inventoryView) const{return inventoryView ? GetInventoryPosSize() : m_posSize;}

//	virtual bool isInventoryView() const{return false;}
//	virtual bool SetInventoryView(const bool& inventoryView){return false;}

//	virtual
	void PaintInfoMessage(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	void PaintTime(std::string& text, COLORREF& color) const;//PM_TIME
	void PaintSymbol(std::string& text, COLORREF& color) const;//PM_SYMBOL
	void PaintPrintPrice(std::string& text, COLORREF& color) const;//PM_PRINT_PRICE
	void PaintPrintSize(std::string& text, COLORREF& color) const;//PM_PRINT_SIZE
	void PaintPositionPrice(std::string& text, COLORREF& color) const;//PM_POS_PRICE
	void PaintPositionSize(std::string& text, COLORREF& color) const;//PM_POS_SIZE
	void PaintExecutionPrice(std::string& text, COLORREF& color) const;//PM_LAST_EXEC_PRICE
	void PaintExecutionSize(std::string& text, COLORREF& color) const;//PM_LAST_EXEC_SIZE
	void PaintExecutionMmid(std::string& text, COLORREF& color) const;//PM_LAST_EXEC_MMID

protected:
	PositionManagerRow(PositionManagerWindow* parent,
		unsigned int millisecond,
		const char* symbol,
		const Price& bid,
		const Price& ask,
		unsigned int bidSize,
		unsigned int askSize,
		unsigned int printPrice,
		unsigned int printSize,
		unsigned int posPrice,
		int posSize,
		unsigned int lastExecPrice,
		int lastExecSize,
		unsigned int lastExecMmid,
		unsigned short roundLot,
		const std::string& message);

	PositionManagerWindow* m_positionManagerWindow;

	Price m_bid;
	Price m_ask;
	Price m_printPrice;
	Price m_posPrice;
	Price m_execPrice;
	unsigned int m_bidSize;
	unsigned int m_askSize;
	unsigned int m_printSize;
	int m_posSize;
	int m_execSize;
	unsigned int m_lastExecMmid;
	unsigned int m_millisecond;
	unsigned short m_roundLot;
	char* m_symbol;
	std::string m_message;
private:
	PositionManagerRow(const PositionManagerRow& other);
	PositionManagerRow& operator=(const PositionManagerRow& other);
};

class TGUI_API PositionManagerInventoryMessageRow : public PositionManagerRow
{
public:
	virtual const std::string& GetInventoryMessage() const override{return m_inventoryMessage;}
	virtual const Price& GetInventoryPosPrice() const override{return m_inventoryPosPrice;}
	virtual int GetInventoryPosSize() const override{return m_inventoryPosSize;}
//	virtual bool isInventoryView() const override{return m_inventoryView;}
//	virtual bool SetInventoryView(const bool& inventoryView) override;
	virtual const unsigned __int64& GetRowNumericSymbol() const{return m_numericSymbol;}
	virtual const char* GetRowSecuritySymbol(const CPoint* point = NULL) const override{return (const char*)&m_numericSymbol;}
protected:
	PositionManagerInventoryMessageRow(PositionManagerWindow* parent,
		unsigned int millisecond,
		const unsigned __int64& numericSymbol,
		const char* symbol,
		const Price& bid,
		const Price& ask,
		unsigned int bidSize,
		unsigned int askSize,
		unsigned int printPrice,
		unsigned int printSize,
		unsigned int posPrice,
		int posSize,
		unsigned int inventoryPosPrice,
		int inventoryPosSize,
		unsigned int lastExecPrice,
		int lastExecSize,
		unsigned int lastExecMmid,
		unsigned short roundLot,
		const std::string& message,
		const std::string* inventoryMessage = NULL);
	unsigned __int64 m_numericSymbol;
	Price m_inventoryPosPrice;
	int m_inventoryPosSize;
	std::string m_inventoryMessage;
//	bool m_inventoryView;
};

class TGUI_API PositionManagerMessageRow : public PositionManagerInventoryMessageRow
{
public:
	PositionManagerMessageRow(PositionManagerWindow* parent,
		unsigned int millisecond,
		const unsigned __int64& numericSymbol,
		const char* symbol,
		const Price& bid,
		const Price& ask,
		unsigned int bidSize,
		unsigned int askSize,
		unsigned int printPrice,
		unsigned int printSize,
		unsigned int posPrice,
		int posSize,
		unsigned int inventoryPosPrice,
		int inventoryPosSize,
		unsigned int lastExecPrice,
		int lastExecSize,
		unsigned int lastExecMmid,
		unsigned short roundLot,
		const std::string& message,
		PosManMessageType type,
		const std::string* inventoryMessage = NULL,
		PosManMessageType inventoryType = PMT_COUNT);
	DECLARE_NED_NEW
	virtual COLORREF GetRowColor() const override;
	virtual unsigned char GetType() const override{return m_type;}
	virtual unsigned char GetInventoryType() const override{return m_inventoryType;}
protected:
	PosManMessageType m_type;
	PosManMessageType m_inventoryType;
};

class TGUI_API PositionManagerTickRow : public PositionManagerInventoryMessageRow
{
public:
	PositionManagerTickRow(PositionManagerWindow* parent,
		unsigned int millisecond,
		const unsigned __int64& numericSymbol,
		const char* symbol,
		const Price& bid,
		const Price& ask,
		unsigned int bidSize,
		unsigned int askSize,
		unsigned int printPrice,
		unsigned int printSize,
		unsigned int posPrice,
		int posSize,
		unsigned int inventoryPosPrice,
		int inventoryPosSize,
		unsigned int lastExecPrice,
		int lastExecSize,
		unsigned int lastExecMmid,
		unsigned short roundLot,
		unsigned char goodbad,
		unsigned char inventoryGoodbad,
		const std::string& message);
//		const std::string* inventoryMessage = NULL);
	DECLARE_NED_NEW
	virtual COLORREF GetRowColor() const override;
	virtual COLORREF GetCellColor(unsigned short columnId) const override;
	virtual bool isTickRow() const override{return true;}
//	virtual const char* GetRowSecuritySymbol(const CPoint* point = NULL) const override;
	virtual unsigned char GetGoodBad() const override{return m_goodbad;}
	virtual unsigned char GetInventoryGoodBad() const override{return m_inventoryGoodbad;}
//	virtual bool SetInventoryView(const bool& inventoryView) override;
protected:
/*
	unsigned int m_bidSize;
	unsigned int m_askSize;
*/
/*
	const Price& m_print;
	unsigned int m_printSize;
	const Price& m_avgPrice;
	unsigned int m_posSize;
	const Price& m_myLastPrice;
	unsigned int m_myLastSize;
*/
	unsigned char m_goodbad;
	unsigned char m_inventoryGoodbad;
};

class PrintBaseRow;

class TGUI_API PrintWnd : public RowWindowScrollable, public Observer
{
public:
	virtual ~PrintWnd();
	virtual const char* GetToolId() const override{return toolPrintId;}
//	virtual Security* GetSecurity(){return m_security;}
	virtual const Security* GetSecurity() const override{return m_security;}
//	virtual void ConnectionDisconnected(unsigned int ipAddress, unsigned short port, unsigned int ipBindAddress, unsigned short bindPort);
	virtual void SetEquitySymbol(const char* symbol, unsigned char basket, bool force, bool addToStockChain) override;
	virtual bool HasMillisecondColumns() const override{return true;}
	virtual bool HasMoneyColumns() const override{return false;}
	virtual bool isPlusMinusable() const override{return false;}
//	virtual bool HasDoubleClickAction() const override{return true;}

	enum ColumnId : unsigned short
	{
		P_SYMBOL,
		P_TIME,
//		P_INSIDE_MARKET,
//		P_INSIDE_SIZE,
		P_PRICE,
		P_SIZE,
		P_SALE_CONDITION_1,
		P_SALE_CONDITION_2,
		P_SALE_CONDITION_3,
		P_SALE_CONDITION_4,
		P_EXCHANGE,
		P_BID,
		P_ASK,
		P_HIDDEN,
		P_SIDE,
		P_SOURCE,
/*
		P_BIDSIZE,
		P_ASKSIZE,
*/
		P_COLUMN_COUNT
	};
	virtual unsigned short GetBuiltInColumnCount() const override{return P_COLUMN_COUNT;}
	virtual void toString(std::string& str, unsigned int contentModifier) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual void fromScratch() override;
	virtual void AddToSpecificToolCollection() override;

	virtual void UpdateDataGraphics(const Graphics* graphics) override;
	virtual bool UpdateDataGraphicsColorsCustom(const GraphicsColorCollection* colorCollection) override;
	virtual bool UpdateDataGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL) override;

	virtual bool CanLink() const override{return !m_allPrePostMarket;}

	virtual Row* CreateRow(const void* object, bool potential) override;
/*
	typedef void (PrintBaseRow::*FnPaintInfo)(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	bool AddPrintFunctions(unsigned short id, FnPaintInfo fnPaint);
	inline const FnPaintInfo& GetFnPaintInfo(unsigned short id) const{return m_paintInfoFunction[id];}
*/
//	void Populate();

	virtual COLORREF GetColorVeryGood() const override{return m_colorVeryGood;}
	virtual COLORREF GetColorVeryBad() const override{return m_colorVeryBad;}
	virtual COLORREF GetColorVeryGoodBk() const override{return m_colorVeryGoodBk;}
	virtual COLORREF GetColorVeryBadBk() const override{return m_colorVeryBadBk;}

	COLORREF GetColorHighlightSize() const{return m_colorHighlightSize;}

	unsigned int GetFractionDivider() const{return m_fractionDivider;}
	unsigned int GetFractionDollar() const{return m_fractionDollar;}

	void SetShowSizeInShares(bool sizeInShares);
	virtual const bool* isShowSizeInShares() const override{return &m_sizeInShares;}

	void SetAllPrePostMarket(bool allPrePostMarket);
	const bool& isAllPrePostMarket() const{return m_allPrePostMarket;}

	void SetEcnExecutionFilter(unsigned int filter);
	void ToggleEcnExecutionFilter(unsigned int filter);
	void SetPrintFilter(unsigned int filter);
	void TogglePrintFilter(unsigned int filter);
	void UpdatePrints();
	void SetPrintShowOddLot(bool printShowOddLot);
	void SetEcnExecShowOddLot(bool ecnExecShowOddLot);
	virtual COLORREF GetBasketColor(const unsigned __int64& symbol) const{return 0xFFFFFFFF;}
	Row* AddPrint(unsigned int millisecond,
//		const char* symbol,
		const unsigned __int64& symbol,
		COLORREF basketColor,
		const Price& bid,
		const Price& ask,
		const Price& printPrice,
		unsigned int printSize,
		unsigned char level1,
		char saleCondition1,
		char saleCondition2,
		char saleCondition3,
		char saleCondition4,
		unsigned char source,
//		bool hidden,
		unsigned int mmid,
		unsigned int roundLot,
		char hidden,
		char side,
		bool prepend,
		bool repaint);

	virtual void AcceptText(const char* text, unsigned int code) override;
	virtual void AppendWindowMenuInfo(std::string& menuText) const override
	{
		RowWindowScrollable::AppendWindowMenuInfo(menuText);
		if(m_allPrePostMarket)
		{
			menuText += " - All Pre/Post";
		}
		else if(m_symbol)//!m_symbol.empty())
		{
			menuText += " - ";
#ifndef TAKION_NO_OPTIONS
			if(m_optionBlock)menuText += m_instrumentSymbol;
			else 
#endif
			menuText += (const char*)&m_symbol;
		}
	}
	virtual void MarketSorterCleanup();
	bool SecurityBelongs(const Security* security) const;
	virtual bool CanClearSymbols() const;
	virtual void ClearSymbols();
	virtual void AddSymbol(const char* symbol);

	virtual void IncludeSecurity(const Security* security) override;
	virtual void ExcludeSecurity(const Security* security) override;
	virtual void UnIncludeSecurity(const Security* security) override;
	virtual void UnExcludeSecurity(const Security* security) override;

//	virtual void AddSecurityToBasket(const Security* security) override;
//	virtual void RemoveSecurityFromBasket(const Security* security) override;

//	virtual bool CanFilterBySymbol() const{return false;}
	unsigned int GetNextMenuId() const;

	const unsigned __int64& GetNumericSymbol() const{return m_symbol;}
	const char* GetSymbol() const{return (const char*)&m_symbol;}
#ifndef TAKION_NO_OPTIONS
	const std::string& GetInstrumentSymbol() const{return m_instrumentSymbol;}
	const unsigned __int64& GetOptionKey() const{return m_optionKey;}
	const unsigned __int64& GetOptionBlock() const{return m_optionBlock;}
	const unsigned __int64& GetRootSymbol() const{return m_rootSymbol;}
#endif

	void SetFilterAndHighlightSize(bool useFilterSize, unsigned int filterSize, bool useHighlightSize, unsigned int highlightSize);
	bool isUseFilterSize() const{return m_useFilterSize;}
	bool isUseHighlightSize() const{return m_useHighlightSize;}
	unsigned int GetFilterSize() const{return m_filterSize;}
	unsigned int GetHighlightSize() const{return m_highlightSize;}

	const Security* ObtainSecurity(const unsigned __int64& symbol) const;
		
	const std::string& GetBasketName() const{return m_basketName;}
	const bool& isBasketHiliteUseBackground() const{return m_basketHiliteUseBackground;}
	void SetBasketHiliteUseBackground(const bool useBackground);
	virtual void AppendUnnamedBasketPopulation(std::string& str) const{}

	virtual SymbolFilter* GetFilterCopy() const override;
	virtual unsigned char GetNativeFilterType() const override{return m_filter.isA();}
	virtual const TakionFilter* GetFilter() const override{return &m_filter;}
protected:
	PrintWnd(const CBitmap* bitmap, unsigned int workspace, bool pinned = false);
	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;

	virtual void BasketHiliteUseBackgroundChanged(){}

//	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
//	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
//	DECLARE_MESSAGE_MAP()
	virtual void DoUpdateTitle() override;

	bool AddHistoricalPrints(unsigned int from, unsigned int to);
	void StartTypingSymbol(unsigned char key);
	virtual bool ProcessKeyDown(unsigned char key, unsigned char modifier, bool repeat, TakionFrame* fromWindow) override;
	bool DoSetSymbol(const char* symbol);
	virtual void SymbolAccepted(const char* text, bool changed);// sameSymbol);
	virtual void UpdateAllPrePostMarket(){}
	void NullifyStock();

	virtual void AddRowsOnResize(unsigned int additionalRows) override;
	virtual void BeforeDestroy() override;
//	virtual void AccountChanged();
	virtual void AddMenuItems(CMenu& menu) override;
	virtual void AddRowPropertiesMenuItems(CMenu& popupMenu) override;
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;
//	FnPaintInfo m_paintInfoFunction[P_COLUMN_COUNT];

	virtual void InvalidateShowMilliseconds() const override;
	COLORREF m_colorVeryGood;
	COLORREF m_colorVeryBad;
	COLORREF m_colorVeryGoodBk;
	COLORREF m_colorVeryBadBk;

	COLORREF m_colorHighlightSize;

	unsigned int m_fractionDivider;
	unsigned int m_fractionDollar;
	unsigned int m_ecnExecutionFilter;
	unsigned int m_printFilter;
	bool m_printShowOddLot;
	bool m_ecnExecShowOddLot;

	void UpdatePrintIterator();
	void UpdateEcnBookIterator();

	bool m_sizeInShares;
	bool m_allPrePostMarket;

//	std::string m_symbol;
	unsigned __int64 m_symbol;
#ifndef TAKION_NO_OPTIONS
	std::string m_instrumentSymbol;
	unsigned __int64 m_optionKey;
	unsigned __int64 m_optionBlock;
	unsigned __int64 m_rootSymbol;
#endif

	void DoSetSecurity(const Security* security);
	const Security* m_security;
	TakionIterator* m_printIterator;

	virtual void PasteStocksFromString(const char* cursor, size_t size, bool replace);
//	virtual void ApplyFilter(const TakionFilter& filter);

	StockFilter m_filter;
	virtual void DoApplyFilter(const TakionFilter& filter, bool forceFilterChanged) override;

	bool SetFilterSize(const bool useFilterSize, const unsigned int filterSize);
	virtual void OnFilterSizeChange(){}

	bool m_useFilterSize;
	bool m_useHighlightSize;
	unsigned int m_filterSize;
	unsigned int m_highlightSize;

	std::string m_basketName;
//	std::string m_basketFilter;
	bool m_basket;
	bool m_basketHiliteUseBackground;
};

class TGUI_API PrintBaseRow : public Row
{
public:
	virtual const void* GetBaseObject() const{return NULL;}

	virtual RowValue* CreateCell(unsigned short id);

	virtual const unsigned __int64& GetRowNumericSymbol() const;
	virtual const char* GetRowSecuritySymbol(const CPoint* point = NULL) const override;
	const unsigned __int64& GetNumericSymbol() const{return m_numericSymbol;}
protected:
//	PrintBaseRow(PrintWnd* parent, const char* symbol, unsigned int millisecond);//, const char* symbol, const Price& bid, const Price& ask, const std::string& message);
	PrintBaseRow(PrintWnd* parent, const unsigned __int64& symbol, unsigned int millisecond);
	unsigned __int64 m_numericSymbol;
	PrintWnd* m_printWindow;
	unsigned int m_millisecond;
};

class TGUI_API PrintRow : public PrintBaseRow
{
public:
	PrintRow(PrintWnd* parent,
//		const char* symbol,
		const unsigned __int64& symbol,
		unsigned int millisecond,
		COLORREF basketColor,
		const Price& bid,
		const Price& ask,
		const Price& printPrice,
		unsigned int printSize,
		unsigned char level1,
		char saleCondition1,
		char saleCondition2,
		char saleCondition3,
		char saleCondition4,
		unsigned char source,
		unsigned int mmid,
		unsigned int roundLot,
		char hidden,
		char side);

	virtual RowValue* CreateCell(unsigned short id) override;

	virtual COLORREF GetRowColor() const override;
	virtual COLORREF GetRowBkColor() const override;
	virtual COLORREF GetCellBkColor(unsigned short columnId) const override;
	virtual COLORREF GetCellColor(unsigned short columnId) const override;
	const unsigned char& GetLevel1() const{return m_level1;}
	const unsigned int& GetPrintSize() const{return m_printSize;}
	bool SetBasketColor(const COLORREF& color)
	{
		if(color != m_basketColor)
		{
			m_basketColor = color;
			return true;
		}
		return false;
	}
protected:
	COLORREF m_basketColor;
	unsigned int m_printSize;
	unsigned char m_level1;
};

class TGUI_API DialogPrintFilterSize : public DialogFilterHighlightSize
{
public:
	DialogPrintFilterSize(TakionMainWnd* mainWnd, bool toDestroyOnFocus, PrintWnd* receipient = NULL);
	void Display(PrintWnd* receipient, const CPoint& mousePoint);
protected:
	virtual void DoApply();
	PrintWnd* m_printWnd;
};


class RowOrderedSet;
class RowSortable;
class RowTotal;

class TGUI_API RowWindowSortable : public RowWindow
{
friend class RowOrderedSetIterator;
friend class RowSortable;
public:
	virtual ~RowWindowSortable();
	typedef CMap<const void*, const void*, RowSortable*, RowSortable*> RowMap;
	typedef std::set<RowSortable*> RowSortableSet;
	typedef std::list<RowSortable*> RowSortableList;

//	virtual unsigned int GetGraphicsColorCollectionCount() const{return RowWindow::GetGraphicsColorCollectionCount() + 1;}
	virtual const Graphics* GetGraphicsAt(unsigned int graphicsOrdinal) const override;

	virtual bool GetCurrentFontParams(std::string& title, FontDescription& fontDescription, FontDescription& fontDescriptionCustom, bool& custom, unsigned int& id) const;
	virtual RowSortable* AddRow(RowSortable* row, bool newRow, bool repaint);
	virtual RowSortable* RemoveRow(RowSortable* row);
	virtual Row* NewRow(const void* object);//returns non-NULL if the row already exists
//	virtual void AddObject(const void* object);
#ifdef SECONDARY_ROWS
	virtual bool CollapseRow(Row* row);
	virtual Row* NewSecondaryRow(const void* object, RowSortable* parentRow);//returns non-NULL if the row already exists
	virtual RowSortable* CreateSecondaryRow(const void* object, bool potential, RowSortable* parentRow){return NULL;}
	virtual bool SecondaryObjectPotentiallyBelongs(const void* object) const{return true;}//no need to call inside lock
	virtual bool SecondaryRowFiltersIn(const RowSortable* row) const;//should be called inside lock
	virtual unsigned char SecondaryRowBelongs(const RowSortable* row) const;//2 - belongs; 1 - does not belong but can update to become belonging; 0 - does not belong and cannot update to become belonging
	virtual unsigned char SecondaryExistingRowBelongs(const RowSortable* row) const;//2 - belongs; 1 - does not belong but can update to become belonging; 0 - does not belong and cannot update to become belonging
	void UpdateSecondaryPopulation(bool sortingChanged);
	virtual void DestroySecondaryRows();
	virtual bool RemoveNotBelongingSecondaryRows(bool removePotential);
	virtual void PopulateSecondaryRows(bool remove);
	virtual void InvalidatePrimaryOrSecondaryRows(size_t endRow, bool secondary, unsigned short columnId = 0xFFFF) const override;
#endif
	virtual bool SetColumnIndentation(int indentation);
	virtual int ResizeColumn(int x);
	virtual bool UpdateColumnRect(const int clientLeft, const int clientRight) override;

	virtual RowSortable* RemoveObject(const void* object);
	virtual bool isSortable() const override{return true;}
	virtual bool isMultiSelect() const override{return m_multiselect;}
	const Row* GetFirstVisibleSelectedRow(CRect* rect) const;
	virtual bool SetMultiSelect(bool multiselect);//{m_multiselect = multiselect;}
	virtual void toString(std::string& str, unsigned int contentModifier) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual void fromScratch() override;

	virtual void AppendWindowMenuInfo(std::string& menuText) const override;

	virtual bool CanShowTotalCount() const override{return true;}

	virtual void InvalidateTotalRowRect() const override{if(m_hWnd)::InvalidateRect(m_hWnd, &m_totalRowRect, FALSE);}
	virtual void InvalidateTotalRowSubRect(const int left, const int right) const override{if(m_hWnd)::InvalidateRect(m_hWnd, &CRect(left, m_totalRowRect.top, right, m_totalRowRect.bottom), FALSE);}

	virtual void UpdateDataGraphics(const Graphics* graphics) override;
	virtual bool isTickable() const{return false;}

	virtual const void* GetGraphicsTabInitInfo(const CPoint& point) const override;
	virtual void UpdateGraphics() override;

	virtual void ApplyUIntValue(unsigned int code, RowSortableSet& rowSet, unsigned short numberColumnId, unsigned int value){}
	virtual void ApplyIntValue(unsigned int code, RowSortableSet& rowSet, unsigned short numberColumnId, int value){}
	virtual void ApplyPriceValue(unsigned int code, RowSortableSet& rowSet, unsigned short numberColumnId, const Price& value){}
	virtual void ApplyStringValue(unsigned int code, RowSortableSet& rowSet, unsigned short stringColumnId, const char* value){}
//	virtual void ApplyDateValue(unsigned int code, RowSortableSet& rowSet, unsigned short numberColumnId, const unsigned int& date){}

/*
#ifndef TAKION_NO_OPTIONS
	virtual void ApplyStrikePrice(unsigned int code, unsigned int selectedStrikePrice, unsigned int initialStrikePrice, unsigned int expirationDate, const unsigned __int64& rootSymbol){}
	virtual void ApplyExpirationDate(unsigned int code, unsigned int selectedExpirationDate, unsigned int initialExpirationDate, unsigned int strikePrice, const unsigned __int64& rootSymbol){}
#endif
*/
	virtual bool CanDragClient(UINT nFlags, CPoint point) const;

	virtual void CopySelectedStocksToClipboard() const;
	virtual void CopyAllStocksToClipboard() const;
//	unsigned short GetSortColumn() const{return m_sortColumn;}
//	bool SetSortColumn(unsigned short id);
	bool UpdateRow(RowSortable* row, bool lockRow, bool dynamicOnly);
	bool UpdateObject(void* object, bool lockObject, bool dynamicOnly);
	void UpdateAllRows(bool lockObject, bool dynamicOnly);
	RowSortable* FindObject(const void* object)
	{
		RowMap::CPair* found = m_rowMap.PLookup(object);
		return found ? found->value : NULL;
	}
	const RowSortable* FindObject(const void* object) const
	{
		const RowMap::CPair* found = m_rowMap.PLookup(object);
		return found ? found->value : NULL;
	}
	virtual void DestroyRows() override;
//	virtual void UpdateColumnUse(const UseChangeMap& useChangeMap, bool global);
	virtual bool DoUpdateColumnUse(const UseChangeSet& use, const UseChangeSet& unuse
#ifdef SECONDARY_ROWS
		, bool secondary
#endif
		) override;
//	virtual bool DoUpdateSecondaryColumnUse(const UseChangeSet& use, const UseChangeSet& unuse) override;
	virtual void SortData(bool scrollToTop = true) override;
	virtual size_t GetRowCount() const override;//{return m_rowSet.size();}
	virtual size_t GetRowLastVisibleOrd() const override;//returns row count if all visible
	virtual Row* GetRowAt(size_t ord) const override;//{return *m_rowSet.GetObjectAt(ord);}//m_rowVector[ord];}
	virtual size_t FindRow(const Row* row) const override;
	virtual size_t GetPotentialRowCount() const override{return m_rowMap.GetCount();}
	virtual size_t GetSelectedOrAllRowCount() const override{return m_selectedSet.size();}
	virtual size_t GetSelectedRowCount() const override{return m_selectedSet.size();}
	virtual Row* GetSingleSelectedRow() const override;//{return m_selectedSet.empty() ? NULL : *m_selectedSet.begin();}

	virtual void CopySelectedStocksToStr(std::string& info) const;

	const RowOrderedSet* GetRowSet() const{return m_rowSet;}

	bool HasSelectedRows() const;

	size_t GetRowOrdinal(RowSortable* row) const;
	bool GetRowRectPtr(RowSortable* row, CRect& rect) const;

	void InvalidateRowCellIfVisible(RowSortable* row, unsigned short columnId) const;
	void InvalidateConstRowCellIfVisible(const RowSortable* row, unsigned short columnId) const;
	void InvalidateRowPtr(RowSortable* row) const;

	void SortInfoToString(std::string& info) const;

	const COLORREF& GetPositiveTickColor() const{return m_positiveTickColor;}
	const COLORREF& GetNegativeTickColor() const{return m_negativeTickColor;}
	const COLORREF& GetWarningColor() const{return m_warningColor;}
	const COLORREF& GetTopActiveColor() const{return m_topActiveColor;}

	bool isShowTicks() const{return m_showTicks;}
	void SetShowTicks(bool showTicks);

	unsigned int GetTickFlashMillisecond() const{return m_tickFlashMillisecond;}
	void SetTickFlashMillisecond(unsigned int millisecond);
	void ToggleTickFlashMillisecond(unsigned int millisecond);

	virtual void PaintTick(CDC& dc, const Column* column, const RowValue* rowValue, const CRect& rect) const;
	
	bool isTopActive() const{return m_topActive;}
	virtual void SetTopActive(bool topActive);//{m_topActive = topActive;}

	virtual void InvalidateDataAndExpandRect();

	virtual TakionIterator* CreateRowIterator() const;
	virtual Row* GetNextRow(TakionIterator* it) const;

	virtual TakionIterator* CreateSelectedRowIterator() const;
	virtual Row* GetNextSelectedRow(TakionIterator* it) const;

	virtual TakionIterator* CreateDefaultRowIterator() const{return m_multiselect ? CreateSelectedRowIterator() : CreateRowIterator();}
	virtual Row* GetDefaultNextRow(TakionIterator* it) const{return m_multiselect ? GetNextSelectedRow(it) : GetNextRow(it);}

	RowSortableSet::const_iterator GetSelectedSetEnd() const{return m_selectedSetEnd;}
	const RowSortableSet& GetSelectedSet() const{return m_selectedSet;}
	RowSortableSet& GetSelectedSet(){return m_selectedSet;}
	const RowSortable* GetLastRowSelected() const{return m_lastRowSelected;}
	RowSortable* GetLastRowSelected(){return m_lastRowSelected;}
	size_t GetLastOrdinalSelected() const{return m_lastOrdinalSelected;}
	size_t GetScrollingSelectionStartOrd() const{return m_scrollingSelectionStartOrd;}
	size_t GetScrollingSelectionLastOrd() const{return m_scrollingSelectionLastOrd;}
	virtual bool AreAllRowsSelected() const override;
	virtual void SelectAllRows(bool forceMultisel) override;
	virtual bool UnselectAllRows(bool repaint) override;

	const RowMap& GetRowMap() const{return m_rowMap;}
	RowMap& GetRowMap(){return m_rowMap;}

	virtual bool ObjectPotentiallyBelongs(const void* object) const{return true;}//no need to call inside lock
	virtual bool RowFiltersIn(const RowSortable* row) const{return true;}//should be called inside lock

	virtual unsigned char RowBelongs(const RowSortable* row) const{return 2;}//2 - belongs; 1 - does not belong but can update to become belonging; 0 - does not belong and cannot update to become belonging
	virtual unsigned char ExistingRowBelongs(const RowSortable* row) const{return RowBelongs(row);}//2 - belongs; 1 - does not belong but can update to become belonging; 0 - does not belong and cannot update to become belonging
//	virtual void UpdatePopulation(bool sortingChanged);
	bool UpdatePopulation(bool sortingChanged);
	virtual bool RemoveNotBelongingRows(bool removePotential);
	virtual void RepaintOnPopulation(bool resetToTop) override;

	virtual void UpdateTitleGraphics(const Graphics* graphics) override;

	const unsigned __int64& GetActiveSymbol() const{return m_activeSymbol;}
	void SetActiveSymbol(const unsigned __int64& symbol
#ifndef TAKION_NO_OPTIONS
		, const unsigned __int64& optionBlock
#endif
		);

#ifndef TAKION_NO_OPTIONS
	const unsigned __int64& GetActiveOptionBlock() const{return m_activeOptionBlock;}
#endif
	RowSortable* SelectRowByObject(const void* object);
	void SelectRow(RowSortable* row);
	virtual void ExecuteDebuggingCommand();//For debuggingOnly
	virtual bool CanHaveTotal() const{return true;}
	virtual void SetCustomFont(const FontDescription& fontDescription, bool custom, unsigned int id) override;
	virtual void SetCustomColors(const Graphics* graphics, GraphicsColorCollection* colorCollection, const COLORREF* colors, unsigned short colorCount, bool custom, const FilterStringAsNumberArray& title) override;//, const FilterStringAsNumberArray& title, unsigned int colorId) override;

	void UpdateTotalGraphics(const Graphics* graphics);
	bool UpdateTotalGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL);
	bool UpdateTotalGraphicsColorsCustom(const GraphicsColorCollection* colorCollection);
	virtual void UpdateColorsCustom(const GraphicsColorCollection* colorCollection) override;

	virtual bool UpdateDataGraphicsColorsCustom(const GraphicsColorCollection* colorCollection) override;
	virtual bool UpdateDataGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL) override;

	int CalculateExtraTotalRowHeight(unsigned char spacing, int height) const;
	int CalculateExtraTotalRowWidth(unsigned char spacing, int height) const;
	int GetTotalRowHoizontalOffset() const{return m_totalRowOffsetX;}
	const COLORREF& GetTotalBkColor() const{return m_totalBkColor;}
	const COLORREF& GetTotalNeutralColor() const{return m_totalNeutralColor;}
	const COLORREF& GetTotalPositiveColor() const{return m_totalPositiveColor;}
	const COLORREF& GetTotalNegativeColor() const{return m_totalNegativeColor;}
	const CRect& GetTotalRowRect() const{return m_totalRowRect;}
	virtual const CRect* GetTotalRowRectPtr() const override{return &m_totalRowRect;}
	const CRect& GetTotalRowIndentationRect() const{return m_totalRowIndentationRect;}
	const CRect& GetTotalRowFillRect() const{return m_totalRowFillRect;}

	void AdjustRowInTotal(const Row* row, bool dynamicOnly);
	void AdjustRowValueInTotal(const Row* row, unsigned short id);
	void UpdateNonCumulativeValuesInTotal(const Row* row);
//	void UpdateInventoryViewNonCumulativeValuesInTotal(const Row* row);

//	virtual void UpdateUseTickRects();
//	virtual void UpdateUseTickRectsHeight();

	COLORREF GetTotalFollowedColor(const Row* row, const Column* column, bool neutral) const;
	unsigned int GetNextPopOrdinal() const{return ++m_nextPopOrdinal;}
	virtual unsigned short GetPopOrdinalColumnId() const{return 0xFFFF;}
	void ResetPopOrdinal();
	RowTotal* GetRowTotal(){return m_rowTotal;}
	const RowTotal* GetRowTotal() const{return m_rowTotal;}

#if (_MSC_VER > 1600)
	typedef std::unordered_set<RowSortable*> RowSortableHashSet;
#else
	typedef std::hash_set<RowSortable*> RowSortableHashSet;
#endif
	void GetVisibleRows(RowSortableHashSet& rowHashSet) const;

//PositionWindow virtuals
	virtual unsigned short GetPositionBuiltInColumnCount() const{return 0;}
	virtual const PositionGroupCollection* GetMergedPositions() const{return NULL;}
	virtual const bool& CanSeeFirmPositions() const{return boolFalse;}
	virtual const COLORREF& GetColorFlat() const{return colorrefZero;}
	virtual const COLORREF& GetColorLong() const{return colorrefZero;}
	virtual const COLORREF& GetColorShort() const{return colorrefZero;}
//OrderWindow virtuals
	virtual unsigned short GetOrderBuiltInColumnCount() const{return 0;}
	virtual const COLORREF& GetBuyColor() const{return colorrefZero;}
	virtual const COLORREF& GetSellColor() const{return colorrefZero;}
	virtual const COLORREF& GetShortColor() const{return colorrefZero;}
	virtual const COLORREF& GetBustedBuyColor() const{return colorrefZero;}
	virtual const COLORREF& GetBustedSellColor() const{return colorrefZero;}

	virtual const COLORREF& GetBuyOpenColor() const{return colorrefZero;}
	virtual const COLORREF& GetBuyClosedColor() const{return colorrefZero;}
	virtual const COLORREF& GetShortOpenColor() const{return colorrefZero;}
	virtual const COLORREF& GetSellClosedColor() const{return colorrefZero;}

	virtual const COLORREF& GetColorPendingBuy() const{return colorrefZero;}
	virtual const COLORREF& GetColorPendingSell() const{return colorrefZero;}
	virtual const COLORREF& GetColorPendingShort() const{return colorrefZero;}
	virtual const COLORREF& GetColorPendingFilledBuy() const{return colorrefZero;}
	virtual const COLORREF& GetColorPendingFilledSell() const{return colorrefZero;}
	virtual const COLORREF& GetColorPendingFilledShort() const{return colorrefZero;}

	virtual const COLORREF& GetColorUnacknowledged() const{return colorrefZero;}
	virtual const COLORREF& GetColorNotSent() const{return colorrefZero;}
	virtual const COLORREF& GetColorFilled() const{return colorrefZero;}
	virtual const COLORREF& GetColorPartialFilled() const{return colorrefZero;}
	virtual const COLORREF& GetColorKicked() const{return colorrefZero;}
	virtual const COLORREF& GetColorBlocked() const{return colorrefZero;}
	virtual const COLORREF& GetColorCanceled() const{return colorrefZero;}
	virtual const COLORREF& GetColorCanceling() const{return colorrefZero;}
	virtual const COLORREF& GetColorReplacing() const{return colorrefZero;}
	virtual const COLORREF& GetColorPostponed() const{return colorrefZero;}
	virtual const COLORREF& GetColorWaiting() const{return colorrefZero;}
	virtual const COLORREF& GetOrderBuyColor() const{return colorrefZero;}
	virtual const COLORREF& GetOrderSellColor() const{return colorrefZero;}
	virtual const COLORREF& GetOrderShortColor() const{return colorrefZero;}
//
	virtual bool isRowActiveSymbol(const RowSortable* row) const{return false;}

	virtual RowSortable* FindRowActiveSymbol(const unsigned __int64& activeSymbol
#ifndef TAKION_NO_OPTIONS
			,const unsigned __int64& activeOptionBlock
#endif
		) const{return NULL;}

	virtual bool isFiltered() const{return false;}
protected:
	RowWindowSortable(bool multiselect,
		const CBitmap* bitmap,
		unsigned int workspace,
		bool pinned = false,
		int minVisibleSize = 15,
		int minWidth = 20,
		int maxWidth = 0,
		int minHeight = 20,
		int maxHeight = 0,
		int minBorderWidth = 2,
		int maxBorderWidth = 2,
		const char* className = "TakionTool",
		int minTitleHeight = 0,
		int maxTitleHeight = 15,
		int titleHeight = 15);
	virtual void TitleFontChanged() override;
	virtual void NextDayStarted() override;
	virtual void ClearConfig() override;
	virtual void ClearRowsTemporarily();
	void ClearRowSetTemporarily(RowSortableSet& whatRowSet, RowSortableHashSet& rowHashSet);
	void ClearAllRowsTemporarily(RowSortableHashSet& rowHashSet);

	virtual void Repopulate(){}

	virtual void ResetMinMaxValues(){}
	virtual bool Populate(bool remove){ return false; }

	Row* AddNewRow(const void* object);
	virtual void AddNewRows(){Repopulate();}

	virtual void BackgroundColorChanged() override;

	virtual void UpdateInventoryView() override;
	void UpdateRowInventoryValues(RowSortable* row);
	void RepaintInventoryValues() const;

	void AddUnsignedIntFilter(unsigned int& filter, const unsigned int addFilter, bool populate = false);
	void RemoveUnsignedIntFilter(unsigned int& filter, const unsigned int removeFilter, bool populate = false);
	bool SetUnsignedIntFilter(unsigned int& filter, unsigned int newFilter, const unsigned int mask, unsigned int& addFilter);

	void RemoveActiveRowsTemporarily(RowSortable*& prevActiveRow, RowSortable*& nextActiveRow, const unsigned __int64& newActiveSymbol
#ifndef TAKION_NO_OPTIONS
		,const unsigned __int64& newActiveOptionBlock
#endif
	);
	bool ReInsertActiveRows(RowSortable*& prevActiveRow, RowSortable*& nextActiveRow);

	size_t DoRemoveRow(RowSortable* row);

	virtual bool RemoveAllObjectsBelongingToAccount(const Account* account);
#ifdef FIRM_VALUES
	virtual bool RemoveAllObjectsBelongingToAccountAggregator(const AccountAggregator* accountAggregator);
#endif
	virtual void DataRightUpdated(
#ifdef SECONDARY_ROWS
		bool secondary
#endif
		) override;
	bool ProcessRowBelonging(RowSortable* row, unsigned char belongs, bool sortingChanged);
	void InitDraggedRow(Row* row, size_t ord, const CPoint& point);
	size_t GetRowDraggedTo(const CPoint& point, CRect& rect) const;
//	size_t GetRowDraggedTo(size_t ord, CRect& rect, const CPoint& point) const;
	size_t GetRowDraggedTo(size_t ord, CRect& rect, int y) const;
	virtual void RowLeftClicked(Row* row, size_t ord, const CPoint& point) override;
	virtual void BeforeRowsScrolled(int lines);
	virtual void RowsScrolled(int lines);
	virtual bool ClientSetCursor() override;
	void SelectRowsTo(size_t ord);
	virtual void OnSuccessfulCreate();
	virtual void OnMouseForcedReleaseCapture() override;
	virtual size_t DoPaintData(CDC& dc, size_t startRow, size_t endRow, const ColumnConstIterator& startColumn, const ColumnConstIterator& endColumn, const int left, const int right, bool paintExpand
#ifdef SECONDARY_ROWS
		, const bool secondary
#endif
		) const override;
	virtual void DrawDataAdditional(const CRect& rcPaint, CDC& dc) override;
	virtual void DoPaintTitle(const RECT& interRect, CDC& dc) override;
	virtual void UpdateTitleRects() override;
	virtual void OnTitleResize() override;
	virtual void SizeHorizontal(int cx, int cy, int oldX, int oldY) override;
	virtual void SizeVertical(int cx, int cy, int oldX, int oldY) override;
	virtual void AddMenuItems(CMenu& menu) override;
	virtual void AddRowPropertiesMenuItems(CMenu& popupMenu) override;
	virtual void PostAddRowPropertiesMenuItems(CMenu& popupMenu) override;
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;
	virtual void BeforeDestroy() override;
	virtual void LineRightSelected() override;
	void SelectSingleRow(RowSortable* rowSortable, size_t ord);
	void AddSelectedRow(RowSortable* rowSortable, size_t ord);
//	virtual void AdjustFirstVisibleRow(int lines);
	virtual void AddInventoryMenuItems(CMenu& popupMenu) override;

	virtual void HideSelectedPositions(bool show);
	virtual void HandleSelectedInventory(const unsigned char action);

	virtual const void* GetInventorySettingsTabInitInfo(const CPoint& point) const;

	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;
//	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
//	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
//	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
//	afx_msg void OnVScroll(UINT nCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	DECLARE_MESSAGE_MAP()

	bool ClearScrollingSelection();

	void EraseRowsTemporarily(const void* object, RowSortableList& topRowList);
	bool EraseRowTemporarily(RowSortable* row, RowSortableHashSet& rowHashSet);
	bool EraseRowTemporarily(RowSortable* row);

	bool ReInsertRow(RowSortable* row, size_t& ord);

	bool DoInsertRow(RowSortable* row);
	virtual void RowInserted(RowSortable* row);
	virtual void RowRemoved(RowSortable* row);

	void ClearLastRowSelected(RowSortable* row);

	virtual unsigned int BeforeRowInsertion(RowSortable* row);
	virtual void RevertRowInsertion(RowSortable* row, unsigned int prevPopOrdinal);
/*
	virtual void AssignDefaultSortColumn(bool setSortChain);
	virtual bool UpdateSortChain(ColumnIterator columnPressed, bool shift, bool ctrl, bool alt);
	virtual bool RemoveColumnFromSortChain(Column* column);
	virtual bool AddColumnToSortChain(Column* column);
	virtual bool ClearColumnsFromSortChain();
*/
	void RepaintRows(const size_t from, const size_t to);

#ifdef SECONDARY_ROWS
	virtual void UpdateSecondaryRowColors() override;

	virtual void ScrollPrimaryAndSecondaryDataHorizontally(size_t endRow, int diff, CRect& rectToScroll, const CRect* rectClip, CRect& secondaryRectToScroll, const CRect* secondaryRectClip) const override;
	virtual void ScrollPrimaryOrSecondaryDataHorizontally(size_t endRow, int diff, CRect& rectToScroll, const CRect* rectClip, CRect* rectToRepaint, const bool secondary) const override;
	virtual void FlashRowTicks(size_t endRow) override;
	virtual void ScrollTotalRowHorizontally(int diff, CRect& rectToScroll, const CRect* rectClip, CRect* rectToRepaint) const override;
	bool EraseChildRowsTemporarily(RowSortable* row, RowSortableHashSet& rowSet);
	bool EraseChildRows(RowSortable* row, bool permanently);
	bool RemoveAndDestroyChildRows(RowSortable* row);
	void DestroyChildRows(RowSortable* row);//already erased from m_rowSet
	void ChildRowsRemoved(RowSortable* row);
	bool AddChildRows(RowSortable* row, bool addToRowMap);
#endif
	size_t EraseRow(RowSortable* row);
	RowMap m_rowMap;
	RowOrderedSet* m_rowSet;
	RowSortableSet m_selectedSet;
	RowSortableSet::const_iterator m_selectedSetEnd;
	RowSortable* m_lastRowSelected;
	COLORREF m_colorRowSelected;
	size_t m_lastOrdinalSelected;
	size_t m_scrollingSelectionStartOrd;
	size_t m_scrollingSelectionLastOrd;
	bool m_multiselect;

	CRect m_potentialCountRect;
	int m_potentialCountWidth;

	COLORREF m_positiveTickColor;
	COLORREF m_negativeTickColor;
	COLORREF m_warningColor;
	COLORREF m_topActiveColor;

	unsigned int m_tickFlashMillisecond;
	bool m_showTicks;
	bool m_topActive;

	unsigned __int64 m_activeSymbol;
#ifndef TAKION_NO_OPTIONS
	unsigned __int64 m_activeOptionBlock;
#endif

//	virtual void ActiveSymbolAboutToChange(const std::string* newActiveSymbol){}
	virtual void ActiveSymbolAboutToChange(const unsigned __int64& newActiveSymbol
#ifndef TAKION_NO_OPTIONS
		,const unsigned __int64& newActiveOptionBlock
#endif
		){}
	virtual bool ActiveSymbolChanged(){return false;}
//	RowIterator m_rowFirstVisible;
//	typename RowOrderedSet::iterator* m_rowEnd;

	virtual void DoPaintClient(const RECT& rcPaint, CDC& dc) override;

	virtual RowTotal* CreateRowTotal();
//	virtual void FillRowTotalWithValues(){}
	void SetShowRowTotal(bool show);
	void DestroyRowTotal();
	virtual void HorizontalScrollVisibilityChanged();
	void UpdateRowTotalRect(int cy, int oldY);//, int prevDataRectBottom);
	RowTotal* m_rowTotal;
	COLORREF m_totalBkColor;
	COLORREF m_totalNeutralColor;
	COLORREF m_totalPositiveColor;
	COLORREF m_totalNegativeColor;
	virtual void UpdateTotalRectOnResizeSecondaryColumn() override;
	CRect m_totalRowRect;
	CRect m_totalRowIndentationRect;
	CRect m_totalRowFillRect;
	void SetFontTotalRow(const FontDescription& fontDescription);
	void UpdateTotalRowRect();
	void UpdateTotalRowMetrics();

	bool PaintTotalCell(const Row* row, CDC& dc, const Column* column, const CRect& rect, UINT verticalJustification) const;//, unsigned char horizontalAlignment) const;

	unsigned int m_totalRowTextHeight;
//	unsigned int m_rowHeight;
	int m_totalRowOffsetX;
	int m_totalRowOffsetY;
	unsigned char m_totalRowHorizontalSpacing;
	unsigned char m_totalRowVerticalSpacing;
	FontDescription m_fontDescriptionTotalRow;
	FontDescription m_fontDescriptionTotalRowCustom;
	CFont* m_fontTotalRow;
	bool m_fontTotalRowCustom;

	int m_rowDragOffset;
	int m_rowDragInitY;
	int m_rowInsertionWidth;

	size_t SetVerticalTimer(const CPoint& point);
	void DrawInsertionLine();
	void DoDrawInsertionLine(CDC& dc);
//	virtual bool UpdateDataRight(bool redrawFocus = true);
	bool CanScrollRowBottom() const;
	void SetRowDragTimer(DragTimerDirection direction);
	DragTimerDirection m_rowDragTimerDirection;
	unsigned int m_rowDragTimerMillisecond;
	void UpdateRowDragTimerDelayFactor(unsigned int distance);
	unsigned int m_rowDragTimerCount;
	unsigned int m_rowDragTimerDelayFactorMax;
	unsigned int m_rowDragTimerDelayFactor;
	unsigned int m_rowDragTimerDelayDistance;
	Row* m_rowDragged;
	size_t m_rowDraggedOrd;
	size_t m_rowDraggedTo;
	CRect m_rowInsertionRect;

	mutable unsigned int m_nextPopOrdinal;
private:
	virtual bool MoveRow(Row* rowDragged, size_t from, size_t to){return false;}
	RowWindowSortable& operator=(const RowWindowSortable& other){return *this;}
};

class TGUI_API RowDynamic : public Row
{
public:
/*
	void UpdateRowValue(unsigned short id);
	virtual void Update();
	virtual void UpdateAndInvalidate(CRect& rowRect);
	virtual bool UpdateRowColor(){return false;}//should be called only inside a lock
*/
	bool SetRowValue(unsigned short id, RowValue* value, bool dynamic);
	virtual bool DestroyCell(unsigned short id) override;//{return NullifyRowValue(id);}
//	bool NullifyRowValue(unsigned short id);
//	typedef std::list<RowValue*> RowValueList;
	typedef std::vector<RowValue*> RowValueList;
	void UpdateRowValueIterators()
	{
		m_dynamicRowValuesBegin = m_dynamicRowValues.begin();
		m_dynamicRowValuesEnd = m_dynamicRowValues.end();
	}
	RowWindowSortable* GetWindowSortable(){return m_windowSortable;}
	const RowWindowSortable* GetWindowSortable() const{return m_windowSortable;}
#ifdef SECONDARY_ROWS
	Columns* GetColumns(){return m_columns;}
	const Columns* GetColumns() const{return m_columns;}
#else
	Columns* GetColumns(){return m_windowSortable;}
	const Columns* GetColumns() const{return m_windowSortable;}
#endif
protected:
	RowDynamic(unsigned short columnCount, RowWindowSortable* window)://, void* object):
		Row(columnCount),
		m_windowSortable(window)
#ifdef SECONDARY_ROWS
		,m_columns(window)
#endif
	{
		m_dynamicRowValues.reserve(m_columnCount);
		UpdateRowValueIterators();
	}
	RowWindowSortable* m_windowSortable;
#ifdef SECONDARY_ROWS
	Columns* m_columns;
#endif
	RowValueList m_dynamicRowValues;
	RowValueList::iterator m_dynamicRowValuesBegin;
	RowValueList::iterator m_dynamicRowValuesEnd;
};

class TGUI_API RowSortable : public RowDynamic
{
friend class RowWindowSortable;
#ifdef SECONDARY_ROWS
friend class RowSortableChild;
friend class RowOrderedSetIterator;
#endif
public:
	virtual ~RowSortable();//{m_windowSortable->m_selectedSet.erase(this);}
//	virtual bool isSortValueChanged() const;
	virtual bool isSortValueChanged() const
	{
		const RowValue* rowValue =
#ifdef SECONDARY_ROWS
			GetParentRow() ? GetRowValue(m_windowSortable->GetSecondarySortId()):
#endif
			GetRowValue(m_windowSortable->GetSortId());
		if(rowValue && rowValue->isValueChanged())
		{
			return true;
		}
		return isChainSortValueChanged();
	}

//	virtual bool isChainSortValueChanged() const;
	virtual bool isChainSortValueChanged() const
	{
		const RowValue* rowValue;
		const Columns::UShortChain::List& sortList =
#ifdef SECONDARY_ROWS
			GetParentRow() ? m_windowSortable->GetSecondarySortChain()->GetList():
#endif
			m_windowSortable->GetSortChain()->GetList();
		for(Columns::UShortChain::List::const_iterator it = sortList.begin(), itend = sortList.end(); it != itend; ++it)
		{
			rowValue = GetRowValue(*it);
			if(rowValue && rowValue->isValueChanged())
			{
				return true;
			}
		}
		return false;
	}

	virtual short Compare(const RowSortable& other) const;
	virtual short CompareAhead(const RowSortable& other) const;
//	virtual bool DefaultLess(const RowSortable& other) const{return GetBaseObject() < other.GetBaseObject();}
	virtual short DefaultCompare(const RowSortable& other) const;
	virtual short DefaultCompareAhead(const RowSortable& other) const{return DefaultCompare(other);}
	virtual short CompareChain(const RowSortable& other) const;
	virtual short CompareChainAhead(const RowSortable& other) const;
	bool operator<(const RowSortable& other) const
	{
		return Compare(other) < 0;
	}
	
	virtual bool CompareFunction(const RowSortable& other, unsigned short sortId, short& ret) const{return false;}
	virtual bool CompareFunctionAhead(const RowSortable& other, unsigned short sortId, short& ret) const{return false;}
	virtual short PreCompare(const RowSortable& other) const{return 0;}

	virtual bool DestroyCell(unsigned short id) override;

	void UpdateRowValue(unsigned short id);
	virtual void Update(bool dynamicOnly);
	virtual void UpdateAndInvalidate(CRect& rowRect, bool dynamicOnly);
	virtual bool UpdateRowColor(){return false;}//should be called only inside a lock

	bool UpdateRowColorWithLock()
	{
		bool ret;
//		LockWait();
		Lock(true);
		ret = UpdateRowColor();
		Unlock();
		return ret;
	}

	RowValue* GetDefaultSortValue() {return m_defaultSortValue;}
	const RowValue* GetDefaultSortValue() const{return m_defaultSortValue;}
	
	virtual bool isPotential() const override{return m_potential;}
	void SetPotential(const bool potential){m_potential = potential;}

	virtual bool isSelected() const override{return m_selected;}
	bool SetSelected(const bool& selected)
	{
		if(selected != m_selected)
		{
			m_selected = selected;
			return true;
		}
		return false;
	}
	virtual const unsigned int& GetPopOrdinal() const{return m_popOrdinal;}
	unsigned int SetPopOrdinal(const unsigned int popOrdinal);

	virtual bool hasInventory() const{return false;}

#ifdef SECONDARY_ROWS
	virtual Row* GetParentRow(){return NULL;}
	virtual const Row* GetParentRow() const{return NULL;}

	virtual RowSortable* GetParentSortableRow(){return NULL;}
	virtual const RowSortable* GetParentSortableRow() const{return NULL;}

	virtual void SetParentRow(RowSortable* const& parentRow){}

	virtual RowWindowSortable::RowSortableHashSet* GetChildRows(){return NULL;}
	virtual const RowWindowSortable::RowSortableHashSet* GetChildRows() const{return NULL;}
	virtual unsigned int GetChildRowCount() const{return 0;}
	virtual bool HasChildRows() const{return false;}
#endif

	typedef short (RowSortable::*Comparator)(const RowSortable& other) const;
//	inline short BasePreCompare(const RowSortable& other) const{return RowSortable::PreCompare(other);}
//	inline short BaseDefaultCompare(const RowSortable& other) const{return RowSortable::DefaultCompare(other);}
	inline short BaseCompare(const RowSortable& other) const{return RowSortable::Compare(other);}
	inline short BaseCompareAhead(const RowSortable& other) const{return RowSortable::CompareAhead(other);}
	inline short BaseCompareChain(const RowSortable& other) const{return RowSortable::CompareChain(other);}
	inline short BaseCompareChainAhead(const RowSortable& other) const{return RowSortable::CompareChainAhead(other);}

	virtual void PrepareForModification(){}
	virtual void UnprepareForModification(){}
protected:
	RowSortable(unsigned short columnCount, RowWindowSortable* window, bool potential)://, void* object):
		RowDynamic(columnCount, window),
		m_defaultSortValue(NULL),
		m_popOrdinal(0),
		m_potential(potential),
		m_selected(false)
	{
//		UpdateRowValueIterators();
	}

#ifdef SECONDARY_ROWS
	virtual void NullifyParentRow(){}
	virtual bool AddChildRow(RowSortable* childRow){return false;}
	virtual bool RemoveChildRow(RowSortable* childRow){return false;}
	virtual bool ClearChildRows(RowSortable* childRow){return false;}
#endif

	RowValue* m_defaultSortValue;

	virtual void AdjustColor(const Column* column) const;
	unsigned int m_popOrdinal;
	bool m_potential;
	bool m_selected;
};

#ifdef SECONDARY_ROWS

class TGUI_API RowSortableChild : public RowSortable
{
public:
	virtual ~RowSortableChild();
	inline short ApplyComparator(Comparator comparator, const RowSortable& other) const
	{
		const RowSortable* otherParentRow = other.GetParentSortableRow();
		if(m_parentRow)
		{
			if(otherParentRow)
				if(m_parentRow == otherParentRow)return (this->*comparator)(other);
				else return (m_parentRow->*comparator)(*otherParentRow);
			else
				if(&other == m_parentRow)return 1;
				else return (m_parentRow->*comparator)(other);
		}
		else
		{
			if(otherParentRow)
				if(this == otherParentRow)return -1;
				else return (this->*comparator)(*otherParentRow);
			else return (this->*comparator)(other);
		}
	}

//	virtual short PreCompare(const RowSortable& other) const{return ApplyComparator(&RowSortable::BasePreCompare, other);}
//	virtual short DefaultCompare(const RowSortable& other) const{return ApplyComparator(&RowSortable::BaseDefaultCompare, other);}
	virtual short Compare(const RowSortable& other) const{return ApplyComparator(&RowSortable::BaseCompare, other);}
	virtual short CompareAhead(const RowSortable& other) const{return ApplyComparator(&RowSortable::BaseCompareAhead, other);}
	virtual short CompareChain(const RowSortable& other) const{return ApplyComparator(&RowSortable::BaseCompareChain, other);}
	virtual short CompareChainAhead(const RowSortable& other) const{return ApplyComparator(&RowSortable::BaseCompareChainAhead, other);}

	virtual bool isSecondary() const override{return m_parentRow != NULL;}
	virtual bool isPrimary() const{return !m_parentRow;}
	
	virtual Row* GetParentRow(){return m_parentRow;}
	virtual const Row* GetParentRow() const{return m_parentRow;}

	virtual RowSortable* GetParentSortableRow() override{return m_parentRow;}
	virtual const RowSortable* GetParentSortableRow() const override{return m_parentRow;}
	virtual bool isExpandable() const override{return !m_parentRow;}
	virtual bool isExpanded() const override{return m_expanded;}
	virtual bool SetExpanded(const bool expanded)
	{
		if(!m_parentRow && expanded != m_expanded)
		{
			m_expanded = expanded;
			return true;
		}
		return false;
	}
	virtual void SetParentRow(RowSortable* const& parentRow)
	{
		if(parentRow != m_parentRow)
		{
			if(m_parentRow)m_parentRow->RemoveChildRow(this);
			m_parentRow = parentRow;
			if(m_parentRow)
			{
				m_parentRow->AddChildRow(this);
				m_columns = m_windowSortable->GetSecondaryColumns();
			}
			else m_columns = m_windowSortable;
		}
	}
	virtual RowWindowSortable::RowSortableHashSet* GetChildRows(){return m_childRows;}
	virtual const RowWindowSortable::RowSortableHashSet* GetChildRows() const{return m_childRows;}
	virtual unsigned int GetChildRowCount() const{return m_childRows ? (unsigned int)m_childRows->size() : 0;}
	virtual bool HasChildRows() const{return m_childRows && !m_childRows->empty();}

	virtual const unsigned int& GetPopOrdinal() const{return m_parentRow ? m_parentRow->GetPopOrdinal() : m_popOrdinal;}
protected:
	RowSortableChild(const unsigned short& columnCount, RowWindowSortable* const& window, bool potential, RowSortable* const& parentRow = NULL, bool expanded = false):
		RowSortable(columnCount, window, potential),
		m_parentRow(NULL),
		m_childRows(NULL),
		m_expanded(expanded)
	{
		SetParentRow(parentRow);
	}

	virtual void NullifyParentRow()
	{
		m_parentRow = NULL;
	}
	virtual bool AddChildRow(RowSortable* childRow)
	{
		if(!m_childRows)m_childRows = new RowWindowSortable::RowSortableHashSet;
		return m_childRows->insert(childRow).second;
	}
	virtual bool RemoveChildRow(RowSortable* childRow)
	{
		return m_childRows && m_childRows->erase(childRow) != 0;
	}
	virtual bool ClearChildRows(RowSortable* childRow)
	{
		if(m_childRows && !m_childRows->empty())
		{
			m_childRows->clear();
			return true;
		}
		return false;
	}

	RowSortable* m_parentRow;
	RowWindowSortable::RowSortableHashSet* m_childRows;
	bool m_expanded;
};
#endif

class TGUI_API RowTotal : public RowDynamic
{
public:
	RowTotal(unsigned short columnCount, RowWindowSortable* window):
		RowDynamic(columnCount, window),
		m_additionalNonCumulativeRowValuesEnd(m_additionalNonCumulativeRowValues.end())
	{
		UpdateCumulativeRowValueIterators();
	}
	virtual const void* GetBaseObject() const override{return NULL;}
	bool SetRowValue(unsigned short id, RowValue* value, bool dynamic, bool cumulative = true, unsigned short additionalId = 0xFFFF);
	virtual bool DestroyCell(unsigned short id) override;//{return NullifyRowValue(id);}
//	bool NullifyRowValue(unsigned short id);
	typedef std::set<unsigned short> UShortSet;
	bool AddRow(const Row* row, const UShortSet& columnIds);
	void AddRow(const Row* row);
	void RemoveRow(const Row* row);
	void AdjustRow(const Row* row, bool dynamicOnly);
	void AdjustRowValue(const Row* row, unsigned short id);
	void ResetRow();
	void UpdateCumulativeRowValueIterators()
	{
		m_cumulativeRowValuesBegin = m_cumulativeRowValues.begin();
		m_cumulativeRowValuesEnd = m_cumulativeRowValues.end();
	}
	virtual COLORREF GetRowColor() const;

	virtual void UpdateNonCumulativeValues(const Row* row, bool dynamicOnly){}
	virtual void AddNonCumulativeValues(const Row* row){}
	virtual void RemoveNonCumulativeValues(const Row* row){}
	virtual void ResetNonCumulativeValues()
	{
		if(!m_additionalNonCumulativeRowValues.empty())
		{
			for(RowValueUShortMap::iterator it = m_additionalNonCumulativeRowValues.begin(); it != m_additionalNonCumulativeRowValuesEnd; ++it)
			{
				it->first->Reset();
			}
		}
	}
	virtual void ResetMinMaxValues(const void* container){}
//	virtual void UpdateInventoryViewNonCumulativeValues(const Row* row){}
	typedef std::map<RowValue*, unsigned short> RowValueUShortMap;
protected:
	bool AddRowValue(const Row* row, unsigned short id);
	RowValueList m_cumulativeRowValues;
	RowValueList::iterator m_cumulativeRowValuesBegin;
	RowValueList::iterator m_cumulativeRowValuesEnd;

	RowValueUShortMap m_additionalNonCumulativeRowValues;
	RowValueUShortMap::const_iterator m_additionalNonCumulativeRowValuesEnd;

	void AdjustNonCumulativeMaxMoneyValue(const MoneyRowValue* moneyRowValue, CRect& rowRect);
};


#ifndef TAKION_NO_OPTIONS

class TGUI_API DialogListOptionUInt : public DialogListUIntDerived
{
public:
	void Display(const unsigned int& code,
		const Underlier* const& underlier,
		const unsigned __int64& rootSymbol,
		const unsigned int& collectionItem,
		const unsigned int& selectedItem,
		const bool& rightButton,
		CWnd* const& parent,
		const int& x,
		const int& y,
		const int& w,
		const int& h,
		const bool& fastSelection,
		const unsigned int& maxVisibleItemCount = 0,
		CWnd* const& receipient = NULL,
		const COLORREF& bkColor = 0xFFFFFFFF,
		const COLORREF& selectionBkColor = 0xFFFFFFFF,
		const COLORREF& textColor = 0xFFFFFFFF,
		const COLORREF& selectionTextColor = 0xFFFFFFFF)
	{
		m_underlier = underlier;
		m_rootSymbol = rootSymbol;
		m_collectionItem = collectionItem;
//		m_rowWindow = receipient;
		DialogListUIntDerived::Display(code,
			rightButton,
			selectedItem,
			parent,
			x,
			y,
			w,
			h,
			fastSelection,
			maxVisibleItemCount,
			receipient, bkColor,
			selectionBkColor,
			textColor,
			selectionTextColor);
	}
	const unsigned __int64& GetRootSymbol() const{return m_rootSymbol;}
	const unsigned int& GetCollectionItem() const{return m_collectionItem;}
protected:
	DialogListOptionUInt(TakionMainWnd* mainFrame, CWnd* parent, ListBoxUIntDerivedBold* listBoxDerivedBold, unsigned int maxVisibleItemtCount);

	const Underlier::ExpirationMap* FindCollectionMap() const{return m_underlier ? DoFindCollectionMap() : NULL;}
	virtual const Underlier::ExpirationMap* DoFindCollectionMap() const = 0;
	virtual void FinishDialog(int result) override
	{
		DialogListUIntDerived::FinishDialog(result);
//		m_rowWindow = NULL;
		m_underlier = NULL;
		m_rootSymbol = 0;
		m_collectionItem = 0;
	}
	virtual void FillNumbers() override;
/*
	virtual void DoApplyUInt(unsigned int selectedItem, unsigned int initialItem){}

	virtual void Apply() override
	{
		const unsigned int selectedItem = GetSelectedUInt();
		const unsigned int initialItem = (unsigned int)
#if (_MSC_VER > 1600)
			(size_t)
#endif
			m_item;

		if(selectedItem != initialItem)
		{
			DoApplyUInt(selectedItem, initialItem);
			DialogListUIntDerived::Apply();
		}
	}

	RowWindowSortable* m_rowWindow;
*/
	const Underlier* m_underlier;
	unsigned __int64 m_rootSymbol;
	unsigned int m_collectionItem;
};

class TGUI_API DialogListOptionExpirationDate : public DialogListOptionUInt
{
public:
	DialogListOptionExpirationDate(TakionMainWnd* const& mainFrame, CWnd* const& parent, const unsigned int& maxVisibleItemtCount, const bool& showDayOfWeek = false)://, bool ownItems);// = 0, CWnd* receipient = NULL);
		DialogListOptionUInt(mainFrame, parent, &m_ListBoxDate, maxVisibleItemtCount),
		m_ListBoxDate(0, true, false, false, true, NULL, showDayOfWeek)
	{
	}
	void Display(const Underlier* const& underlier,
		const unsigned __int64& rootSymbol,
		const unsigned int& strikePrice,
		const unsigned int& expirationDate,
		const bool& rightButton,
		CWnd* const& parent,
		const int& x,
		const int& y,
		const int& w,
		const int& h,
		const bool& fastSelection,
		const unsigned int& maxVisibleItemCount = 0,
		CWnd* const& receipient = NULL,
		const COLORREF& bkColor = 0xFFFFFFFF,
		const COLORREF& selectionBkColor = 0xFFFFFFFF,
		const COLORREF& textColor = 0xFFFFFFFF,
		const COLORREF& selectionTextColor = 0xFFFFFFFF)
	{
		DialogListOptionUInt::Display(0,
			underlier,
			rootSymbol,
			strikePrice,
			expirationDate,
			rightButton,
			parent,
			x,
			y,
			w,
			h,
			fastSelection,
			maxVisibleItemCount,
			receipient,
			bkColor,
			selectionBkColor,
			textColor,
			selectionTextColor);
	}
protected:
	virtual const Underlier::ExpirationMap* DoFindCollectionMap() const override{return m_underlier->FindStrikeMap(m_rootSymbol);}
/*
	virtual void DoApplyUInt(unsigned int selectedItem, unsigned int initialItem) override
	{
		m_rowWindow->ApplyExpirationDate(m_code, selectedItem, initialItem, m_collectionItem, m_rootSymbol);
	}
*/
	ListBoxDate m_ListBoxDate;
};

class TGUI_API DialogListOptionStrikePrice : public DialogListOptionUInt
{
public:
	DialogListOptionStrikePrice(TakionMainWnd* const& mainFrame, CWnd* const& parent, const unsigned int& maxVisibleItemtCount)://, bool ownItems);// = 0, CWnd* receipient = NULL);
		DialogListOptionUInt(mainFrame, parent, &m_ListBoxPrice, maxVisibleItemtCount),
		m_ListBoxPrice(0, true)//, false, false)
	{
	}
	void Display(const Underlier* const& underlier,
		const unsigned __int64& rootSymbol,
		const unsigned int& expirationDate,
		const unsigned int& strikePrice,
		const bool& rightButton,
		CWnd* const& parent,
		const int& x,
		const int& y,
		const int& w,
		const int& h,
		const bool& fastSelection,
		const unsigned int& maxVisibleItemCount = 0,
		CWnd* const& receipient = NULL,
		const COLORREF& bkColor = 0xFFFFFFFF,
		const COLORREF& selectionBkColor = 0xFFFFFFFF,
		const COLORREF& textColor = 0xFFFFFFFF,
		const COLORREF& selectionTextColor = 0xFFFFFFFF)
	{
		DialogListOptionUInt::Display(0,
			underlier,
			rootSymbol,
			expirationDate,
			strikePrice,
			rightButton,
			parent,
			x,
			y,
			w,
			h,
			fastSelection,
			maxVisibleItemCount,
			receipient,
			bkColor,
			selectionBkColor,
			textColor,
			selectionTextColor);
	}
protected:
	virtual const Underlier::ExpirationMap* DoFindCollectionMap() const override{return m_underlier->FindExpirationMap(m_rootSymbol);}
/*
	virtual void DoApplyUInt(unsigned int selectedItem, unsigned int initialItem) override
	{
		m_rowWindow->ApplyStrikePrice(m_code, selectedItem, initialItem, m_collectionItem, m_rootSymbol);
	}
*/
	ListBoxPrice m_ListBoxPrice;
};

#endif

class HistoricalPrintRow;

class TGUI_API HistoricalPrintWnd : public RowWindowSortable, public Observer
{
public:
	virtual ~HistoricalPrintWnd();
	virtual const char* GetToolId() const override{return toolHistoricalPrintId;}
//	Security* GetSecurity(){return m_security;}
	const COLORREF& GetColorNotLoaded() const{return m_colorNotLoaded;}
	const COLORREF& GetColorDisconnected() const{return m_colorDisconnected;}
	virtual COLORREF GetBkColor() const override{return m_historicalPrintConnected ? m_requestId == 0 ? m_backgroundColor : m_colorNotLoaded : m_requestId == 0 || m_symbol.empty() ? m_colorDisconnected : m_backgroundColor;}
	virtual void SetEquitySymbol(const char* symbol, unsigned char basket, bool force, bool addToStockChain) override;
	virtual bool HasMillisecondColumns() const override{return true;}
	virtual bool HasMoneyColumns() const override{return false;}
	virtual bool isPlusMinusable() const override{return false;}
//	virtual bool HasDoubleClickAction() const override{return false;}

	enum ColumnId : unsigned short
	{
		HP_SYMBOL,
		HP_TIME,
//		P_INSIDE_MARKET,
//		P_INSIDE_SIZE,
		HP_PRICE,
		HP_SIZE,
		HP_SALE_CONDITION_1,
		HP_SALE_CONDITION_2,
		HP_SALE_CONDITION_3,
		HP_SALE_CONDITION_4,
		HP_EXCHANGE,
		HP_REF_NUMBER,
		HP_SOURCE,
//		HP_BID,
//		HP_ASK,
//		HP_BIDSIZE,
//		HP_ASKSIZE,

		HP_COLUMN_COUNT
	};
	virtual unsigned short GetBuiltInColumnCount() const override{return HP_COLUMN_COUNT;}
	virtual void toString(std::string& str, unsigned int contentModifier) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual void fromScratch() override;
	virtual void AddToSpecificToolCollection() override;

	virtual void UpdateDataGraphics(const Graphics* graphics) override;
	virtual bool UpdateDataGraphicsColorsCustom(const GraphicsColorCollection* colorCollection) override;
	virtual bool UpdateDataGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL) override;

//	virtual bool CanLink() const{return true;}

	virtual Row* CreateRow(const void* object, bool potential) override;
	virtual RowSortable* AddRow(RowSortable* row, bool newRow, bool repaint) override;
	virtual RowSortable* RemoveRow(RowSortable* row) override;
	virtual void DestroyRows() override;

	typedef void (HistoricalPrintRow::*FnPaintInfo)(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	typedef short (HistoricalPrintRow::*FnCompare)(const HistoricalPrintRow& other) const;
	bool AddHistoricalPrintFunctions(unsigned short id, FnPaintInfo fnPaint, FnCompare fnCompare, FnCompare fnCompareAhead);
	inline const FnPaintInfo& GetFnPaintInfo(const unsigned short& id) const{return id < HP_COLUMN_COUNT ? m_paintInfoFunction[id] : NULL;}
	inline const FnCompare& GetFnCompare(const unsigned short& id) const{return id < HP_COLUMN_COUNT ? m_compareFunction[id] : NULL;}
	inline const FnCompare& GetFnCompareAhead(const unsigned short& id) const{return id < HP_COLUMN_COUNT ? m_compareAheadFunction[id] : NULL;}

//	virtual bool ObjectPotentiallyBelongs(const void* object) const;//no need to call inside lock, because Execution does not change
	virtual bool RowFiltersIn(const RowSortable* row) const override;//no need to call inside lock, because Execution does not change
	virtual unsigned char RowBelongs(const RowSortable* row) const override;//no need to call inside lock, because Execution does not change

	virtual COLORREF GetColorVeryGood() const override{return m_colorVeryGood;}
	virtual COLORREF GetColorVeryBad() const override{return m_colorVeryBad;}
	virtual COLORREF GetColorVeryGoodBk() const override{return m_colorVeryGoodBk;}
	virtual COLORREF GetColorVeryBadBk() const override{return m_colorVeryBadBk;}

	unsigned int GetFractionDivider() const{return m_fractionDivider;}
	unsigned int GetFractionDollar() const{return m_fractionDollar;}

	void SetShowSizeInShares(bool sizeInShares);
	virtual const bool* isShowSizeInShares() const override{return &m_sizeInShares;}

	void SetPrintFilter(unsigned int filter);
	void TogglePrintFilter(unsigned int filter);
//	void UpdatePrints();
	void SetPrintShowOddLot(bool printShowOddLot);

	Row* AddPrint(unsigned int millisecond,
//		const char* symbol,
//		const Price& printPrice,
		unsigned int compactPrice,
		unsigned int printSize,
		unsigned char level1,
		char saleCondition1,
		char saleCondition2,
		char saleCondition3,
		char saleCondition4,
		unsigned char source,
//		unsigned int mmid,
		unsigned int roundLot,
		unsigned __int64 referenceNumber,
		bool repaint);
//		bool prepend);

	virtual void AcceptText(const char* text, unsigned int code) override;
	virtual void AppendWindowMenuInfo(std::string& menuText) const override
	{
		RowWindowSortable::AppendWindowMenuInfo(menuText);
		if(!m_symbol.empty())
		{
			menuText += " - ";
			menuText += m_symbol;
		}
	}

	const std::string& GetSymbol() const{return m_symbol;}
	virtual const char* GetStringSymbolPtr(unsigned char& basket) const override{basket = EST_STOCK; return m_symbol.c_str();}
	const unsigned __int64& GetNumericSymbol() const{return m_numericSymbol;}
//	COLORREF GetTopActiveColor() const{return m_topActiveColor;}
	
	unsigned int GetNextMenuId() const;

	typedef CMap<unsigned __int64, const unsigned __int64&, HistoricalPrintRow*, HistoricalPrintRow* const&> HistoricalPrintRowMap;
	const HistoricalPrintRow* FindRowByRefNumber(const unsigned __int64& ref) const
	{
		const HistoricalPrintRowMap::CPair* found = m_historicalPrintRowMap.PLookup(ref);
		return found ? found->value : NULL;
	}
protected:
	HistoricalPrintWnd(const CBitmap* bitmap, unsigned int workspace, bool pinned = false);

	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;
//	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
//	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
//	DECLARE_MESSAGE_MAP()

	virtual void ActiveStockChosen(const char* symbol) override;

	virtual void RowInserted(RowSortable* row) override;
	virtual void RowRemoved(RowSortable* row) override;
//	size_t EraseRow(RowSortable* row);
//	bool AddHistoricalPrints();//unsigned int from, unsigned int to);
	void StartTypingSymbol(unsigned char key);
	virtual bool ProcessKeyDown(unsigned char key, unsigned char modifier, bool repeat, TakionFrame* fromWindow) override;
	bool DoSetSymbol(const char* symbol);
	virtual void SymbolAccepted(const char* text, bool changed);
	void NullifyStock();
	void UpdatePrints(bool remove, bool add);
	void UpdatePrintIterator(bool remove, bool add);

	virtual void Reload(const char* symbol, bool changed){}

	virtual void BeforeDestroy() override;
	virtual void AddMenuItems(CMenu& menu) override;
	virtual void AddRowPropertiesMenuItems(CMenu& popupMenu) override;
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;

	void SetHistoricalPrintLoaded();
	void SetHistoricalPrintConnected(bool connected);

	virtual void InvalidateShowMilliseconds() const override;
	COLORREF m_colorVeryGood;
	COLORREF m_colorVeryBad;
	COLORREF m_colorVeryGoodBk;
	COLORREF m_colorVeryBadBk;
	COLORREF m_colorNotLoaded;
	COLORREF m_colorDisconnected;
	unsigned int m_fractionDivider;
	unsigned int m_fractionDollar;
//	unsigned int m_ecnExecutionFilter;
	unsigned int m_printFilter;
	bool m_printShowOddLot;

	bool m_sizeInShares;

//	Security* m_security;
//	TakionIterator* m_printIterator;

	std::string m_symbol;
	unsigned __int64 m_numericSymbol;
	unsigned int m_requestId;
	bool m_historicalPrintConnected;

	HistoricalPrintRowMap m_historicalPrintRowMap;

	FnPaintInfo m_paintInfoFunction[HP_COLUMN_COUNT];
	FnCompare m_compareFunction[HP_COLUMN_COUNT];
	FnCompare m_compareAheadFunction[HP_COLUMN_COUNT];
};

class TGUI_API HistoricalPrintRow : public RowSortable
{
public:
	HistoricalPrintRow::HistoricalPrintRow(HistoricalPrintWnd* parent,
//		const char* symbol,
		unsigned int millisecond,
//		const Price& printPrice,
		unsigned int compactPrice,
		unsigned int printSize,
		unsigned char level1,
		char saleCondition1,
		char saleCondition2,
		char saleCondition3,
		char saleCondition4,
//		unsigned char source,
		unsigned char source,
		unsigned int mmid,
		unsigned int roundLot,
		unsigned __int64 referenceNumber);
	virtual const void* GetBaseObject() const override{return this;}
	virtual COLORREF GetRowColor() const override;
	virtual COLORREF GetRowBkColor() const override;
	virtual COLORREF GetCellColor(unsigned short columnId) const override;

	void PaintSymbol(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareSymbol(const HistoricalPrintRow& other) const;
	void PaintTime(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareTime(const HistoricalPrintRow& other) const;
	void PaintPrice(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short ComparePrice(const HistoricalPrintRow& other) const;
	void PaintSize(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareSize(const HistoricalPrintRow& other) const;
	void PaintSaleCondition1(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareSaleCondition1(const HistoricalPrintRow& other) const;
	void PaintSaleCondition2(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareSaleCondition2(const HistoricalPrintRow& other) const;
	void PaintSaleCondition3(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareSaleCondition3(const HistoricalPrintRow& other) const;
	void PaintSaleCondition4(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareSaleCondition4(const HistoricalPrintRow& other) const;
	void PaintExchange(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareExchange(const HistoricalPrintRow& other) const;
	void PaintRefNumber(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareRefNumber(const HistoricalPrintRow& other) const;
	void PaintSource(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareSource(const HistoricalPrintRow& other) const;

	DECLARE_NED_NEW

	virtual const unsigned __int64& GetRowNumericSymbol() const override;
	virtual const char* GetRowSecuritySymbol(const CPoint* point = NULL) const override;//{return m_execution ? &m_execution->GetSymbolStr() : NULL;}
	unsigned char GetLevel1() const{return m_level1;}
	const unsigned __int64& GetReferenceNumber() const{return m_referenceNumber;}
	virtual short DefaultCompare(const RowSortable& other) const;
//	virtual short Compare(const RowSortable& other) const;
//	virtual short CompareChain(const RowSortable& other) const;
//	virtual short CompareAhead(const RowSortable& other) const;
//	virtual short CompareChainAhead(const RowSortable& other) const;
	virtual bool CompareFunction(const RowSortable& other, unsigned short sortId, short& ret) const override;
	virtual bool CompareFunctionAhead(const RowSortable& other, unsigned short sortId, short& ret) const override;
	virtual bool GetPaintTextInfo(unsigned short columnId, std::string& text, COLORREF& color) const override;//, UINT& horizontalJustification) const override;
	const unsigned char& GetSource() const{return m_source;}
	bool isOddLot() const{return m_saleCondition1 == 'I' || m_saleCondition4 == 'I';}
protected:
	HistoricalPrintWnd* m_historicalPrintWindow;

//	unsigned __int64 m_symbol;//taken from the m_historicalPrintWindow

	unsigned __int64 m_referenceNumber;

	unsigned int m_time;
	unsigned int m_compactPrice;
	unsigned int m_printSize;
	unsigned int m_roundLot;
	unsigned int m_mmid;
	unsigned char m_source;
	char m_saleCondition1;
	char m_saleCondition2;
	char m_saleCondition3;
	char m_saleCondition4;
//	unsigned int roundLot,
	unsigned char m_level1;

};

enum OrderCommandDisplaySizeMode : unsigned char
{
	OCDSM_SIZE_FRACTION,
	OCDSM_ROUND_LOT,

	OCDSM_COUNT
};

class TGUI_API DialogReplaceOrder : public DialogReset, public Observer
{
public:
	DialogReplaceOrder(TakionMainWnd* mainWnd, bool toDestroyOnFocus = false, CWnd* parent = NULL);
//	void Display(bool priceColumn, bool expanded, const CPoint& corner, CancelOrderWindow* receipient, unsigned int code, CWnd* parent, const CPoint& mousePoint);//, int x, int y, int w, int h);
	void Display(const OrderReplaceSet& orderSet,
		bool priceColumn,

		bool preBorrow,
		bool marketOrder,
		bool replaceNative,
		bool priceOffsetPercent,
		bool priceOffsetReverseForSell,
		bool sizeOffsetReverseForSell,
		const SignedPrice& priceOffset,
		const Price& borrowPrice,
		int sizeOffset,
		OrderCommandDisplaySizeMode displaySizeMode,
		unsigned int displaySize,
		unsigned int displaySizeFraction,
		unsigned int displaySizeRoundLot,

		const CPoint& corner,
		unsigned int code,
		CWnd* parent,
		const CPoint& mousePoint);//, int x, int y, int w, int h);

//	virtual const char* GetRowValueAsString(const Row* row, char* buf, unsigned int bufsize) const = 0;
	virtual bool isChanged() const override;
	virtual bool isValid() const override;
	bool isDifferent() const;
//	void SetReceipient(RowWindowSortable* const& receipient){m_rowWindow = receipient;}
	virtual bool DoReset() override;
protected:
//	DialogSymbolValue(ListBoxOwnerDraw* listBox, CWnd* entryControl, int controlWidth, TakionMainWnd* mainWnd, bool toDestroyOnFocus = false, RowWindowSortable* receipient = NULL, CWnd* parent = NULL);
	virtual void SetInitialValue(){}
	virtual void UpdateInitialValue(){}
	virtual void FillControls(){}
	virtual void InitEntryControl(){}
//	virtual void InitEntryControlHeight(){}
	virtual void DoApply();

	virtual void DoDataExchange(CDataExchange* pDX) override;
	virtual BOOL OnInitDialog() override;
	virtual void Resize(bool widthChanged = true, bool heightChanged = true) override;
	virtual void FinishDialog(int result) override;
	virtual void BeforeShow() override;
//	afx_msg void OnReset();

	afx_msg void OnDisplaySizeNoChange();
	afx_msg void OnDisplaySizeFraction();
	afx_msg void OnDisplaySizeRoundLot();

	afx_msg void OnPreBorrow();
	afx_msg void OnMarketOrder();
	afx_msg void OnNative();
	afx_msg void OnPriceOffsetPercent();
	afx_msg void OnPriceOffsetReverseFoSell();
	afx_msg void OnSizeOffsetReverseFoSell();

	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg LRESULT OnSpinChange(WPARAM spinId, LPARAM l);
	DECLARE_MESSAGE_MAP()

	void InvalidateControlsOnMarketOrder();
	
//	virtual void EnableOkButton() override;

	virtual void DoEnableOkButton(bool enable) override;
	void EnableResetButton();


	virtual void Notify(const Message* message, const Observable* from, const Message* info = NULL) override;

//	virtual void ItemDoubleClicked(unsigned int sel, void* item){}

//	CancelOrderWindow* m_cancelOrderWindow;

	unsigned int m_sellOrderCount;
	unsigned int m_algoCount;

	bool m_priceColumn;
	bool m_expanded;

	CPoint m_corner;

	CStatic m_StaticTitle;

	CStatic m_StaticOrderCount;

	CStatic m_StaticAbsolutePrice;
	UnsignedNumberTypeSpin<unsigned __int64> m_SpinAbsolutePrice;

	CStatic m_StaticAbsoluteSize;
	UnsignedNumberTypeSpin<unsigned int> m_SpinAbsoluteSize;

	CStatic m_StaticPriceOffset;
	CButton m_CheckBoxPriceOffsetPercent;
	SignedNumberTypeSpin<int> m_SpinPriceOffset;
	CButton m_CheckBoxPriceOffsetReverseForSell;

	CStatic m_StaticSizeOffset;
	SignedNumberTypeSpin<int> m_SpinSizeOffset;
	CButton m_CheckBoxSizeOffsetReverseForSell;

//	CButton m_GroupPreBorrow;
	CStatic m_StaticPreBorrowCent;
	CButton m_CheckBoxPreBorrow;
	UnsignedNumberTypeSpin<unsigned int> m_SpinBorrowPrice;

	CButton m_GroupDisplaySize;
//	CStatic m_StaticDisplaySize;
	CButton m_radioDisplaySizeMode[OCDSM_COUNT + 1];
	UnsignedNumberTypeSpin<unsigned int> m_SpinDisplaySizeFraction;
	UnsignedNumberTypeSpin<unsigned int> m_SpinDisplaySizeRoundLot;

	CButton m_CheckBoxMarketOrder;
	CButton m_CheckBoxReplaceNative;

	void SetExpanded(bool expanded);

	void InitDisplaySize();

	void InitOffsets();
	int m_topControlY;
	int m_topOffsetControlY;

	int m_staticHeight;
	int m_spinHeight;
	int m_checkBoxHeight;
	int m_radioHeight;
	int m_displaySizeDistance;

	int m_titleRight;
	int m_verticalGap;
	int m_offsetX;

	int m_percentOffsetX;

	int m_preBorrowOffsetX;

	int m_groupDisplayOffsetX;
	int m_groupDisplayHeight;
	int m_groupTopOffset;
	int m_displayNoChangeOffsetX;
	int m_displayFractionOffsetX;
	int m_displayRoundLotOffsetX;
	int m_displaySpinOffsetX;

	int m_buttonWidth;
	int m_buttonHeight;

	bool m_preBorrowInitial;
	bool m_marketOrderInitial;
	bool m_replaceNativeInitial;
	bool m_priceOffsetPercentInitial;
	bool m_priceOffsetReverseForSellInitial;
	bool m_sizeOffsetReverseForSellInitial;

	Price m_orderPrice;
	unsigned int m_orderSize;

	Price m_priceAbsoluteInitial;
	unsigned int m_sizeAbsoluteInitial;
	SignedPrice m_priceOffsetInitial;
	Price m_borrowPriceInitial;
	int m_sizeOffsetInitial;
	OrderCommandDisplaySizeMode m_displaySizeModeInitial;
	unsigned int m_displaySizeInitial;
	unsigned int m_displaySizeFractionInitial;
	unsigned int m_displaySizeRoundLotInitial;

	bool m_preBorrow;
	bool m_marketOrder;
	bool m_replaceNative;
	bool m_priceOffsetPercent;
	bool m_priceOffsetReverseForSell;
	bool m_sizeOffsetReverseForSell;

	Price m_priceAbsolute;
	unsigned int m_sizeAbsolute;
	SignedPrice m_priceOffset;
	Price m_borrowPrice;
	int m_sizeOffset;
	OrderCommandDisplaySizeMode m_displaySizeMode;
	unsigned int m_displaySize;
	unsigned int m_displaySizeFraction;
	unsigned int m_displaySizeRoundLot;

	int m_expandedHeight;

	bool DisplaySizeModeChange(OrderCommandDisplaySizeMode mode);
	void FillDisplaySize(unsigned char displaySizeMode, unsigned int& displaySize, unsigned int& displaySizeFraction) const;
//	OrderReplaceSet m_orderSet;
//	OrderReplaceSet::const_iterator m_orderSetEnd;
	Order::OrderSet m_orderSet;
	Order::OrderSet::const_iterator m_orderSetEnd;
};


///////////////////
class TGUI_API DialogSymbolValue : public DialogReset
{
public:
	void Display(unsigned short stringColumnId, unsigned short valueColumnId, const CPoint& corner, RowWindowSortable* receipient, unsigned int code, CWnd* parent, const CPoint& mousePoint);//, int x, int y, int w, int h);
	virtual bool isValueChanged() const{return true;}
	virtual const char* GetRowValueAsString(const Row* row, char* buf, unsigned int bufsize) const = 0;
	virtual bool isChanged() const override;
	virtual bool isEnableOkInitially() const{return false;}
//	virtual bool DoReset();
	enum DialogSymbolValueIds
	{
		titleId = 1000,
		symbolNumberListBoxId,
		entryControlId,

		symbolValueIdCount
	};
//	void SetReceipient(RowWindowSortable* const& receipient){m_rowWindow = receipient;}
	virtual bool DoReset() override;
protected:
//	DialogSymbolValue(ListBoxOwnerDraw* listBox, CWnd* entryControl, int controlWidth, TakionMainWnd* mainWnd, bool toDestroyOnFocus = false, RowWindowSortable* receipient = NULL, CWnd* parent = NULL);
	DialogSymbolValue(ListBoxOwnerDraw* listBox, CWnd* entryControl, TakionMainWnd* mainWnd, bool toDestroyOnFocus = false, bool listBoxSorted = false, RowWindowSortable* receipient = NULL, CWnd* parent = NULL, bool executeCommands = true);
	virtual void SetInitialValue(){}
	virtual void UpdateInitialValue(){}
	virtual void FillControls(){}
	virtual void InitEntryControl(){}
//	virtual void InitEntryControlHeight(){}
	virtual void DoApply();

	virtual void DoDataExchange(CDataExchange* pDX) override;
	virtual BOOL OnInitDialog() override;
	virtual void Resize(bool widthChanged = true, bool heightChanged = true) override;
	virtual void FinishDialog(int result) override;
	virtual void BeforeShow() override;
//	afx_msg void OnReset();
	afx_msg void OnListBoxDoubleClick();
//	afx_msg LRESULT OnSpinChange(WPARAM spinId, LPARAM l);
	DECLARE_MESSAGE_MAP()

	virtual void EnableOkButton();

	virtual void ItemDoubleClicked(unsigned int sel, void* item){}

	CStatic m_StaticTitle;
	ListBoxOwnerDraw* m_listBox;
	CWnd* m_entryControl;
//	TakionSpin* m_spin;

	RowWindowSortable* m_rowWindow;
	unsigned short m_stringColumnId;
	unsigned short m_valueColumnId;
	bool m_sameValueForAll;

	CPoint m_corner;
	int m_lbWidth;
	int m_lbHeight;
	int m_lbBorderSize;
	int m_controlHeight;
	int m_controlWidth;
	int m_clientWidth;
	int m_buttonWidth;
	int m_buttonHeight;
	int m_entryControlHeight;
	int m_staticHeight;
	int m_minWidth;
	void MoveControls(bool moveDialog);

	RowWindowSortable::RowSortableSet m_rowSet;

	static const unsigned int buttonWidth;
	static const unsigned int buttonHeight;
	static const unsigned int buttonGapV;
	static const unsigned int buttonGapH;
	static const unsigned int checkBoxHeight;
	static const int spinHeight;
	static const int editHeight;
	static const int staticHeight;
	static const int staticWidth;
};

class TGUI_API DialogSymbolString : public DialogSymbolValue
{
public:
	DialogSymbolString(TakionMainWnd* mainWnd, int entryControlWidth, bool toDestroyOnFocus = false, bool listBoxSorted = false, RowWindowSortable* receipient = NULL, CWnd* parent = NULL);
	void Display(unsigned short stringColumnId, unsigned short valueColumnId, int minWidth, const CPoint& corner, RowWindowSortable* receipient, unsigned int code, CWnd* parent, const CPoint& mousePoint);//, int x, int y, int w, int h)
	virtual bool isValueChanged() const override;
	virtual const char* GetRowValueAsString(const Row* row, char* buf, unsigned int bufsize) const override;
protected:
	virtual void SetInitialValue() override;
	virtual void UpdateInitialValue() override;
	virtual void FillControls() override;
	virtual void Apply() override;
	virtual BOOL PreTranslateMessage(MSG* pMsg) override;
	virtual void FinishDialog(int result) override;
	virtual void InitEntryControl() override;

	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnValueChange();
//	afx_msg void OnValueUpdate();
	DECLARE_MESSAGE_MAP()

	virtual void ItemDoubleClicked(unsigned int sel, void* item) override;

	ListBoxStringString m_ListBoxSymbolString;
	ValidEdit m_EditString;
	std::string m_initialValue;
	std::string m_currentValue;
};

class TGUI_API DialogSymbolNumber : public DialogSymbolValue
{
public:
	void Display(unsigned short stringColumnId, unsigned short numberColumnId, const CPoint& corner, RowWindowSortable* receipient, unsigned int code, CWnd* parent, const CPoint& mousePoint);//, int x, int y, int w, int h);
protected:
	DialogSymbolNumber(ListBoxOwnerDraw* listBox, TakionSpin* spin, int spinWidth, TakionMainWnd* mainWnd, bool toDestroyOnFocus = false, bool listBoxSorted = false, RowWindowSortable* receipient = NULL, CWnd* parent = NULL);
	virtual void InitEntryControl() override;
	afx_msg LRESULT OnSpinChange(WPARAM spinId, LPARAM l);
	DECLARE_MESSAGE_MAP()

	TakionSpin* m_spin;
};

class TGUI_API DialogSymbolUIntNumber : public DialogSymbolNumber
{
public:
	DialogSymbolUIntNumber(TakionMainWnd* mainWnd, bool toDestroyOnFocus = false, bool listBoxSorted = false, RowWindowSortable* receipient = NULL, CWnd* parent = NULL);
	void Display(unsigned short stringColumnId, unsigned short numberColumnId, const CPoint& corner, unsigned int minValue, unsigned int maxValue, RowWindowSortable* receipient, unsigned int code, CWnd* parent, const CPoint& mousePoint);//, int x, int y, int w, int h)
	virtual bool isValueChanged() const override;
	virtual const char* GetRowValueAsString(const Row* row, char* buf, unsigned int bufsize) const override;
protected:
	virtual void SetInitialValue() override;
	virtual void UpdateInitialValue() override;
	virtual void FillControls() override;
	virtual void Apply() override;
	virtual void FinishDialog(int result) override;

	ListBoxStringUInt m_ListBoxSymbolNumber;
	UnsignedNumberTypeSpin<unsigned int> m_SpinNumber;
	unsigned int m_initialValue;
};

class TGUI_API DialogSymbolIntNumber : public DialogSymbolNumber
{
public:
	DialogSymbolIntNumber(TakionMainWnd* mainWnd, bool toDestroyOnFocus = false, bool listBoxSorted = false, RowWindowSortable* receipient = NULL, CWnd* parent = NULL);
	void Display(unsigned short stringColumnId, unsigned short numberColumnId, const CPoint& corner, int minValue, int maxValue, RowWindowSortable* receipient, unsigned int code, CWnd* parent, const CPoint& mousePoint);//, int x, int y, int w, int h)
	virtual bool isValueChanged() const override;
	virtual const char* GetRowValueAsString(const Row* row, char* buf, unsigned int bufsize) const override;
protected:
	virtual void SetInitialValue() override;
	virtual void UpdateInitialValue() override;
	virtual void FillControls() override;
	virtual void Apply() override;
	virtual void FinishDialog(int result) override;

	ListBoxStringInt m_ListBoxSymbolNumber;
//	SignedNumberTypeSpin<int, unsigned int> m_SpinNumber;
	SignedNumberTypeSpin<int> m_SpinNumber;
	int m_initialValue;
};

class TGUI_API DialogSymbolPrice : public DialogSymbolNumber
{
public:
	DialogSymbolPrice(TakionMainWnd* mainWnd, bool toDestroyOnFocus = false, bool listBoxSorted = false, RowWindowSortable* receipient = NULL, CWnd* parent = NULL);
	void Display(unsigned short stringColumnId, unsigned short numberColumnId, unsigned short altNumberColumnId, const CPoint& corner, unsigned __int64 minValue, unsigned __int64 maxValue, RowWindowSortable* receipient, unsigned int code, CWnd* parent, const CPoint& mousePoint);
	virtual bool isValueChanged() const override;
	virtual const char* GetRowValueAsString(const Row* row, char* buf, unsigned int bufsize) const override;
	static unsigned __int64 GetNumberFromPrice(const Price& price);
	static void GetPriceFromNumber(unsigned __int64 number, Price& price);
protected:
	virtual void SetInitialValue() override;
	virtual void UpdateInitialValue() override;
	virtual void FillControls() override;
	virtual void Apply() override;
	virtual void FinishDialog(int result) override;

	ListBoxStringPrice m_ListBoxSymbolPrice;
	UnsignedNumberTypeSpin<unsigned __int64> m_SpinPrice;
	unsigned __int64 m_initialValue;
	unsigned short m_altNumberColumnId;
};

class TGUI_API DialogSymbolDate : public DialogSymbolValue
{
public:
	DialogSymbolDate(TakionMainWnd* mainWnd, bool toDestroyOnFocus = false, bool listBoxSorted = false, RowWindowSortable* receipient = NULL, CWnd* parent = NULL);
//	void Display(unsigned short stringColumnId, unsigned short numberColumnId, unsigned short altNumberColumnId, const CPoint& corner, unsigned __int64 minValue, unsigned __int64 maxValue, RowWindowSortable* receipient, unsigned int code, CWnd* parent, const CPoint& mousePoint);
	void Display(unsigned short stringColumnId, unsigned short numberColumnId, unsigned short altNumberColumnId, const CPoint& corner, RowWindowSortable* receipient, unsigned int code, CWnd* parent, const CPoint& mousePoint);
	virtual bool isValueChanged() const override;
	virtual bool isEnableOkInitially() const override{return m_enableOkInitially;}
	virtual const char* GetRowValueAsString(const Row* row, char* buf, unsigned int bufsize) const override;
protected:
	virtual void SetInitialValue() override;
	virtual void UpdateInitialValue() override;
	virtual void FillControls() override;
	virtual void Apply() override;
	virtual void FinishDialog(int result) override;

	virtual void InitEntryControl() override;

	afx_msg void OnCalendarDropdown(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnCalendarCloseup(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnChangeDate(NMHDR *pNMHDR, LRESULT *pResult);
	DECLARE_MESSAGE_MAP()

	void SetDate(unsigned int date);
	unsigned int CalculateDate() const;
	void UpdateCurrentValue();
	void OnUpdateCurrentValue();

	ListBoxStringDate m_ListBoxSymbolDate;
	ColorDateTimeCtrl m_DateTime;
	unsigned int m_initialValue;
	unsigned int m_currentValue;
	unsigned short m_altNumberColumnId;

	bool m_enableOkInitially;
};

class ExtensionRow;

class TGUI_API ExtensionWindow : public RowWindowSortable
{
public:
	virtual const char* GetToolId() const override{return toolExtensionId;}

	enum ColumnId : unsigned short
	{
		EXT_NAME,
		EXT_PATH,
		EXT_VERSION,
		EXT_DESCRIPTION,
		EXT_ERROR,
		EXT_LOAD_ERROR,
		EXT_UNLOAD_ERROR,
		EXT_LOAD_TIME,
		EXT_UNLOAD_TIME,

		EXT_DATA_VERSION,
		EXT_DATA_HEADER_VERSION,
		EXT_OBSERVER_VERSION,
		EXT_OBSERVER_HEADER_VERSION,
		EXT_GUI_VERSION,
		EXT_GUI_HEADER_VERSION,
		EXT_TAKION_UTILS_VERSION,
		EXT_TAKION_UTILS_HEADER_VERSION,
		EXT_UTILS_VERSION,
		EXT_UTILS_HEADER_VERSION,
		EXT_TAKION_LOG_VERSION,
		EXT_TAKION_LOG_HEADER_VERSION,
		EXT_UGUI_VERSION,
		EXT_UGUI_HEADER_VERSION,
		EXT_RECEIVER_VERSION,
		EXT_RECEIVER_HEADER_VERSION,

		EXT_FOLDER,
		EXT_INFO,
		EXT_DEBUG,

		EXT_AUTO,

		EXT_COLUMN_COUNT
	};
	virtual unsigned short GetBuiltInColumnCount() const override{return EXT_COLUMN_COUNT;}
	virtual void toString(std::string& str, unsigned int contentModifier) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual void fromScratch() override;
//	virtual TakionTool* Clone() const;
	virtual void AddToSpecificToolCollection() override;

	virtual void UpdateDataGraphics(const Graphics* graphics) override;
	virtual bool UpdateDataGraphicsColorsCustom(const GraphicsColorCollection* colorCollection) override;
	virtual bool UpdateDataGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL) override;

	virtual Row* CreateRow(const void* object, bool potential) override;
//	virtual ExtensionDll* CreateExtensionObject(const char* absolutePath) const = 0;
	virtual bool HasDoubleClickAction() const override{return false;}
	virtual bool RowHasSecuritySymbol() const override{return false;}
	virtual bool HasPriceColumns() const override{return false;}
	virtual bool HasSizeColumns() const override{return false;}
	virtual bool HasMoneyColumns() const override{return false;}
	virtual bool isPlusMinusable() const override{return false;}
	virtual bool HasMillisecondColumns() const override{return true;}

//	bool LoadExtension(ExtensionDll* extension, bool displayError, bool existing);

	COLORREF GetColorLoaded() const{return m_colorLoaded;}
	COLORREF GetColorUnloaded() const{return m_colorUnloaded;}
	COLORREF GetColorWrongVersion() const{return m_colorWrongVersion;}
	COLORREF GetColorInvalid() const{return m_colorInvalid;}

	virtual bool CanHaveTotal() const override{return false;}

	void LoadSelected();
	void UnloadSelected();
	void ToggleLoadSelected();
protected:
	ExtensionWindow(const CBitmap* bitmap, unsigned int workspace, bool pinned = false);
	
	void Browse();
	void DisplayAutoloadSaveError(const char* title, const std::string& error, const std::string* path);

	virtual void BeforeDestroy() override;
	virtual void AddMenuItems(CMenu& menu) override;
	virtual void PostAddMenuItems(CMenu& menu) override;
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;

	virtual void RowDoubleClicked(Row* row, size_t ord, const CPoint& point) override;

	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;

	void AddLoadMenuItems(CMenu& popupMenu,
		bool startEnabled,
		bool stopEnabled,
		bool loadEnabled,
		bool unloadEnabled,
		bool saveLayoutEnabled,
		bool openLayoutEnabled,
		bool saveAsLayoutEnabled,
		bool restoreLayoutEnabled,
		bool openConfigEnabled);

	void Populate();

	COLORREF m_colorLoaded;
	COLORREF m_colorUnloaded;
	COLORREF m_colorWrongVersion;
	COLORREF m_colorInvalid;

	typedef std::vector<bool> BoolVector;
	typedef std::list<std::string> StringList;
	StringList m_extensionCommandVector;
	BoolVector m_checkableVector;
	unsigned int m_lastExtensionCommandId;
	int m_extensionCommandMenuWidth;
};

class TGUI_API ExtensionRow : public RowSortable
{
public:
	ExtensionRow(ExtensionWindow* parent, ExtensionDll* extension);
	virtual const void* GetBaseObject() const override{return m_extension;}
	virtual COLORREF GetRowColor() const override;
	virtual COLORREF GetCellColor(unsigned short columnId) const override;
	virtual bool UpdateRowColor() override;//should be called only inside a lock

	virtual RowValue* CreateCell(unsigned short id) override;

	ExtensionDll* GetExtension(){return m_extension;}
	const ExtensionDll* GetExtension() const{return m_extension;}

	virtual short DefaultCompare(const RowSortable& other) const override;

	DECLARE_NED_NEW
protected:
	ExtensionWindow* m_extensionWindow;
	ExtensionDll* m_extension;
	COLORREF m_rowColor;
};

class AlertRow;

class TGUI_API AlertWindow : public RowWindowSortable
{
public:
	AlertWindow(const CBitmap* bitmap, unsigned int workspace, bool pinned = false);

	virtual const char* GetToolId() const override{return toolAlertId;}

	const bool& isCancelActive() const{return m_cancelActive;}
	void SetCancelActive(bool active);

	enum ColumnId : unsigned short
	{
		ALR_SYMBOL,
		ALR_TYPE,
		ALR_DATE_CREATED,
		ALR_TIME_CREATED,
		ALR_PRICE,
		ALR_PRICE_FROM,
		ALR_EXPIRATION,
		ALR_TIME_TRIGGERED,
		ALR_NOTE,
		ALR_VOLUME,
		ALR_VALUE,
		ALR_VALUE_FROM,
		ALR_TIME,
		ALR_INVALID,

		ALR_IMBALANCE,
		ALR_IMBALANCE_FROM,

		ALR_POPUP,
		ALR_VOLUME_FROM,

		ALR_SIZE,
		ALR_SIZE_FROM,

		ALR_COLUMN_COUNT
	};
	virtual unsigned short GetBuiltInColumnCount() const override{return ALR_COLUMN_COUNT;}
	virtual void toString(std::string& str, unsigned int contentModifier) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual void fromScratch() override;
	virtual const char* GetSettingsTabPath(const CPoint& point) const override;
	virtual void AddToSpecificToolCollection() override;
	virtual void UpdateDataGraphics(const Graphics* graphics) override;

	virtual bool UpdateDataGraphicsColorsCustom(const GraphicsColorCollection* colorCollection) override;
	virtual bool UpdateDataGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL) override;

	virtual Row* CreateRow(const void* object, bool potential) override;
//	virtual ExtensionDll* CreateExtensionObject(const char* absolutePath) const = 0;
//	virtual bool HasDoubleClickAction() const{return false;}
//	virtual bool RowHasSecuritySymbol() const{return true;}
//	virtual bool HasPriceColumns() const{return true;}
	virtual bool HasMoneyColumns() const override{return false;}
	virtual bool HasVolumeColumns() const override{return true;}
	virtual bool isPlusMinusable() const override{return false;}
	virtual bool HasMillisecondColumns() const override{return true;}
	virtual bool CanLink() const override{return true;}
	virtual TakionTool* Clone() const override;

	bool isAlertSelectedForCancelling() const;

	const COLORREF& GetColorLive() const{return m_colorLive;}
	const COLORREF& GetColorTriggered() const{return m_colorTriggered;}

	virtual bool CanHaveTotal() const override{return false;}

//	void ClearAlerts();
	void ClearTriggeredAlerts();
	bool SetStatusFilter(const unsigned char filter, unsigned char& addFilter);
	void SwitchStatusFilter(const AlertStatus alertStatus);
	void AddStatusFilter(const unsigned char filter);
	void RemoveStatusFilter(const unsigned char filter);

	virtual bool CancelSelectedAlert() override;

	bool SetTypeFilter(const unsigned int filter, unsigned int& addFilter);
	void AddTypeFilter(const unsigned int filter);
	void RemoveTypeFilter(const unsigned int filter);
	void SwitchTypeFilter(const AlertType alertType);

	bool SetSymbolInvalidFilter(const unsigned char filter, unsigned char& addFilter);
	void AddSymbolInvalidFilter(const unsigned char filter);
	void RemoveSymbolInvalidFilter(const unsigned char filter);
	void SwitchSymbolInvalidFilter(const AlertSymbolInvalid alertSymbolInvalid);

	bool AlertPotentiallyBelongs(const Alert* alert) const;
	bool AlertStatusBelongs(const Alert* alert) const;
	bool AlertTypeBelongs(const Alert* alert) const;
	bool AlertSymbolInvalidBelongs(const Alert* alert) const;
	bool AlertBelongs(const Alert* alert) const;
	virtual bool ObjectPotentiallyBelongs(const void* object) const;
	virtual bool RowFiltersIn(const RowSortable* row) const;//should be called inside lock
	virtual unsigned char RowBelongs(const RowSortable* row) const;//should be called inside lock
	virtual unsigned char ExistingRowBelongs(const RowSortable* row) const;//should be called inside lock
	unsigned char AlertBelongingStatus(const Alert* alert) const;

	const unsigned __int64& GetSymbol() const{return m_symbol;}
	void SetSymbol(const unsigned __int64& symbol, bool forcePopulation);
	virtual void SetEquityNumericSymbol(const unsigned __int64& symbol, unsigned char basket, bool force, bool addToStockChain) override{if(basket == EST_STOCK)SetSymbol(symbol, false);}
	virtual void SetEquitySymbol(const char* symbol, unsigned char basket, bool force, bool addToStockChain) override{if(basket == EST_STOCK)SetSymbol(symbol ? U_RepresentStringAsUnsignedNumber<unsigned __int64>(symbol, sizeof(unsigned __int64) - 1) : 0, false);}
	virtual void OnUnlink() override;
	virtual void AppendWindowMenuInfo(std::string& menuText) const override
	{
		RowWindowSortable::AppendWindowMenuInfo(menuText);
		if(m_cancelActive)
		{
			menuText += " - ActCancel";
		}
		if(m_symbol)
		{
			menuText += " - ";
			menuText += (const char*)&m_symbol;
		}
	}

	typedef void (AlertRow::*FnPaintInfo)(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	typedef short (AlertRow::*FnCompare)(const AlertRow& other) const;
	bool AddAlertFunctions(unsigned short id, FnPaintInfo fnPaint, FnCompare fnCompare, FnCompare fnCompareAhead);
	inline const FnPaintInfo& GetFnPaintInfo(const unsigned short& id) const{return id < ALR_COLUMN_COUNT ? m_paintInfoFunction[id] : NULL;}
	inline const FnCompare& GetFnCompare(const unsigned short& id) const{return id < ALR_COLUMN_COUNT ? m_compareFunction[id] : NULL;}
	inline const FnCompare& GetFnCompareAhead(const unsigned short& id) const{return id < ALR_COLUMN_COUNT ? m_compareAheadFunction[id] : NULL;}

protected:
	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;
//	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
//	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
//	DECLARE_MESSAGE_MAP()

	bool AddRemoveAlert(Alert* alert);
	virtual void DoUpdateTitle() override;
	virtual void Repopulate() override;
	virtual void BeforeDestroy() override;
//	virtual void RowLeftClicked(Row* row, size_t ord, const CPoint& point) override;
	virtual void RowDoubleClicked(Row* row, size_t ord, const CPoint& point) override;
	virtual void AddDoubleClickActionMenuItems(CMenu& menu) override;
	virtual void AddMenuItems(CMenu& menu) override;
	virtual void PostAddMenuItems(CMenu& menu) override;
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;

	virtual bool Populate(bool remove) override;
	unsigned __int64 m_symbol;
	COLORREF m_colorLive;
	COLORREF m_colorTriggered;
	unsigned int m_typeFilter;
	unsigned char m_statusFilter;
	unsigned char m_symbolInvalidFilter;
	bool m_cancelActive;

	bool m_dblclkCancelAlert;
//	Alert* m_leftClickedAlert;

	FnPaintInfo m_paintInfoFunction[ALR_COLUMN_COUNT];
	FnCompare m_compareFunction[ALR_COLUMN_COUNT];
	FnCompare m_compareAheadFunction[ALR_COLUMN_COUNT];

	virtual void ActiveSymbolAboutToChange(const unsigned __int64& newActiveSymbol
#ifndef TAKION_NO_OPTIONS
		,const unsigned __int64& newActiveOptionBlock
#endif
		) override;
	virtual bool ActiveSymbolChanged();
//	COLORREF m_topActiveColor;
	RowSortableList m_topRowList;
};

class TGUI_API AlertRow : public RowSortable
{
public:
	AlertRow(AlertWindow* parent, Alert* alert, bool potential);
	virtual const void* GetBaseObject() const{return m_alert;}
	virtual COLORREF GetRowColor() const{return m_rowColor;}
//	virtual COLORREF GetCellColor(unsigned short columnId) const;
	virtual bool UpdateRowColor() override;

	virtual COLORREF GetCellColor(unsigned short columnId) const override;

	virtual RowValue* CreateCell(unsigned short id) override;

	Alert* GetAlert(){return m_alert;}
	const Alert* GetAlert() const{return m_alert;}

	virtual short DefaultCompare(const RowSortable& other) const override;

	virtual bool CompareFunction(const RowSortable& other, unsigned short sortId, short& ret) const override;
	virtual bool CompareFunctionAhead(const RowSortable& other, unsigned short sortId, short& ret) const override;
	virtual short PreCompare(const RowSortable& other) const override;
	virtual bool GetPaintTextInfo(unsigned short columnId, std::string& text, COLORREF& color) const override;//, UINT& horizontalJustification) const override;

	virtual const char* GetRowSecuritySymbol(const CPoint* point = NULL) const override;
	virtual const unsigned __int64& GetRowNumericSymbol() const override;

	void PaintSymbol(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareSymbol(const AlertRow& other) const;
/*
	void PaintType(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareType(const AlertRow& other) const;
	void PaintDateCreated(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareDateCreated(const AlertRow& other) const;
	void PaintTimeCreated(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareTimeCreated(const AlertRow& other) const;
	void PaintPriceTo(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short ComparePriceTo(const AlertRow& other) const;
	void PaintAlertExpiration(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareAlertExpiration(const AlertRow& other) const;
	void PaintNote(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareNote(const AlertRow& other) const;
	void PaintVolume(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareVolume(const AlertRow& other) const;
	void PaintValueTo(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareValueTo(const AlertRow& other) const;
	void PaintTime(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareTime(const AlertRow& other) const;
/**/
	DECLARE_NED_NEW
protected:
	AlertWindow* m_alertWindow;
	Alert* m_alert;
	COLORREF m_rowColor;
};

class TGUI_API RowWindowSortableAccount : public RowWindowSortable, public Observer
{
public:
	const Account* GetAccount(){return m_account;}

	unsigned char GetAllAccountsView() const{return m_allAccounts;}//0 - current account, 1 - all accounts, 2 - selected account
	void SetAllAccounts(unsigned char allAccounts);
	virtual bool CanShowAllAccounts() const{return false;}

	virtual void AccountDeleted(const Account* account) override;
	virtual void AllAccountsDeleted() override;
	virtual void NewAccount(const Account* account) override;

	virtual void CurrentAccountChanged(const Account* currentAccount) override;
	virtual void SetAccount(const Account* account);
	virtual void toString(std::string& str, unsigned int contentModifier) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual void fromScratch() override;
	virtual void CurrentAccountLoaded() override;
	virtual void AccountLoaded(const Account* account) override;
	virtual void AllAccountsLoaded() override;
	virtual void LoggedToExecutor() override;
	unsigned short GetHistoryLoadCode() const{return m_historyLoadCode;}
	const Position* GetPosition() const{return m_position;}
//	const PositionData* GetPosition() const{return m_position;}
//	const Position* GetAccountPosition() const{return m_position->GetAccountPosition();}
	virtual bool CanFilterBySymbol() const{return true;}
	const unsigned __int64& GetSymbol() const{return m_symbol;}
#ifndef TAKION_NO_OPTIONS
	const std::string& GetInstrumentSymbol() const{return m_instrumentSymbol;}
	const unsigned __int64& GetOptionKey() const{return m_optionKey;}
	const unsigned __int64& GetOptionBlock() const{return m_optionBlock;}
	const unsigned __int64& GetRootSymbol() const{return m_rootSymbol;}
#endif
	void SetSymbol(const unsigned __int64& underlierSymbol,//rootSymbol,
#ifndef TAKION_NO_OPTIONS
		const unsigned __int64& optionKey,//optionBlock,
#endif
		bool forcePopulation);
	virtual void SetEquityNumericSymbol(const unsigned __int64& symbol, unsigned char basket, bool force, bool addToStockChain) override;
	virtual void SetEquitySymbol(const char* symbol, unsigned char basket, bool force, bool addToStockChain) override;
	virtual void ConnectionDisconnected(unsigned int ipAddress, unsigned short port, unsigned int ipBindAddress, unsigned short bindPort, unsigned char connectionType, const char* connectionName) override;
	virtual void ConnectionConnected(unsigned int ipAddress, unsigned short port, unsigned int ipBindAddress, unsigned short bindPort, unsigned char connectionType, const char* connectionName) override;
	virtual void OnUnlink() override;
	virtual void AppendWindowMenuInfo(std::string& menuText) const override;
	virtual void AppendTitleInfo(std::string& info) const;
	const std::string& GetAccountId() const{return m_accountId;}
	unsigned int GetMenuAccountNameCount() const{return (unsigned int)m_menuAccountNames.size();}
	virtual bool CanPlayNewLineSound() const;
	unsigned int GetNextMenuId() const;
	virtual bool isContentsChangeOnAccountChange() const{return true;}
	const int& GetAccountMenuWidth() const{return m_accountMenuWidth;}
	virtual void AddAccountMergeMenu(CMenu& popupMenu){}

	const std::string& GetStockBasketName() const{return m_stockBasketName;}

//	const bool& isBasketFilter() const{return m_basketFilter;}
//	const StockBasketMap& GetStockBasketMap() const{return m_stockBasketMap;}
	const StockBasketMap* GetCommandToolStockBasketMap() const{return m_stockBasketMapPtr;}

//	virtual bool FillCommandToolBasketSymbols(StockBasketMap& stockBasketMap) const{return false;}//defined in the MmBox
//	virtual const StockBasketMap* GetCommandToolBasketSymbolsPtr() const{return NULL;}//defined in the MmBox

//	virtual void SetCommandToolBasketSymbols(const StockBasketMap& stockBasketMap) override;
	virtual void SetCommandToolStockBasketMap(const StockBasketMap* stockBasketMap) override;
	virtual void StockAddedToCommandToolBasket(const unsigned __int64& symbol) override;//not used
	virtual void StockRemovedFromCommandToolBasket(const unsigned __int64& symbol) override;
	virtual void StocksClearedFromCommandToolBasket() override;
protected:
	RowWindowSortableAccount(bool multiselect,
		const CBitmap* bitmap,
		unsigned int workspace,
		bool pinned = false,
		int minVisibleSize = 15,
		int minWidth = 20,
		int maxWidth = 0,
		int minHeight = 20,
		int maxHeight = 0,
		int minBorderWidth = 2,
		int maxBorderWidth = 2,
		const char* className = "TakionTool",
		int minTitleHeight = 0,
		int maxTitleHeight = 15,
		int titleHeight = 15);
//////////////////////
	void SetStockBasketName(const char* stockBasketName);//{m_stockBasketName = stockBasketName;}
	bool ClearStockBasket()
	{
		if(m_stockBasketMapPtr)
		{
			m_stockBasketMapPtr = NULL;
			m_stockBasketName.clear();
			return true;
		}
		return false;
/*
		m_basketFilter = false;
		m_stockBasketMap.RemoveAll();
*/
	}
/*
	bool SetBasketFilter(const bool& basketFilter)
	{
		if(basketFilter != m_basketFilter)
		{
			m_basketFilter = basketFilter;
			return true;
		}
		return false;
	}
	bool ClearStockBasketMap()
	{
		if(m_stockBasketMap.GetCount())
		{
			m_stockBasketMap.RemoveAll();
			return true;
		}
		return false;
	}

	bool AddStockToBasket(const unsigned __int64& numericSymbol)
	{
		if(!m_stockBasketMap.PLookup(numericSymbol))
		{
			m_stockBasketMap[numericSymbol] = 0;
			return true;
		}
		return false;
	}
	bool RemoveStockFromBasket(const unsigned __int64& numericSymbol)
	{
		return m_stockBasketMap.RemoveKey(numericSymbol) == TRUE;
	}
*/
/////////////////////////
	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;
//	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
//	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	afx_msg LRESULT OnSelectionMade(WPARAM w, LPARAM l);
	DECLARE_MESSAGE_MAP()

//	virtual void OnSuccessfulCreate();

	virtual void AllAccountsModeChanged(){}
//	virtual void UpdateCurrentAccount(){}
	virtual void DoUpdateTitle() override;

//	virtual void DoSetSymbol(unsigned __int64 symbol){m_symbol = symbol;}
	virtual void PreAddMenuItems(CMenu& menu) override;
	virtual void PostAddMenuItems(CMenu& menu) override;
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;
	virtual BOOL PreTranslateMessage(MSG* pMsg) override;

//	virtual void Repopulate(){}

	virtual void ViewAllAccountsChanged(bool remove){}

	void UpdateHistoryLoad();
	virtual bool UpdateHistoryLoadBkColor();
	virtual void AccountChanged(){}
	const Account* m_account;
	unsigned short m_historyLoadCode;
	COLORREF m_colorHistLoaded;
	COLORREF m_colorHistPending;
	COLORREF m_colorHistError;

	void SetPosition(const Position* position);
	const Position* m_position;
	unsigned __int64 m_symbol;
#ifndef TAKION_NO_OPTIONS
	std::string m_instrumentSymbol;
	unsigned __int64 m_optionKey;
	unsigned __int64 m_optionBlock;
	unsigned __int64 m_rootSymbol;
#endif

	std::string m_symbolBeingPassed;

	std::string m_stockBasketName;
	const StockBasketMap* m_stockBasketMapPtr;
//	StockBasketMap m_stockBasketMap;
//	bool m_basketFilter;

	unsigned char m_allAccounts;
	std::string m_accountId;
	int m_accountMenuWidth;
private:
	typedef std::vector<std::string> StringVector;
	StringVector m_menuAccountNames;
};

class TGUI_API CancelOrderWindow : public RowWindowSortableAccount
{
friend class TakionMainWnd;
public:
	virtual bool CanShowAllAccounts() const{return true;}
	const bool& isCancelPossible() const{return m_cancelPossible;}
	const bool& isCancelActive() const{return m_cancelActive;}
	void SetCancelPossible(bool possible);
	void SetCancelActive(bool active);
	virtual void toString(std::string& str, unsigned int contentModifier) const;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier);
	virtual Order* GetOrderFromRow(Row* row){return NULL;}
	virtual const Order* GetOrderFromRow(const Row* row) const{return NULL;}
	virtual Position* GetPositionFromRow(Row* row){return NULL;}
	virtual const Position* GetPositionFromRow(const Row* row) const{return NULL;}
	virtual void AppendWindowMenuInfo(std::string& menuText) const override
	{
		RowWindowSortableAccount::AppendWindowMenuInfo(menuText);
		if(m_cancelActive)
		{
			menuText += " - ActCancel";
		}
	}
	bool isOrderSelectedForCancelling() const;
	virtual void CancelSelectedOrder() override;
	virtual void ExecuteSelectedOrderInSimulation() override;
	void SelectedOrderNoMassCancel();
	void SelectedOrderUnpostpone();
	void SelectedOrderFire();//unsigned char tif);//enum TifType

	void SelectedOrderMakeGtc(bool gtc);

//	bool CancelReplaceSelectedOrder();
	inline void ReplaceSelectedOrder(const bool& replaceNative,
		const SignedPrice& replacePriceOffset,
		const bool& replacePriceOffsetPercent,
		const bool& replacePriceReverseForSell,
		const bool& marketOrder,
		const int& replaceSizeOffset,
		const bool& replaceSizeReverseForSell,
		const bool& preBorrow,
		const Price& preBorrowPrice,
		const bool& adjustable,
		const bool& adjustableOrderBox,
		const bool& adjustableOnly,
		const unsigned char& displaySizeMode,//0 - size fraction, 1 - round lot, 2 - no change
		const unsigned int& displaySize,
		const unsigned int& displaySizeFraction)
	{
		DoReplaceSelectedOrder(replaceNative,
			replacePriceOffset,
			replacePriceOffsetPercent,
			replacePriceReverseForSell,
			marketOrder,
			replaceSizeOffset,
			replaceSizeReverseForSell,
			preBorrow,
			preBorrowPrice,
			adjustable,
			adjustableOrderBox,
			adjustableOnly,
			displaySizeMode,//0 - size fraction, 1 - round lot, 2 - no change
			displaySize,
			displaySizeFraction,
			true);
	}
//	const COLORREF& GetTopActiveColor() const{return m_topActiveColor;}

	void SetCurrentOcoBySelectedOrder();
	void AddSelectedOcoOrders();
	void RemoveSelectedOcoOrders();
	void ClearSelectedOcoOrders();
protected:
	CancelOrderWindow(bool multiselect, const CBitmap* bitmap, unsigned int workspace, bool pinned = false, bool cancelPossible = false);

	void DoReplaceSelectedOrder(bool replaceNative,
		const SignedPrice& replacePriceOffset,
		bool replacePriceOffsetPercent,
		bool replacePriceReverseForSell,
		bool marketOrder,
		int replaceSizeOffset,
		bool replaceSizeReverseForSell,
		bool preBorrow,
		const Price& preBorrowPrice,
		bool adjustable,
		bool adjustableOrderBox,
		bool adjustableOnly,
		unsigned char displaySizeMode,//0 - size fraction, 1 - round lot, 2 - no change
		unsigned int displaySize,
		unsigned int displaySizeFraction,
		bool fromExtension);

	virtual void BeforeDestroy() override;
	virtual void AddMenuItems(CMenu& menu) override;
	virtual void PostAddMenuItems(CMenu& menu) override;
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;
//	virtual void RowLeftClicked(Row* row, size_t ord, const CPoint& point) override;
	virtual void RowDoubleClicked(Row* row, size_t ord, const CPoint& point) override;
	virtual void AddDoubleClickActionMenuItems(CMenu& menu) override;

	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;

//	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
//	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
//	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);

//	DECLARE_MESSAGE_MAP()

//	virtual void OrderDeleted(Order* order);

	bool m_cancelPossible;
	bool m_cancelActive;
//	virtual void PopulateAllAccounts(){}

	bool m_dblclkCancelOrder;
//	Order* m_leftClickedOrder;

//	COLORREF m_topActiveColor;
};

typedef std::set<unsigned int, lessUIntAsStr<unsigned int> > MnemonicSet;

class ExecutionRow;

class TGUI_API ExecutionWindow : public RowWindowSortableAccount
{
public:
	virtual const char* GetToolId() const override{return toolExecutionId;}
	virtual bool CanShowAllAccounts() const override{return true;}

	static void AddInventoryColumns(Columns* columns);

	unsigned int GetNextMenuId() const;

	virtual unsigned short GetSymbolColumn() const override{return EXE_SYMBOL;}

	enum ColumnId : unsigned short
	{
		EXE_SYMBOL,
		EXE_SIDE,
		EXE_SIZE,
		EXE_ORDER_SIZE,
		EXE_PRICE,
		EXE_LIMIT_PRICE,
		EXE_TIME_SENT,
		EXE_TIME_RECEIVED,
		EXE_DELAY,
		EXE_DESTINATION,
		EXE_MM,
		EXE_ID,
		EXE_PNL_CLOSED,
		EXE_REF,
		EXE_ORDER_ID,
		EXE_TRADER_ID,
		EXE_BORROW,
		EXE_ERRONEOUS_SHARES,
		EXE_LIQUIDITY,
		EXE_ORIGIN,
		EXE_ACCOUNT_NAME,
		EXE_REMAINING_SIZE,
		EXE_POSITION_PNL_MARKED,
		EXE_ACCOUNT_PNL_MARKED,
		EXE_POSITION_SIZE,
		EXE_POSITION_PRICE,
		EXE_ROUTING,
		EXE_SHARES_TRADED_POSITION,
		EXE_SHARES_TRADED_ACCOUNT,
		EXE_ACCOUNT_USER_NAME,
		EXE_USER_TYPE,
		EXE_USER_INFO,
		EXE_USER_ID,
		EXE_PARENT_ID,
		EXE_POSITION_PNL_CLOSED,
		EXE_ACCOUNT_PNL_CLOSED,
		EXE_PNL_CLOSED_COST,
		EXE_DROPCOPY,
		EXE_BUSTED,
		EXE_ORDER_MNEMONIC,

		EXE_FIRM_SIDE,

		EXE_IP_SENT_FROM,

		EXE_REPLACED_ID,

		EXE_SEND_ID,

		EXE_CLIENT_ID,

		EXE_ADDED_LIQUIDITY,

		EXE_SIZE_ADDED,
		EXE_SIZE_REMOVED,
		EXE_NET_PERCENT,

		EXE_SUPERVISOR_AUTO_CLOSE,
		EXE_2_LETTER_LIQUIDITY_FORMAT,

#ifndef TAKION_NO_OPTIONS
		EXE_COLUMN_NO_OPT_COUNT,

		EXE_OPT_SUFFIX = EXE_COLUMN_NO_OPT_COUNT,
		EXE_OPT_CALL_PUT,
		EXE_OPT_EXPIRATION_DATE,
		EXE_OPT_STRIKE_PRICE,
		EXE_OPT_EXPIRATION_TYPE,
		EXE_OPT_EXPIRATION_DAYS,
		EXE_OPT_CONTRACT_SIZE,
#endif
		EXE_COLUMN_COUNT
	};
	virtual unsigned short GetBuiltInColumnCount() const override{return EXE_COLUMN_COUNT;}
	virtual void toString(std::string& str, unsigned int contentModifier) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual void fromScratch() override;
//	virtual TakionTool* Clone() const;
	virtual void AddToSpecificToolCollection() override;

	virtual void UpdateDataGraphics(const Graphics* graphics) override;
	virtual bool UpdateDataGraphicsColorsCustom(const GraphicsColorCollection* colorCollection) override;
	virtual bool UpdateDataGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL) override;
	void UpdateDataColors();

	virtual Row* CreateRow(const void* object, bool potential) override;

	typedef void (ExecutionRow::*FnPaintInfo)(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	typedef short (ExecutionRow::*FnCompare)(const ExecutionRow& other) const;
/*
	bool AddExecutionFunctions(unsigned short id, FnPaintInfo fnPaint, FnCompare fnCompare, FnCompare fnCompareAhead);
	inline const FnPaintInfo& GetFnPaintInfo(unsigned short id) const{return id < EXE_COLUMN_COUNT ? m_paintInfoFunction[id] : NULL;}
	inline const FnCompare& GetFnCompare(unsigned short id) const{return id < EXE_COLUMN_COUNT ? m_compareFunction[id] : NULL;}
	inline const FnCompare& GetFnCompareAhead(unsigned short id) const{return id < EXE_COLUMN_COUNT ? m_compareAheadFunction[id] : NULL;}
*/
	virtual bool CanLink() const override{return true;}

	bool ExecutionSideBelongs(const Execution* execution) const;//no need to call inside lock, because Execution does not change
	bool ExecutionBorrowBelongs(const Execution* execution) const;//no need to call inside lock, because Execution does not change
	bool ExecutionAutoCloseBelongs(const Execution* execution) const;//no need to call inside lock, because Execution does not change
	bool ExecutionMnemonicBelongs(const Execution* execution) const;//no need to call inside lock, because Execution does not change
	bool ExecutionBelongs(const Execution* execution) const;//no need to call inside lock, because Execution does not change
	
	virtual bool AccountBelongs(const Account* account) const;
	virtual bool ObjectPotentiallyBelongs(const void* object) const override;//no need to call inside lock, because Execution does not change
	virtual bool RowFiltersIn(const RowSortable* row) const override;//no need to call inside lock, because Execution does not change
	virtual unsigned char RowBelongs(const RowSortable* row) const override;//no need to call inside lock, because Execution does not change
/*
	virtual const COLORREF& GetColorBuy() const{return m_colorBuy;}
	virtual const COLORREF& GetColorSell() const{return m_colorSell;}
	virtual const COLORREF& GetColorSellShort() const{return m_colorShort;}
*/
	virtual const COLORREF& GetBuyColor() const override{return m_colorBuy;}
	virtual const COLORREF& GetSellColor() const override{return m_colorSell;}
	virtual const COLORREF& GetShortColor() const override{return m_colorShort;}

	virtual const COLORREF& GetBustedBuyColor() const override{return m_colorBustedBuy;}
	virtual const COLORREF& GetBustedSellColor() const override{return m_colorBustedSell;}

	virtual const COLORREF& GetBuyOpenColor() const override{return m_colorBuyOpen;}
	virtual const COLORREF& GetBuyClosedColor() const override{return m_colorBuyClosed;}
	virtual const COLORREF& GetShortOpenColor() const override{return m_colorShortOpen;}
	virtual const COLORREF& GetSellClosedColor() const override{return m_colorSellClosed;}

	unsigned int GetExecutionSideFilter() const{return m_executionSideFilter;}
	bool SetExecutionSideFilter(unsigned int executionSideFilter, unsigned int& addFilter);
	void AddExecutionSideFilter(unsigned int filter);
	void RemoveExecutionSideFilter(unsigned int filter);
	void SwitchExecutionSideFilter(OrderSide orderSide);

#ifndef TAKION_NO_OPTIONS
	virtual unsigned short GetNoOptionBuiltInColumnCount() const override{return EXE_COLUMN_NO_OPT_COUNT;}
	unsigned int GetInstrumentFilter() const{return m_instrumentFilter;}
	bool SetInstrumentFilter(unsigned int instrumentFilter, unsigned int& addFilter);
	void AddInstrumentFilter(unsigned int filter);
	void RemoveInstrumentFilter(unsigned int filter);
	void SwitchInstrumentFilter(SecurityType instrument);
	bool ExecutionInstrumentBelongs(const Execution* execution) const;//no need to call inside lock, because Execution does not change
#endif

	const unsigned int& GetExecutionBorrowFilter() const{return m_executionBorrowFilter;}
	bool SetExecutionBorrowFilter(unsigned int executionBorrowFilter, unsigned int& addFilter);
	void AddExecutionBorrowFilter(unsigned int filter);
	void RemoveExecutionBorrowFilter(unsigned int filter);
	void SwitchExecutionBorrowFilter(OrderBorrow orderBorrow);

	const unsigned int& GetExecutionAutoCloseFilter() const{return m_executionAutoCloseFilter;}
	bool SetExecutionAutoCloseFilter(unsigned int executionAutoCloseFilter, unsigned int& addFilter);
	void AddExecutionAutoCloseFilter(unsigned int filter);
	void RemoveExecutionAutoCloseFilter(unsigned int filter);
	void SwitchExecutionAutoCloseFilter(unsigned int filter);

	const unsigned int& GetMnemonicFilter() const{return m_mnemonicFilter;}
	bool SetMnemonicFilter(unsigned int mnemonicFilter, unsigned int& addFilter);
	void AddMnemonicFilter(unsigned int filter);
	void RemoveMnemonicFilter(unsigned int filter);
	void SwitchMnemonicFilter(unsigned char yesNoFilter);
	void FilterMnemonicRemoved(unsigned int mnemonic);

	virtual bool HasMillisecondColumns() const override{return true;}
	virtual bool HasVolumeColumns() const override{return true;}

//	const COLORREF& GetTopActiveColor() const{return m_topActiveColor;}

	virtual bool hasInventoryView() const override{return true;}

	virtual void StockAddedToCommandToolBasket(const unsigned __int64& symbol) override;
//	virtual void StockRemovedFromCommandToolBasket(const unsigned __int64& symbol) override;
protected:
	ExecutionWindow(const CBitmap* bitmap, unsigned int workspace, bool pinned = false);

	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;
//	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
//	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
//	DECLARE_MESSAGE_MAP()

	virtual void SecurityDoubleClicked(UINT nFlags, const CPoint& point) override;

	virtual RowTotal* CreateRowTotal() override;
//	virtual void DoSetSymbol(unsigned __int64 symbol);
	virtual void Repopulate() override;
	virtual void BeforeDestroy() override;
	virtual void AccountChanged() override;
	virtual void ViewAllAccountsChanged(bool remove) override;
	virtual void AddMenuItems(CMenu& menu) override;
//	virtual void PostAddMenuItems(CMenu& menu);
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;

	virtual void OnSuccessfulCreate() override;

	virtual bool Populate(bool remove) override;
	bool PopulateAllAccounts();
	bool PopulateOneAccount(const Account* account, const Position* position);
	unsigned int m_executionSideFilter;
#ifndef TAKION_NO_OPTIONS
	unsigned int m_instrumentFilter;
#endif
	unsigned int m_executionBorrowFilter;
	unsigned int m_executionAutoCloseFilter;
	unsigned int m_mnemonicFilter;
	MnemonicSet m_mnemonicFilterSet;
	MnemonicSet::const_iterator m_mnemonicFilterSetEnd;

	COLORREF m_colorBuy;
	COLORREF m_colorSell;
	COLORREF m_colorShort;

	COLORREF m_colorBustedBuy;
	COLORREF m_colorBustedSell;

	COLORREF m_colorBuyOpen;
	COLORREF m_colorBuyClosed;
	COLORREF m_colorShortOpen;
	COLORREF m_colorSellClosed;
/*
	FnPaintInfo m_paintInfoFunction[EXE_COLUMN_COUNT];
	FnCompare m_compareFunction[EXE_COLUMN_COUNT];
	FnCompare m_compareAheadFunction[EXE_COLUMN_COUNT];

*/
	virtual void ActiveSymbolAboutToChange(const unsigned __int64& newActiveSymbol
#ifndef TAKION_NO_OPTIONS
		,const unsigned __int64& newActiveOptionBlock
#endif
		) override;
	virtual bool ActiveSymbolChanged() override;
//	COLORREF m_topActiveColor;
	RowSortableList m_topRowList;
};

class TGUI_API ExecutionRow : public
#ifdef SECONDARY_ROWS
	RowSortableChild
#else
	RowSortable
#endif
{
public:
	ExecutionRow(RowWindowSortable* parent, Execution* execution
#ifdef SECONDARY_ROWS
		, RowSortable* parentRow = NULL
#endif
		);
	virtual const void* GetBaseObject() const override{return m_execution;}
	virtual bool GetPaintTextInfo(unsigned short columnId, std::string& text, COLORREF& color) const override;//, UINT& horizontalJustification) const override;
	virtual COLORREF GetRowColor() const override;
	virtual COLORREF GetCellColor(unsigned short columnId) const override;

	virtual RowValue* CreateCell(unsigned short id) override;

	virtual bool hasInventory() const override{return m_execution && m_execution->GetInventory() != NULL;}
	virtual const PositionData* GetRowPosition(const CPoint* point = NULL) const override
	{
		if(m_execution)
		{
			const Order* order = m_execution->GetOrder();
			if(order)return order->GetPosition();
		}
		return NULL;
	}
	Execution* GetExecution(){return m_execution;}
	const Execution* GetExecution() const{return m_execution;}

	virtual const Account* GetRowAccount() const override{return GetOrder()->GetAccount();}

	Order* GetOrder(){return m_execution->GetOrder();}
	const Order* GetOrder() const{return m_execution->GetOrder();}

//	Position* GetPosition(){return GetOrder()->GetPosition();}
	const Position* GetPosition() const{return GetOrder()->GetPosition();}

//	virtual short Compare(const RowSortable& other) const;
//	virtual short CompareAhead(const RowSortable& other) const;
	virtual short DefaultCompare(const RowSortable& other) const override;

	virtual bool CompareFunction(const RowSortable& other, unsigned short sortId, short& ret) const override;
	virtual bool CompareFunctionAhead(const RowSortable& other, unsigned short sortId, short& ret) const override;
	virtual short PreCompare(const RowSortable& other) const override;
/*
	virtual bool Lock() const override;
	virtual void LockWait() const override;
	virtual void Unlock() const override;
*/
//	virtual void Update(bool dynamicOnly);
//	virtual bool UpdateRowColor();

	DECLARE_NED_NEW

	virtual const char* GetRowSecuritySymbol(const CPoint* point = NULL) const override{return m_execution ? m_execution->GetSymbol() : NULL;}
	virtual const unsigned __int64& GetRowNumericSymbol() const{return m_execution ? m_execution->GetNumericSymbol() : uint64Zero;}

	void PaintSymbol(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareSymbol(const ExecutionRow& other) const;
	void PaintSide(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareSide(const ExecutionRow& other) const;

//	void PaintSize(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
//	short CompareSize(const ExecutionRow& other) const;
	void PaintLimitPrice(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareLimitPrice(const ExecutionRow& other) const;
	void PaintPrice(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short ComparePrice(const ExecutionRow& other) const;
	void PaintExecNetPercent(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareExecNetPercent(const ExecutionRow& other) const;
	void PaintTimeSent(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareTimeSent(const ExecutionRow& other) const;
	void PaintTimeReceived(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareTimeReceived(const ExecutionRow& other) const;
	void PaintDelay(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareDelay(const ExecutionRow& other) const;
	void PaintVenue(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareVenue(const ExecutionRow& other) const;
	void PaintRouting(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareRouting(const ExecutionRow& other) const;
	void PaintMnemonic(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareMnemonic(const ExecutionRow& other) const;
	void PaintMmid(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareMmid(const ExecutionRow& other) const;
	void PaintRef(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareRef(const ExecutionRow& other) const;
	void PaintOrderId(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareOrderId(const ExecutionRow& other) const;
	void PaintTraderId(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareTraderId(const ExecutionRow& other) const;

//	void PaintBorrow(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
//	short CompareBorrow(const ExecutionRow& other) const;

	void PaintLiquidity(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareLiquidity(const ExecutionRow& other) const;
	void PaintAddedLiquidity(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareAddedLiquidity(const ExecutionRow& other) const;
	void PaintOrigin(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareOrigin(const ExecutionRow& other) const;
	void PaintAccountName(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareAccountName(const ExecutionRow& other) const;
	void PaintRemainingQuantity(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareRemainingQuantity(const ExecutionRow& other) const;
	void PaintOrderSize(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareOrderSize(const ExecutionRow& other) const;
	void PaintSharesTradedPosition(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareSharesTradedPosition(const ExecutionRow& other) const;
	void PaintSharesTradedAccount(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareSharesTradedAccount(const ExecutionRow& other) const;
	void PaintAccountUserName(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareAccountUserName(const ExecutionRow& other) const;

	void PaintUserType(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareUserType(const ExecutionRow& other) const;
	void PaintUserInfo(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareUserInfo(const ExecutionRow& other) const;
	void PaintUserOrderId(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareUserOrderId(const ExecutionRow& other) const;
	void PaintParentId(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareParentId(const ExecutionRow& other) const;
	void PaintDropcopy(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareDropcopy(const ExecutionRow& other) const;
	void PaintBusted(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareBusted(const ExecutionRow& other) const;
	void PaintReplacedId(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareReplacedId(const ExecutionRow& other) const;
	void PaintSendId(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareSendId(const ExecutionRow& other) const;
	void PaintId(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareId(const ExecutionRow& other) const;
	void PaintClientId(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareClientId(const ExecutionRow& other) const;
#ifdef FIRM_VALUES
	void PaintFirmSide(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareFirmSide(const ExecutionRow& other) const;
#endif
	void PaintIpOrderSentFrom(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareIpOrderSentFrom(const ExecutionRow& other) const;
#ifndef TAKION_NO_OPTIONS
//	void PaintSuffix(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
//	short CompareSuffix(const ExecutionRow& other) const;
	void PaintCall(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareCall(const ExecutionRow& other) const;
	void PaintExpiration(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareExpiration(const ExecutionRow& other) const;
	void PaintExpirationDays(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareExpirationDays(const ExecutionRow& other) const;
	void PaintStrike(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareStrike(const ExecutionRow& other) const;
	void PaintExpirationType(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareExpirationType(const ExecutionRow& other) const;
#endif
protected:
//	ExecutionWindow* m_executionWindow;
	Execution* m_execution;

//	COLORREF m_executionColor;
};

class TGUI_API ExecutionRowTotal : public RowTotal
{
public:
	ExecutionRowTotal(ExecutionWindow* window):
		RowTotal(ExecutionWindow::EXE_COLUMN_COUNT, window)
	{
	}
//protected:
//	virtual void UpdateNonCumulativeValues(const Row* row, bool dynamicOnly);
//	virtual void ResetNonCumulativeValues();
};

enum OrderFilter : unsigned char
{
	OF_PENDING,
	OF_CANCELED,
	OF_FILLED,
	OF_REJECTED,
	OF_ALGORITHM,
	OF_KICKED,
	OF_BLOCKED,

	OF_COUNT
};
/*
enum OrderSideFilter : unsigned char
{
	OSF_BUY,
	OSF_SELL,
	OSF_SHORT,

	OSF_COUNT
};
*/

class OrderRow;

class TGUI_API OrderWindow : public CancelOrderWindow
{
public:
//	virtual ~OrderWindow(){DestroyPotentialRows();}
	virtual const char* GetToolId() const override{return toolOrderId;}

	virtual Order* GetOrderFromRow(Row* row) override;
	virtual const Order* GetOrderFromRow(const Row* row) const override;

	static void AddInventoryColumns(Columns* columns);

#ifdef SECONDARY_ROWS
//	virtual const Columns* GetExecutionColumns() const{return m_secondaryColumns;}
	virtual const char* GetSecondaryToolId() const{return toolExecutionId;}
//	virtual const char* GetSecondaryColumnsMenuName() const{return "Executions";}
	virtual void UpdateSecondaryDataGraphics(const Graphics* graphics);
/*OrderWindow already has these colors that are going to be used for Execution secondary rows
	virtual const COLORREF& GetBuyColor() const{return m_colorBuy;}
	virtual const COLORREF& GetSellColor() const{return m_colorSell;}
	virtual const COLORREF& GetShortColor() const{return m_colorShort;}
*/
	bool ExecutionBelongs(const Execution* execution) const;
//	bool ExecutionPotentiallyBelongs(const Execution* execution) const;
	unsigned char ExecutionBelongingStatus(const Execution* execution) const;//0 - not belonging, 1 - potentially belonging, 2 - belonging
	unsigned char ExistingExecutionBelongingStatus(const Execution* execution) const;//0 - not belonging, 1 - potentially belonging, 2 - belonging

	virtual bool SecondaryObjectPotentiallyBelongs(const void* object) const override;//no need to call inside lock
	virtual bool SecondaryRowFiltersIn(const RowSortable* row) const override;//should be called inside lock
	virtual unsigned char SecondaryRowBelongs(const RowSortable* row) const override;//2 - belongs; 1 - does not belong but can update to become belonging; 0 - does not belong and cannot update to become belonging
	virtual unsigned char SecondaryExistingRowBelongs(const RowSortable* row) const override;//2 - belongs; 1 - does not belong but can update to become belonging; 0 - does not belong and cannot update to become belonging

	virtual bool ExpandRow(Row* row) override;
	virtual RowSortable* CreateSecondaryRow(const void* object, bool potential, RowSortable* parentRow) override;
/*
	virtual bool SecondaryRowFiltersIn(const RowSortable* row) const{return true;}//should be called inside lock
	virtual unsigned char SecondaryRowBelongs(const RowSortable* row) const//2 - belongs; 1 - does not belong but can update to become belonging; 0 - does not belong and cannot update to become belonging
	{
		const RowSortable* parentRow = row->GetParentSortableRow();
		return parentRow ? RowBelongs(parentRow) : 0;
	}
	virtual unsigned char SecondaryExistingRowBelongs(const RowSortable* row) const//2 - belongs; 1 - does not belong but can update to become belonging; 0 - does not belong and cannot update to become belonging
	{
		const RowSortable* parentRow = row->GetParentSortableRow();
		return parentRow ? ExistingRowBelongs(parentRow) : 0;
	}
*/
#endif
	unsigned int GetNextMenuId() const;
	virtual unsigned short GetSymbolColumn() const override{return ORD_SYMBOL;}
	enum ColumnId : unsigned short
	{
		ORD_SYMBOL,
		ORD_SIDE,
		ORD_SIZE,
		ORD_LIMIT_PRICE,
		ORD_BP_USED,
		ORD_EXEC_PRICE,
		ORD_SERVER_ID,
		ORD_CLIENT_ID,
		ORD_TIME_CREATED,
		ORD_TIME_CANCEL_SENT,
		ORD_TIME_DEAD,
		ORD_DELAY_SERVER,
		ORD_DELAY_MARKET,
		ORD_DESTINATION,
		ORD_STATUS,
		ORD_REMAINING_SIZE,
		ORD_EXECUTED_SIZE,
		ORD_CANCELED_SIZE,
		ORD_REJECTED_SIZE,
		ORD_PNL_CLOSED,
		ORD_REJECT_CODE,
		ORD_REJECT_TEXT,
		ORD_MARKET_REF,
		ORD_TRADER_ID,
		ORD_TIF,
		ORD_RESERVE,
		ORD_ISO,
		ORD_DISPLAY_SIZE,
		ORD_ALGORITHM,
		ORD_TIME_CANCEL_REJECTED,
		ORD_PEG_TYPE,
		ORD_PEG_OFFSET,
		ORD_ORIGIN,
		ORD_DISCRETIONARY_PRICE,
		ORD_STOP_PRICE,
		ORD_ODD_LOT,
		ORD_ODD_LOT_CREATED,
		ORD_BORROW,
		ORD_ROUTING,
		ORD_MNEMONIC,
		ORD_PARENT_ID,
		ORD_IMBALANCE_ONLY,
		ORD_AGGRESSIVE,
		ORD_ACCOUNT_NAME,

		ORD_STOP_TYPE,
		ORD_STOP_BASE,

		ORD_POSITION_PNL_MARKED,
		ORD_ACCOUNT_PNL_MARKED,

		ORD_USER_TYPE,
		ORD_USER_INFO,

		ORD_SHARES_BEING_CANCELED,
		ORD_POSITION_SIZE,

		ORD_ACCOUNT_USER_NAME,

		ORD_USER_ID,

		ORD_POSITION_PNL_CLOSED,
		ORD_ACCOUNT_PNL_CLOSED,

		ORD_TIME_TO_EXPIRE,

		ORD_CANCEL_REJECT_CODE,

		ORD_STUCK,
		ORD_CANCEL_BLOCKED,

		ORD_PNL_CLOSED_COST,

		ORD_DROPCOPY,

		ORD_TIME_SENT,

		ORD_SUB_TYPE,

		ORD_NIGHT_ORDER,

		ORD_NON_CANCELABLE,

		ORD_CHRONOLOGICAL_ID,

		ORD_FIRM_SIDE,

		ORD_OPENING,
		ORD_DMA,

		ORD_IP_SENT_FROM,
		ORD_IP_CANCEL_FROM,

		ORD_SPLIT_PARENT_ID,

		ORD_DAY_VOLUME,
		ORD_YESTERDAY_VOLUME,

		ORD_OCO_ID,

		ORD_AVERAGE_DAILY_VOLUME,

		ORD_CANCEL_REJECT_TEXT,

		ORD_REPLACED_ID,
		ORD_REPLACED_BY_ID,

		ORD_ACTIVATE_TIME,

		ORD_SEND_ID,

		ORD_SPLIT_CHILD_ID,

		ORD_BID,
		ORD_ASK,
		ORD_LAST_PRICE,
		ORD_INITIAL_STOP_PRICE,

		ORD_REPLACING_SIZE,

		ORD_REPLACING_NATIVELY,

		ORD_SENT_TIF,

		ORD_DATE_GTC_CREATED,
		ORD_TIME_GTC_CREATED,
		ORD_REMAINING_INITIAL_SIZE,

		ORD_DESTINATION_ID,

		ORD_MIN_DISPLAY_SIZE,
		ORD_MAX_DISPLAY_SIZE,
		ORD_REMAINING_DISPLAY_SIZE,
		ORD_INITIAL_DISPLAY_SIZE,

		ORD_KICKED,

		ORD_REPLACED_BY_SEND_ID,

		ORD_BLOCKED,

		ORD_RESIZE_TO_CLOSE,

		ORD_FROM_EXTENSION,

		ORD_STAGE,

		ORD_NET_PERCENT,

		ORD_PASSIVE,

		ORD_BETA_BP_USED,
		ORD_DIRECTION,
		ORD_POS_SIZE,

		ORD_SECURITY_CLOSE_PRICE,

		ORD_SUPERVISOR_AUTO_CLOSE,

		ORD_INITIAL_DIRECTION,

		ORD_CLOSE_ONLY,

		ORD_INITIAL_TIF,

		ORD_INHERITED_EXECUTED_SIZE,

		ORD_DQUOTE,

		ORD_ME_USED,

#ifndef TAKION_NO_OPTIONS
		ORD_COLUMN_NO_OPT_COUNT,

		ORD_OPT_SUFFIX = ORD_COLUMN_NO_OPT_COUNT,
		ORD_OPT_CALL_PUT,
		ORD_OPT_EXPIRATION_DATE,
		ORD_OPT_STRIKE_PRICE,
		ORD_OPT_EXPIRATION_TYPE,
		ORD_OPT_EXPIRATION_DAYS,
		ORD_OPT_CONTRACT_SIZE,
#endif
		ORD_COLUMN_COUNT
	};
	virtual unsigned short GetBuiltInColumnCount() const override{return ORD_COLUMN_COUNT;}
	virtual unsigned short GetOrderBuiltInColumnCount() const override{return GetBuiltInColumnCount();}
#ifdef SECONDARY_ROWS
	virtual unsigned short GetSecondaryBuiltInColumnCount() const override{return ExecutionWindow::EXE_COLUMN_COUNT;}
#endif
	virtual unsigned short GetAdditionalColumnCount() const override;

	virtual void toString(std::string& str, unsigned int contentModifier) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual void fromScratch() override;
//	virtual TakionTool* Clone() const;
	virtual void AddToSpecificToolCollection() override;
	virtual void UpdateDataGraphics(const Graphics* graphics) override;

	virtual bool UpdateDataGraphicsColorsCustom(const GraphicsColorCollection* colorCollection) override;
	virtual bool UpdateDataGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL) override;
	void UpdateDataColors();

	virtual bool CanLink() const override{return true;}

#ifndef TAKION_NO_OPTIONS
	virtual unsigned short GetNoOptionBuiltInColumnCount() const override{return ORD_COLUMN_NO_OPT_COUNT;}
#ifdef SECONDARY_ROWS
	virtual unsigned short GetSecondaryNoOptionBuiltInColumnCount() const override{return ExecutionWindow::EXE_COLUMN_NO_OPT_COUNT;}
#endif
	unsigned int GetInstrumentFilter() const{return m_instrumentFilter;}
	bool SetInstrumentFilter(unsigned int instrumentFilter, unsigned int& addFilter);
	bool OrderInstrumentBelongs(const Order* order) const;
	void AddInstrumentFilter(unsigned int filter);
	void RemoveInstrumentFilter(unsigned int filter);
	void SwitchInstrumentFilter(SecurityType instrument);
#endif

	const unsigned int& GetOrderBorrowFilter() const{return m_orderBorrowFilter;}
	bool SetOrderBorrowFilter(unsigned int orderBorrowFilter, unsigned int& addFilter);

	const unsigned int& GetOrderMnemonicFilter() const{return m_orderMnemonicFilter;}
	bool SetOrderMnemonicFilter(unsigned int orderMnemonicFilter, unsigned int& addFilter);
	void FilterMnemonicRemoved(unsigned int mnemonic);

	const unsigned int& GetSupervisorAutoCloseFilter() const{return m_supervisorAutoCloseFilter;}
	bool SetSupervisorAutoCloseFilter(unsigned int supervisorAutoCloseFilter, unsigned int& addFilter);

	const unsigned int& GetOrderPostponedFilter() const{return m_orderPostponedFilter;}
	bool SetOrderPostponedFilter(unsigned int orderPostponedFilter, unsigned int& addFilter);

	const unsigned int& GetOrderUserTypeFilter() const{return m_orderUserTypeFilter;}
	bool SetOrderUserTypeFilter(unsigned int orderUserTypeFilter, unsigned int& addFilter);

	const unsigned int& GetOrderStopTypeFilter() const{return m_orderStopTypeFilter;}
	bool SetOrderStopTypeFilter(unsigned int orderStopTypeFilter, unsigned int& addFilter);

	const unsigned int& GetOrderDirectionFilter() const{return m_orderDirectionFilter;}
	bool SetOrderDirectionFilter(unsigned int orderDirectionFilter, unsigned int& addFilter);

	const unsigned int& GetOrderTifFilter() const{return m_orderTifFilter;}
	bool SetOrderTifFilter(unsigned int orderTifFilter, unsigned int& addFilter);

	const unsigned int& GetOrderFilter() const{return m_orderFilter;}
	bool SetOrderFilter(unsigned int orderFilter, unsigned int& addFilter);

	const unsigned int& GetOrderSideFilter() const{return m_orderSideFilter;}
	bool SetOrderSideFilter(unsigned int orderSideFilter, unsigned int& addFilter);

	void AddOrderFilter(unsigned int filter);
	void RemoveOrderFilter(unsigned int filter);
	void AddOrderSideFilter(unsigned int filter);
	void RemoveOrderSideFilter(unsigned int filter);
	void AddOrderBorrowFilter(unsigned int filter);
	void RemoveOrderBorrowFilter(unsigned int filter);

	void AddOrderMnemonicFilter(unsigned int filter);
	void RemoveOrderMnemonicFilter(unsigned int filter);

	void AddSupervisorAutoCloseFilter(unsigned int filter);
	void RemoveSupervisorAutoCloseFilter(unsigned int filter);

	void AddOrderPostponedFilter(unsigned int filter);
	void RemoveOrderPostponedFilter(unsigned int filter);
	void AddOrderUserTypeFilter(unsigned int filter);
	void RemoveOrderUserTypeFilter(unsigned int filter);

	void AddOrderStopTypeFilter(unsigned int filter);
	void RemoveOrderStopTypeFilter(unsigned int filter);

	void AddOrderDirectionFilter(unsigned int filter);
	void RemoveOrderDirectionFilter(unsigned int filter);

	void AddOrderTifFilter(unsigned int filter);
	void RemoveOrderTifFilter(unsigned int filter);

	void SwitchOrderSideFilter(OrderSide orderSide);
	void SwitchOrderFilter(OrderFilter orderFilter);
	void SwitchOrderBorrowFilter(OrderBorrow orderBorrow);
	void SwitchOrderMnemonicFilter(unsigned char yesNoFilter);
	void SwitchSupervisorAutoCloseFilter(unsigned char yesNoFilter);
	void SwitchOrderPostponedFilter(OrderPostponed orderPostponed);
	void SwitchOrderUserTypeFilter(OrderUserType orderUserType);
	void SwitchOrderStopTypeFilter(OrderStopType orderStopType);
	void SwitchOrderDirectionFilter(OrderDirection orderDirection);
	void SwitchOrderTifFilter(TifType tifType);

	bool OrderBelongs(const Order* order) const;
//	bool OrderPotentiallyBelongs(const Order* order) const;
	bool OrderSideBelongs(const Order* order) const;
	bool OrderBorrowBelongs(const Order* order) const;
	bool OrderMnemonicBelongs(const Order* order) const;
	bool OrderSupervisorAutoCloseBelongs(const Order* order) const;
	bool OrderPostponedBelongs(const Order* order) const;
	bool OrderUserTypeBelongs(const Order* order) const;
	bool OrderStopTypeBelongs(const Order* order) const;
	bool OrderDirectionBelongs(const Order* order) const;
	bool OrderTifBelongs(const Order* order) const;
	unsigned char OrderBelongingStatus(const Order* order) const;//0 - not belonging, 1 - potentially belonging, 2 - belonging
	unsigned char ExistingOrderBelongingStatus(const Order* order) const;//0 - not belonging, 1 - potentially belonging, 2 - belonging
/*
	void MovePotentialRowToBelonging(OrderRow* row);
	void MoveBelongingRowToPotential(OrderRow* row);
	bool RemoveAndDestroyPotentialRow(OrderRow* row);
	void AddRowToPotential(OrderRow* row);
*/
	virtual Row* CreateRow(const void* object, bool potential);

	typedef void (OrderRow::*FnPaintInfo)(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	typedef short (OrderRow::*FnCompare)(const OrderRow& other) const;
/*
	bool AddOrderFunctions(unsigned short id, FnPaintInfo fnPaint, FnCompare fnCompare, FnCompare fnCompareAhead);
	inline const FnPaintInfo& GetFnPaintInfo(unsigned short id) const{return id < ORD_COLUMN_COUNT ? m_paintInfoFunction[id] : NULL;}
	inline const FnCompare& GetFnCompare(unsigned short id) const{return id < ORD_COLUMN_COUNT ? m_compareFunction[id] : NULL;}
	inline const FnCompare& GetFnCompareAhead(unsigned short id) const{return id < ORD_COLUMN_COUNT ? m_compareAheadFunction[id] : NULL;}
*/
//	COLORREF GetOrderColor(const Order* order) const;
//	COLORREF GetColorPending() const{return m_colorPending;}
//	COLORREF GetColorPendingFilled() const{return m_colorPendingFilled;}

	virtual const COLORREF& GetBuyColor() const override{return m_executionBuyColor;}//m_buyColor;}
	virtual const COLORREF& GetSellColor() const override{return m_executionSellColor;}//m_sellColor;}
	virtual const COLORREF& GetShortColor() const override{return m_executionShortColor;}//m_shortColor;}
	virtual const COLORREF& GetBustedBuyColor() const override{return m_bustedBuyColor;}
	virtual const COLORREF& GetBustedSellColor() const override{return m_bustedSellColor;}

	virtual const COLORREF& GetBuyOpenColor() const override{return m_executionColorBuyOpen;}
	virtual const COLORREF& GetBuyClosedColor() const override{return m_executionColorBuyClosed;}
	virtual const COLORREF& GetShortOpenColor() const override{return m_executionColorShortOpen;}
	virtual const COLORREF& GetSellClosedColor() const override{return m_executionColorSellClosed;}

	virtual const COLORREF& GetColorPendingBuy() const override{return m_colorPendingBuy;}
	virtual const COLORREF& GetColorPendingSell() const override{return m_colorPendingSell;}
	virtual const COLORREF& GetColorPendingShort() const override{return m_colorPendingShort;}
	virtual const COLORREF& GetColorPendingFilledBuy() const override{return m_colorPendingFilledBuy;}
	virtual const COLORREF& GetColorPendingFilledSell() const override{return m_colorPendingFilledSell;}
	virtual const COLORREF& GetColorPendingFilledShort() const override{return m_colorPendingFilledShort;}

	virtual const COLORREF& GetColorUnacknowledged() const override{return m_colorUnacknowledged;}
	virtual const COLORREF& GetColorNotSent() const override{return m_colorNotSent;}
	virtual const COLORREF& GetColorFilled() const override{return m_colorFilled;}
	virtual const COLORREF& GetColorPartialFilled() const override{return m_colorPartialFilled;}
	virtual const COLORREF& GetColorKicked() const override{return m_colorKicked;}
	virtual const COLORREF& GetColorBlocked() const override{return m_colorBlocked;}
	virtual const COLORREF& GetColorCanceled() const override{return m_colorCanceled;}
	virtual const COLORREF& GetColorCanceling() const override{return m_colorCanceling;}
	virtual const COLORREF& GetColorReplacing() const override{return m_colorReplacing;}
	virtual const COLORREF& GetColorPostponed() const override{return m_colorPostponed;}
	virtual const COLORREF& GetColorWaiting() const override{return m_colorWaiting;}

	virtual const COLORREF& GetOrderBuyColor() const override{return m_buyColor;}
	virtual const COLORREF& GetOrderSellColor() const override{return m_sellColor;}
	virtual const COLORREF& GetOrderShortColor() const override{return m_shortColor;}

	virtual bool HasMillisecondColumns() const override{return true;}

	virtual bool AccountBelongs(const Account* account) const;
	virtual bool ObjectPotentiallyBelongs(const void* object) const override;//no need to call inside lock
	virtual bool RowFiltersIn(const RowSortable* row) const override;//should be called inside lock
	virtual unsigned char RowBelongs(const RowSortable* row) const override;//should be called inside lock
	virtual unsigned char ExistingRowBelongs(const RowSortable* row) const override;//should be called inside lock

	virtual bool hasInventoryView() const override{return true;}

	virtual void StockAddedToCommandToolBasket(const unsigned __int64& symbol) override;
//	virtual void StockRemovedFromCommandToolBasket(const unsigned __int64& symbol) override;
protected:
	OrderWindow(const CBitmap* bitmap, unsigned int workspace, bool pinned = false);
	
#ifdef SECONDARY_ROWS
	virtual void DoUpdateSecondaryDataGraphicsColorsCustom(const GraphicsColorCollection* colorCollection) override;
	virtual void DoUpdateSecondaryDataGraphicsColors(const Graphics* graphics) override;
#endif

	virtual void DisplayClientMenu(UINT nFlags, CPoint point) override;

	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;
//	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
//	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
//	DECLARE_MESSAGE_MAP()

	virtual void CreateAdditionalColumns() override;

	virtual RowTotal* CreateRowTotal() override;
	virtual void ViewAllAccountsChanged(bool remove) override;
	void Populate(bool remove,
		unsigned int addOrderFilter,
		unsigned int addOrderSideFilter,
		unsigned int addOrderBorrowFilter,
		unsigned int addOrderMnemonicFilter,
		unsigned int addSupervisorAutoCloseFilter,
		unsigned int addOrderPostponedFilter,
		unsigned int addOrderUserTypeFilter,
		unsigned int addOrderStopTypeFilter,
		unsigned int addOrderDirectionFilter,
		unsigned int addOrderTifFilter
#ifndef TAKION_NO_OPTIONS
		, unsigned int addInstrumentFilter
#endif
		);//, unsigned __int64 symbol);
	bool PopulateOneAccount(const Account* account,
		const Position* position,
		unsigned int addOrderFilter,
		unsigned int addOrderSideFilter,
		unsigned int addOrderBorrowFilter,
		unsigned int addOrderMnemonicFilter,
		unsigned int addSupervisorAutoCloseFilter,
		unsigned int addOrderPostponedFilter,
		unsigned int addOrderUserTypeFilter,
		unsigned int addOrderStopTypeFilter,
		unsigned int addOrderDirectionFilter,
		unsigned int addOrderTifFilter
#ifndef TAKION_NO_OPTIONS
		, unsigned int addInstrumentFilter
#endif
		);
	bool PopulateAllAccounts(unsigned int addOrderFilter,
		unsigned int addOrderSideFilter,
		unsigned int addOrderBorrowFilter,
		unsigned int addOrderMnemonicFilter,
		unsigned int addSupervisorAutoCloseFilter,
		unsigned int addOrderPostponedFilter,
		unsigned int addOrderUserTypeFilter,
		unsigned int addOrderStopTypeFilter,
		unsigned int addOrderDirectionFilter,
		unsigned int addOrderTifFilter
#ifndef TAKION_NO_OPTIONS
		, unsigned int addInstrumentFilter
#endif
		);
//	virtual void DoSetSymbol(unsigned __int64 symbol);

	virtual void OnSuccessfulCreate() override;

	virtual void OrderDeleted(Order* order);
	virtual void RowRemoved(RowSortable* row) override;

	virtual void Repopulate() override;

	virtual void SecurityDoubleClicked(UINT nFlags, const CPoint& point) override;

	virtual void BeforeDestroy() override;
	virtual void AccountChanged() override;
	virtual void AddMenuItems(CMenu& menu) override;
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;
//	void DestroyPotentialRows();
	unsigned int m_orderFilter;
	unsigned int m_orderSideFilter;
#ifndef TAKION_NO_OPTIONS
	unsigned int m_instrumentFilter;
#endif
	unsigned int m_orderMnemonicFilter;
	MnemonicSet m_orderMnemonicFilterSet;
	MnemonicSet::const_iterator m_orderMnemonicFilterSetEnd;

	unsigned int m_supervisorAutoCloseFilter;
	unsigned int m_orderBorrowFilter;
	unsigned int m_orderPostponedFilter;
	unsigned int m_orderUserTypeFilter;
	unsigned int m_orderStopTypeFilter;
	unsigned int m_orderDirectionFilter;
	unsigned int m_orderTifFilter;
	COLORREF m_colorUnacknowledged;
	COLORREF m_colorNotSent;
//	COLORREF m_colorPending;
	COLORREF m_colorPendingBuy;
	COLORREF m_colorPendingSell;
	COLORREF m_colorPendingShort;
//	COLORREF m_colorPendingFilled;
	COLORREF m_colorPendingFilledBuy;
	COLORREF m_colorPendingFilledSell;
	COLORREF m_colorPendingFilledShort;
	COLORREF m_colorFilled;
	COLORREF m_colorPartialFilled;
	COLORREF m_colorKicked;
	COLORREF m_colorBlocked;
	COLORREF m_colorCanceled;
	COLORREF m_colorCanceling;
	COLORREF m_colorReplacing;
	COLORREF m_colorPostponed;
	COLORREF m_colorWaiting;

	COLORREF m_buyColor;
	COLORREF m_sellColor;
	COLORREF m_shortColor;

	COLORREF m_executionBuyColor;
	COLORREF m_executionSellColor;
	COLORREF m_executionShortColor;
	COLORREF m_bustedBuyColor;
	COLORREF m_bustedSellColor;

	COLORREF m_executionColorBuyOpen;
	COLORREF m_executionColorBuyClosed;
	COLORREF m_executionColorShortOpen;
	COLORREF m_executionColorSellClosed;
/*
#ifdef SECONDARY_ROWS
//Exe Colors
	COLORREF m_colorBuy;
	COLORREF m_colorSell;
	COLORREF m_colorShort;
#endif
*/
/*
	FnPaintInfo m_paintInfoFunction[ORD_COLUMN_COUNT];
	FnCompare m_compareFunction[ORD_COLUMN_COUNT];
	FnCompare m_compareAheadFunction[ORD_COLUMN_COUNT];
*/
	virtual void ActiveSymbolAboutToChange(const unsigned __int64& newActiveSymbol
#ifndef TAKION_NO_OPTIONS
		,const unsigned __int64& newActiveOptionBlock
#endif
		);
	virtual bool ActiveSymbolChanged();

	RowSortableList m_topRowList;
};

class TGUI_API OrderRow : public
#ifdef SECONDARY_ROWS
	RowSortableChild
#else
	RowSortable
#endif
	, public Observer
{
public:
	OrderRow(RowWindowSortable* parent, Order* order, bool potential = false
#ifdef SECONDARY_ROWS
		, RowSortable* parentRow = NULL, bool expanded = false
#endif
		);
	virtual const void* GetBaseObject() const{return m_order;}
	virtual bool GetPaintTextInfo(unsigned short columnId, std::string& text, COLORREF& color) const override;//, UINT& horizontalJustification) const override;
	virtual COLORREF GetRowColor() const;
	virtual COLORREF GetCellColor(unsigned short columnId) const;

	virtual RowValue* CreateCell(unsigned short id);

	virtual bool hasInventory() const{return m_order && m_order->GetInventory() != NULL;}
	virtual const PositionData* GetRowPosition(const CPoint* point = NULL) const override{return m_order ? m_order->GetPosition() : NULL;}

	Order* GetOrder(){return m_order;}
	const Order* GetOrder() const{return m_order;}

//	Position* GetPosition(){return m_order->GetPosition();}
	const Position* GetPosition() const{return m_order->GetPosition();}

	virtual const char* GetRowSecuritySymbol(const CPoint* point = NULL) const override{return m_order ? m_order->GetSymbol() : NULL;}
	virtual const unsigned __int64& GetRowNumericSymbol() const{return m_order ? m_order->GetNumericSymbol() : uint64Zero;}

	virtual const Account* GetRowAccount() const{return m_order->GetAccount();}

	virtual bool Lock(bool wait) const override;
//	virtual void LockWait() const override;
	virtual void Unlock() const override;

//	virtual short Compare(const RowSortable& other) const;
//	virtual short CompareAhead(const RowSortable& other) const;
//	virtual short CompareChain(const RowSortable& other) const;
//	virtual short CompareChainAhead(const RowSortable& other) const;
	virtual short DefaultCompare(const RowSortable& other) const;

	virtual bool CompareFunction(const RowSortable& other, unsigned short sortId, short& ret) const;
	virtual bool CompareFunctionAhead(const RowSortable& other, unsigned short sortId, short& ret) const;
	virtual short PreCompare(const RowSortable& other) const;

//	virtual void Update(bool dynamicOnly);
	virtual bool UpdateRowColor() override;//should be called only inside a lock

	DECLARE_NED_NEW

//	bool isPotential() const{return m_potential;}
//	void SetPotential(bool potential){m_potential = potential;}

	void PaintSymbol(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareSymbol(const OrderRow& other) const;
//	void PaintTif(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
//	short CompareTif(const OrderRow& other) const;
	void PaintSentTif(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareSentTif(const OrderRow& other) const;
	void PaintInitialTif(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareInitialTif(const OrderRow& other) const;
	void PaintClientIdChronological(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareClientIdChronological(const OrderRow& other) const;
	void PaintClientId(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareClientId(const OrderRow& other) const;
	void PaintMinDisplaySize(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareMinDisplaySize(const OrderRow& other) const;
	void PaintMaxDisplaySize(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareMaxDisplaySize(const OrderRow& other) const;
	void PaintSplitParentClientId(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareSplitParentClientId(const OrderRow& other) const;
	void PaintSplitChildClientId(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareSplitChildClientId(const OrderRow& other) const;
//	void PaintServerId(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
//	short CompareServerId(const OrderRow& other) const;
//	void PaintSize(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
//	short CompareSize(const OrderRow& other) const;
//	void PaintLimitPrice(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
//	short CompareLimitPrice(const OrderRow& other) const;
	void PaintActivateTime(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareActivateTime(const OrderRow& other) const;
	void PaintTimeCreated(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareTimeCreated(const OrderRow& other) const;
	void PaintDateGtcCreated(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareDateGtcCreated(const OrderRow& other) const;
	void PaintTimeGtcCreated(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareTimeGtcCreated(const OrderRow& other) const;
	void PaintVenue(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareVenue(const OrderRow& other) const;
	void PaintVenueId(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareVenueId(const OrderRow& other) const;
	void PaintRouting(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareRouting(const OrderRow& other) const;
	void PaintMnemonic(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareMnemonic(const OrderRow& other) const;
	void PaintDiscretionaryPrice(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareDiscretionaryPrice(const OrderRow& other) const;
//	void PaintStopPrice(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
//	short CompareStopPrice(const OrderRow& other) const;

//	void PaintOddLotCreated(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
//	short CompareOddLotCreated(const OrderRow& other) const;
/*
	void PaintResizeToClose(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareResizeToClose(const OrderRow& other) const;
	void PaintFromExtension(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareFromExtension(const OrderRow& other) const;
	void PaintBlocked(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareBlocked(const OrderRow& other) const;
	void PaintBorrow(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareBorrow(const OrderRow& other) const;
*/
	void PaintParentId(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareParentId(const OrderRow& other) const;
	void PaintReplacedId(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareReplacedId(const OrderRow& other) const;
	void PaintSendId(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareSendId(const OrderRow& other) const;
	void PaintDayVolume(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareDayVolume(const OrderRow& other) const;
	void PaintYesterdayVolume(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareYesterdayVolume(const OrderRow& other) const;
	void PaintAverageDailyVolume(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareAverageDailyVolume(const OrderRow& other) const;

	void PaintInitialDirection(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareInitialDirection(const OrderRow& other) const;

//	void PaintImbalanceOnly(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
//	short CompareImbalanceOnly(const OrderRow& other) const;
//	void PaintOpening(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
//	short CompareOpening(const OrderRow& other) const;
//	void PaintDma(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
//	short CompareDma(const OrderRow& other) const;
//	void PaintAggressive(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
//	short CompareAggressive(const OrderRow& other) const;

	void PaintAccountName(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareAccountName(const OrderRow& other) const;
	void PaintUserType(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareUserType(const OrderRow& other) const;
	void PaintUserInfo(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareUserInfo(const OrderRow& other) const;
	void PaintAccountUserName(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareAccountUserName(const OrderRow& other) const;
	void PaintUserId(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareUserId(const OrderRow& other) const;
	void PaintIpSentFrom(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareIpSentFrom(const OrderRow& other) const;
//	void PaintIpCancelFrom(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
//	short CompareIpCancelFrom(const OrderRow& other) const;

//	void PaintDropcopy(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
//	short CompareDropcopy(const OrderRow& other) const;
	
	void PaintRoutingSubtype(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareRoutingSubtype(const OrderRow& other) const;

//	void PaintNightOrder(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
//	short CompareNightOrder(const OrderRow& other) const;
//	void PaintNonCancelable(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
//	short CompareNonCancelable(const OrderRow& other) const;

	void PaintStopType(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareStopType(const OrderRow& other) const;
	void PaintStopBase(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareStopBase(const OrderRow& other) const;
	void PaintTraderId(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareTraderId(const OrderRow& other) const;

//	void PaintIso(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
//	short CompareIso(const OrderRow& other) const;

	void PaintPegType(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short ComparePegType(const OrderRow& other) const;
	void PaintPegOffset(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short ComparePegOffset(const OrderRow& other) const;
	void PaintOrigin(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareOrigin(const OrderRow& other) const;
	void PaintSide(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareSide(const OrderRow& other) const;

//	void PaintNetPercent(std::string& text, COLORREF& color) const;
//	short CompareNetPercent(const OrderRow& other) const;
	void PaintBid(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareBid(const OrderRow& other) const;
	void PaintAsk(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareAsk(const OrderRow& other) const;
	void PaintLastPrice(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareLastPrice(const OrderRow& other) const;
	void PaintInitialStopPrice(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareInitialStopPrice(const OrderRow& other) const;

//	void PaintReplacingNatively(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
//	short CompareReplacingNatively(const OrderRow& other) const;

#ifdef FIRM_VALUES
	void PaintFirmSide(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareFirmSide(const OrderRow& other) const;
#endif

#ifndef TAKION_NO_OPTIONS
//	void PaintSuffix(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
//	short CompareSuffix(const OrderRow& other) const;
	void PaintCall(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareCall(const OrderRow& other) const;
	void PaintExpiration(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareExpiration(const OrderRow& other) const;
	void PaintExpirationDays(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareExpirationDays(const OrderRow& other) const;
	void PaintStrike(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareStrike(const OrderRow& other) const;
	void PaintExpirationType(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareExpirationType(const OrderRow& other) const;
#endif
protected:
	virtual void Notify(const Message* message, const Observable* from, const Message* info = NULL) override;
//	OrderWindow* m_orderWindow;
	Order* m_order;

	COLORREF m_orderColor;
//	bool m_potential;
};

class TGUI_API OrderRowTotal : public RowTotal
{
public:
	OrderRowTotal(OrderWindow* window):
		RowTotal(OrderWindow::ORD_COLUMN_COUNT, window)
	{
	}
protected:
	virtual void UpdateNonCumulativeValues(const Row* row, bool dynamicOnly);
//	virtual void UpdateInventoryViewNonCumulativeValues(const Row* row);
	virtual void AddNonCumulativeValues(const Row* row);
	virtual void RemoveNonCumulativeValues(const Row* row);
//	virtual void ResetNonCumulativeValues();
};

class PositionRow;

enum CoverFilter
{
	CF_UNDERCOVERED,
	CF_COVERED,
	CF_OVERCOVERED,

	CF_Count
};

enum PhantomFilter
{
	PF_REAL,
	PF_PHANTOM,

	PF_Count
};

class TGUI_API PositionWindow : public CancelOrderWindow
{
//friend class TakionMainWnd;
public:
	virtual const char* GetToolId() const override{return toolPositionId;}
	virtual ~PositionWindow(){DestroyMergedPositions();}

	virtual Order* GetOrderFromRow(Row* row) override;
	virtual const Order* GetOrderFromRow(const Row* row) const override;
	virtual Position* GetPositionFromRow(Row* row) override;
	virtual const Position* GetPositionFromRow(const Row* row) const override;
	static void AddInventoryColumns(Columns* columns);
#ifdef SECONDARY_ROWS
//	virtual const Columns* GetOrderColumns() const{return m_secondaryColumns;}
	virtual const char* GetSecondaryToolId() const override{return toolOrderId;}
	virtual void UpdateSecondaryDataGraphics(const Graphics* graphics) override;

	virtual unsigned short GetSecondaryAdditionalColumnCount() const override;
/*
	const unsigned int& GetOrderBorrowFilter() const{return m_orderBorrowFilter;}
	bool SetOrderBorrowFilter(const unsigned int orderBorrowFilter, unsigned int& addFilter);

	const bool& isIncludeAlgos() const{return m_includeAlgos;}
	bool SetIncludeAlgos(const bool includeAlgos);
*/
////////////
	const unsigned int& GetOrderBorrowFilter() const{return m_orderBorrowFilter;}
	bool SetOrderBorrowFilter(unsigned int orderBorrowFilter, unsigned int& addFilter);

	const unsigned int& GetOrderMnemonicFilter() const{return m_orderMnemonicFilter;}
	bool SetOrderMnemonicFilter(unsigned int orderMnemonicFilter, unsigned int& addFilter);
	void FilterMnemonicRemoved(unsigned int mnemonic);

	const unsigned int& GetOrderAutoCloseFilter() const{return m_orderAutoCloseFilter;}
	bool SetOrderAutoCloseFilter(unsigned int orderAutoCloseFilter, unsigned int& addFilter);

	const unsigned int& GetOrderPostponedFilter() const{return m_orderPostponedFilter;}
	bool SetOrderPostponedFilter(unsigned int orderPostponedFilter, unsigned int& addFilter);

	const unsigned int& GetOrderUserTypeFilter() const{return m_orderUserTypeFilter;}
	bool SetOrderUserTypeFilter(unsigned int orderUserTypeFilter, unsigned int& addFilter);

	const unsigned int& GetOrderStopTypeFilter() const{return m_orderStopTypeFilter;}
	bool SetOrderStopTypeFilter(unsigned int orderStopTypeFilter, unsigned int& addFilter);

	const unsigned int& GetOrderDirectionFilter() const{return m_orderDirectionFilter;}
	bool SetOrderDirectionFilter(unsigned int orderDirectionFilter, unsigned int& addFilter);

	const unsigned int& GetOrderTifFilter() const{return m_orderTifFilter;}
	bool SetOrderTifFilter(unsigned int orderTifFilter, unsigned int& addFilter);

	const unsigned int& GetOrderFilter() const{return m_orderFilter;}
	bool SetOrderFilter(unsigned int orderFilter, unsigned int& addFilter);

	const unsigned int& GetOrderSideFilter() const{return m_orderSideFilter;}
	bool SetOrderSideFilter(unsigned int orderSideFilter, unsigned int& addFilter);

	void AddOrderFilter(unsigned int filter);
	void RemoveOrderFilter(unsigned int filter);
	void AddOrderSideFilter(unsigned int filter);
	void RemoveOrderSideFilter(unsigned int filter);
	void AddOrderBorrowFilter(unsigned int filter);
	void RemoveOrderBorrowFilter(unsigned int filter);
	void AddOrderMnemonicFilter(unsigned int filter);
	void RemoveOrderMnemonicFilter(unsigned int filter);
	void AddOrderAutoCloseFilter(unsigned int filter);
	void RemoveOrderAutoCloseFilter(unsigned int filter);
	void AddOrderPostponedFilter(unsigned int filter);
	void RemoveOrderPostponedFilter(unsigned int filter);
	void AddOrderUserTypeFilter(unsigned int filter);
	void RemoveOrderUserTypeFilter(unsigned int filter);
	void AddOrderStopTypeFilter(unsigned int filter);
	void RemoveOrderStopTypeFilter(unsigned int filter);
	void AddOrderDirectionFilter(unsigned int filter);
	void RemoveOrderDirectionFilter(unsigned int filter);
	void AddOrderTifFilter(unsigned int filter);
	void RemoveOrderTifFilter(unsigned int filter);

	void SwitchOrderSideFilter(OrderSide orderSide);
	void SwitchOrderFilter(OrderFilter orderFilter);
	void SwitchOrderBorrowFilter(OrderBorrow orderBorrow);
	void SwitchOrderMnemonicFilter(unsigned char yesNoFilter);
	void SwitchOrderAutoCloseFilter(unsigned char yesNoFilter);
	void SwitchOrderPostponedFilter(OrderPostponed orderPostponed);
	void SwitchOrderUserTypeFilter(OrderUserType orderUserType);
	void SwitchOrderStopTypeFilter(OrderStopType orderStopType);
	void SwitchOrderDirectionFilter(OrderDirection orderDirection);
	void SwitchOrderTifFilter(TifType orderTifType);
////////////
	bool OrderBelongs(const Order* order) const;
//	bool OrderPotentiallyBelongs(const Order* order) const;
	bool OrderSideBelongs(const Order* order) const;
	bool OrderMnemonicBelongs(const Order* order) const;
	bool OrderAutoCloseBelongs(const Order* order) const;
	bool OrderBorrowBelongs(const Order* order) const;
	bool OrderPostponedBelongs(const Order* order) const;
	bool OrderUserTypeBelongs(const Order* order) const;
	bool OrderStopTypeBelongs(const Order* order) const;
	bool OrderDirectionBelongs(const Order* order) const;
	bool OrderTifBelongs(const Order* order) const;
	unsigned char OrderBelongingStatus(const Order* order) const;//0 - not belonging, 1 - potentially belonging, 2 - belonging
	unsigned char ExistingOrderBelongingStatus(const Order* order) const;//0 - not belonging, 1 - potentially belonging, 2 - belonging

	virtual bool SecondaryObjectPotentiallyBelongs(const void* object) const override;//no need to call inside lock
	virtual bool SecondaryRowFiltersIn(const RowSortable* row) const override;//should be called inside lock
	virtual unsigned char SecondaryRowBelongs(const RowSortable* row) const override;//2 - belongs; 1 - does not belong but can update to become belonging; 0 - does not belong and cannot update to become belonging
	virtual unsigned char SecondaryExistingRowBelongs(const RowSortable* row) const override;//2 - belongs; 1 - does not belong but can update to become belonging; 0 - does not belong and cannot update to become belonging

	virtual bool ExpandRow(Row* row) override;
	virtual RowSortable* CreateSecondaryRow(const void* object, bool potential, RowSortable* parentRow) override;

	virtual const COLORREF& GetBuyColor() const override{return m_buyColor;}
	virtual const COLORREF& GetSellColor() const override{return m_sellColor;}
	virtual const COLORREF& GetShortColor() const override{return m_shortColor;}
	virtual const COLORREF& GetColorPendingBuy() const override{return m_colorPendingBuy;}
	virtual const COLORREF& GetColorPendingSell() const override{return m_colorPendingSell;}
	virtual const COLORREF& GetColorPendingShort() const override{return m_colorPendingShort;}
	virtual const COLORREF& GetColorPendingFilledBuy() const override{return m_colorPendingFilledBuy;}
	virtual const COLORREF& GetColorPendingFilledSell() const override{return m_colorPendingFilledSell;}
	virtual const COLORREF& GetColorPendingFilledShort() const override{return m_colorPendingFilledShort;}

	virtual const COLORREF& GetOrderBuyColor() const override{return m_buyColor;}
	virtual const COLORREF& GetOrderSellColor() const override{return m_sellColor;}
	virtual const COLORREF& GetOrderShortColor() const override{return m_shortColor;}

	virtual const COLORREF& GetColorUnacknowledged() const override{return m_colorUnacknowledged;}
	virtual const COLORREF& GetColorNotSent() const override{return m_colorNotSent;}
	virtual const COLORREF& GetColorFilled() const override{return m_colorFilled;}
	virtual const COLORREF& GetColorPartialFilled() const override{return m_colorPartialFilled;}
	virtual const COLORREF& GetColorKicked() const override{return m_colorKicked;}
	virtual const COLORREF& GetColorBlocked() const override{return m_colorBlocked;}
	virtual const COLORREF& GetColorCanceled() const override{return m_colorCanceled;}
	virtual const COLORREF& GetColorCanceling() const override{return m_colorCanceling;}
	virtual const COLORREF& GetColorReplacing() const override{return m_colorReplacing;}
	virtual const COLORREF& GetColorPostponed() const override{return m_colorPostponed;}
	virtual const COLORREF& GetColorWaiting() const override{return m_colorWaiting;}
#endif

	virtual unsigned short GetSymbolColumn() const override{return POS_SYMBOL;}

	enum ColumnId : unsigned short
	{
		POS_SYMBOL,
		POS_SIZE,
		POS_PRICE,
		POS_PNL_CLOSED,
		POS_OPNL_L1,
		POS_OPNL_PRINT,
		POS_BP_USED,
		POS_ORDERS,
		POS_LONG_ORDERS,
		POS_SHORT_ORDERS,
		POS_SHARES_TRADED,
		POS_SIZE_PEND_LONG,
		POS_SIZE_PEND_SHORT,
		POS_MONEY_PEND_LONG,
		POS_MONEY_PEND_SHORT,
		POS_TICKET_AVERAGE,
		POS_PNL_CLOSED_NET,
		POS_INVESTMENT,
		POS_MPNL_L1,
		POS_SIZE_OVERNIGHT,
		POS_SIZE_PEND_SELL,

		POS_BORROW_PEND_INVESTMENT,
		POS_BORROW_INVESTMENT,
		POS_BORROW_BP_USED,
		POS_BORROW_PRICE,
		POS_BORROW_PEND_BUY_SIZE,
		POS_BORROW_SIZE,
		POS_GPS_L1,
		POS_GPS_PRINT,
		POS_PNL_MARKED_NET,
		POS_ACCOUNT_NAME,
		POS_SIZE_PTL_LONG,
		POS_SIZE_PTL_SHORT,
		POS_SIZE_PTL,
		POS_MPNL_PRINT,

		POS_S_L1_BID,
		POS_S_L1_ASK,
		POS_S_L1_BID_SIZE,
		POS_S_L1_ASK_SIZE,

		POS_S_NYS_BID,
		POS_S_NYS_ASK,
		POS_S_NYS_BID_SIZE,
		POS_S_NYS_ASK_SIZE,

		POS_S_LAST_PRICE,
		POS_S_LAST_SIZE,
		POS_S_BID_TICK,

		POS_PHANTOM_SIZE,
		
		POS_BUY_SHARES_BEING_CANCELED,
		POS_SELL_AND_SHORT_SHARES_BEING_CANCELED,

		POS_ACCOUNT_USER_NAME,

		POS_HTB,
		POS_AVAILABLE_BORROW_SIZE,
		POS_AVAILABLE_BORROW_PRICE,

		POS_L1_BID_SIZE,//not used; use POS_S_L1_BID_SIZE instead
		POS_L1_ASK_SIZE,//not used; use POS_S_L1_ASK_SIZE instead

		POS_VALUE_PTL_LONG,
		POS_VALUE_PTL_SHORT,

		POS_OPNL_NBBO_PRINT,
		POS_MPNL_NBBO_PRINT,

		POS_S_LAST_NBBO_PRICE,
		POS_S_EXCHANGE,
		POS_S_IMB_REG_NYSE,
		POS_S_IMB_NYSE,

		POS_ORDERS_STUCK,
		POS_ORDERS_CANCEL_REJECTED,
		POS_ORDERS_CANCEL_BLOCKED,

		POS_S_DAY_NET_CHANGE,
		POS_S_DAY_NET_PERCENT_CHANGE,

		POS_COST,
		POS_INVESTMENT_COST,

		POS_MIN_SIZE,

		POS_OPNL_L1_COST,
		POS_PNL_CLOSED_COST,

		POS_GPS_PRINT_HI,
		POS_GPS_PRINT_LO,
		POS_MPNL_NBBO_PRINT_HI,
		POS_MPNL_NBBO_PRINT_LO,

		POS_UNCLOSED_OVERNIGHT_SIZE,

		POS_ENTER_TIME,

		POS_SHARES_ADDED,
		POS_SHARES_REMOVED,

		POS_OPNL_TCLOSE,
		POS_MPNL_TCLOSE,

		POS_ABS_SIZE,
		POS_ABS_SIZE_OVERNIGHT,

		POS_EXEC_PRICE,
		POS_EXEC_SIZE,

		POS_ON_OPEN_PEND_LONG,
		POS_ON_OPEN_PEND_SHORT,
		POS_ON_CLOSE_PEND_LONG,
		POS_ON_CLOSE_PEND_SHORT,

		POS_ON_OPEN_TO_COVER,
		POS_ON_CLOSE_TO_COVER,

		POS_PNL_MARKED_PRINT_NET,

		POS_MARKED_TICKET_AVERAGE,
		POS_HARD_BP_USED,

		POS_LOCATE_REF,

		POS_FIRM_SIZE,

		POS_UNCLOSED_OVERNIGHT_SHORT_SIZE,
		POS_UNBORROWED_OVERNIGHT_SIZE,
		POS_FIRM_UNTRADEABLE_LEVEL,
		POS_UNTRADEABLE,

		POS_MARKED_TICKET_AVERAGE_HI,
		POS_MARKED_TICKET_AVERAGE_LO,

		POS_INVENTORY_SIZE,
		POS_HIDDEN,

		POS_OVERNIGHT_PRICE,
		POS_SECURITY_CLOSE_PRICE,

		POS_S_DAY_VOLUME,
		POS_S_YESTERDAY_VOLUME,

		POS_ON_OPEN,
		POS_ON_CLOSE,

		POS_ADV_PASSIVE_SHARES,
		POS_ADV_PASSIVE_ORDER_COUNT,

		POS_TIME_LOADED,
		POS_UPDATED_PNL,
		POS_INVALID_SECURITY,
		POS_S_LEVEL,

		POS_OPNL_PRINT_COST,

		POS_AVG_BUY_PRICE,
		POS_AVG_SELL_PRICE,

		POS_S_BID_NET_PERCENT,
		POS_S_ASK_NET_PERCENT,

		POS_OPNL_IMBEXNEAR,
		POS_S_OPEN_STATE,
		POS_S_PQOPEN_TIME,

		POS_OPNL_ACTION,
//		POS_OPNL_ACTION_INV,

		POS_S_DAY_LAST_PRICE_IN_RANGE,

		POS_PNL_CLOSED_PREMARKET,
		POS_PNL_CLOSED_MARKET,
		POS_PNL_CLOSED_POSTMARKET,
		POS_PNL_OPEN_PREMARKET,
		POS_PNL_OPEN_MARKET,
		POS_PNL_OPEN_POSTMARKET,
		POS_PNL_MARKED_PREMARKET,
		POS_PNL_MARKED_MARKET,
		POS_PNL_MARKED_POSTMARKET,
		POS_UNCLOSED_OVERNIGHT_LONG_SIZE,

		POS_OPNL_ACTION_PRINT,
		POS_ACTION_PRINT,

		POS_S_IMB_OPEN_EXCH,

		POS_THERMOGRAPH_QUOTES,
		POS_THERMOGRAPH_PRINTS,

		POS_INVESTMENT_LONG,
		POS_INVESTMENT_SHORT,
		POS_INVESTMENT_SIGNED,

		POS_S_IMB_EXCH_NEAR_NET_PERCENT,
		POS_S_HEADLINE_COUNT,
		POS_S_HEADLINE_DATETIME,

		POS_ORDERS_BLOCKED,

		POS_S_IMB_NSDQ,
		POS_S_SOURCE_MARKET_DATA,

		POS_S_IMB_REL_NYSE,
		POS_S_IMB_DELTA_NYSE,
		POS_S_PQ_OPEN_PRICE,
		POS_S_TODAYS_CLOSE_PRICE,
		POS_S_L2_BID,
		POS_S_L2_ASK,
		POS_S_IMB_EXCH,

		POS_MARGIN,
		POS_BETA,
		POS_BETA_INVESTMENT,
		POS_BETA_INVESTMENT_LONG,
		POS_BETA_INVESTMENT_SHORT,
		POS_BETA_MONEY_PEND_LONG,
		POS_BETA_MONEY_PEND_SHORT,
		POS_BETA_VALUE_PTL_LONG,
		POS_BETA_VALUE_PTL_SHORT,
		POS_BETA_BP_USED,

		POS_MAX_INVESTMENT,
		POS_MAX_INVESTMENT_LONG,
		POS_MAX_INVESTMENT_SHORT,

		POS_BETA_MAX_INVESTMENT,
		POS_BETA_MAX_INVESTMENT_LONG,
		POS_BETA_MAX_INVESTMENT_SHORT,

		POS_SECURITY_TODAYS_CLOSE_PRICE,

		POS_NITE_VALUE_PTL_LONG,
		POS_NITE_VALUE_PTL_SHORT,
		POS_NITE_BP_USED,
		POS_NITE_SIZE_PTL_LONG,
		POS_NITE_SIZE_PTL_SHORT,
		POS_NITE_SIZE_PTL,

		POS_MAX_SIZE,

		POS_S_PRICE_CLS_PERCENT,
		POS_S_NITE_PERCENT_CHANGE,
		POS_AGPS_L1,

		POS_PM_EL_RATE,
		POS_PM_ES_RATE,
		POS_PM_HL_RATE,
		POS_PM_HS_RATE,
		POS_EL_RATE,
		POS_ES_RATE,
		POS_HL_RATE,
		POS_HS_RATE,
		POS_FED_REQ,
		POS_ASSET_TYPE,
		POS_MARGINABLE,
		POS_SEC_TYPE,
		POS_STATUS,

		POS_ME_PTL_LONG,
		POS_ME_PTL_SHORT,
		POS_ME_PEND_LONG,
		POS_ME_PEND_SHORT,
		POS_ME_USED,
		POS_ME_INVESTMENT,
		POS_ME_INVESTMENT_LONG,
		POS_ME_INVESTMENT_SHORT,
		POS_ME_MAX_INVESTMENT,
		POS_ME_MAX_INVESTMENT_LONG,
		POS_ME_MAX_INVESTMENT_SHORT,

		POS_TIME_HTB_CHANGED,
		POS_INVESTMENT_BY_REAL_TIME_EQUITY,

		POS_HARD_ME_USED,

		POS_FIRM_POTENTIAL_SHORT_SIZE,

		POS_INVESTMENT_OVERNITE,
		POS_BETA_INVESTMENT_OVERNITE,
		POS_ME_INVESTMENT_OVERNITE,

		POS_INVENTORY_COST,
		POS_INVENTORY_INVESTMENT,
		POS_INVENTORY_OPNL_NBBO_PRINT,
		POS_INVENTORY_FLOATING,

		POS_S_NET_PERCENT_POSITION_PRICE,

#ifndef TAKION_NO_OPTIONS
		POS_COLUMN_NO_OPT_COUNT,

		POS_OPT_SUFFIX = POS_COLUMN_NO_OPT_COUNT,
		POS_OPT_CALL_PUT,
		POS_OPT_EXPIRATION_DATE,
		POS_OPT_STRIKE_PRICE,
		POS_OPT_EXPIRATION_TYPE,
		POS_OPT_EXPIRATION_DAYS,
		POS_OPT_CONTRACT_SIZE,

		POS_ABS_SHARE_SIZE,
		POS_OPT_SIZE_PTL_SOLD_CALLS,
		POS_OPT_SIZE_PTL_SOLD_PUTS,
		POS_OPT_CONTRACTS_TRADED,

		POS_OPT_INTRINSIC,
		POS_OPT_TIME_VALUE,
		POS_OPT_UNDERLIER_LAST,
		POS_OPT_UNDERLIER_SOURCE_MARKET_DATA,
		POS_SHARE_SIZE,
		POS_UNDERLIER_VALUE_LONG,
		POS_UNDERLIER_VALUE_SHORT,
#endif
#ifdef _DEBUG
		POS_S_REF,
#endif
		POS_COLUMN_COUNT
	};

	static const unsigned short thermographSize = 16;
	static const unsigned short thermographDepth = 16;
	virtual const COLORREF* GetThermographRedColors() const override{return m_thermographRedColors;}
	virtual const COLORREF* GetThermographGreenColors() const override{return m_thermographGreenColors;}

//	virtual void CreateNewBasketTradingWindow(){}
	unsigned int GetNextMenuId() const;//should not be virtual

	virtual unsigned short GetBuiltInColumnCount() const override{return POS_COLUMN_COUNT;}

	virtual unsigned short GetPositionBuiltInColumnCount() const override{return GetBuiltInColumnCount();}
	virtual unsigned short GetOrderBuiltInColumnCount() const override{return OrderWindow::ORD_COLUMN_COUNT;}

#ifdef SECONDARY_ROWS
	virtual unsigned short GetSecondaryBuiltInColumnCount() const override{return GetOrderBuiltInColumnCount();}
#endif
	virtual unsigned short GetAdditionalColumnCount() const override;
	virtual void toString(std::string& str, unsigned int contentModifier) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual void fromScratch() override;
//	virtual TakionTool* Clone() const;
	virtual void AddToSpecificToolCollection() override;
	virtual void UpdateDataGraphics(const Graphics* graphics) override;

	virtual bool UpdateDataGraphicsColorsCustom(const GraphicsColorCollection* colorCollection) override;
	virtual bool UpdateDataGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL) override;
	void UpdateDataColors(bool thermoRedChanged, bool thermoGreenChanged);

//	virtual void UpdateTitle() override;
	virtual void AppendTitleInfo(std::string& info) const override;

	virtual bool CanLink() const override{return true;}

	virtual bool isTickable() const override{return true;}

	virtual void SelectPositionRows(unsigned int filter) override;//PositionStatus

	virtual void MarketSorterCleanup();

	virtual const char* GetSettingsTabPath(const CPoint& point) const override;
	virtual const void* GetSettingsTabInitInfo(const CPoint& point) const override;

	bool PositionPotentiallyBelongs(const PositionData* position) const;
	bool PositionProperBelongs(const PositionData* position) const;
	bool PositionBelongs(const PositionData* position) const;
	virtual bool AccountBelongs(const Account* account) const;
	virtual bool ObjectPotentiallyBelongs(const void* object) const override;
//	bool SecurityBelongs(const PositionData* position) const;
	bool SecurityBelongs(const Security* security) const;
/*
	void MovePotentialRowToBelonging(PositionRow* row);
	void MoveBelongingRowToPotential(PositionRow* row);
	bool RemoveAndDestroyPotentialRow(PositionRow* row);
	void AddRowToPotential(PositionRow* row);
*/
	virtual Row* CreateRow(const void* object, bool potential) override;

	typedef void (PositionRow::*FnPaintInfo)(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	typedef short (PositionRow::*FnCompare)(const PositionRow& other) const;
/*
	bool AddPositionFunctions(unsigned short id, FnPaintInfo fnPaint, FnCompare fnCompare, FnCompare fnCompareAhead);
	inline const FnPaintInfo& GetFnPaintInfo(unsigned short id) const{return id < POS_COLUMN_COUNT ? m_paintInfoFunction[id] : NULL;}
	inline const FnCompare& GetFnCompare(unsigned short id) const{return id < POS_COLUMN_COUNT ? m_compareFunction[id] : NULL;}
	inline const FnCompare& GetFnCompareAhead(unsigned short id) const{return id < POS_COLUMN_COUNT ? m_compareAheadFunction[id] : NULL;}
*/
	void AddPositionFilter(unsigned int filter);
	void RemovePositionFilter(unsigned int filter);
	void SwitchPositionFilter(PositionStatus positionFilter); 
	const unsigned int& GetPositionFilter() const{return m_positionFilter;}
	bool SetPositionFilter(unsigned int positionFilter, unsigned int& addFilter);

	void AddMarketCategoryFilter(unsigned int filter);
	void RemoveMarketCategoryFilter(unsigned int filter);
	void SwitchMarketCategoryFilter(unsigned char positionFilter); 
	const unsigned int& GetMarketCategoryFilter() const{return m_marketCategoryFilter;}
	bool SetMarketCategoryFilter(unsigned int marketCategoryFilter, unsigned int& addFilter);

	void AddOvernightFilter(unsigned int filter);
	void RemoveOvernightFilter(unsigned int filter);
	void SwitchOvernightFilter(unsigned char overnightFilter);
	const unsigned int& GetOvernightFilter() const{return m_overnightFilter;}
	bool SetOvernightFilter(unsigned int overnightFilter, unsigned int& addFilter);

	void AddPhantomFilter(unsigned int filter);
	void RemovePhantomFilter(unsigned int filter);
	void SwitchPhantomFilter(unsigned char phantomFilter);
	const unsigned int& GetPhantomFilter() const{return m_phantomFilter;}
	bool SetPhantomFilter(unsigned int phantomFilter, unsigned int& addFilter);

#ifndef TAKION_NO_OPTIONS
	virtual unsigned short GetNoOptionBuiltInColumnCount() const override{return POS_COLUMN_NO_OPT_COUNT;}
#ifdef SECONDARY_ROWS
	virtual unsigned short GetSecondaryNoOptionBuiltInColumnCount() const override{return OrderWindow::ORD_COLUMN_NO_OPT_COUNT;}
#endif
/*
	bool InstrumentBelongs(const PositionData* position) const;
	void AddInstrumentFilter(unsigned int filter);
	void RemoveInstrumentFilter(unsigned int filter);
	void SwitchInstrumentFilter(unsigned char instrumentFilter);
	const unsigned int& GetInstrumentFilter() const{return m_instrumentFilter;}
	bool SetInstrumentFilter(unsigned int instrumentFilter, unsigned int& addFilter);
*/
#endif
	void AddPqOpenFilter(unsigned int filter);
	void RemovePqOpenFilter(unsigned int filter);
	void SwitchPqOpenFilter(unsigned char yesNoFilter);
	const unsigned int& GetPqOpenFilter() const{return m_pqOpenFilter;}
	bool SetPqOpenFilter(unsigned int pqOpenFilter, unsigned int& addFilter);

	void AddTCloseFilter(unsigned int filter);
	void RemoveTCloseFilter(unsigned int filter);
	void SwitchTCloseFilter(unsigned char yesNoFilter);
	const unsigned int& GetTCloseFilter() const{return m_tCloseFilter;}
	bool SetTCloseFilter(unsigned int tCloseFilter, unsigned int& addFilter);

	void AddInventoryFilter(unsigned int filter);
	void RemoveInventoryFilter(unsigned int filter);
	void SwitchInventoryFilter(unsigned char yesNoFilter);
	const unsigned int& GetInventoryFilter() const{return m_inventoryFilter;}
	bool SetInventoryFilter(unsigned int inventoryFilter, unsigned int& addFilter);

	void AddHiddenFilter(unsigned int filter);
	void RemoveHiddenFilter(unsigned int filter);
	void SwitchHiddenFilter(unsigned char yesNoFilter);
	const unsigned int& GetHiddenFilter() const{return m_hiddenFilter;}
	bool SetHiddenFilter(unsigned int hiddenFilter, unsigned int& addFilter);

	static bool CoverBelongs(unsigned int filter, int realSize, unsigned int buy, unsigned int sell);

	void AddOnOpenCoverFilter(unsigned int filter);
	void RemoveOnOpenCoverFilter(unsigned int filter);
	void SwitchOnOpenCoverFilter(unsigned char coverFilter);
	const unsigned int& GetOnOpenCoverFilter() const{return m_onOpenCoverFilter;}
	bool SetOnOpenCoverFilter(unsigned int coverFilter, unsigned int& addFilter);

	void AddOnCloseCoverFilter(unsigned int filter);
	void RemoveOnCloseCoverFilter(unsigned int filter);
	void SwitchOnCloseCoverFilter(unsigned char coverFilter);
	const unsigned int& GetOnCloseCoverFilter() const{return m_onCloseCoverFilter;}
	bool SetOnCloseCoverFilter(unsigned int coverFilter, unsigned int& addFilter);

//	const bool& isFilterBorrowPositions() const{return m_filterBorrowPositions;}
//	bool SetFilterBorrowPositions(bool filter);
	void AddBorrowFilter(unsigned int filter);
	void RemoveBorrowFilter(unsigned int filter);
	void SwitchBorrowFilter(unsigned char yesNoFilter);
	const unsigned int& GetBorrowFilter() const{return m_borrowFilter;}
	bool SetBorrowFilter(unsigned int borrowFilter, unsigned int& addFilter);

//	const bool& isFilterPendingOrders() const{return m_filterPendingOrders;}
//	bool SetFilterPendingOrders(bool filter);
	void AddPendingOrdersFilter(unsigned int filter);
	void RemovePendingOrdersFilter(unsigned int filter);
	void SwitchPendingOrdersFilter(unsigned char yesNoFilter);
	const unsigned int& GetPendingOrdersFilter() const{return m_pendingOrdersFilter;}
	bool SetPendingOrdersFilter(unsigned int pendingOrdersFilter, unsigned int& addFilter);

	const bool& isFilterUntraded() const{return m_filterUntraded;}
	bool SetFilterUntraded(bool filter);

	const bool& isFilterOpenBasket() const{return m_filterOpenBasket;}
	bool SetFilterOpenBasket(bool filter);

	const bool& isAccountMerge() const{return m_accountMerge;}
	bool SetAccountMerge(bool merge);

	virtual const COLORREF& GetColorFlat() const{return m_colorFlat;}
	virtual const COLORREF& GetColorLong() const{return m_colorLong;}
	virtual const COLORREF& GetColorShort() const{return m_colorShort;}
	virtual const COLORREF& GetInvalidColor() const override{return m_invalidColor;}
//	const COLORREF& GetWarningColor() const{return m_warningColor;}

//	virtual bool ObjectPotentiallyBelongs(const void* object) const;
	virtual bool RowFiltersIn(const RowSortable* row) const;//should be called inside lock
	virtual unsigned char RowBelongs(const RowSortable* row) const;//should be called inside lock
	virtual unsigned char ExistingRowBelongs(const RowSortable* row) const;//should be called inside lock

	virtual bool HasVolumeColumns() const{return true;}
	virtual bool HasMillisecondColumns() const{return true;}

	virtual void AddAccountMergeMenu(CMenu& popupMenu);
	virtual const PositionGroupCollection* GetMergedPositions() const{return m_mergedPositions;}

#ifdef FIRM_VALUES
	void UpdateCanSeeFirmPositions();
	virtual const bool& CanSeeFirmPositions() const override{return m_canSeeFirmPositions;}
#endif

	virtual bool Populate(bool remove) override;
	virtual bool isFiltered() const override;
	virtual bool hasInventoryView() const{return true;}

	virtual void StockAddedToCommandToolBasket(const unsigned __int64& symbol) override;
//	virtual void StockRemovedFromCommandToolBasket(const unsigned __int64& symbol) override;
protected:
	PositionWindow(const CBitmap* bitmap, unsigned int workspace, bool pinned = false);

	virtual void OnSuccessfulCreate();
//	virtual void UpdateInventoryView();

	virtual bool DoUpdateColumnUse(const UseChangeSet& use, const UseChangeSet& unuse
#ifdef SECONDARY_ROWS
		, bool secondary
#endif
	) override;

	virtual bool RemoveAllObjectsBelongingToAccount(const Account* account) override;

	virtual void CreateAdditionalColumns() override;
	virtual void SecurityDoubleClicked(UINT nFlags, const CPoint& point) override;

	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;
//	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
//	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
//	DECLARE_MESSAGE_MAP()

//	void CalculateMaxTotalValues(bool filtered);
	virtual void ResetMinMaxValues() override;

	void SelectedTradePhantom(unsigned char side);//0 - sell, 1 - buy, 2 - flip, 3 - remove
	void RemoveAllVisiblePhantom();
	void RemoveAllPhantom();

	void SelectedPositionCancelOrders(unsigned char mode);//0 - all, 1 - opening

#ifdef _DEBUG
	void SelectedUpdateRow();
#endif

	virtual void BeforeDestroy() override;
	virtual void AccountChanged() override;
	virtual void AddMenuItems(CMenu& menu) override;
	virtual void PostAddMenuItems(CMenu& menu) override;
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;
	virtual void ViewAllAccountsChanged(bool remove) override;

	virtual RowTotal* CreateRowTotal() override;
	
#ifdef SECONDARY_ROWS
	virtual void CreateSecondaryAdditionalColumns() override;
	virtual void DoUpdateSecondaryDataGraphicsColorsCustom(const GraphicsColorCollection* colorCollection) override;
	virtual void DoUpdateSecondaryDataGraphicsColors(const Graphics* graphics) override;

	virtual void OrderDeleted(Order* order);
	virtual void RowRemoved(RowSortable* row) override;
#endif

	virtual void Repopulate() override;

	bool PopulateAllAccounts();
	bool PopulateOneAccount(const Account* account, const Position* position);
	bool PopulateOnePosition(const Position* position);

//	void DestroyPotentialRows();
//	RowMap m_potentialRows;
/////
	unsigned int m_positionFilter;
	unsigned int m_marketCategoryFilter;
	unsigned int m_overnightFilter;
	unsigned int m_phantomFilter;
//#ifndef TAKION_NO_OPTIONS
//	unsigned int m_instrumentFilter;
//#endif
	unsigned int m_onOpenCoverFilter;
	unsigned int m_onCloseCoverFilter;
	unsigned int m_pqOpenFilter;
	unsigned int m_tCloseFilter;
	unsigned int m_borrowFilter;
	unsigned int m_pendingOrdersFilter;
	unsigned int m_inventoryFilter;
	unsigned int m_hiddenFilter;
//	bool m_filterBorrowPositions;
//	bool m_filterPendingOrders;
	bool m_filterUntraded;
	bool m_filterOpenBasket;
/////
	bool m_accountMerge;
#ifdef FIRM_VALUES
	bool m_canSeeFirmPositions;
#endif
	
	virtual bool UpdateHistoryLoadBkColor() override;

	COLORREF m_colorThermographRed;
	COLORREF m_colorThermographGreen;
	COLORREF m_thermographRedColors[thermographSize];
	COLORREF m_thermographGreenColors[thermographSize];

	COLORREF m_colorFlat;
	COLORREF m_colorLong;
	COLORREF m_colorShort;

	COLORREF m_invalidColor;

#ifdef SECONDARY_ROWS
	virtual void AddSecondaryRowMenuItems(CMenu& menu) override;

	COLORREF m_buyColor;
	COLORREF m_sellColor;
	COLORREF m_shortColor;

	COLORREF m_colorPendingBuy;
	COLORREF m_colorPendingSell;
	COLORREF m_colorPendingShort;
	COLORREF m_colorPendingFilledBuy;
	COLORREF m_colorPendingFilledSell;
	COLORREF m_colorPendingFilledShort;

	COLORREF m_colorUnacknowledged;
	COLORREF m_colorNotSent;
	COLORREF m_colorFilled;
	COLORREF m_colorPartialFilled;
	COLORREF m_colorKicked;
	COLORREF m_colorBlocked;
	COLORREF m_colorCanceled;
	COLORREF m_colorCanceling;
	COLORREF m_colorReplacing;
	COLORREF m_colorPostponed;
	COLORREF m_colorWaiting;

	unsigned int m_orderFilter;
	unsigned int m_orderSideFilter;
	unsigned int m_orderBorrowFilter;
	unsigned int m_orderAutoCloseFilter;
	unsigned int m_orderPostponedFilter;
	unsigned int m_orderUserTypeFilter;
	unsigned int m_orderStopTypeFilter;
	unsigned int m_orderDirectionFilter;
	unsigned int m_orderTifFilter;

	unsigned int m_orderMnemonicFilter;
	MnemonicSet m_orderMnemonicFilterSet;
	MnemonicSet::const_iterator m_orderMnemonicFilterSetEnd;

//	bool m_includeAlgos;
#endif
//	COLORREF m_warningColor;
/*
	FnPaintInfo m_paintInfoFunction[POS_COLUMN_COUNT];
	FnCompare m_compareFunction[POS_COLUMN_COUNT];
	FnCompare m_compareAheadFunction[POS_COLUMN_COUNT];
*/
	virtual void ActiveSymbolAboutToChange(const unsigned __int64& newActiveSymbol
#ifndef TAKION_NO_OPTIONS
		,const unsigned __int64& newActiveOptionBlock
#endif
		);
	virtual bool ActiveSymbolChanged();
	RowSortableList m_topRowList;
//	PositionRow* m_prevTopRow;
	//PositionRow* m_nextTopRow;

	virtual void AllAccountsModeChanged();
	bool CreateMergedPositions();
	bool DestroyMergedPositions();
	bool UpdateAccountMerge();
	virtual PositionGroupCollection* DoCreateMergedPositions() = 0;
	PositionGroupCollection* m_mergedPositions;

private:

#if (_MSC_VER > 1600)
	typedef std::unordered_set<const PositionGroup*> PositionGroupSet;
#else
	typedef std::hash_set<const PositionGroup*> PositionGroupSet;
#endif
	void CollectPositionGroupsForAccount(const Account* account, PositionGroupSet& positionGroupSet);
	bool NotifyPositionGroupsRemoved(PositionGroupSet& positionGroupSet);
};

class TGUI_API PositionRow : public
#ifdef SECONDARY_ROWS
	RowSortableChild
#else
	RowSortable
#endif
	, public Observer
{
friend class PositionWindow;
friend class AccountWindow;
public:
	PositionRow(RowWindowSortable* parent, PositionData* position, bool potential = false
#ifdef SECONDARY_ROWS
		, RowSortable* parentRow = NULL, bool expanded = false
#endif
		);
	virtual const void* GetBaseObject() const override{return m_position;}
	virtual bool GetPaintTextInfo(unsigned short columnId, std::string& text, COLORREF& color) const override;//, UINT& horizontalJustification) const override;
	virtual bool PaintCell(CDC& dc, const Column* column, const CRect& rect, UINT verticalJustification, int horizontalOffset) const override;//, unsigned char horizontalAlignment) const;
	virtual bool CellToString(std::string& info, unsigned short columnId) const override;
	virtual COLORREF GetRowColor() const override;
	virtual COLORREF GetCellColor(unsigned short columnId) const override;
	virtual COLORREF GetCellBkColor(unsigned short columnId) const override;

//	virtual bool hasInventory() const{return m_position && m_position->GetConstInventory() != NULL;}
	virtual bool hasInventory() const override{return m_position && m_position->GetInventory() != NULL;}

	virtual RowValue* CreateCell(unsigned short id) override;

	virtual const Account* GetRowAccount() const override{return m_position->GetAccount();}

	virtual bool Lock(bool wait) const override;
//	virtual void LockWait() const override;
	virtual void Unlock() const override;

	virtual short DefaultCompare(const RowSortable& other) const override;

	virtual bool isSortValueChanged() const override;
	virtual bool isChainSortValueChanged() const override;

	virtual bool CompareFunction(const RowSortable& other, unsigned short sortId, short& ret) const override;
	virtual bool CompareFunctionAhead(const RowSortable& other, unsigned short sortId, short& ret) const override;
	virtual short PreCompare(const RowSortable& other) const override;

	virtual void Update(bool dynamicOnly) override;
	virtual void UpdateAndInvalidate(CRect& rowRect, bool dynamicOnly) override;
	virtual bool UpdateRowColor() override;//should be called only inside a lock


//	virtual
	bool SetSecurity(const Security* security, bool marketDataSecurity);
	bool SetSortableSecurity(const Security* security);
	virtual const Security* GetSecurity() const{return m_security;}
	const Security* const& GetSecurityRef() const{return m_security;}

#ifndef TAKION_NO_OPTIONS
	bool SetUnderlierSecurity(const Security* security);
	bool SetUnderlierSortableSecurity(const Security* security);
//	virtual const Security* GetUnderlierSecurity() const{return m_security;}
	const Security* const& GetUnderlierSecurityRef() const{return m_underlierSecurity;}
#endif

	bool NewEquity(const Security* security);
	bool NewStock(const Security* security);

	virtual const PositionData* GetRowPosition(const CPoint* point = NULL) const override{return m_position;}

	PositionData* GetPosition(){return m_position;}
	const PositionData* GetPosition() const{return m_position;}
	virtual const char* GetRowSecuritySymbol(const CPoint* point = NULL) const override;//{return m_position ? m_position->GetSymbol() : NULL;}
	virtual const unsigned __int64& GetRowNumericSymbol() const{return m_position ? m_position->GetNumericSymbol() : uint64Zero;}

	DECLARE_NED_NEW

	void PaintSymbol(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareSymbol(const PositionRow& other) const;
	void PaintAccountId(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareAccountId(const PositionRow& other) const;
	void PaintAccountUserName(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareAccountUserName(const PositionRow& other) const;
#ifndef TAKION_NO_OPTIONS
//	void PaintSuffix(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
//	short CompareSuffix(const PositionRow& other) const;
	void PaintCall(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareCall(const PositionRow& other) const;
	void PaintExpiration(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareExpiration(const PositionRow& other) const;
	void PaintExpirationDays(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareExpirationDays(const PositionRow& other) const;
	void PaintStrike(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareStrike(const PositionRow& other) const;
	void PaintExpirationType(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareExpirationType(const PositionRow& other) const;
#endif

	static const unsigned short thermographLength = 16;

	const Thermograph& GetThermographQuotesGreen() const{return m_thermographQuotesGreen;}
	const Thermograph& GetThermographQuotesRed() const{return m_thermographQuotesRed;}
	const Thermograph& GetThermographPrintsGreen() const{return m_thermographPrintsGreen;}
	const Thermograph& GetThermographPrintsRed() const{return m_thermographPrintsRed;}

	short CompareThermographPrints(const PositionRow& other) const;
	short CompareThermographPrintsAhead(const PositionRow& other) const;
	short CompareThermographQuotes(const PositionRow& other) const;
	short CompareThermographQuotesAhead(const PositionRow& other) const;

	bool UpdatePrintsAndQuotes(bool lock);
	bool UpdateQuotes(bool lock);
protected:
	bool NullifyEquity();
	bool NullifySortableEquity();
	virtual void Notify(const Message* message, const Observable* from, const Message* info = NULL) override;
//	PositionWindow* m_positionWindow;
	PositionData* m_position;
	const Security* m_security;

#ifndef TAKION_NO_OPTIONS
	bool NullifyUnderlierEquity();
	const Security* m_underlierSecurity;
#endif
	COLORREF m_positionColor;

	void CleanupThermographs();

	Thermograph m_thermographQuotesGreen;
	Thermograph m_thermographQuotesRed;
	Thermograph m_thermographPrintsGreen;
	Thermograph m_thermographPrintsRed;

	int m_quotesThermographValueRed;
	int m_quotesThermographValueGreen;
	int m_printsThermographValueRed;
	int m_printsThermographValueGreen;
};

class TGUI_API PositionRowTotal : public RowTotal
{
public:
	PositionRowTotal(PositionWindow* window, unsigned short columnCount = PositionWindow::POS_COLUMN_COUNT):
//		RowTotal(PositionWindow::POS_COLUMN_COUNT, window),
		RowTotal(columnCount + window->GetAdditionalColumnCount(), window),
		m_size(NULL),
		m_signedSize(NULL),
#ifndef TAKION_NO_OPTIONS
		m_shareSize(NULL),
#endif
		m_onOpenSize(NULL),
		m_onCloseSize(NULL),
		m_firmSize(NULL),
		m_phantomSize(NULL),
		m_pnlOpenLevel1(NULL),
//		m_pnlOpenLevel1Cost(NULL),
		m_pnlOpenPrint(NULL),
		m_ticketAverage(NULL),
		m_markedTicketAverage(NULL),
		m_markedTicketAverageHi(NULL),
		m_markedTicketAverageLo(NULL),
		m_pnlClosed(NULL),
		m_pnlClosedNet(NULL),
//		m_pnlClosedCost(NULL),
		m_sharesTraded(NULL),

		m_maxInvestment(NULL),
		m_maxInvestmentLong(NULL),
		m_maxInvestmentShort(NULL),
		m_investment(NULL),

		m_maxInvestmentMe(NULL),
		m_maxInvestmentLongMe(NULL),
		m_maxInvestmentShortMe(NULL),
		m_investmentMe(NULL),

		m_maxInvestmentBeta(NULL),
		m_maxInvestmentLongBeta(NULL),
		m_maxInvestmentShortBeta(NULL),
		m_investmentBeta(NULL),

		m_mpnlNbboPrint(NULL),
		m_mpnlNbboPrintHi(NULL),
		m_mpnlNbboPrintLo(NULL),

		m_gpsLevel1(NULL),
		m_gpsPrint(NULL),
		m_gpsPrintHi(NULL),
		m_gpsPrintLo(NULL),
		m_untradeableLevel(NULL),
		m_untradeableCount(NULL),
		m_inventorySize(NULL),
		m_hiddenCount(NULL)
	{
	}
	virtual ~PositionRowTotal();
	void SetSizePtr(UIntRowValue* const& value){m_size = value;}
	void SetSignedSizePtr(IntRowValue* const& value){m_signedSize = value;}
#ifndef TAKION_NO_OPTIONS
	void SetShareSizePtr(UIntRowValue* const& value){m_shareSize = value;}
#endif
	void SetOnOpenSizePtr(UIntRowValue* const& value){m_onOpenSize = value;}
	void SetOnCloseSizePtr(UIntRowValue* const& value){m_onCloseSize = value;}

	void SetFirmSizePtr(UIntRowValue* const& value){m_firmSize = value;}
	void SetPhantomSizePtr(UIntRowValue* const& value){m_phantomSize = value;}
	void SetPnlOpenLevel1Ptr(MoneyRowValue* const& value){m_pnlOpenLevel1 = value;}
//	void SetPnlOpenLevel1CostPtr(MoneyRowValue* const& value){m_pnlOpenLevel1Cost = value;}
	void SetPnlOpenPrintPtr(MoneyRowValue* const& value){m_pnlOpenPrint = value;}
	void SetTicketAveragePtr(MoneyRowValue* const& value){m_ticketAverage = value;}
	void SetMarkedTicketAveragePtr(MoneyRowValue* const& value){m_markedTicketAverage = value;}
	void SetMarkedTicketAverageHiPtr(MoneyRowValue* const& value){m_markedTicketAverageHi = value;}
	void SetMarkedTicketAverageLoPtr(MoneyRowValue* const& value){m_markedTicketAverageLo = value;}
	void SetPnlClosedPtr(MoneyRowValue* const& value){m_pnlClosed = value;}
	void SetPnlClosedNetPtr(MoneyRowValue* const& value){m_pnlClosedNet = value;}
//	void SetPnlClosedCostPtr(MoneyRowValue* value){m_pnlClosedCost = value;}
	void SetSharesTradedPtr(UIntRowValue* const& value){m_sharesTraded = value;}

	void SetMaxInvestmentPtr(MoneyRowValue* const& value){m_maxInvestment = value;}
	void SetMaxInvestmentLongPtr(MoneyRowValue* const& value){m_maxInvestmentLong = value;}
	void SetMaxInvestmentShortPtr(MoneyRowValue* const& value){m_maxInvestmentShort = value;}
	void SetInvestmentPtr(MoneyRowValue* const& value){m_investment = value;}

	void SetMaxInvestmentMePtr(MoneyRowValue* const& value){m_maxInvestmentMe = value;}
	void SetMaxInvestmentLongMePtr(MoneyRowValue* const& value){m_maxInvestmentLongMe = value;}
	void SetMaxInvestmentShortMePtr(MoneyRowValue* const& value){m_maxInvestmentShortMe = value;}
	void SetInvestmentMePtr(MoneyRowValue* const& value){m_investmentMe = value;}

	void SetMaxInvestmentBetaPtr(MoneyRowValue* const& value){m_maxInvestmentBeta = value;}
	void SetMaxInvestmentLongBetaPtr(MoneyRowValue* const& value){m_maxInvestmentLongBeta = value;}
	void SetMaxInvestmentShortBetaPtr(MoneyRowValue* const& value){m_maxInvestmentShortBeta = value;}
	void SetInvestmentBetaPtr(MoneyRowValue* const& value){m_investmentBeta = value;}

	void SetMpnlNbboPrintPtr(MoneyRowValue* const& value){m_mpnlNbboPrint = value;}
	void SetMpnlNbboPrintHiPtr(MoneyRowValue* const& value){m_mpnlNbboPrintHi = value;}
	void SetMpnlNbboPrintLoPtr(MoneyRowValue* const& value){m_mpnlNbboPrintLo = value;}

	void SetGpsLevel1Ptr(SignedPriceRowValue* const& value){m_gpsLevel1 = value;}
	void SetGpsPrintPtr(SignedPriceRowValue* const& value){m_gpsPrint = value;}
	void SetGpsPrintHiPtr(SignedPriceRowValue* const& value){m_gpsPrintHi = value;}
	void SetGpsPrintLoPtr(SignedPriceRowValue* const& value){m_gpsPrintLo = value;}

	void SetUntradeableLevelPtr(UIntRowValue* const& value){m_untradeableLevel = value;}
	void SetUntradeableCountPtr(UIntRowValue* const& value){m_untradeableCount = value;}
	void SetInventorySizePtr(UIntRowValue* const& value){m_inventorySize = value;}
	void SetHiddenCountPtr(UIntRowValue* const& value){m_hiddenCount = value;}

	const UIntRowValue* const& GetSizePtr() const{return m_size;}
	const IntRowValue* const& GetSignedSizePtr() const{return m_signedSize;}
#ifndef TAKION_NO_OPTIONS
	const UIntRowValue* const& GetShareSizePtr() const{return m_shareSize;}
#endif
	const UIntRowValue* const& GetOnOpenSizePtr() const{return m_onOpenSize;}
	const UIntRowValue* const& GetOnCloseSizePtr() const{return m_onCloseSize;}
	const UIntRowValue* const& GetFirmSizePtr() const{return m_firmSize;}
	const UIntRowValue* const& GetPhantomSizePtr() const{return m_phantomSize;}
	const MoneyRowValue* const& GetPnlOpenLevel1Ptr() const{return m_pnlOpenLevel1;}
	const MoneyRowValue* const& GetPnlOpenPrintPtr() const{return m_pnlOpenPrint;}
	const MoneyRowValue* const& GetTicketAveragePtr() const{return m_ticketAverage;}
	const MoneyRowValue* const& GetMarkedTicketAveragePtr() const{return m_markedTicketAverage;}
	const MoneyRowValue* const& GetMarkedTicketAverageHiPtr() const{return m_markedTicketAverageHi;}
	const MoneyRowValue* const& GetMarkedTicketAverageLoPtr() const{return m_markedTicketAverageLo;}
	const MoneyRowValue* const& GetPnlClosedPtr() const{return m_pnlClosed;}
	const MoneyRowValue* const& GetPnlClosedNetPtr() const{return m_pnlClosedNet;}
	const UIntRowValue* const& GetSharesTradedPtr() const{return m_sharesTraded;}

	const MoneyRowValue* const& GetMaxInvestmentPtr() const{return m_maxInvestment;}
	const MoneyRowValue* const& GetMaxInvestmentLongPtr() const{return m_maxInvestmentLong;}
	const MoneyRowValue* const& GetMaxInvestmentShortPtr() const{return m_maxInvestmentShort;}
	const MoneyRowValue* const& GetInvestmentPtr() const{return m_investment;}

	const MoneyRowValue* const& GetMaxInvestmentMePtr() const{return m_maxInvestmentMe;}
	const MoneyRowValue* const& GetMaxInvestmentLongMePtr() const{return m_maxInvestmentLongMe;}
	const MoneyRowValue* const& GetMaxInvestmentShortMePtr() const{return m_maxInvestmentShortMe;}
	const MoneyRowValue* const& GetInvestmentMePtr() const{return m_investmentMe;}

	const MoneyRowValue* const& GetMaxInvestmentBetaPtr() const{return m_maxInvestmentBeta;}
	const MoneyRowValue* const& GetMaxInvestmentLongBetaPtr() const{return m_maxInvestmentLongBeta;}
	const MoneyRowValue* const& GetMaxInvestmentShortBetaPtr() const{return m_maxInvestmentShortBeta;}
	const MoneyRowValue* const& GetInvestmentBetaPtr() const{return m_investmentBeta;}

	const MoneyRowValue* const& GetMpnlNbboPrintPtr() const{return m_mpnlNbboPrint;}
	const MoneyRowValue* const& GetMpnlNbboPrintHiPtr() const{return m_mpnlNbboPrintHi;}
	const MoneyRowValue* const& GetMpnlNbboPrintLoPtr() const{return m_mpnlNbboPrintLo;}

	const SignedPriceRowValue* const& GetGpsLevel1Ptr() const{return m_gpsLevel1;}
	const SignedPriceRowValue* const& GetGpsPrintPtr() const{return m_gpsPrint;}
	const SignedPriceRowValue* const& GetGpsPrintHiPtr() const{return m_gpsPrintHi;}
	const SignedPriceRowValue* const& GetGpsPrintLoPtr() const{return m_gpsPrintLo;}

	const UIntRowValue* const& GetUntradeableLevelPtr() const{return m_untradeableLevel;}
	const UIntRowValue* const& GetUntradeableCountPtr() const{return m_untradeableCount;}
	const UIntRowValue* const& GetInventorySizePtr() const{return m_inventorySize;}
	const UIntRowValue* const& GetHiddenCountPtr() const{return m_hiddenCount;}
protected:
	virtual void UpdateNonCumulativeValues(const Row* row, bool dynamicOnly) override;
//	virtual void UpdateInventoryViewNonCumulativeValues(const Row* row);
	virtual void AddNonCumulativeValues(const Row* row) override;
	virtual void RemoveNonCumulativeValues(const Row* row) override;
	virtual void ResetNonCumulativeValues() override;
	virtual void ResetMinMaxValues(const void* container) override;

	void AddNonCumulativeMinMaxValues(const Row* row);

	UIntRowValue* m_size;
	IntRowValue* m_signedSize;
#ifndef TAKION_NO_OPTIONS
	UIntRowValue* m_shareSize;
#endif
	UIntRowValue* m_onOpenSize;
	UIntRowValue* m_onCloseSize;
	UIntRowValue* m_firmSize;
	UIntRowValue* m_phantomSize;
	MoneyRowValue* m_pnlOpenLevel1;
//	MoneyRowValue* m_pnlOpenLevel1Cost;
	MoneyRowValue* m_pnlOpenPrint;
	MoneyRowValue* m_ticketAverage;
	MoneyRowValue* m_markedTicketAverage;
	MoneyRowValue* m_markedTicketAverageHi;
	MoneyRowValue* m_markedTicketAverageLo;
	MoneyRowValue* m_pnlClosed;
	MoneyRowValue* m_pnlClosedNet;
//	MoneyRowValue* m_pnlClosedCost;
	UIntRowValue* m_sharesTraded;

	MoneyRowValue* m_maxInvestment;
	MoneyRowValue* m_maxInvestmentLong;
	MoneyRowValue* m_maxInvestmentShort;
	MoneyRowValue* m_investment;

	MoneyRowValue* m_maxInvestmentMe;
	MoneyRowValue* m_maxInvestmentLongMe;
	MoneyRowValue* m_maxInvestmentShortMe;
	MoneyRowValue* m_investmentMe;

	MoneyRowValue* m_maxInvestmentBeta;
	MoneyRowValue* m_maxInvestmentLongBeta;
	MoneyRowValue* m_maxInvestmentShortBeta;
	MoneyRowValue* m_investmentBeta;

	MoneyRowValue* m_mpnlNbboPrint;
	MoneyRowValue* m_mpnlNbboPrintHi;
	MoneyRowValue* m_mpnlNbboPrintLo;

	SignedPriceRowValue* m_gpsLevel1;
	SignedPriceRowValue* m_gpsPrint;
	SignedPriceRowValue* m_gpsPrintHi;
	SignedPriceRowValue* m_gpsPrintLo;

	UIntRowValue* m_untradeableLevel;
	UIntRowValue* m_untradeableCount;
	UIntRowValue* m_inventorySize;
	UIntRowValue* m_hiddenCount;
};

class AccountRow;

class TGUI_API AccountWindow : public RowWindowSortable//, public Observer
{
//friend class TakionMainWnd;
public:
	virtual const char* GetToolId() const override{return toolAccountId;}
//	virtual ~AccountWindow(){DestroyPotentialRows();}

	virtual bool isTickable() const override{return true;}
//	virtual Account* GetAccountFromRow(Row* row);
#ifdef SECONDARY_ROWS
	void SelectedTradePhantom(unsigned char side);//0 - sell, 1 - buy, 2 - flip, 3 - remove
	void RemoveAllVisiblePhantom();
	void RemoveAllPhantom();
//	virtual const Columns* GetPositionColumns() const{return m_secondaryColumns;}
	virtual void SetCommandToolStockBasketMap(const StockBasketMap* stockBasketMap) override;
	virtual void StockAddedToCommandToolBasket(const unsigned __int64& symbol) override;
	virtual void StockRemovedFromCommandToolBasket(const unsigned __int64& symbol) override;
	virtual void StocksClearedFromCommandToolBasket() override;

	virtual const char* GetSecondaryToolId() const{return toolPositionId;}
	virtual void UpdateSecondaryDataGraphics(const Graphics* graphics);

	virtual const COLORREF& GetColorFlat() const{return m_colorFlat;}
	virtual const COLORREF& GetColorLong() const{return m_colorLong;}
	virtual const COLORREF& GetColorShort() const{return m_colorShort;}
	virtual const COLORREF& GetInvalidColor() const override{return m_invalidColor;}

	static const unsigned short thermographSize = 16;
	static const unsigned short thermographDepth = 16;
	virtual const COLORREF* GetThermographRedColors() const override{return m_thermographRedColors;}
	virtual const COLORREF* GetThermographGreenColors() const override{return m_thermographGreenColors;}

	virtual bool SecondaryObjectPotentiallyBelongs(const void* object) const;//no need to call inside lock
	virtual bool SecondaryRowFiltersIn(const RowSortable* row) const;//should be called inside lock
	virtual unsigned char SecondaryRowBelongs(const RowSortable* row) const;//2 - belongs; 1 - does not belong but can update to become belonging; 0 - does not belong and cannot update to become belonging
	virtual unsigned char SecondaryExistingRowBelongs(const RowSortable* row) const;//2 - belongs; 1 - does not belong but can update to become belonging; 0 - does not belong and cannot update to become belonging
	virtual bool ExpandRow(Row* row) override;
	virtual RowSortable* CreateSecondaryRow(const void* object, bool potential, RowSortable* parentRow) override;
	bool PopulateOnePosition(const Position* position, RowSortable* parentRow);

	unsigned char PositionBelongingStatus(const PositionData* position) const;
	bool PositionPotentiallyBelongs(const PositionData* position) const;
	bool PositionBelongs(const PositionData* position) const;//, const Security* security) const
	bool PositionProperBelongs(const PositionData* position) const;//, const Security* security) const
	static bool CoverBelongs(unsigned int filter, int realSize, unsigned int buy, unsigned int sell);

//	bool SecurityBelongs(const PositionData* position) const;
	bool SecurityBelongs(const Security* security) const;//should be called inside lock

	virtual void MarketSorterCleanup();
	virtual void SelectPositionRows(unsigned int filter);
	Position* GetPositionFromRow(Row* row);
	const Position* GetPositionFromRow(const Row* row) const;
/////
	void AddPositionFilter(unsigned int filter);
	void RemovePositionFilter(unsigned int filter);
	void SwitchPositionFilter(PositionStatus positionFilter); 
	const unsigned int& GetPositionFilter() const{return m_positionFilter;}
	bool SetPositionFilter(unsigned int positionFilter, unsigned int& addFilter);

	void AddMarketCategoryFilter(unsigned int filter);
	void RemoveMarketCategoryFilter(unsigned int filter);
	void SwitchMarketCategoryFilter(unsigned char positionFilter); 
	const unsigned int& GetMarketCategoryFilter() const{return m_marketCategoryFilter;}
	bool SetMarketCategoryFilter(unsigned int marketCategoryFilter, unsigned int& addFilter);

	void AddOvernightFilter(unsigned int filter);
	void RemoveOvernightFilter(unsigned int filter);
	void SwitchOvernightFilter(unsigned char overnightFilter);
	const unsigned int& GetOvernightFilter() const{return m_overnightFilter;}
	bool SetOvernightFilter(unsigned int overnightFilter, unsigned int& addFilter);

	void AddPhantomFilter(unsigned int filter);
	void RemovePhantomFilter(unsigned int filter);
	void SwitchPhantomFilter(unsigned char phantomFilter);
	const unsigned int& GetPhantomFilter() const{return m_phantomFilter;}
	bool SetPhantomFilter(unsigned int phantomFilter, unsigned int& addFilter);
/*
#ifndef TAKION_NO_OPTIONS
	bool InstrumentBelongs(const PositionData* position) const;
	void AddInstrumentFilter(unsigned int filter);
	void RemoveInstrumentFilter(unsigned int filter);
	void SwitchInstrumentFilter(unsigned char instrumentFilter);
	const unsigned int& GetInstrumentFilter() const{return m_instrumentFilter;}
	bool SetInstrumentFilter(unsigned int instrumentFilter, unsigned int& addFilter);
#endif
*/
	void AddPqOpenFilter(unsigned int filter);
	void RemovePqOpenFilter(unsigned int filter);
	void SwitchPqOpenFilter(unsigned char yesNoFilter);
	const unsigned int& GetPqOpenFilter() const{return m_pqOpenFilter;}
	bool SetPqOpenFilter(unsigned int pqOpenFilter, unsigned int& addFilter);

	void AddTCloseFilter(unsigned int filter);
	void RemoveTCloseFilter(unsigned int filter);
	void SwitchTCloseFilter(unsigned char yesNoFilter);
	const unsigned int& GetTCloseFilter() const{return m_tCloseFilter;}
	bool SetTCloseFilter(unsigned int tCloseFilter, unsigned int& addFilter);

	void AddPosInventoryFilter(unsigned int filter);
	void RemovePosInventoryFilter(unsigned int filter);
	void SwitchPosInventoryFilter(unsigned char yesNoFilter);
	const unsigned int& GetPosInventoryFilter() const{return m_posInventoryFilter;}
	bool SetPosInventoryFilter(unsigned int posInventoryFilter, unsigned int& addFilter);

	void AddPosHiddenFilter(unsigned int filter);
	void RemovePosHiddenFilter(unsigned int filter);
	void SwitchPosHiddenFilter(unsigned char yesNoFilter);
	const unsigned int& GetPosHiddenFilter() const{return m_posHiddenFilter;}
	bool SetPosHiddenFilter(unsigned int posHiddenFilter, unsigned int& addFilter);

//	static bool CoverBelongs(unsigned int filter, int realSize, unsigned int buy, unsigned int sell);

	void AddOnOpenCoverFilter(unsigned int filter);
	void RemoveOnOpenCoverFilter(unsigned int filter);
	void SwitchOnOpenCoverFilter(unsigned char coverFilter);
	const unsigned int& GetOnOpenCoverFilter() const{return m_onOpenCoverFilter;}
	bool SetOnOpenCoverFilter(unsigned int coverFilter, unsigned int& addFilter);

	void AddOnCloseCoverFilter(unsigned int filter);
	void RemoveOnCloseCoverFilter(unsigned int filter);
	void SwitchOnCloseCoverFilter(unsigned char coverFilter);
	const unsigned int& GetOnCloseCoverFilter() const{return m_onCloseCoverFilter;}
	bool SetOnCloseCoverFilter(unsigned int coverFilter, unsigned int& addFilter);

//	const bool& isFilterBorrowPositions() const{return m_filterBorrowPositions;}
//	bool SetFilterBorrowPositions(bool filter);
	void AddBorrowFilter(unsigned int filter);
	void RemoveBorrowFilter(unsigned int filter);
	void SwitchBorrowFilter(unsigned char yesNoFilter);
	const unsigned int& GetBorrowFilter() const{return m_borrowFilter;}
	bool SetBorrowFilter(unsigned int borrowFilter, unsigned int& addFilter);

//	const bool& isFilterPendingOrders() const{return m_filterPendingOrders;}
//	bool SetFilterPendingOrders(bool filter);
	void AddPendingOrdersFilter(unsigned int filter);
	void RemovePendingOrdersFilter(unsigned int filter);
	void SwitchPendingOrdersFilter(unsigned char yesNoFilter);
	const unsigned int& GetPendingOrdersFilter() const{return m_pendingOrdersFilter;}
	bool SetPendingOrdersFilter(unsigned int pendingOrdersFilter, unsigned int& addFilter);

	const bool& isFilterUntraded() const{return m_filterUntraded;}
	bool SetFilterUntraded(bool filter);

	const bool& isFilterOpenBasket() const{return m_filterOpenBasket;}
	bool SetFilterOpenBasket(bool filter);
/////
	const std::string& GetStockBasketName() const{return m_stockBasketName;}
	const StockBasketMap* GetCommandToolStockBasketMap() const{return m_stockBasketMapPtr;}
#endif

	virtual void AllAccountsLoaded() override;
	virtual void LoggedToExecutor() override;
	virtual void ConnectionDisconnected(unsigned int ipAddress, unsigned short port, unsigned int ipBindAddress, unsigned short bindPort, unsigned char connectionType, const char* connectionName) override;
	virtual void ConnectionConnected(unsigned int ipAddress, unsigned short port, unsigned int ipBindAddress, unsigned short bindPort, unsigned char connectionType, const char* connectionName) override;

	enum ColumnId : unsigned short
	{
		ACT_NAME,
		ACT_FIRM_ID,
		ACT_BP_USED,
		ACT_BP_AVAILABLE,
		ACT_POS_COUNT,
		ACT_LONG_POS_COUNT,
		ACT_SHORT_POS_COUNT,
		ACT_PNL_CLOSED,
		ACT_PNL_CLOSED_NET,
		ACT_MPNL_L1,
		ACT_OPNL_L1,
		ACT_OPNL_PRINT,
		ACT_ORDERS,
		ACT_LONG_ORDERS,
		ACT_SHORT_ORDERS,
		ACT_SHARES_TRADED,
		ACT_SIZE_PEND_LONG,
		ACT_SIZE_PEND_SHORT,
		ACT_SIZE_PTL_LONG,
		ACT_SIZE_PTL_SHORT,
		ACT_MONEY_PEND_LONG,
		ACT_MONEY_PEND_SHORT,
		ACT_TICKET_AVERAGE,
		ACT_INVESTMENT,
		ACT_MAX_INVESTMENT,
		ACT_INVESTMENT_LONG,
		ACT_MAX_INVESTMENT_LONG,
		ACT_INVESTMENT_SHORT,
		ACT_MAX_INVESTMENT_SHORT,
		ACT_SIZE_LONG_OVERNITE,
		ACT_SIZE_SHORT_OVERNITE,
		ACT_INVESTMENT_LONG_OVERNITE,
		ACT_INVESTMENT_SHORT_OVERNITE,
		ACT_INVESTMENT_OVERNITE,

		ACT_CTRN_BP,
		ACT_CTRN_DAY_POS_INVEST,
		ACT_CTRN_NITE_POS_INVEST,
		ACT_CTRN_DAY_LONG_INVEST,
		ACT_CTRN_DAY_SHORT_INVEST,
		ACT_CTRN_NITE_LONG_INVEST,
		ACT_CTRN_NITE_SHORT_INVEST,
		ACT_CTRN_LOSS,
		ACT_CTRN_POS_LOSS,
		ACT_CTRN_POS_OPEN_LOSS,
		ACT_CTRN_TRADED_MONEY,
		ACT_CTRN_SHORT_PRICE,
		ACT_CTRN_SHARES_TOTAL,
		ACT_CTRN_SHARES_TRADED,
		ACT_CTRN_DAY_POS_SHARES,
		ACT_CTRN_NITE_POS_SHARES,
		ACT_CTRN_POS_ORDERS,
		ACT_CTRN_POS_COUNT,
		ACT_CTRN_ORDER_SIZE,

		ACT_BORROW_PEND_INVESTMENT,
		ACT_BORROW_INVESTMENT,
		ACT_BORROW_PEND_BUY_SIZE,
		ACT_BORROW_SIZE,
		ACT_USER_NAME,
		ACT_SIZE_PTL,

		ACT_MPNL_PRINT,

		ACT_SIZE_LONG,
		ACT_SIZE_SHORT,
		ACT_SIZE,
		ACT_CLEARING_NAME,

		ACT_ESTIMATED_BEGINNING_EQUITY,
		ACT_REAL_TIME_EQUITY,

		ACT_MAX_BP_USED,

		ACT_VALUE_PTL_LONG,
		ACT_VALUE_PTL_SHORT,

		ACT_CTRN_LOSS_CLOSE,
		ACT_CTRN_POS_LOSS_CLOSE,
		ACT_CTRN_LOSS_SLACK,
		ACT_CTRN_POS_LOSS_SLACK,

		ACT_OPNL_NBBO_PRINT,
		ACT_MPNL_NBBO_PRINT,

		ACT_ORDERS_STUCK,
		ACT_ORDERS_CANCEL_REJECTED,
		ACT_ORDERS_CANCEL_BLOCKED,

		ACT_CTRN_ORDER_VALUE,

		ACT_CTRN_AUTO_CLOSE_START_DELAY,
		ACT_CTRN_AUTO_CLOSE_END_DELAY,

		ACT_INVESTMENT_COST,
		ACT_INVESTMENT_COST_LONG,
		ACT_INVESTMENT_COST_SHORT,
//		ACT_MAX_INVESTMENT_COST,
//		ACT_MAX_INVESTMENT_COST_LONG,
//		ACT_MAX_INVESTMENT_COST_SHORT,

		ACT_PNL_CLOSED_COST,
		ACT_OPNL_L1_COST,

		ACT_NET_EXPOSURE,

		ACT_MPNL_NBBO_PRINT_HI,
		ACT_MPNL_NBBO_PRINT_LO,

		ACT_TYPE,
		ACT_RETAIL,

		ACT_SHARES_ADDED,
		ACT_SHARES_REMOVED,

		ACT_OPNL_TCLOSE,
		ACT_MPNL_TCLOSE,

		ACT_CTRN_HBP,
		ACT_HBP_AVAILABLE,

		ACT_CTRN_NITE_INVEST,

		ACT_PNL_MARKED_NET,
		ACT_PNL_MARKED_PRINT_NET,

		ACT_MARKED_TICKET_AVERAGE,

		ACT_ACTIVE_POS_COUNT,
		ACT_HARD_BP_USED,

		ACT_PERCENT_MAX_LOSS,

		ACT_POS_AGGREGATON,

		ACT_MARKED_TICKET_AVERAGE_HI,
		ACT_MARKED_TICKET_AVERAGE_LO,

		ACT_CTRN_ISO_ALLOWED,
		ACT_CTRN_SPOOFING_ORDER_COUNT,
		ACT_CTRN_SPOOFING_ORDER_SIZE,
		ACT_CTRN_SPOOFING_OFFSET,
		ACT_CTRN_LAYERING_OFFSET,

		ACT_INVENTORY,
		ACT_INVENTORY_SIZE,
		ACT_INVENTORY_SIZE_LONG,
		ACT_INVENTORY_SIZE_SHORT,
		ACT_INVENTORY_STOCK_POS_COUNT,
		ACT_HIDDEN_STOCK_POS_COUNT,
		ACT_CURRENT_OCO_ID,
		ACT_CTRN_MIN_SHARE_PRICE,
		ACT_CTRN_MAX_SHARE_PRICE,

		ACT_CTRN_ADV_ORDER_COUNT,
		ACT_CTRN_ADV_ORDER_SIZE,
		ACT_CTRN_ADV_BORDER,
		ACT_CTRN_ADV_FORCE_HIDDEN,
		ACT_CTRN_ADV_REJECT,
		ACT_CTRN_BLOCK_AGGR_PRICE_PERCENT,

		ACT_LOADED_POS_COUNT,
		ACT_UPDATED_PNL_POS_COUNT,

		ACT_OPNL_PRINT_COST,

		ACT_OPNL_IMBEXNEAR,

		ACT_OPNL_ACTION,
//		ACT_OPNL_ACTION_INV,

		ACT_OPF,

		ACT_PNL_CLOSED_PREMARKET,
		ACT_PNL_CLOSED_MARKET,
		ACT_PNL_CLOSED_POSTMARKET,
		ACT_PNL_OPEN_PREMARKET,
		ACT_PNL_OPEN_MARKET,
		ACT_PNL_OPEN_POSTMARKET,
		ACT_PNL_MARKED_PREMARKET,
		ACT_PNL_MARKED_MARKET,
		ACT_PNL_MARKED_POSTMARKET,

		ACT_CTRN_HTBT_ALLOWED,

		ACT_SIZE_LONG_OVERNITE_UNCLOSED,
		ACT_SIZE_SHORT_OVERNITE_UNCLOSED,

		ACT_OPNL_ACTION_PRINT,

		ACT_ORDERS_BLOCKED,

		ACT_CTRN_MORNING_POS_SHARES,
		ACT_CTRN_MORNING_POS_INVEST,
		ACT_CTRN_MORNING_LONG_INVEST,
		ACT_CTRN_MORNING_SHORT_INVEST,
		ACT_CTRN_MORNING_INVEST,

		ACT_CTRN_NITE_LOSS,
		ACT_CTRN_MORNING_LOSS,
		ACT_CTRN_NITE_LOSS_CLOSE,
		ACT_CTRN_MORNING_LOSS_CLOSE,

		ACT_CTRN_NITE_POS_LOSS,
		ACT_CTRN_MORNING_POS_LOSS,
		ACT_CTRN_NITE_POS_LOSS_CLOSE,
		ACT_CTRN_MORNING_POS_LOSS_CLOSE,

		ACT_CTRN_ADV_FORCE_HIDDEN_CLOSE,

		ACT_CTRN_CONSERVATIVE_ORDER_MARKING,
		ACT_CTRN_LOCAL_SIDE_MARKING,

		ACT_BETA_INVESTMENT,
		ACT_BETA_INVESTMENT_LONG,
		ACT_BETA_INVESTMENT_SHORT,
		ACT_BETA_MONEY_PEND_LONG,
		ACT_BETA_MONEY_PEND_SHORT,
		ACT_BETA_VALUE_PTL_LONG,
		ACT_BETA_VALUE_PTL_SHORT,
		ACT_BETA_BP_USED,
		ACT_BETA_MAX_BP_USED,

		ACT_BETA_MAX_INVESTMENT,
		ACT_BETA_MAX_INVESTMENT_LONG,
		ACT_BETA_MAX_INVESTMENT_SHORT,

		ACT_INVESTMENT_BY_REAL_TIME_EQUITY,
		ACT_REMAINING_EQUITY,

		ACT_NITE_VALUE_PTL_LONG,
		ACT_NITE_VALUE_PTL_SHORT,
		ACT_NITE_BP_USED,
		ACT_NITE_SIZE_PTL_LONG,
		ACT_NITE_SIZE_PTL_SHORT,
		ACT_NITE_SIZE_PTL,
		ACT_REL_BPU,

		ACT_CTRN_ME,
		ACT_ME_MANAGED,
		ACT_PORTFOLIO_MANAGED,
		ACT_ME_PTL_LONG,
		ACT_ME_PTL_SHORT,
		ACT_ME_AVAILABLE,
		ACT_ME_USED,
		ACT_MAX_ME_USED,
		ACT_ME_PEND_LONG,
		ACT_ME_PEND_SHORT,
		ACT_ME_INVESTMENT,
		ACT_ME_INVESTMENT_LONG,
		ACT_ME_INVESTMENT_SHORT,
		ACT_ME_MAX_INVESTMENT,
		ACT_ME_MAX_INVESTMENT_LONG,
		ACT_ME_MAX_INVESTMENT_SHORT,

		ACT_CTRN_HME,
		ACT_HME_AVAILABLE,
		ACT_HARD_ME_USED,

		ACT_APF,

		ACT_BETA_INVESTMENT_OVERNITE,
		ACT_ME_INVESTMENT_OVERNITE,

		ACT_INVENTORY_INVESTMENT,
		ACT_INVENTORY_OPNL_NBBO_PRINT,

		ACT_CTRN_POOL_LOCATES,

		ACT_DISABLED,
		ACT_CTRN_LOCATE_VENUE,

#ifndef TAKION_NO_OPTIONS
		ACT_COLUMN_NO_OPT_COUNT,

		ACT_OPT_POS_COUNT = ACT_COLUMN_NO_OPT_COUNT,
		ACT_OPT_LONG_POS_COUNT,
		ACT_OPT_SHORT_POS_COUNT,
		ACT_OPT_ACTIVE_POS_COUNT,
		ACT_CTRN_OPTION_BP,
		ACT_CTRN_OPTION_SHARES_TRADED,
		ACT_CTRN_OPTION_ORDER_SIZE,
		ACT_CTRN_OPTION_ORDER_VALUE,
		ACT_CTRN_OPTION_NAKED_SELL,
		ACT_OPTION_BP_USED,
		ACT_OPTION_BP_AVAILABLE,
		ACT_MAX_OPTION_BP_USED,
		ACT_OPT_SIZE_PTL_LONG,
		ACT_OPT_SIZE_PTL_SHORT,
		ACT_OPT_SIZE_PTL,
		ACT_CTRN_OPTION_CONTRACTS_OPEN,
		ACT_OPT_CONTRACTS_TRADED,
		ACT_CTRN_OPTION_VENUE,

		ACT_INVENTORY_OPTION_POS_COUNT,
		ACT_INVENTORY_POS_COUNT,
		ACT_HIDDEN_OPTION_POS_COUNT,
		ACT_HIDDEN_POS_COUNT,
		ACT_CTRN_OPTION_POS_COUNT,

		ACT_UNDERLIER_VALUE_LONG,
		ACT_UNDERLIER_VALUE_SHORT,

		ACT_OPT_INVESTMENT,
		ACT_OPT_MAX_INVESTMENT,
		ACT_OPT_INVESTMENT_LONG,
		ACT_OPT_MAX_INVESTMENT_LONG,
		ACT_OPT_INVESTMENT_SHORT,
		ACT_OPT_MAX_INVESTMENT_SHORT,
#endif

		ACT_COLUMN_COUNT
	};

	unsigned int GetNextMenuId() const;//should not be virtual

	virtual unsigned short GetBuiltInColumnCount() const override{return ACT_COLUMN_COUNT;}
#ifndef TAKION_NO_OPTIONS
	virtual unsigned short GetNoOptionBuiltInColumnCount() const override{return ACT_COLUMN_NO_OPT_COUNT;}
#endif
	virtual unsigned short GetAdditionalColumnCount() const override;

	virtual unsigned short GetPositionBuiltInColumnCount() const override{return PositionWindow::POS_COLUMN_COUNT;}

	virtual void RowRemoved(RowSortable* row) override;
#ifdef SECONDARY_ROWS
	virtual unsigned short GetSecondaryBuiltInColumnCount() const override{return GetPositionBuiltInColumnCount();}
#ifndef TAKION_NO_OPTIONS
	virtual unsigned short GetSecondaryNoOptionBuiltInColumnCount() const override{return PositionWindow::POS_COLUMN_NO_OPT_COUNT;}
#endif
	virtual unsigned short GetSecondaryAdditionalColumnCount() const;
#endif
	virtual void toString(std::string& str, unsigned int contentModifier) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual void fromScratch() override;
//	virtual TakionTool* Clone() const;
	virtual void AddToSpecificToolCollection() override;
	virtual void UpdateDataGraphics(const Graphics* graphics) override;

	virtual bool UpdateDataGraphicsColorsCustom(const GraphicsColorCollection* colorCollection) override;
	virtual bool UpdateDataGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL) override;
	void UpdateDataColors();
/*
	void MovePotentialRowToBelonging(AccountRow* row);
	void MoveBelongingRowToPotential(AccountRow* row);
	bool RemoveAndDestroyPotentialRow(AccountRow* row);
	void AddRowToPotential(AccountRow* row);
*/
	void AddInventoryFilter(unsigned int filter);
	void RemoveInventoryFilter(unsigned int filter);
	void SwitchInventoryFilter(unsigned char yesNoFilter);
	const unsigned int& GetInventoryFilter() const{return m_inventoryFilter;}
	bool SetInventoryFilter(unsigned int inventoryFilter, unsigned int& addFilter);

	void AddHiddenFilter(unsigned int filter);
	void RemoveHiddenFilter(unsigned int filter);
	void SwitchHiddenFilter(unsigned char yesNoFilter);
	const unsigned int& GetHiddenFilter() const{return m_hiddenFilter;}
	bool SetHiddenFilter(unsigned int hiddenFilter, unsigned int& addFilter);

	virtual Row* CreateRow(const void* object, bool potential);

	typedef void (AccountRow::*FnPaintInfo)(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	typedef short (AccountRow::*FnCompare)(const AccountRow& other) const;

	bool AddAccountFunctions(unsigned short id, FnPaintInfo fnPaint, FnCompare fnCompare, FnCompare fnCompareAhead);

	inline const FnPaintInfo& GetFnPaintInfo(const unsigned short& id) const{return id < ACT_COLUMN_COUNT ? m_paintInfoFunction[id] : NULL;}
	inline const FnCompare& GetFnCompare(const unsigned short& id) const{return id < ACT_COLUMN_COUNT ? m_compareFunction[id] : NULL;}
	inline const FnCompare& GetFnCompareAhead(const unsigned short& id) const{return id < ACT_COLUMN_COUNT ? m_compareAheadFunction[id] : NULL;}
/*
	void AddAccountFilter(unsigned int filter);
	void RemoveAccountFilter(unsigned int filter);
	void SwitchAccountFilter(AccountStatus accountFilter); 

	unsigned int GetAccountFilter() const{return m_accountFilter;}
	bool SetAccountFilter(unsigned int accountFilter, unsigned int& addFilter);
*/
	virtual const void* GetSettingsTabInitInfo(const CPoint& point) const override;
	virtual const void* GetInventorySettingsTabInitInfo(const CPoint& point) const override;

	virtual void HideSelectedPositions(bool show);
	virtual void HandleSelectedInventory(const unsigned char action);

	unsigned __int64 GetCurrentPositionNumericSymbol() const{return m_numericSymbol;}
	void SetNumericSymbol(unsigned __int64 symbol);

	const Account* const& GetTopAccount() const{return m_topAccount;}
	virtual void CurrentAccountChanged(const Account* currentAccount);
	virtual bool HasTopActiveMenu() const{return true;}
	virtual void SetTopActive(bool topActive);

//	const COLORREF& GetTopActiveColor() const{return m_topActiveColor;}
	const COLORREF& GetColorNeutralProfit() const{return m_colorNeutralProfit;}
	const COLORREF& GetColorPositiveProfit() const{return m_colorPositiveProfit;}
	const COLORREF& GetColorNegativeProfit() const{return m_colorNegativeProfit;}
	const COLORREF& GetColorLoser() const{return m_colorLoser;}
	const COLORREF& GetColorLoser10PercentOff() const{return m_colorLoser10PercentOff;}
	const COLORREF& GetColorHistLoaded() const{return m_colorHistLoaded;}
	const COLORREF& GetColorHistPending() const{return m_colorHistPending;}
//	COLORREF GetColorHistError() const{return m_colorHistError;}
	const bool& isHistoryLoaded() const{return m_historyLoaded;}

//	virtual COLORREF GetBkColor() const;
	virtual bool ObjectPotentiallyBelongs(const void* object) const override;
	virtual bool AccountBelongs(const Account* account) const;

//	virtual bool ObjectPotentiallyBelongs(const void* object) const;//no need to call inside lock
	virtual bool RowFiltersIn(const RowSortable* row) const override;//should be called inside lock
	virtual unsigned char RowBelongs(const RowSortable* row) const override;//2 - belongs; 1 - does not belong but can update to become belonging; 0 - does not belong and cannot update to become belonging
	virtual unsigned char ExistingRowBelongs(const RowSortable* row) const override;//2 - belongs; 1 - does not belong but can update to become belonging; 0 - does not belong and cannot update to become belonging

	virtual bool RowHasSecuritySymbol() const
	{
#ifdef SECONDARY_ROWS
		return true;
#else
		return false;
#endif
	}
//	virtual bool RowHasAccountName() const{return true;}
	virtual bool HasVolumeColumns() const{return true;}

	virtual bool hasInventoryView() const override{return true;}
#ifdef SECONDARY_ROWS
#ifdef FIRM_VALUES
	void UpdateCanSeeFirmPositions();
	virtual const bool& CanSeeFirmPositions() const override{return m_canSeeFirmPositions;}
#endif
#endif
protected:
	AccountWindow(const CBitmap* bitmap, unsigned int workspace, bool pinned = false);
	virtual void AddInventoryMenuItems(CMenu& popupMenu) override;
	virtual void OnSuccessfulCreate() override;
//	virtual void UpdateInventoryView();
	virtual void CreateAdditionalColumns() override;
	virtual void BeforeDestroy() override;
//	virtual void AccountChanged();
	virtual void AddMenuItems(CMenu& menu) override;
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;
	virtual bool Populate(bool remove) override;
	virtual bool AddNewAccounts(){return false;}
	bool InsertAccountRowIntoRowSet(AccountRow* row);

	virtual void RepaintDefaultOnlyTradingAllowed() override;

	virtual RowTotal* CreateRowTotal() override;
//	void DestroyPotentialRows();
//	RowMap m_potentialRows;

//	unsigned int m_accountFilter;

	unsigned int m_inventoryFilter;
	unsigned int m_hiddenFilter;

//	COLORREF m_topActiveColor;
	COLORREF m_colorNeutralProfit;
	COLORREF m_colorPositiveProfit;
	COLORREF m_colorNegativeProfit;
	COLORREF m_colorLoser;
	COLORREF m_colorLoser10PercentOff;
	COLORREF m_colorHistLoaded;
	COLORREF m_colorHistPending;
	COLORREF m_bgColorTradeAllAccounts;
//	COLORREF m_colorHistError;
#ifdef SECONDARY_ROWS
	virtual bool DoUpdateColumnUse(const UseChangeSet& use, const UseChangeSet& unuse, bool secondary) override;
	virtual void CreateSecondaryAdditionalColumns() override;
	virtual void DoUpdateSecondaryDataGraphicsColorsCustom(const GraphicsColorCollection* colorCollection) override;
	virtual void DoUpdateSecondaryDataGraphicsColors(const Graphics* graphics) override;

	virtual void SecurityDoubleClicked(UINT nFlags, const CPoint& point) override;
	virtual void AddSecondaryRowMenuItems(CMenu& menu) override;
	COLORREF m_colorFlat;
	COLORREF m_colorLong;
	COLORREF m_colorShort;
	COLORREF m_invalidColor;
/////
	COLORREF m_colorThermographRed;
	COLORREF m_colorThermographGreen;
	COLORREF m_thermographRedColors[thermographSize];
	COLORREF m_thermographGreenColors[thermographSize];

	unsigned int m_positionFilter;
	unsigned int m_marketCategoryFilter;
	unsigned int m_overnightFilter;
	unsigned int m_phantomFilter;
//#ifndef TAKION_NO_OPTIONS
//	unsigned int m_instrumentFilter;
//#endif
	unsigned int m_onOpenCoverFilter;
	unsigned int m_onCloseCoverFilter;
	unsigned int m_pqOpenFilter;
	unsigned int m_tCloseFilter;
	unsigned int m_borrowFilter;
	unsigned int m_pendingOrdersFilter;
	unsigned int m_posInventoryFilter;
	unsigned int m_posHiddenFilter;
//	bool m_filterBorrowPositions;
//	bool m_filterPendingOrders;
	bool m_filterUntraded;
	bool m_filterOpenBasket;

#ifdef FIRM_VALUES
	bool m_canSeeFirmPositions;
#endif
	std::string m_stockBasketName;
	const StockBasketMap* m_stockBasketMapPtr;

	void SetStockBasketName(const char* stockBasketName);//{m_stockBasketName = stockBasketName;}
	bool ClearStockBasket()
	{
		if(m_stockBasketMapPtr)
		{
			m_stockBasketMapPtr = NULL;
			m_stockBasketName.clear();
			return true;
		}
		return false;
	}
/////
#endif
	unsigned __int64 m_numericSymbol;
	virtual void RowLeftClicked(Row* row, size_t ord, const CPoint& point) override;
	virtual void AddDoubleClickActionMenuItems(CMenu& menu) override;
	
	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;

//	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
//	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	DECLARE_MESSAGE_MAP()
/*
	void SetInventoryMode(const InventoryMode inventoryMode);
	InventoryMode m_inventoryMode;//0-non inventory; 1-inventory; 2 - default (same as in the main bar
	bool m_inventoryView;
*/
	void UpdateHistoryLoaded(const bool historyLoaded);
	bool UpdateHistoryLoadBkColor();
	bool m_historyLoaded;
	bool m_dblclkMakeCurrentAccount;
	Account* m_leftClickedAccount;

	void SetTopAccount(const Account* account);
	const Account* m_topAccount;
	void TopAccountAboutToChange(const Account* newTopAccount);
	bool TopAccountChanged();
	AccountRow* m_prevTopRow;
	AccountRow* m_nextTopRow;

	FnPaintInfo m_paintInfoFunction[ACT_COLUMN_COUNT];
	FnCompare m_compareFunction[ACT_COLUMN_COUNT];
	FnCompare m_compareAheadFunction[ACT_COLUMN_COUNT];
//private:
//	void SetInventoryView(const bool inventoryView);
};

class TGUI_API AccountRow : public
#ifdef SECONDARY_ROWS
	RowSortableChild
#else
	RowSortable
#endif
	, public Observer
{
public:
	AccountRow(AccountWindow* parent, Account* account, bool potential = false
#ifdef SECONDARY_ROWS
		, bool expanded = false
#endif
		);
	virtual const void* GetBaseObject() const{return m_account;}
	virtual bool GetPaintTextInfo(unsigned short columnId, std::string& text, COLORREF& color) const override;//, UINT& horizontalJustification) const override;
	virtual COLORREF GetRowColor() const;
	virtual COLORREF GetCellColor(unsigned short columnId) const;
	virtual RowValue* CreateCell(unsigned short id);
	virtual bool Lock(bool wait) const override;
//	virtual void LockWait() const override;
	virtual void Unlock() const override;
	virtual short DefaultCompare(const RowSortable& other) const;

	virtual bool hasInventory() const{return m_account && m_account->GetInventory() != NULL;}

	virtual bool CompareFunction(const RowSortable& other, unsigned short sortId, short& ret) const;
	virtual bool CompareFunctionAhead(const RowSortable& other, unsigned short sortId, short& ret) const;
	virtual short PreCompare(const RowSortable& other) const;

	virtual bool UpdateRowColor() override;//should be called only inside a lock

	Account* GetAccount(){return m_account;}
	const Account* GetAccount() const{return m_account;}

	Position* GetPosition(){return m_position;}
	const Position* GetPosition() const{return m_position;}
	void SetPositionSymbol(unsigned __int64 symbol);
//	bool isPotential() const{return m_potential;}
//	void SetPotential(bool potential){m_potential = potential;}

	DECLARE_NED_NEW

protected:
	virtual void Notify(const Message* message, const Observable* from, const Message* info = NULL) override;
	AccountWindow* m_accountWindow;
	Account* m_account;
	Position* m_position;

	COLORREF m_accountColor;
//	bool m_potential;
};

class TGUI_API AccountRowTotal : public RowTotal
{
public:
	AccountRowTotal(AccountWindow* window, unsigned short columnCount = AccountWindow::ACT_COLUMN_COUNT):
		RowTotal(columnCount + window->GetAdditionalColumnCount(), window),
		m_activeAccountCount(NULL),
		m_ticketAverage(NULL),
		m_markedTicketAverage(NULL),
		m_markedTicketAverageHi(NULL),
		m_markedTicketAverageLo(NULL),

		m_maxInvestment(NULL),
		m_maxInvestmentLong(NULL),
		m_maxInvestmentShort(NULL),
		m_investment(NULL),

		m_maxInvestmentMe(NULL),
		m_maxInvestmentLongMe(NULL),
		m_maxInvestmentShortMe(NULL),
		m_investmentMe(NULL),
		m_investmentLongMe(NULL),
		m_investmentShortMe(NULL),

		m_maxInvestmentBeta(NULL),
		m_maxInvestmentLongBeta(NULL),
		m_maxInvestmentShortBeta(NULL),
		m_investmentBeta(NULL),
		m_investmentLongBeta(NULL),
		m_investmentShortBeta(NULL),

		m_realTimeEquity(NULL),
		m_leverage(NULL),

		m_hardBpUsed(NULL),
		m_hardMeUsed(NULL),
		m_investmentLong(NULL),
		m_investmentShort(NULL),
		m_netExposure(NULL),

//		m_investmentBeta(NULL),
//		m_investmentBetaLong(NULL),
//		m_investmentBetaShort(NULL),

//		m_maxInvestmentCost(NULL),
//		m_maxInvestmentCostLong(NULL),
//		m_maxInvestmentCostShort(NULL),
		m_investmentCost(NULL),
		m_investmentCostLong(NULL),
		m_investmentCostShort(NULL),

		m_investmentOvernight(NULL),
		m_investmentOvernightLong(NULL),
		m_investmentOvernightShort(NULL),

		m_mpnlNbboPrint(NULL),
		m_mpnlNbboPrintHi(NULL),
		m_mpnlNbboPrintLo(NULL),
#ifndef TAKION_NO_OPTIONS
//		m_underlierValueLong(NULL),
//		m_underlierValueShort(NULL),
		m_optionInvestment(NULL),
		m_optionInvestmentLong(NULL),
		m_optionInvestmentShort(NULL),
		m_maxOptionInvestment(NULL),
		m_maxOptionInvestmentLong(NULL),
		m_maxOptionInvestmentShort(NULL),

		m_optionBpUsed(NULL),
		m_maxOptionBpUsed(NULL),
		m_optionNakedSellAllowed(NULL),
#endif
		m_bpUsed(NULL),
		m_maxBpUsed(NULL),
		m_meUsed(NULL),
		m_maxMeUsed(NULL),
		m_bpBetaUsed(NULL),
		m_maxBpBetaUsed(NULL),
		m_pnlClosed(NULL),
		m_pnlClosedNet(NULL),
		m_sharesTraded(NULL),
		m_accountSize(NULL),
		m_isoAllowed(NULL),
		m_htbTborrowOrdersAllowed(NULL),
		m_conservativeOrderMarking(NULL),
		m_localSideMarking(NULL),
		m_poolLocates(NULL),
		m_hasInventory(NULL),
		m_disabled(NULL)
	{
	}
	void SetActiveAccountCountPtr(UIntRowValue* const& value){m_activeAccountCount = value;}
	void SetTicketAveragePtr(MoneyRowValue* const& value){m_ticketAverage = value;}
	void SetMarkedTicketAveragePtr(MoneyRowValue* const& value){m_markedTicketAverage = value;}
	void SetMarkedTicketAverageHiPtr(MoneyRowValue* const& value){m_markedTicketAverageHi = value;}
	void SetMarkedTicketAverageLoPtr(MoneyRowValue* const& value){m_markedTicketAverageLo = value;}

	void SetMaxInvestmentPtr(MoneyRowValue* const& value){m_maxInvestment = value;}
	void SetMaxInvestmentLongPtr(MoneyRowValue* const& value){m_maxInvestmentLong = value;}
	void SetMaxInvestmentShortPtr(MoneyRowValue* const& value){m_maxInvestmentShort = value;}
	void SetInvestmentPtr(MoneyRowValue* const& value){m_investment = value;}

	void SetMaxInvestmentMePtr(MoneyRowValue* const& value){m_maxInvestmentMe = value;}
	void SetMaxInvestmentLongMePtr(MoneyRowValue* const& value){m_maxInvestmentLongMe = value;}
	void SetMaxInvestmentShortMePtr(MoneyRowValue* const& value){m_maxInvestmentShortMe = value;}
	void SetInvestmentMePtr(MoneyRowValue* const& value){m_investmentMe = value;}
	void SetInvestmentLongMePtr(MoneyRowValue* const& value){m_investmentLongMe = value;}
	void SetInvestmentShortMePtr(MoneyRowValue* const& value){m_investmentShortMe = value;}

	void SetMaxInvestmentBetaPtr(MoneyRowValue* const& value){m_maxInvestmentBeta = value;}
	void SetMaxInvestmentLongBetaPtr(MoneyRowValue* const& value){m_maxInvestmentLongBeta = value;}
	void SetMaxInvestmentShortBetaPtr(MoneyRowValue* const& value){m_maxInvestmentShortBeta = value;}
	void SetInvestmentBetaPtr(MoneyRowValue* const& value){m_investmentBeta = value;}
	void SetInvestmentLongBetaPtr(MoneyRowValue* const& value){m_investmentLongBeta = value;}
	void SetInvestmentShortBetaPtr(MoneyRowValue* const& value){m_investmentShortBeta = value;}

	void SetRealTimeEquityPtr(MoneyRowValue* const& value){m_realTimeEquity = value;}
	void SetLeveragePtr(MoneyRowValue* const& value){m_leverage = value;}

	void SetHardBpUsedPtr(MoneyRowValue* const& value){m_hardBpUsed = value;}
	void SetHardMeUsedPtr(MoneyRowValue* const& value){m_hardMeUsed = value;}
	void SetInvestmentLongPtr(MoneyRowValue* const& value){m_investmentLong = value;}
	void SetInvestmentShortPtr(MoneyRowValue* const& value){m_investmentShort = value;}
	void SetNetExposurePtr(MoneyRowValue* const& value){m_netExposure = value;}

	void SetInvestmentCostPtr(MoneyRowValue* const& value){m_investmentCost = value;}
	void SetInvestmentCostLongPtr(MoneyRowValue* const& value){m_investmentCostLong = value;}
	void SetInvestmentCostShortPtr(MoneyRowValue* const& value){m_investmentCostShort = value;}

	void SetInvestmentOvernightPtr(MoneyRowValue* const& value){m_investmentOvernight = value;}
	void SetInvestmentOvernightLongPtr(MoneyRowValue* const& value){m_investmentOvernightLong = value;}
	void SetInvestmentOvernightShortPtr(MoneyRowValue* const& value){m_investmentOvernightShort = value;}

	void SetMpnlNbboPrintPtr(MoneyRowValue* const& value){m_mpnlNbboPrint = value;}
	void SetMpnlNbboPrintHiPtr(MoneyRowValue* const& value){m_mpnlNbboPrintHi = value;}
	void SetMpnlNbboPrintLoPtr(MoneyRowValue* const& value){m_mpnlNbboPrintLo = value;}

	void SetBpUsedPtr(MoneyRowValue* const& value){m_bpUsed = value;}
	void SetMaxBpUsedPtr(MoneyRowValue* const& value){m_maxBpUsed = value;}

	void SetMeUsedPtr(MoneyRowValue* const& value){m_meUsed = value;}
	void SetMaxMeUsedPtr(MoneyRowValue* const& value){m_maxMeUsed = value;}

	void SetBpBetaUsedPtr(MoneyRowValue* const& value){m_bpBetaUsed = value;}
	void SetMaxBpBetaUsedPtr(MoneyRowValue* const& value){m_maxBpBetaUsed = value;}

	void SetPnlClosedPtr(MoneyRowValue* const& value){m_pnlClosed = value;}
	void SetPnlClosedNetPtr(MoneyRowValue* const& value){m_pnlClosedNet = value;}
	void SetSharesTradedPtr(UIntRowValue* const& value){m_sharesTraded = value;}
	void SetAccountSizePtr(UIntRowValue* const& value){m_accountSize = value;}
	void SetIsoAllowedPtr(UIntRowValue* const& value){m_isoAllowed = value;}
	void SetHtbTborrowOrdersAllowedPtr(UIntRowValue* const& value){m_htbTborrowOrdersAllowed = value;}
	void SetConservativeOrderMarkingPtr(UIntRowValue* const& value){m_conservativeOrderMarking = value;}
	void SetLocalSideMarkingPtr(UIntRowValue* const& value){m_localSideMarking = value;}
	void SetPoolLocatesPtr(UIntRowValue* const& value){m_poolLocates = value;}
	void SetHasInventoryPtr(UIntRowValue* const& value){m_hasInventory = value;}
	void SetDisabledPtr(UIntRowValue* const& value){m_disabled = value;}

#ifndef TAKION_NO_OPTIONS
//	void SetUnderlierValueLongPtr(MoneyRowValue* const& value){m_underlierValueLong = value;}
//	void SetUnderlierValueShortPtr(MoneyRowValue* const& value){m_underlierValueShort = value;}
//	const MoneyRowValue* const& GetUnderlierValueLongPtr() const{return m_underlierValueLong;}
//	const MoneyRowValue* const& GetUnderlierValueShortPtr() const{return m_underlierValueShort;}

	void SetOptionInvestmentPtr(MoneyRowValue* const& value){m_optionInvestment = value;}
	void SetOptionInvestmentLongPtr(MoneyRowValue* const& value){m_optionInvestmentLong = value;}
	void SetOptionInvestmentShortPtr(MoneyRowValue* const& value){m_optionInvestmentShort = value;}
	void SetMaxOptionInvestmentPtr(MoneyRowValue* const& value){m_maxOptionInvestment = value;}
	void SetMaxOptionInvestmentLongPtr(MoneyRowValue* const& value){m_maxOptionInvestmentLong = value;}
	void SetMaxOptionInvestmentShortPtr(MoneyRowValue* const& value){m_maxOptionInvestmentShort = value;}

	const MoneyRowValue* const& GetOptionInvestmentPtr() const{return m_optionInvestment;}
	const MoneyRowValue* const& GetOptionInvestmentLongPtr() const{return m_optionInvestmentLong;}
	const MoneyRowValue* const& GetOptionInvestmentShortPtr() const{return m_optionInvestmentShort;}
	const MoneyRowValue* const& GetMaxOptionInvestmentPtr() const{return m_maxOptionInvestment;}
	const MoneyRowValue* const& GetMaxOptionInvestmentLongPtr() const{return m_maxOptionInvestmentLong;}
	const MoneyRowValue* const& GetMaxOptionInvestmentShortPtr() const{return m_maxOptionInvestmentShort;}

	void SetOptionBpUsedPtr(MoneyRowValue* const& value){m_optionBpUsed = value;}
	void SetMaxOptionBpUsedPtr(MoneyRowValue* const& value){m_maxOptionBpUsed = value;}
	void SetOptionNakedSellAllowedPtr(UIntRowValue* const& value){m_optionNakedSellAllowed = value;}
	const MoneyRowValue* const& GetOptionBpUsedPtr() const{return m_optionBpUsed;}
	const MoneyRowValue* const& GetMaxOptionBpUsedPtr() const{return m_maxOptionBpUsed;}
	const UIntRowValue* const& GetOptionNakedSellAllowedPtr() const{return m_optionNakedSellAllowed;}
#endif
	const UIntRowValue* const& GetActiveAccountCountPtr() const{return m_activeAccountCount;}
	const MoneyRowValue* const& GetTicketAveragePtr() const{return m_ticketAverage;}
	const MoneyRowValue* const& GetMarkedTicketAveragePtr() const{return m_markedTicketAverage;}
	const MoneyRowValue* const& GetMarkedTicketAverageHiPtr() const{return m_markedTicketAverageHi;}
	const MoneyRowValue* const& GetMarkedTicketAverageLoPtr() const{return m_markedTicketAverageLo;}
	
	const MoneyRowValue* const& GetMaxInvestmentPtr() const{return m_maxInvestment;}
	const MoneyRowValue* const& GetMaxInvestmentLongPtr() const{return m_maxInvestmentLong;}
	const MoneyRowValue* const& GetMaxInvestmentShortPtr() const{return m_maxInvestmentShort;}
	const MoneyRowValue* const& GetInvestmentPtr() const{return m_investment;}

	const MoneyRowValue* const& GetMaxInvestmentMePtr() const{return m_maxInvestmentMe;}
	const MoneyRowValue* const& GetMaxInvestmentLongMePtr() const{return m_maxInvestmentLongMe;}
	const MoneyRowValue* const& GetMaxInvestmentShortMePtr() const{return m_maxInvestmentShortMe;}
	const MoneyRowValue* const& GetInvestmentMePtr() const{return m_investmentMe;}
	const MoneyRowValue* const& GetInvestmentLongMePtr() const{return m_investmentLongMe;}
	const MoneyRowValue* const& GetInvestmentShortMePtr() const{return m_investmentShortMe;}

	const MoneyRowValue* const& GetMaxInvestmentBetaPtr() const{return m_maxInvestmentBeta;}
	const MoneyRowValue* const& GetMaxInvestmentLongBetaPtr() const{return m_maxInvestmentLongBeta;}
	const MoneyRowValue* const& GetMaxInvestmentShortBetaPtr() const{return m_maxInvestmentShortBeta;}
	const MoneyRowValue* const& GetInvestmentBetaPtr() const{return m_investmentBeta;}
	const MoneyRowValue* const& GetInvestmentLongBetaPtr() const{return m_investmentLongBeta;}
	const MoneyRowValue* const& GetInvestmentShortBetaPtr() const{return m_investmentShortBeta;}

	const MoneyRowValue* const& GetRealTimeEquityPtr() const{return m_realTimeEquity;}
	const MoneyRowValue* const& GetLeveragePtr() const{return m_leverage;}

	const MoneyRowValue* const& GetHardBpUsedPtr() const{return m_hardBpUsed;}
	const MoneyRowValue* const& GetHardMeUsedPtr() const{return m_hardMeUsed;}
	const MoneyRowValue* const& GetInvestmentLongPtr() const{return m_investmentLong;}
	const MoneyRowValue* const& GetInvestmentShortPtr() const{return m_investmentShort;}
	const MoneyRowValue* const& GetNetExposurePtr() const{return m_netExposure;}

	const MoneyRowValue* const& GetInvestmentCostPtr() const{return m_investmentCost;}
	const MoneyRowValue* const& GetInvestmentCostLongPtr() const{return m_investmentCostLong;}
	const MoneyRowValue* const& GetInvestmentCostShortPtr() const{return m_investmentCostShort;}

	const MoneyRowValue* const& GetInvestmentOvernightPtr() const{return m_investmentOvernight;}
	const MoneyRowValue* const& GetInvestmentOvernightLongPtr() const{return m_investmentOvernightLong;}
	const MoneyRowValue* const& GetInvestmentOvernightShortPtr() const{return m_investmentOvernightShort;}

	const MoneyRowValue* const& GetMpnlNbboPrintPtr() const{return m_mpnlNbboPrint;}
	const MoneyRowValue* const& GetMpnlNbboPrintHiPtr() const{return m_mpnlNbboPrintHi;}
	const MoneyRowValue* const& GetMpnlNbboPrintLoPtr() const{return m_mpnlNbboPrintLo;}

	const MoneyRowValue* const& GetBpUsedPtr() const{return m_bpUsed;}
	const MoneyRowValue* const& GetMaxBpUsedPtr() const{return m_maxBpUsed;}

	const MoneyRowValue* const& GetMeUsedPtr() const{return m_meUsed;}
	const MoneyRowValue* const& GetMaxMeUsedPtr() const{return m_maxMeUsed;}

	const MoneyRowValue* const& GetBpBetaUsedPtr() const{return m_bpBetaUsed;}
	const MoneyRowValue* const& GetMaxBpBetaUsedPtr() const{return m_maxBpBetaUsed;}

	const MoneyRowValue* const& GetPnlClosedPtr() const{return m_pnlClosed;}
	const MoneyRowValue* const& GetPnlClosedNetPtr() const{return m_pnlClosedNet;}
	const UIntRowValue* const& GetSharesTradedPtr() const{return m_sharesTraded;}
	const UIntRowValue* const& GetAccountSizePtr() const{return m_accountSize;}

	const UIntRowValue* const& GetIsoAllowedPtr() const{return m_isoAllowed;}
	const UIntRowValue* const& GetHtbTborrowOrdersAllowedPtr() const{return m_htbTborrowOrdersAllowed;}
	const UIntRowValue* const& GetConservativeOrderMarkingPtr() const{return m_conservativeOrderMarking;}
	const UIntRowValue* const& GetLocalSideMarkingPtr() const{return m_localSideMarking;}
	const UIntRowValue* const& GetPoolLocatesPtr() const{return m_poolLocates;}
	const UIntRowValue* const& GetHasInventoryPtr() const{return m_hasInventory;}
	const UIntRowValue* const& GetDisabledPtr() const{return m_disabled;}
protected:
	virtual void UpdateNonCumulativeValues(const Row* row, bool dynamicOnly) override;
//	virtual void UpdateInventoryViewNonCumulativeValues(const Row* row) override;
	virtual void AddNonCumulativeValues(const Row* row) override;
	virtual void RemoveNonCumulativeValues(const Row* row) override;
	virtual void ResetNonCumulativeValues() override;
	
	virtual void ResetMinMaxValues(const void* container) override;

	void AddNonCumulativeMinMaxValues(const Row* row);

	UIntRowValue* m_activeAccountCount;
	MoneyRowValue* m_ticketAverage;
	MoneyRowValue* m_markedTicketAverage;
	MoneyRowValue* m_markedTicketAverageHi;
	MoneyRowValue* m_markedTicketAverageLo;
	
	MoneyRowValue* m_maxInvestment;
	MoneyRowValue* m_maxInvestmentLong;
	MoneyRowValue* m_maxInvestmentShort;
	MoneyRowValue* m_investment;

	MoneyRowValue* m_maxInvestmentMe;
	MoneyRowValue* m_maxInvestmentLongMe;
	MoneyRowValue* m_maxInvestmentShortMe;
	MoneyRowValue* m_investmentMe;
	MoneyRowValue* m_investmentLongMe;
	MoneyRowValue* m_investmentShortMe;

	MoneyRowValue* m_maxInvestmentBeta;
	MoneyRowValue* m_maxInvestmentLongBeta;
	MoneyRowValue* m_maxInvestmentShortBeta;
	MoneyRowValue* m_investmentBeta;
	MoneyRowValue* m_investmentLongBeta;
	MoneyRowValue* m_investmentShortBeta;

	MoneyRowValue* m_realTimeEquity;
	MoneyRowValue* m_leverage;

	MoneyRowValue* m_hardBpUsed;
	MoneyRowValue* m_hardMeUsed;
	MoneyRowValue* m_investmentLong;
	MoneyRowValue* m_investmentShort;
	MoneyRowValue* m_netExposure;

	MoneyRowValue* m_investmentCost;
	MoneyRowValue* m_investmentCostLong;
	MoneyRowValue* m_investmentCostShort;

	MoneyRowValue* m_investmentOvernight;
	MoneyRowValue* m_investmentOvernightLong;
	MoneyRowValue* m_investmentOvernightShort;

	MoneyRowValue* m_mpnlNbboPrint;
	MoneyRowValue* m_mpnlNbboPrintHi;
	MoneyRowValue* m_mpnlNbboPrintLo;
#ifndef TAKION_NO_OPTIONS
//	MoneyRowValue* m_underlierValueLong;
//	MoneyRowValue* m_underlierValueShort;
	MoneyRowValue* m_optionInvestment;
	MoneyRowValue* m_optionInvestmentLong;
	MoneyRowValue* m_optionInvestmentShort;
	MoneyRowValue* m_maxOptionInvestment;
	MoneyRowValue* m_maxOptionInvestmentLong;
	MoneyRowValue* m_maxOptionInvestmentShort;

	MoneyRowValue* m_optionBpUsed;
	MoneyRowValue* m_maxOptionBpUsed;
	UIntRowValue* m_optionNakedSellAllowed;
#endif	
	MoneyRowValue* m_bpUsed;
	MoneyRowValue* m_maxBpUsed;

	MoneyRowValue* m_meUsed;
	MoneyRowValue* m_maxMeUsed;

	MoneyRowValue* m_bpBetaUsed;
	MoneyRowValue* m_maxBpBetaUsed;

	MoneyRowValue* m_pnlClosed;
	MoneyRowValue* m_pnlClosedNet;
	UIntRowValue* m_sharesTraded;
	UIntRowValue* m_accountSize;

	UIntRowValue* m_isoAllowed;
	UIntRowValue* m_htbTborrowOrdersAllowed;
	UIntRowValue* m_conservativeOrderMarking;
	UIntRowValue* m_localSideMarking;
	UIntRowValue* m_poolLocates;
	UIntRowValue* m_hasInventory;
	UIntRowValue* m_disabled;
};

class ClearingFirmRow;

class TGUI_API ClearingFirmWindow : public RowWindowSortable//, public Observer
{
public:
	virtual const char* GetToolId() const override{return toolClearingFirmId;}
	virtual void AllAccountsLoaded() override;
	virtual void LoggedToExecutor() override;
	virtual void ConnectionDisconnected(unsigned int ipAddress, unsigned short port, unsigned int ipBindAddress, unsigned short bindPort, unsigned char connectionType, const char* connectionName) override;
	virtual void ConnectionConnected(unsigned int ipAddress, unsigned short port, unsigned int ipBindAddress, unsigned short bindPort, unsigned char connectionType, const char* connectionName) override;

	enum ColumnId : unsigned short
	{
		CF_NAME,
//		CF_FIRM_ID,
		CF_CTRN_NITE_BETA_BP_ENFORCE_TIME,
		CF_CTRN_NITE_BETA_BP,
		CF_BETA_BP_USED,
		CF_NITE_BETA_BP_AVAILABLE,
		CF_BETA_INVESTMENT,
		CF_ACCOUNT_COUNT,
//		CF_OPEN_ORDER_COUNT,
		CF_ENFORCE_AGGREGATION,
		CF_CONSERVATIVE_ORDER_MARKING,
		CF_LOCAL_SIDE_MARKING,

		CF_CTRN_MARGIN_EXCESS_MULTIPLIER,
		CF_CTRN_MARGIN_EXCESS,
		CF_CTRN_TOTAL_EQUITY,

		CF_COLUMN_COUNT
	};
	const COLORREF& GetColorHistLoaded() const{return m_colorHistLoaded;}
	const COLORREF& GetColorHistPending() const{return m_colorHistPending;}
//	COLORREF GetColorHistError() const{return m_colorHistError;}
	const bool& isHistoryLoaded() const{return m_historyLoaded;}
	virtual Row* CreateRow(const void* object, bool potential);

	unsigned int GetNextMenuId() const;//should not be virtual

	virtual unsigned short GetBuiltInColumnCount() const override{return CF_COLUMN_COUNT;}

//	virtual void RowRemoved(RowSortable* row) override;
	virtual void toString(std::string& str, unsigned int contentModifier) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual void fromScratch() override;
//	virtual TakionTool* Clone() const;
	virtual void AddToSpecificToolCollection() override;
	virtual void UpdateDataGraphics(const Graphics* graphics) override;

	virtual bool UpdateDataGraphicsColorsCustom(const GraphicsColorCollection* colorCollection) override;
	virtual bool UpdateDataGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL) override;
	void UpdateDataColors();

	void UpdateCanSeeFirmPositions();
	virtual const bool& CanSeeFirmPositions() const override{return m_canSeeFirmPositions;}

	typedef void (ClearingFirmRow::*FnPaintInfo)(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	typedef short (ClearingFirmRow::*FnCompare)(const ClearingFirmRow& other) const;

	bool AddClearingFirmFunctions(unsigned short id, FnPaintInfo fnPaint, FnCompare fnCompare, FnCompare fnCompareAhead);

	inline const FnPaintInfo& GetFnPaintInfo(const unsigned short& id) const{return id < CF_COLUMN_COUNT ? m_paintInfoFunction[id] : NULL;}
	inline const FnCompare& GetFnCompare(const unsigned short& id) const{return id < CF_COLUMN_COUNT ? m_compareFunction[id] : NULL;}
	inline const FnCompare& GetFnCompareAhead(const unsigned short& id) const{return id < CF_COLUMN_COUNT ? m_compareAheadFunction[id] : NULL;}
protected:
	ClearingFirmWindow(const CBitmap* bitmap, unsigned int workspace, bool pinned = false);

	virtual void OnSuccessfulCreate() override;
	virtual void BeforeDestroy() override;
//	virtual void AccountChanged();

	virtual void AddMenuItems(CMenu& menu) override;
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;
	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;

	virtual bool Populate(bool remove) override;
	virtual bool AddNewClearingFirms(){return false;}
	bool InsertClearingFirmRowIntoRowSet(ClearingFirmRow* row);

	virtual RowTotal* CreateRowTotal() override;

	void UpdateHistoryLoaded(const bool historyLoaded);
	bool UpdateHistoryLoadBkColor();
	COLORREF m_colorHistLoaded;
	COLORREF m_colorHistPending;
	bool m_historyLoaded;

	bool m_canSeeFirmPositions;

	FnPaintInfo m_paintInfoFunction[CF_COLUMN_COUNT];
	FnCompare m_compareFunction[CF_COLUMN_COUNT];
	FnCompare m_compareAheadFunction[CF_COLUMN_COUNT];
};

class TGUI_API ClearingFirmRow : public RowSortable, public Observer
{
public:
	ClearingFirmRow(ClearingFirmWindow* parent, ClearingFirm* clearingFirm, bool potential = false);
	virtual const void* GetBaseObject() const{return m_clearingFirm;}
	virtual bool GetPaintTextInfo(unsigned short columnId, std::string& text, COLORREF& color) const override;//, UINT& horizontalJustification) const override;
	virtual COLORREF GetRowColor() const;
	virtual COLORREF GetCellColor(unsigned short columnId) const;
	virtual RowValue* CreateCell(unsigned short id);
	virtual bool Lock(bool wait) const override;
//	virtual void LockWait() const override;
	virtual void Unlock() const override;
	virtual short DefaultCompare(const RowSortable& other) const;

	virtual bool CompareFunction(const RowSortable& other, unsigned short sortId, short& ret) const;
	virtual bool CompareFunctionAhead(const RowSortable& other, unsigned short sortId, short& ret) const;
//	virtual short PreCompare(const RowSortable& other) const;

	virtual bool UpdateRowColor() override;//should be called only inside a lock

	ClearingFirm* GetClearingFirm(){return m_clearingFirm;}
	const ClearingFirm* GetClearingFirm() const{return m_clearingFirm;}

//	Position* GetPosition(){return m_position;}
//	const Position* GetPosition() const{return m_position;}
//	void SetPositionSymbol(unsigned __int64 symbol);

	DECLARE_NED_NEW
	void PaintId(std::string& text, COLORREF& color) const;
	short CompareId(const ClearingFirmRow& other) const;

protected:
	virtual void Notify(const Message* message, const Observable* from, const Message* info = NULL) override;
	ClearingFirmWindow* m_clearingFirmWindow;
	ClearingFirm* m_clearingFirm;
//	Position* m_position;

	COLORREF m_clearingFirmColor;
//	bool m_potential;
};

class TGUI_API ClearingFirmRowTotal : public RowTotal
{
public:
	ClearingFirmRowTotal(ClearingFirmWindow* window, unsigned short columnCount = ClearingFirmWindow::CF_COLUMN_COUNT):
		RowTotal(columnCount, window)
	{
	}
protected:
//	virtual void UpdateNonCumulativeValues(const Row* row, bool dynamicOnly);
//	virtual void AddNonCumulativeValues(const Row* row);
//	virtual void RemoveNonCumulativeValues(const Row* row);
//	virtual void ResetNonCumulativeValues();
	
//	virtual void ResetMinMaxValues(const void* container);

//	void AddNonCumulativeMinMaxValues(const Row* row);

//	UIntRowValue* m_activeAccountCount;
//	MoneyRowValue* m_ticketAverage;
};


class TGUI_API NewsHeadlineSecurityFilter : public SecurityScrollerFilter
{
public:
	NewsHeadlineSecurityFilter(){}

	virtual bool isFiltering() const override;
	virtual bool isEmpty() const override;

	virtual void Copy(const TakionFilter& other);

	virtual TakionFilter* CreateFilterCopy() const override;
	virtual unsigned char isA() const override{return FT_NEWS_HEADLINE;}
	virtual bool isNewsHeadlineSecurityFilter() const override{return true;}
	void CopyMyFields(const NewsHeadlineSecurityFilter& other, unsigned int doNotCopyFlags);
	virtual void CopySymbolFilterOfOtherKind(const SymbolFilter& other, unsigned int doNotCopyFlags) override
	{
		if(other.isNewsHeadlineSecurityFilter())CopyMyFields((const NewsHeadlineSecurityFilter&)other, doNotCopyFlags);
		SecurityScrollerFilter::CopySymbolFilterOfOtherKind(other, doNotCopyFlags);
	}
	bool MyFieldsEqual(const NewsHeadlineSecurityFilter& other, unsigned int doNotCopyFlags) const;
	virtual bool isSymbolIntersectionEqual(const SymbolFilter& other, unsigned int doNotCopyFlags) const override
	{
		return SecurityScrollerFilter::isSymbolIntersectionEqual(other, doNotCopyFlags) && (!other.isNewsHeadlineSecurityFilter() || MyFieldsEqual((const NewsHeadlineSecurityFilter&)other, doNotCopyFlags));
	}
	virtual bool operator==(const TakionFilter& other) const override
	{
		return SecurityScrollerFilter::operator==(other) && MyFieldsEqual((const NewsHeadlineSecurityFilter&)other, 0);
	}

	virtual void toString(std::string& str) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual bool SecurityBelongs(const SecurityChartRow* securityChartRow) const override;
	virtual bool SecurityPotentiallyBelongs(const Security* security) const override;
	virtual unsigned char isPotentialFilterSame(const TakionFilter& filter) const override;//0 - same; 1 - to add; 2 - to remove; 3 - to add and remove
	virtual bool isFilterSame(const TakionFilter& filter) const override;
//protected:
};

///////////////////
class TGUI_API NewsHeadlineWnd : public RowWindowSortableAccount//, public Observer
{
friend class NewsHeadlineRow;
friend class NewsHeadlineSecurity;
public:
	virtual ~NewsHeadlineWnd();
	virtual const char* GetToolId() const override{return toolNewsHeadlineId;}
//	virtual Security* GetSecurity(){return m_security;}
//	virtual const Security* GetSecurity() const{return m_security;}
//	virtual COLORREF GetBkColor() const{return m_newsConnected ? m_requestId == 0 ? m_bkColor : m_colorNotLoaded : m_requestId == 0 || m_symbol.empty() ? m_colorDisconnected : m_bkColor;}
	virtual COLORREF GetBkColor() const override;
	virtual void SetEquitySymbol(const char* symbol, unsigned char basket, bool force, bool addToStockChain) override;
	virtual void SetEquityNumericSymbol(const unsigned __int64& symbol, unsigned char basket, bool force, bool addToStockChain){SetEquitySymbol((const char*)&symbol, basket, force, addToStockChain);}
	virtual bool HasPriceColumns() const override{return false;}
	virtual bool HasSizeColumns() const override{return false;}
	virtual bool HasMoneyColumns() const override{return false;}
	virtual bool HasMillisecondColumns() const override{return true;}
	virtual bool isPlusMinusable() const override{return false;}
	virtual bool HasDoubleClickAction() const override{return false;}
	virtual bool RowHasSecuritySymbol() const override{return false;}
	virtual bool CanHaveTotal() const override{return false;}
	virtual bool CanFilterBySymbol() const override{return false;}

	enum NewsSearchType : unsigned char
	{
		NST_STOCK,
		NST_ALL,
		NST_ALL_US,
		NST_UNFILTERED,

		NST_Count
	};

	enum ColumnId : unsigned short
	{
//		HP_SYMBOL,
		NH_DATETIME,
		NH_DATETIME_PUBLISHED,
		NH_TEXT,
		NH_RESOURCE_ID,
		NH_ALERT_TAKE,
		NH_WIRE_ID,
		NH_SUBWIRE_ID,
		NH_RELEVANCE,
		NH_HEADLINE_TYPE,
		NH_TICKER_SYMBOLS,
		NH_STORY_CODES,
		NH_PROVIDER_SERVICE,
		NH_SYNOPSIS,
		NH_SYMBOL,
		NH_ORDINAL,
		NH_TIME_ARRIVED,

		NH_COLUMN_COUNT
	};
	virtual unsigned short GetBuiltInColumnCount() const override{return NH_COLUMN_COUNT;}
	virtual void toString(std::string& str, unsigned int contentModifier) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual void fromScratch() override;
	virtual void AddToSpecificToolCollection() override;

	virtual void UpdateDataGraphics(const Graphics* graphics) override;
	virtual bool UpdateDataGraphicsColorsCustom(const GraphicsColorCollection* colorCollection) override;
	virtual bool UpdateDataGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL) override;

	virtual void SetCustomFont(const FontDescription& fontDescription, bool custom, unsigned int id) override;

	virtual bool CanLink() const override{return true;}

	virtual void DestroyRows() override;

//	virtual Row* CreateRow(const void* object, bool potential);

//	virtual bool ObjectPotentiallyBelongs(const void* object) const;//no need to call inside lock, because Execution does not change
	virtual bool RowFiltersIn(const RowSortable* row) const override;//no need to call inside lock, because Execution does not change
	virtual unsigned char RowBelongs(const RowSortable* row) const override;//no need to call inside lock, because Execution does not change

	virtual void AcceptText(const char* text, unsigned int code) override;
	virtual void AppendWindowMenuInfo(std::string& menuText) const override;

	virtual void ProfilesLoaded(){}

//	virtual bool PasteStocksFromClipboard(bool replace);
	virtual void CopySelectedStocksToClipboard() const override;
	virtual void CopyAllStocksToClipboard() const override;
	virtual unsigned short GetSymbolColumn() const override{return NH_SYMBOL;}
	virtual void PasteStocksFromString(const char* cursor, size_t size, bool replace) override;

	virtual const char* GetSettingsTabPath(const CPoint& point) const override;
	virtual const void* GetSettingsTabInitInfo(const CPoint& point) const override;

	virtual bool UpdateHistoryLoadBkColor() override;

	const bool& isNewsConnected() const{return m_newsConnected;}
	const bool& isNoProfile() const{return m_noProfile;}

	const bool& isLoadingHistory() const{return m_loadingHistory;}

	const unsigned short& GetDaysBack() const{return m_daysBack;}
	const unsigned int& GetHeadlineCount() const{return m_headlineCount;}
	const bool& isAfterMarket() const{return m_afterMarket;}
	unsigned char SetLimits(unsigned short daysBack, unsigned int headlineCount, bool afterMarket);
	const unsigned char& GetSerachType() const{return m_searchType;}
	const bool& isShowStoryChain() const{return m_showStoryChain;}
	const bool& isFirstTickerOnly() const{return m_firstTickerOnly;}
	const bool& isDisplayLastHistoricStory() const{return m_displayLastHistoricStory;}

	const bool& isInvalid() const{return m_invalid;}
	void SetInvalid(const bool& invalid)
	{
		if(invalid != m_invalid)
		{
			m_invalid = invalid;
			if(invalid)
			{
				m_loadingHistory = false;
			}
			InvalidateDataRectIfValid();
		}
	}

	void SetSearchType(unsigned char searchType);
	void SetShowStoryChain(bool show);
	void SetFirstTickerOnly(bool only);
	void SetDisplayLastHistoricStory(bool display);

//	const std::string& GetSymbol() const{return m_symbol;}
//	virtual const char* GetStringSymbolPtr(unsigned char& basket) const{return &m_symbol;}
//	COLORREF GetColorNeutral() const{return m_colorNeutral;}
	const std::string& GetBasketName() const{return m_basketName;}
	const std::string& GetBasketFilter() const{return m_basketFilter;}

	typedef std::set<NewsHeadlineRow*> HiliteSet;
	typedef std::map<unsigned int, HiliteSet> HiliteMap;

	static const unsigned short maxHiliteMinute = 10;
	const unsigned short& GetHiliteMinute() const{return m_hiliteMinute;};
	void SetHiliteMinute(unsigned short minute);

	const bool& isHiliteUseBackground() const{return m_hiliteUseBackground;}
	void SetHiliteUseBackground(const bool useBackground);
	const bool& isHiliteEntireRow() const{return m_hiliteEntireRow;}
	void SetHiliteEntireRow(const bool entireRow);

	const bool& isHiliteNonMarketUseBackground() const{return m_hiliteNonMarketUseBackground;}
	void SetHiliteNonMarketUseBackground(const bool useBackground);
	const bool& isHiliteNonMarketEntireRow() const{return m_hiliteNonMarketEntireRow;}
	void SetHiliteNonMarketEntireRow(const bool entireRow);

	const bool& isBasketHiliteUseBackground() const{return m_basketHiliteUseBackground;}
	void SetBasketHiliteUseBackground(const bool useBackground);
	const bool& isBasketHiliteEntireRow() const{return m_basketHiliteEntireRow;}
	void SetBasketHiliteEntireRow(const bool entireRow);

	const bool& isHiliteNonMarket() const{return m_hiliteNonMarket;}
	void SetHiliteNonMarket(const bool hiliteNonMarket);

	const bool& isHilitePostMarket() const{return m_hilitePostMarket;}
	void SetHilitePostMarket(const bool hilitePostMarket);

	const COLORREF& GetHiliteColor() const{return m_hiliteColor;}
	void CurrentSecondChanged(unsigned int currentSecond);

	const COLORREF& GetHiliteNonMarketColor() const{return m_hiliteNonMarketColor;}
	const COLORREF& GetHilitePostMarketColor() const{return m_hilitePostMarketColor;}

	const COLORREF& GetColorNotLoaded() const{return m_colorNotLoaded;}
	const COLORREF& GetColorDisconnected() const{return m_colorDisconnected;}

	unsigned int GetNextMenuId() const;
//StockFiltering
//	typedef CMap<const Security*, const Security* const&, NewsHeadlineSecurity*, NewsHeadlineSecurity* const&> SecurityMap;
	typedef CMap<unsigned __int64, const unsigned __int64&, NewsHeadlineSecurity*, NewsHeadlineSecurity* const&> SecurityMap;
//	virtual void ApplyFilter(const TakionFilter& filter) override;
	virtual void LeaveFilter() override;

//	const COLORREF& GetColorNotLoaded() const{return m_colorNotLoaded;}
//	const COLORREF& GetColorDisconnected() const{return m_colorDisconnected;}

//	virtual COLORREF GetBkColor() const override{return m_marketSorterConnected ? m_marketSorterLoaded ? m_bkColor : m_colorNotLoaded : m_colorDisconnected;}
	void SetMarketSorterConnected(bool connected);
	void SetMarketSorterLoaded(bool loaded);

	const unsigned short& GetTimeFrame() const{return m_timeFrame;}

	virtual bool isTimeFrameInMinutes() const override{return m_timeFrameInMinutes;}
	virtual unsigned short GetTimeFrameInSeconds() const override{return m_timeFrameInSecondsValue;}
	void SetTimeFrameInMinutes(bool timeFrameInMinutes);
	void UpdateEquityTimeFrame();

	unsigned char NewsHeadlineSecurityBelongs(const SecurityChartRow* row) const;//should be called inside lock

	bool SecurityBelongs(const SecurityChartRow* security) const;// = 0;
	bool SecurityPotentiallyBelongs(const Security* security) const;// = 0;

	virtual NewsHeadlineSecurity* CreateSecurity(const Security* security, Position* position, bool potential);
	void NewSecurity(const Security* security);

	void RemoveNewsHeadlineSecurity(NewsHeadlineSecurity* row);

	virtual void AllAccountsDeleted() override;
	virtual void SetAccount(const Account* account) override;
	virtual void CurrentAccountLoaded() override;
	virtual void CurrentAccountConstraintsLoaded() override;
	virtual bool isContentsChangeOnAccountChange() const override{return false;}
////
	virtual void OnUnlink() override{}

	void TokenExpressionAdded(const TokenExpressionCollection* const expression);
	void TokenExpressionRemoved(const TokenExpressionCollection* const expression);
	void TokenExpressionChanged(const TokenExpressionCollection* const expression);
	bool SetFilterTokenExpression(const TokenExpressionCollection* const expression);
	bool SetFilterTokenExpressionByName(const char* name);
	bool SetHighlightTokenExpression(const TokenExpressionCollection* const expression);
	bool SetHighlightTokenExpressionByName(const char* name);

	const COLORREF& GetHighlightTokensColor() const{return m_highlightTokensColor;}

	typedef std::map<std::string, bool> StringBoolMap;//bool - WHole WOrd

	virtual SymbolFilter* GetFilterCopy() const override;
	virtual unsigned char GetNativeFilterType() const override{return FT_NEWS_HEADLINE;}// m_filter.isA(); }
	virtual const TakionFilter* GetFilter() const override{return m_securityFilter;}
protected:
	NewsHeadlineWnd(const CBitmap* bitmap, unsigned int workspace, bool pinned = false);
	virtual void DoUpdateTitle() override;

	void DestroySecurityFiltering();
	void DestroySecurityMap();

	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;
//	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
//	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
//	DECLARE_MESSAGE_MAP()

	virtual void NextDayStarted() override;
	virtual void RowInserted(RowSortable* row) override;
	virtual void RowRemoved(RowSortable* row) override;

	virtual void SearchTypeChanged(){}
	virtual void FirstTickerOnlyChanged(){}
	virtual void DisplayLastHistoricStoryChanged(){}
	void StartTypingSymbol(unsigned char key);
	virtual bool ProcessKeyDown(unsigned char key, unsigned char modifier, bool repeat, TakionFrame* fromWindow) override;
	bool DoSetSymbol(const char* symbol);
	virtual void SymbolAccepted(const char* text, bool changed);
	void NullifyStock();
//	void UpdatePrints();

	virtual void BeforeDestroy();
	virtual void AddMenuItems(CMenu& menu);
	virtual void AddRowPropertiesMenuItems(CMenu& popupMenu);
	virtual void PostAddRowPropertiesMenuItems(CMenu& popupMenu);
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

//	void SetNewsLoaded();
	void SetNewsConnected(const bool connected);
	void SetNoProfile(const bool& noProfile)
	{
		if(noProfile != m_noProfile)
		{
			m_noProfile = noProfile;
			if(m_hWnd)InvalidateRect(&m_clientRect, FALSE);
		}
	}
	void SetLoadingHistory(const bool& loadingHistory)
	{
		if(loadingHistory != m_loadingHistory)
		{
			m_loadingHistory = loadingHistory;
			if(m_hWnd)InvalidateRect(&m_clientRect, FALSE);
		}
	}

	virtual void InvalidateShowMilliseconds() const override;
	COLORREF m_colorNotLoaded;
	COLORREF m_colorDisconnected;
	COLORREF m_colorNoProfile;
	COLORREF m_colorInvalid;
	COLORREF m_hiliteColor;
	COLORREF m_hiliteNonMarketColor;
	COLORREF m_hilitePostMarketColor;
//	COLORREF m_colorNeutral;

	std::string m_symbol;
	std::string m_basketName;
	std::string m_basketFilter;
	bool m_basket;
//	unsigned int m_requestId;
	bool m_newsConnected;
	bool m_noProfile;

	bool m_loadingHistory;

	unsigned int m_headlineCount;
	unsigned short m_daysBack;
	bool m_afterMarket;

	unsigned char m_searchType;

	bool m_showStoryChain;
	bool m_firstTickerOnly;
	bool m_displayLastHistoricStory;

	bool m_invalid;

	void UpdateHiliteMinute(unsigned int decreasedSeconds);
	bool AddHiliteRow(NewsHeadlineRow* row);
	bool RemoveHiliteRow(NewsHeadlineRow* row);
	void ClearHiliteMap();
	unsigned short m_hiliteMinute;
	bool m_hiliteUseBackground;
	bool m_hiliteEntireRow;

	bool m_basketHiliteUseBackground;
	bool m_basketHiliteEntireRow;

	bool m_hiliteNonMarket;
	bool m_hilitePostMarket;
	bool m_hiliteNonMarketUseBackground;
	bool m_hiliteNonMarketEntireRow;

	HiliteMap m_hiliteMap;
	HiliteMap::const_iterator m_hiliteMapEnd;
//TextFiltering
	const TokenExpressionCollection* m_textFilter;
	std::string m_textFilterName;
//TextHighlighting
	void UpdateTextHighlight();
	void ClearTextHighlight();
	void ClearTextHighlightInfo();
	void OnSetHighlightTokenExpression();

//	bool UpdateFilterTokens();

	const TokenExpressionCollection* m_textHighlight;
	std::string m_textHighlightName;

	StringBoolMap m_highlightTokenCiMap;
	StringBoolMap::const_iterator m_highlightTokenCiMapBegin;
	StringBoolMap::const_iterator m_highlightTokenCiMapEnd;

	StringBoolMap m_highlightTokenCsMap;
	StringBoolMap::const_iterator m_highlightTokenCsMapBegin;
	StringBoolMap::const_iterator m_highlightTokenCsMapEnd;

	COLORREF m_highlightTokensColor;

	bool UpdateTimeFrame(unsigned short minutes);
	bool DoUpdateTimeFrame();
	virtual void Repopulate(){}
//	virtual void UpdatePopulation();
	void UpdatePopulation();

	void UpdateAccountInfo();
	virtual void AccountChanged() override;

	virtual void PopulateStockNews(){}

	void UpdateRsiMhParams();
	void UpdateRsiDaysParams();

	void UpdatedBecameFilteredIn(NewsHeadlineSecurity* newsHeadlineSecurity){}
	void UpdatedBecameFilteredOut(NewsHeadlineSecurity* newsHeadlineSecurity){}

	void ProcessNewsHeadlineSecurityBelonging(NewsHeadlineSecurity* row, unsigned char belongs);

	bool m_marketSorterConnected;
	bool m_marketSorterLoaded;
//	COLORREF m_colorDisconnected;
//	COLORREF m_colorNotLoaded;
	unsigned short m_timeFrame;

	bool m_timeFrameInMinutes;
	unsigned short m_timeFrameInSecondsValue;

	SecurityMap* m_securityMap;
	NewsHeadlineSecurityFilter* m_securityFilter;
//StockFiltering
	virtual void DoApplyFilter(const TakionFilter& filter, bool forceFilterChanged) override;
};

class TGUI_API NewsHeadlineSecurity : public PotentialSecurityChartRow
{
public:
	NewsHeadlineSecurity(NewsHeadlineWnd* parent, const Security* security, Position* position, bool potential = false);

	virtual unsigned char Belongs() const override;//0 - does not belong ever; 1 - potentially belongs; 2 - belongs
	virtual bool FiltersIn() const override;//does not check foe "does not belong ever"; false - potentially belongs; true - belongs

//	bool NewsHeadlineSecurity::SecurityBelongs() const
//	virtual bool isUseOddLotPrints() const{return m_scrollerWindow->isUseOddLotPrints();}

//	DECLARE_NED_NEW
//	bool isUseTimeFrameInMinutes() const{return m_scrollerWindow->isUseTimeFrameInMinutes();}
//	unsigned short GetTimeFrameInSeconds() const{return m_scrollerWindow->GetTimeFrameInSeconds();}
	const NewsHeadlineWnd* const& GetNewsHeadlineWindow() const{return m_newsHeadlineWindow;}
	NewsHeadlineWnd* const& GetSecurityScrollerWindow(){return m_newsHeadlineWindow;}
protected:

	virtual void BecameFilteredIn() override;
	virtual void BecameFilteredOut() override;

//	virtual void Notify(const Message* message, const Observable* from, const Message* info = NULL) override;
	NewsHeadlineWnd* m_newsHeadlineWindow;
};

class TGUI_API NewsHeadlineRow : public RowSortable//, public Observer
{
friend class NewsHeadlineWnd;
public:
	virtual ~NewsHeadlineRow();
	virtual const void* GetBaseObject() const{return this;}
	virtual COLORREF GetRowColor() const override;
	virtual COLORREF GetCellColor(unsigned short columnId) const override;
	virtual COLORREF GetCellBkColor(unsigned short columnId) const override;
	virtual COLORREF GetRowBkColor() const override;

	const unsigned int& GetSecondCreated() const{return m_secondCreated;}
	const unsigned int& GetDateCreated() const{return m_dateCreated;}
	const unsigned int& GetHiliteUntilSecond() const{return m_hiliteUntilSecond;}
	void UpdateHiliteUntilSecond();
	void NullifyHiliteUntilSecond(){m_hiliteUntilSecond = 0;}

	bool SetBasketColor(const COLORREF& color)
	{
		if(color != m_basketColor)
		{
			m_basketColor = color;
			return true;
		}
		return false;
	}
	const COLORREF& GeBasketColor() const{return m_basketColor;}
	COLORREF GetNonMarketColor() const;
protected:
	NewsHeadlineRow(NewsHeadlineWnd* parent, const unsigned __int64& dateTime, COLORREF basketColor, bool potential = false);
	NewsHeadlineWnd* m_newsHeadlineWindow;
	virtual void UpdateTextHighlight(HDC& hdc,
		NewsHeadlineWnd::StringBoolMap::const_iterator& ciBegin,
		NewsHeadlineWnd::StringBoolMap::const_iterator& ciEnd,
		NewsHeadlineWnd::StringBoolMap::const_iterator& csBegin,
		NewsHeadlineWnd::StringBoolMap::const_iterator& csEnd){}
	void SetHiliteUntilSecond(const unsigned int& second){m_hiliteUntilSecond = second;}
	unsigned int m_hiliteUntilSecond;
	unsigned int m_secondCreated;
	unsigned int m_dateCreated;
	COLORREF m_basketColor;

};

class TGUI_API DialogNewsHeadlineSecurityFilter : public DialogSecurityScrollerFilter
{
public:
	DialogNewsHeadlineSecurityFilter(TakionMainWnd* mainWnd, bool toDestroyOnFocus = false, TakionFrame* receipient = NULL, CWnd* parent = NULL);
	void Display(const TakionFilter& filter, TakionTool* receipient, unsigned int code, CWnd* parent, int x, int y);
	virtual bool isFilterChanged() const override;
	virtual bool isFilterValid() const override;
	virtual bool isFilterEmpty() const override;
	virtual void SetFilterEmpty() override;

	void UpdateMyFields(NewsHeadlineSecurityFilter& other) const;
	virtual void UpdateSymbolFilterOfOtherKind(SymbolFilter& other) const override
	{
		DialogSecurityScrollerFilter::UpdateSymbolFilterOfOtherKind(other);
		if(other.isNewsHeadlineSecurityFilter())UpdateMyFields((NewsHeadlineSecurityFilter&)other);
	}
	bool MyFieldsIntersectionDifferent(const NewsHeadlineSecurityFilter& other, unsigned int doNotCopyFlags) const;
	virtual bool isSymbolFilterOfOtherKindIntersectionDifferent(const SymbolFilter& other, unsigned int doNotCopyFlags) const override
	{
		return DialogSecurityScrollerFilter::isSymbolFilterOfOtherKindIntersectionDifferent(other, doNotCopyFlags) || other.isNewsHeadlineSecurityFilter() && MyFieldsIntersectionDifferent((const NewsHeadlineSecurityFilter&)other, doNotCopyFlags);
	}

	void MyFieldsToControls(const NewsHeadlineSecurityFilter& other, unsigned int doNotCopyFlags);
	virtual void CopySymbolFilterOfOtherKindToControls(const SymbolFilter& other, unsigned int doNotCopyFlags) override
	{
		DialogSecurityScrollerFilter::CopySymbolFilterOfOtherKindToControls(other, doNotCopyFlags);
		if(other.isNewsHeadlineSecurityFilter())MyFieldsToControls((const NewsHeadlineSecurityFilter&)other, doNotCopyFlags);
	}
protected:
	virtual void DoDataExchange(CDataExchange* pDX);
	virtual BOOL OnInitDialog();
	virtual void BeforeShow() override;
	virtual void FinishDialog(int result) override;
	virtual void UpdateFilterValues() override;
//	virtual bool EnableToolTips(bool enable) override;
	virtual void ToolTipsEnabled(bool enable) override;
	virtual void NamedFilterSelChange(const SymbolFilter* oldFilter, const SymbolFilter* newFilter, COLORREF intersectionColor, CBrush* intersectionBrush, COLORREF regularColor, int intersectionDeflation, int regularDeflation) override;
};

///////////////////

class MarketSorterRow;
class MarketSorterRowTotal;

class TGUI_API MarketSorterWindow : public RowWindowSortableAccount//, public Observer
{
friend class MarketSorterRow;
public:
	virtual const char* GetToolId() const override{return toolMarketSorterId;}
	virtual ~MarketSorterWindow();

	virtual void DestroyRows() override;
	virtual COLORREF GetBkColor() const override;

	const bool& isSaveSelection() const{return m_saveSelection;}

	virtual void GetAdditionalTitleInfo(std::string& text) const override;
	virtual void AppendWindowMenuInfo(std::string& menuText) const override;
	virtual bool isTimeFrameInMinutes() const override{return m_timeFrameInMinutes;}
//	virtual bool isUseTimeFrameInMinutes() const{return m_useTimeFrameInMinutes;}
	virtual unsigned short GetTimeFrameInSeconds() const override{return m_timeFrameInSecondsValue;}
	void SetTimeFrameInMinutes(const bool& timeFrameInMinutes)
	{
		if(m_timeFrameInMinutes != timeFrameInMinutes)
		{
			m_timeFrameInMinutes = timeFrameInMinutes;
			UpdateEquityTimeFrame();
		}
	}
	void UpdateEquityTimeFrame();
	void SetSaveSelection(const bool& saveSelection)
	{
//		if(saveSelection != m_saveSelection)
			m_saveSelection = saveSelection;
	}

	virtual bool isTickable() const override{return true;}
	virtual void AllAccountsDeleted() override;
	enum ColumnId : unsigned short
	{
		MS_SYMBOL,
		MS_EXCHANGE,
		MS_BID,
		MS_ASK,
		MS_SPREAD,
		MS_CLOSE_PRICE,
		MS_TODAYS_CLOSE_PRICE,
		MS_OPEN_PRICE,
		MS_DAY_HIGH_PRICE,
		MS_DAY_LOW_PRICE,
		MS_DAY_RANGE,
		MS_HIGH_PRICE,
		MS_LOW_PRICE,
		MS_RANGE,

		MS_DAY_NET_CHANGE,
		MS_DAY_NET_PERCENT_CHANGE,
		MS_NET_CHANGE,
		MS_NET_PERCENT_CHANGE,
		MS_VOLUME,
		MS_YESTERDAY_VOLUME,
		MS_VOLUME_RATE,
		MS_DAY_VOLUME,
		MS_DAY_VOLUME_RATE_AVG,
		MS_DIVIDEND,
		MS_SPLIT,
		MS_LAST_TRADE,
		MS_IMB_NYSE,
		MS_IMB_NSDQ,
		MS_IMB_ARCA,
		MS_IMB_EXCH,

		MS_IMB_FAR_NSDQ,
		MS_IMB_NEAR_NSDQ,
		MS_IMB_REF_NSDQ,
		MS_IMB_MATCH_NSDQ,
		MS_IMB_TIME_NSDQ,
		MS_IMB_VAR_NSDQ,
		MS_IMB_TYPE_NSDQ,

		MS_IMB_NEAR_ARCA,
		MS_IMB_MATCH_ARCA,
		MS_IMB_TIME_ARCA,
		MS_IMB_TYPE_ARCA,
		MS_IMB_AUCTION_ARCA,
		MS_IMB_MARKET_ARCA,

//		MS_IMB_FAR_NYSE,
//		MS_IMB_NEAR_NSDQ,
		MS_IMB_REF_NYSE,
		MS_IMB_MATCH_NYSE,
		MS_IMB_TIME_NYSE,
		MS_IMB_TYPE_NYSE,
		MS_IMB_REG_NYSE,
		MS_IMB_REG_TIME_NYSE,

		MS_FINANCIAL,
		MS_MARKET_CATEGORY,
		MS_ROUND_LOT,
		MS_ROUND_LOTS_ONLY,
		MS_DESCRIPTION,
		MS_REG_SHO,
		MS_RESTRICTED,
		MS_TRADING_STATUS,
		MS_TRADING_ACTION_REASON,

		MS_POS_SIZE,

		MS_IMB_CLEARING_NYSE,
		
		MS_IMB_REL_NYSE,
		MS_IMB_REL_NSDQ,
		MS_IMB_REL_ARCA,
		MS_IMB_REL_EXCH,

		MS_IMB_REL_REF_NSDQ,
		MS_IMB_REL_PRICE_NSDQ,

		MS_IMB_REL_PRICE_NYSE,
		MS_IMB_REL_PRICE_ARCA,

		MS_IMB_REG_MATCH_NYSE,
		MS_IMB_REG_CLEARING_NYSE,
		MS_IMB_REG_REF_NYSE,

		MS_IMB_SSR_NYSE,
		MS_IMB_REG_SSR_NYSE,

		MS_FIRST_PRICE,
		MS_DAY_FIRST_PRICE,
		MS_LAST_PRINT_TIME,
		MS_LAST_PRINT_SIZE,

		MS_DAY_RANGE_PERCENT,
		MS_RANGE_PERCENT,

		MS_HILO_COUNT,
		MS_HILO_COUNT_REPEAT,

		MS_MARKET_HOURS_VOLUME,
		MS_MARKET_HOURS_FIRST_PRICE,

		MS_MARKET_HOURS_NET_CHANGE,
		MS_MARKET_HOURS_NET_PERCENT_CHANGE,
		MS_MARKET_HOURS_VOLUME_RATE_AVG,

		MS_VWAP,
		MS_DAY_VWAP,
		MS_MARKET_HOURS_VWAP,

		MS_PRE_MARKET_VOLUME,
		MS_PRE_MARKET_VWAP,

		MS_THERMOGRAPH_PRINTS,
		MS_THERMOGRAPH_QUOTES,

		MS_TEST_STOCK,

		MS_TEST_VOLUME_DISCREPANCY,

		MS_HTB,
		MS_BORROW_PRICE,
		MS_BID_NET_CHANGE,
		MS_ASK_NET_CHANGE,
		MS_IMB_FAR_ARCA,
		MS_IMB_REF_ARCA,
		MS_IMB_REL_REF_NYSE,
		MS_IMB_REL_REF_ARCA,
		MS_IMB_THRU_NSDQ,
		MS_IMB_THRU_NYSE,
		MS_IMB_THRU_ARCA,

		MS_IMB_REG_REL_REF_NYSE,
		MS_IMB_REG_THRU_NYSE,
		MS_IMB_DELTA_NYSE,
//		MS_IMB_REG_DELTA_NYSE,
		MS_IMB_INFREG_PERCENT_NYSE,
		MS_IMB_INFMATCH_PERCENT_NYSE,

		MS_PMI_BID,
		MS_PMI_ASK,
		MS_PMI_TIME,
		MS_PMI_SPREAD,
		MS_PMI_BID_NET_CHANGE,
		MS_PMI_ASK_NET_CHANGE,

		MS_CODE,

		MS_LO_MINUTE,
		MS_HI_MINUTE,
//		MS_MARKET_HOURS_RANGE,
//		MS_MARKET_HOURS_HIGH_PRICE,
//		MS_MARKET_HOURS_LOW_PRICE,
/*
		MS_INVALIDATE_NUMBER,
		MS_UPDATE_NUMBER,
		MS_IU_DIFF,
*/
		MS_BORROW_SIZE,

		MS_EXT_HIGH_PRICE,
		MS_EXT_LOW_PRICE,
		MS_MH_HIGH_PRICE,
		MS_MH_LOW_PRICE,

		MS_BID_TICK,

		MS_LAST_PRICE_IN_RANGE,
		MS_DAY_LAST_PRICE_IN_RANGE,

		MS_EXT_RANGE,
//		MS_PRICE_IN_RANGE_DIFF,

		MS_TICK_COUNT,
		MS_TICK_COUNT_REPEAT,

		MS_REL_VOLUME,

		MS_L1_BID_SIZE,
		MS_L1_ASK_SIZE,

		MS_TIER_SIZE,

		MS_NITE_CHANGE,
		MS_NITE_PERCENT_CHANGE,

		MS_OPEN_CHANGE,
		MS_OPEN_PERCENT_CHANGE,

		MS_POS_ORDERS,
		MS_POS_LONG_ORDERS,
		MS_POS_SHORT_ORDERS,
		MS_POS_OPNL_L1,
		MS_POS_OPNL_PRINT,
		MS_POS_PNL_CLOSED,
		MS_POS_INVESTMENT,
		MS_POS_MPNL_L1,
		MS_POS_SHARES_TRADED,
		MS_POS_TICKET_AVERAGE,
		MS_POS_GPS_L1,
		MS_POS_GPS_PRINT,
		MS_POS_BP_USED,

		MS_LAST_NBBO_TRADE,
		MS_POS_OPNL_NBBO_PRINT,

//#ifdef LRPS
		MS_LRP_LOW,
		MS_LRP_HIGH,
		MS_LRP_SPREAD,
		MS_LRP_LOW_TIME,
		MS_LRP_HIGH_TIME,
//#endif

		MS_TRADE_TIME,
		MS_RPI,

		MS_IPO,
		MS_SECURITY_TYPE,
		MS_BANCRUPTCY,
		MS_EX_DISTRIBUTION,
		MS_EX_RIGHTS,
		MS_EX_DIVIDEND,
		MS_SPECIAL_DIVIDEND,
		MS_RULE_19C3,
		MS_ITS_ELIGIBLE,

		MS_POST_MARKET_VOLUME,
		MS_POST_MARKET_VWAP,

		MS_IMB_INIT_NSDQ,
		MS_IMB_INIT_ARCA,

		MS_FROM_HIGH,
		MS_FROM_HIGH_PERCENT,
		MS_FROM_LOW,
		MS_FROM_LOW_PERCENT,

		MS_POS_INVESTMENT_COST,

		MS_IMB_REL_YEST_NYSE,
		MS_IMB_REL_YEST_NSDQ,
		MS_IMB_REL_YEST_ARCA,
		MS_IMB_REL_YEST_EXCH,

		MS_IMB_INIT_NYSE,

		MS_TCLOSE_CHANGE,
		MS_TCLOSE_PERCENT_CHANGE,

		MS_Q_OPEN_PRICE,
		MS_Q_OPEN_CHANGE,
		MS_Q_OPEN_PERCENT_CHANGE,

		MS_EXT_RANGE_CLOSE_PERCENT,

		MS_HI_COUNT_TOTAL,
		MS_LO_COUNT_TOTAL,
		MS_HI_COUNT_REPEAT_TOTAL,
		MS_LO_COUNT_REPEAT_TOTAL,

		MS_POP_ORDINAL,

		MS_PQ_OPEN_PRICE,

		MS_PE_VOLUME,
		MS_PE_MH_VOLUME,

		MS_IMB_INIT_EXCH,
		MS_IMB_MATCH_EXCH,

		MS_OPEN_STATE,

		MS_LULD_LOW,
		MS_LULD_HIGH,
		MS_LULD_SPREAD,
		MS_LULD_LOW_TIME,
		MS_LULD_HIGH_TIME,
		MS_POS_PRICE,
		MS_MARKET_HOURS_LAST_PRICE,
		MS_SYMBOL_UNTRADEABLE,

		MS_POS_ON_OPEN,
		MS_POS_ON_CLOSE,

		MS_AVG_DAILY_VOLUME,
		MS_YESTERDAY_HI,
		MS_YESTERDAY_LO,
		MS_YESTERDAY_PRICE_RANGE,

		MS_CHART_LOADED,

		MS_IMB_REL_CLS_EXCH,
		MS_IMB_MATCH_PERCENT_EXCH,

		MS_LOADED,

		MS_IMB_EXCH_845,
		MS_IMB_EXCH_900,
		MS_IMB_EXCH_915,
		MS_IMB_EXCH_920,
		MS_IMB_EXCH_925,
		MS_IMB_EXCH_926,
		MS_IMB_EXCH_928,

		MS_IMB_TIME_EXCH,

		MS_IMB_DELTA_NYSE_PERCENT,

		MS_QUOTE_CONDITION,
		MS_TIME_QUOTE_CONDITION,
		MS_TIME_TRADING_STATE,

		MS_DAY_MONEY_TRADED,
		MS_MH_MONEY_TRADED,

		MS_COMMENT,

		MS_RELATIVE_VOLUME,

		MS_BID_NET_PERCENT,
		MS_ASK_NET_PERCENT,

		MS_T_BID_NET_CHANGE,
		MS_T_ASK_NET_CHANGE,

		MS_RSI_MH,
		MS_RSI_DAYS,

		MS_IMB_REF_EXCH,
		MS_IMB_REF_EXCH_CHANGED,
		MS_PQOPEN_TIME,

		MS_NOTE,

		MS_POS_OPNL_L1_COST,
		MS_POS_OPNL_PRINT_COST,

		MS_IMB_REL_REF_CLS_EXCH,

		MS_CIRCUIT_BREAKER_TIME,

		MS_IMB_EXCH_1550,
		MS_IMB_EXCH_1555,
		MS_IMB_EXCH_1556,
		MS_IMB_EXCH_1557,
		MS_IMB_EXCH_1558,
		MS_IMB_EXCH_1559,

		MS_TICK_PILOT_GROUP,

		MS_IMB_NEAR_EXCH,

		MS_NET_PERCENT_CHANGE_ABS,

		MS_HEADLINE_COUNT,
		MS_HEADLINE_DATETIME,

		MS_LAST_PRICE_FROM_LD,
		MS_LAST_PRICE_FROM_LU,

		MS_LAST_PRICE_FROM_LD_PERCENT,
		MS_LAST_PRICE_FROM_LU_PERCENT,

		MS_LAST_PRICE_FROM_LULD,
		MS_LAST_PRICE_FROM_LULD_PERCENT,

		MS_PQOPEN_NET_PERCENT_945,
		MS_PQOPEN_NET_PERCENT_1000,

		MS_BID_NET_PERCENT_730,
		MS_ASK_NET_PERCENT_730,
		MS_BID_NET_PERCENT_830,
		MS_ASK_NET_PERCENT_830,

		MS_IMB_FAR_EXCH,
		MS_IMB_FAR_EXCH_1ST,
		MS_IMB_FAR_EXCH_2ND,
		MS_IMB_FAR_EXCH_DIFF,

		MS_IMB_OPEN_EXCH,

		MS_IMB_LAST_MINUS_NEAR_EXCH,
		MS_IMB_LAST_MINUS_FAR_EXCH,

		MS_IMB_OPEN_MATCH_EXCH,
		MS_IMB_OPEN_REF_EXCH,

		MS_YEST_AFTER_MARKET_HEADLINE_COUNT,
		MS_YEST_HEADLINE_DATETIME,

		MS_PRE_MH_VOL_REL,

		MS_TCLOSE_NET,
		MS_TCLOSE_PERCENT_NET,

		MS_BID_DELTA,
		MS_ASK_DELTA,

		MS_IMB_EXCH_1545,
		MS_IMB_RATE_EXCH_926,
		MS_IMB_RATE_EXCH_1545,
		MS_IMB_RATE_EXCH_1559,

		MS_IMB_EXCH_NEAR_NET_PERCENT,

		MS_IMB_EXCH_830,
		MS_IMB_NYSE_830,
		MS_IMB_NSDQ_830,
		MS_IMB_ARCA_830,

		MS_IMB_MARKET_NYSE,
		MS_IMB_MARKET_EXCH,

		MS_SECURITY_TYPE_DESCRIPTION,

		MS_IMB_REF_EXCH_INIT,

		MS_POS_PRICE_CLS_PERCENT,
		MS_Y_LO_BID_PERCENT,
		MS_Y_HI_ASK_PERCENT,

		MS_IMB_NSDQ_NEAR_FAR,
		MS_IMB_EXCH_NEAR_FAR,
		MS_IMB_NSDQ_VALUE,
		MS_IMB_EXCH_VALUE,
		MS_IMB_EXCH_RATE,
		MS_IMB_EXCH_DELTA_PV,

		MS_IMB_LAST_MINUS_INIT_REF_EXCH,
		MS_IMB_FAR_NSDQ_1ST,
		MS_IMB_FAR_NSDQ_2ND,
		MS_IMB_FAR_NSDQ_DIFF,
		MS_IMB_INIT_REF_FAR_NSDQ_DIFF,

		MS_LAST_MINUTE_VOLUME_PERCENT,

		MS_PRE_MH_HIGH_PRICE,
		MS_PRE_MH_LOW_PRICE,
		MS_POST_MH_HIGH_PRICE,
		MS_POST_MH_LOW_PRICE,

		MS_IMB_DELAY_NYSE,
		MS_IMB_DELAY_NSDQ,
		MS_IMB_DELAY_ARCA,

		MS_IMB_NEAR_EXCH_BID_CLOSE_PERCENT,
		MS_IMB_NEAR_EXCH_ASK_CLOSE_PERCENT,

		MS_Y_HI_BID_PERCENT,
		MS_Y_LO_ASK_PERCENT,
			
		MS_YESTERDAY_PRICE_RANGE_PERCENT,

		MS_BID_CLOSE_PERCENT,
		MS_ASK_CLOSE_PERCENT,
		MS_BID_TCLOSE_NET_PERCENT,
		MS_ASK_TCLOSE_NET_PERCENT,
		MS_VWAP_DELTA_DAY,
		MS_VWAP_DELTA_DAY_PERCENT,

		MS_IMB_NYSE_DELTA_VAL_INF,

		MS_BETA,
		MS_MARGIN,
		MS_POS_BETA_INVESTMENT,
		MS_POS_BETA_BP_USED,

		MS_BID_Y_LO_PERCENT,
		MS_ASK_Y_LO_PERCENT,
		MS_BID_Y_HI_PERCENT,
		MS_ASK_Y_HI_PERCENT,

		MS_TEMPORARY_TIER_SIZE,

		MS_LAST_TRADE_TICK,

		MS_CUSTOM_PRICE_BASE,

		MS_IMB_EXCH_ABS,
		MS_IMB_INIT_RELADV_NSDQ,
		MS_CPB_SPREAD,
		MS_CPB_SPREAD_PERCENT,
		MS_CPB_BID_SPREAD,
		MS_CPB_BID_SPREAD_PERCENT,
		MS_CPB_ASK_SPREAD,
		MS_CPB_ASK_SPREAD_PERCENT,

		MS_IMB_REL_REF_CLS_ARCA,
		MS_IMB_REL_NEAR_CLS_ARCA,
		MS_TIER_COST,
		MS_TIER_COST_BETA,
		MS_NET_PERCENT_1400,
		MS_SPREAD_PERCENT,

		MS_PRE_MARKET_VOLUME_NO_FINR,
		MS_POST_MARKET_VOLUME_NO_FINR,

		MS_CUSTOM_DATE,
		MS_IRR,

		MS_PM_EL_RATE,
		MS_PM_ES_RATE,
		MS_PM_HL_RATE,
		MS_PM_HS_RATE,
		MS_EL_RATE,
		MS_ES_RATE,
		MS_HL_RATE,
		MS_HS_RATE,
		MS_FED_REQ,
		MS_ASSET_TYPE,
		MS_MARGINABLE,
		MS_SEC_TYPE,
		MS_STATUS,

		MS_POS_ME_USED,

		MS_TIME_HTB_CHANGED,

		MS_IMB_EXCH_MATCH_VALUE,

		MS_IMB_FROZEN_NYSE,

		MS_IMB_NSDQ_1555,
		MS_IMB_NSDQ_1558,
		MS_IMB_REF_NSDQ_INIT,

		MS_IMB_REF_NSDQ_1555,
		MS_IMB_FAR_NSDQ_1555,
		MS_IMB_NEAR_NSDQ_1555,

		MS_IMB_REF_NSDQ_1558,
		MS_IMB_FAR_NSDQ_1558,
		MS_IMB_NEAR_NSDQ_1558,

		MS_IMB_RELADV_NSDQ_1555,

		MS_IMB_CHANGE_NYSE,
		MS_IMB_CHANGE_ARCA,
		MS_IMB_CHANGE_NSDQ,
		MS_IMB_CHANGE_EXCH,

		MS_NET_PERCENT_POSITION_PRICE,

		MS_PQNITE_CHANGE,
		MS_PQNITE_PERCENT_CHANGE,

//		MS_L1_DELAY,

#ifdef EXCH_OPEN_PRICE
		MS_NSDQ_OPEN_PRICE,
		MS_ARCA_OPEN_PRICE,
#endif

#ifdef _DEBUG
		MS_REF,
		MS_MAP,
		MS_POSITION_COUNT,

		MS_IMB_PREV_NYSE,
		MS_IMB_PREV_NSDQ,
		MS_IMB_PREV_ARCA,
		MS_IMB_PREV_EXCH,

#ifndef TAKION_NO_OPTIONS
		MS_COLUMN_NO_OPT_COUNT,
		MS_STOCK_POSITION_COUNT = MS_COLUMN_NO_OPT_COUNT,
		MS_OPTION_POSITION_COUNT,
#endif
#endif

/*
		MS_LAST_PRICE_AFTER_8_45,
		MS_LAST_PRICE_AFTER_9_00,
		MS_LAST_PRICE_AFTER_9_15,
		MS_LAST_PRICE_AFTER_9_20,
		MS_LAST_PRICE_AFTER_9_25,
		MS_LAST_PRICE_AFTER_9_26,
		MS_LAST_PRICE_AFTER_9_28,
*/
		MS_COLUMN_COUNT
	};

	virtual bool isSortedByClosePrice() const;
//	virtual bool SecurityClosePriceChanged(MarketSorterRow* row);

//	virtual void CreateNewBasketTradingWindow(){}
	virtual unsigned short GetAdjustedAdditionalColumnId(unsigned short id, const unsigned short builtInColumnCount, const unsigned __int64& version) const override;


#ifdef _DEBUG
#ifndef TAKION_NO_OPTIONS
	virtual unsigned short GetNoOptionBuiltInColumnCount() const override{return MS_COLUMN_NO_OPT_COUNT;}
#endif
#endif
	virtual unsigned short GetBuiltInColumnCount() const override{return MS_COLUMN_COUNT;}
	virtual unsigned short GetAdditionalColumnCount() const override;
	virtual void toString(std::string& str, unsigned int contentModifier) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual void fromScratch() override;

	virtual void AddToSpecificToolCollection() override;
	virtual void UpdateDataGraphics(const Graphics* graphics) override;

	virtual bool UpdateDataGraphicsColorsCustom(const GraphicsColorCollection* colorCollection) override;
	virtual bool UpdateDataGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL) override;
	void UpdateDataColors(bool thermoRedChanged, bool thermoGreenChanged);

//	virtual void ApplyFilter(const TakionFilter& filter) override;

	virtual void SelectPositionRows(unsigned int filter) override;//PositionStatus

	virtual void IncludeSecurity(const Security* security) override;
	virtual void ExcludeSecurity(const Security* security) override;
	virtual void UnIncludeSecurity(const Security* security) override;
	virtual void UnExcludeSecurity(const Security* security) override;
//	virtual void ClearingFirmChanged();
//	virtual void StockLoanFirmChanged();

	virtual bool CanFilterBySymbol() const override{return false;}

	virtual bool CanDragClient(UINT nFlags, CPoint point) const;

	bool AreSelectedNotes() const;
	void RemoveSelectedNotes();

	bool NoteBelongsByTextFilter(const char* note) const;
	bool SecurityBelongsByTextFilter(const Security* security) const;

	bool SecurityBelongs(const SecurityChartRow* securityChartRow) const;
	bool SecurityPotentiallyBelongs(const Security* security) const;

	virtual Row* CreateRow(const void* object, bool potential);

	typedef void (MarketSorterRow::*FnPaintInfo)(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	typedef short (MarketSorterRow::*FnCompare)(const MarketSorterRow& other) const;

	bool AddMarketSorterFunctions(unsigned short id, FnPaintInfo fnPaint, FnCompare fnCompare, FnCompare fnCompareAhead);

	inline const FnPaintInfo& GetFnPaintInfo(const unsigned short& id) const{return id < MS_COLUMN_COUNT ? m_paintInfoFunction[id] : NULL;}
	inline const FnCompare& GetFnCompare(const unsigned short& id) const{return id < MS_COLUMN_COUNT ? m_compareFunction[id] : NULL;}
	inline const FnCompare& GetFnCompareAhead(const unsigned short& id) const{return id < MS_COLUMN_COUNT ? m_compareAheadFunction[id] : NULL;}

//	virtual void StockToString(std::string& info, const Row* row) const;
	virtual unsigned short GetSymbolColumn() const{return MS_SYMBOL;}

	virtual void RemoveSelectedStocks() override;
	virtual void RemoveActiveStock() override;

/*
	void AddAccountFilter(unsigned int filter);
	void RemoveAccountFilter(unsigned int filter);
	void SwitchAccountFilter(AccountStatus accountFilter); 

	unsigned int GetAccountFilter() const{return m_accountFilter;}
	bool SetAccountFilter(unsigned int accountFilter, unsigned int& addFilter);
*/
	virtual bool HasMillisecondColumns() const{return true;}
	virtual bool HasVolumeColumns() const{return true;}

	void SetMarketSorterConnected(bool connected);
	void SetMarketSorterLoaded(bool loaded);

	virtual bool ObjectPotentiallyBelongs(const void* object) const;//no need to call inside lock
	virtual bool RowFiltersIn(const RowSortable* row) const;//should be called inside lock
	virtual unsigned char RowBelongs(const RowSortable* row) const;//should be called inside lock
	virtual unsigned char ExistingRowBelongs(const RowSortable* row) const;//should be called inside lock

	unsigned short GetTimeFrame() const{return m_timeFrame;}
	virtual void UpdateTitleGraphics(const Graphics* graphics) override;
	unsigned int GetHiCount() const{return m_hiCount;}
	unsigned int GetLoCount() const{return m_loCount;}
	void IncrementHiCount();
	void DecrementHiCount();
	void IncrementLoCount();
	void DecrementLoCount();
	static const unsigned short thermographSize = 16;
	static const unsigned short thermographDepth = 16;
//	const COLORREF* GetThermographRedColors() const{return m_thermographRedColors;}
//	const COLORREF* GetThermographGreenColors() const{return m_thermographGreenColors;}
	virtual const COLORREF* GetThermographRedColors() const override{return m_thermographRedColors;}
	virtual const COLORREF* GetThermographGreenColors() const override{return m_thermographGreenColors;}

	const bool& isSortThermograhPrintByTotal() const{return m_filter.isSortPrintsByActivity();}//m_sortThermograhPrintByTotal;}
//	void SetSortThermograhPrintByTotal(bool byTotal);

	const bool& isSortThermograhQuoteByTotal() const{return m_filter.isSortQuotesByActivity();}//m_sortThermograhQuoteByTotal;}
//	void SetSortThermograhQuoteByTotal(bool byTotal);

	const COLORREF& GetColorNotLoaded() const{return m_colorNotLoaded;}
	const COLORREF& GetColorDisconnected() const{return m_colorDisconnected;}
//RSI Minutes
	const bool& isRsiMhCalculate() const{return m_filter.isRsiMhCalculate();}
	const unsigned short& GetRsiMhPriorPointCount() const{return m_filter.GetRsiMhPriorPointCount();}
	const unsigned short& GetRsiMhPeriodLength() const{return m_filter.GetRsiMhPeriodLength();}//in minutes
	const unsigned short& GetRsiMhPeriodCount() const{return m_filter.GetRsiMhPeriodCount();}
	const unsigned short& GetRsiMhStartMinute() const{return m_filter.GetRsiMhStartMinute();}
	const bool& isRsiMhTodayOnly() const{return m_filter.isRsiMhTodayOnly();}
	const bool& isRsiMhPostMarket() const{return m_filter.isRsiMhPostMarket();}

//RSI Days
	const bool& isRsiDaysCalculate() const{return m_filter.isRsiDaysCalculate();}
	const unsigned short& GetRsiDaysPriorPointCount() const{return m_filter.GetRsiDaysPriorPointCount();}
	const unsigned short& GetRsiDaysPeriodLength() const{return m_filter.GetRsiDaysPeriodLength();}//in days
	const unsigned short& GetRsiDaysPeriodCount() const{return m_filter.GetRsiDaysPeriodCount();}
	const unsigned short& GetRsiDaysStartMinute() const{return m_filter.GetRsiDaysStartMinute();}
	const bool& isRsiDaysPostMarket() const{return m_filter.isRsiDaysPostMarket();}

	virtual void AcceptText(const char* text, unsigned int code);
	RowSortable* SelectSymbol(const char* symbol);
	virtual void AddSymbol(const char* symbol);
	virtual bool CanClearSymbols() const;
	virtual void ClearSymbols();

	virtual void SetAccount(const Account* account) override;

	const COLORREF& GetDayHighColor() const{return m_dayHighColor;}
	const COLORREF& GetDayLowColor() const{return m_dayLowColor;}
	virtual const COLORREF& GetInvalidColor() const override{return m_invalidColor;}

//	const COLORREF& GetTopActiveColor() const{return m_topActiveColor;}
//	const COLORREF& GetWarningColor() const{return m_warningColor;}

	virtual bool isIncludeStockActive() const{return m_includeStockActive;}
	virtual void SetIncludeStockActive(bool active);
	virtual bool isExcludeStockActive() const{return m_excludeStockActive;}
	virtual void SetExcludeStockActive(bool active);

//	static const unsigned int maxHiLoFlashSecond = 5;
	const unsigned int& GetHiLoFlashSecond() const{return m_hiLoFlashSecond;};
	void SetHiLoFlashSecond(unsigned int second);
	void AddHiLoFlashRow(MarketSorterRow* row);
	void RemoveHiLoFlashRow(MarketSorterRow* row);

	const unsigned int& GetDayHiLoFlashSecond() const{return m_dayHiLoFlashSecond;};
	void SetDayHiLoFlashSecond(unsigned int second);
	void AddDayHiLoFlashRow(MarketSorterRow* row);
	void RemoveDayHiLoFlashRow(MarketSorterRow* row);

	void CurrentSecondChanged(unsigned int currentSecond);

	typedef std::set<MarketSorterRow*> HiLoSet;
	typedef std::map<unsigned int, HiLoSet> HiLoMap;

	const bool& isHiLoFlashUseBackground() const{return m_hiLoFlashUseBackground;}
	void SetHiLoFlashUseBackground(const bool& useBackground)
	{
		if(useBackground != m_hiLoFlashUseBackground)
		{
			m_hiLoFlashUseBackground = useBackground;
			if(m_hiLoFlashEntireRow)
			{
				InvalidateDataRect();
			}
			else
			{
				InvalidateDataAtColumn(MS_SYMBOL);
			}
		}
	}

	const bool& isHiLoFlashEntireRow() const{return m_hiLoFlashEntireRow;}
	void SetHiLoFlashEntireRow(const bool& entireRow)
	{
		if(entireRow != m_hiLoFlashEntireRow)
		{
			m_hiLoFlashEntireRow = entireRow;
			InvalidateDataRect();
		}
	}

	virtual bool CanPopulateSelectedIntoActiveCommandWindow() const{return true;}

	virtual void CurrentAccountLoaded() override;
	virtual void CurrentAccountConstraintsLoaded() override;
	virtual bool HasLastSymbolCommands() const override{return true;}
	virtual bool GetLastSecuritySymbol(std::string& symbol) const override;

	virtual int GetHourRectLeft() const;
	virtual bool CanPlayNewLineSound() const;

	virtual unsigned short GetPopOrdinalColumnId() const{return MS_POP_ORDINAL;}

	const bool& isZeroPriceEmpty() const{return m_zeroPriceEmpty;}
	void SetZeroPriceEmpty(const bool& zeroPriceEmpty)
	{
		if(zeroPriceEmpty != m_zeroPriceEmpty)
		{
			m_zeroPriceEmpty = zeroPriceEmpty;
			SortData();
		}
	}

	unsigned int GetNextMenuId() const;
	virtual bool isAffectedByOddLotPrints() const override{return true;}

	virtual bool isContentsChangeOnAccountChange() const override{return false;}
#ifdef FIRM_VALUES
	const AccountAggregator* GetAccountAggregator() const{return m_accountAggregator;}
#if (_MSC_VER > 1600)
	typedef std::unordered_map<unsigned __int64, unsigned char> SymbolMap;
#else
	typedef std::hash_map<unsigned __int64, unsigned char> SymbolMap;
#endif
	unsigned char isSymbolUntradeable(const unsigned __int64& symbol) const
	{
		SymbolMap::const_iterator found = m_untradeableSymbols.find(symbol);
		return found == m_untradeableSymbolsEnd ? 0 : found->second;
	}
	void UpdateUntradeableStatus(const unsigned __int64& numericSymbol, unsigned char untradeable);
#endif
	virtual bool hasInventoryView() const{return true;}
	void SetRowComment(MarketSorterRow* row, const char* const comment, const bool remember = true);
	virtual void ApplyStringValue(unsigned int code, RowSortableSet& rowSet, unsigned short stringColumnId, const char* value) override;
	virtual void ApplyPriceValue(unsigned int code, RowSortableSet& rowSet, unsigned short numberColumnId, const Price& value) override;
//	virtual void ApplyDateValue(unsigned int code, RowSortableSet& rowSet, unsigned short numberColumnId, const unsigned int& date) override;
	virtual void ApplyUIntValue(unsigned int code, RowSortableSet& rowSet, unsigned short numberColumnId, unsigned int value) override;

	typedef std::map<unsigned __int64, std::string, lessUIntAsStr<unsigned __int64> > UInt64StrMap;
	const UInt64StrMap& GetCommentMap() const{return m_commentMap;}
	const std::string* FindComment(const unsigned __int64& symbol) const
	{
		UInt64StrMap::const_iterator found = m_commentMap.find(symbol);
		return found == m_commentMapEnd ? NULL : &found->second;
	}
//	virtual bool isBasket() const{return false;}//is in TakionTool

#if (_MSC_VER > 1600)
	typedef std::unordered_set<unsigned __int64> UInt64HashSet;
#else
	typedef std::hash_set<unsigned __int64> UInt64HashSet;
#endif
	bool SelectVisibleSecurity(const Security* security)
	{
		return m_multiselect && DoSelectVisibleSecurity(security);
	}
	bool SelectVisibleNumericSymbol(const unsigned __int64& numericSymbol)
	{
		return m_multiselect && DoSelectVisibleNumericSymbol(numericSymbol);
	}

	void MarketSorterDisconnected();

	void TokenExpressionAdded(const TokenExpressionCollection* const expression);
	void TokenExpressionRemoved(const TokenExpressionCollection* const expression);
	void TokenExpressionChanged(const TokenExpressionCollection* const expression);
	bool SetTokenExpression(const TokenExpressionCollection* const expression);
	bool SetTokenExpressionByName(const char* name);

	virtual SymbolFilter* GetFilterCopy() const override;
	virtual unsigned char GetNativeFilterType() const override{return m_filter.isA();}
	virtual const TakionFilter* GetFilter() const override{return &m_filter;}

protected:
	MarketSorterWindow(const CBitmap* bitmap,
		unsigned int workspace,
		bool pinned = false,
		unsigned short builtInColumns = MS_COLUMN_COUNT,
		int minVisibleSize = 15,
		int minWidth = 20,
		int maxWidth = 0,
		int minHeight = 20,
		int maxHeight = 0,
		int minBorderWidth = 2,
		int maxBorderWidth = 2,
		const char* className = "TakionTool",
		int minTitleHeight = 0,
		int maxTitleHeight = 15,
		int titleHeight = 15);

//	virtual void UpdateNamedFiltering() override;

	virtual void TitleFontChanged() override;

	virtual void Notify(const Message* message, const Observable* from, const Message* info = NULL);

	virtual void OnMarketSorterLoaded(bool loaded){}

	void AddComment(const unsigned __int64& symbol, const std::string& comment)
	{
		UInt64StrMap::iterator found = m_commentMap.find(symbol);
		if(found == m_commentMapEnd)
		{
			if(!comment.empty())
			{
				m_commentMap.insert(UInt64StrMap::value_type(symbol, comment));
			}
		}
		else
		{
			if(comment.empty())
			{
				m_commentMap.erase(symbol);
			}
			else
			{
				found->second = comment;
			}
		}
	}
	void RemoveComment(const unsigned __int64& symbol)
	{
		m_commentMap.erase(symbol);
	}
	void ClearComments();

	void DoSecurityNoteAdded(const unsigned __int64& symbol, const std::string& note, bool sort);
	void DoSecurityNoteRemoved(const unsigned __int64& symbol, bool potentiallyBelongs, bool sort);

	virtual void SecurityNoteAdded(const unsigned __int64& symbol, const std::string& note) override;
	virtual void SecurityNoteRemoved(const unsigned __int64& symbol) override;
	virtual void SecurityNotesCleared() override;
//	virtual void SecurityNotesClearDone() override;
	virtual void SecurityNotesReplaced(const std::map<unsigned __int64, std::string, lessUIntAsStr<unsigned __int64> >& newNotes, bool clearOld) override;
//	virtual void SecurityNotesReplacementDone() override;

	virtual void OnSuccessfulCreate();

	virtual void PrefixChanging(const char* from) const override;

	virtual void DisplayClientMenu(UINT nFlags, CPoint point) override;

	virtual bool UpdateHistoryLoadBkColor() override;

	virtual void DoUpdateTitle() override;
//	virtual void UpdateCurrentAccount(){}

	virtual void NextDayStarted() override;

	virtual void ClearRowsTemporarily() override;

	virtual void CreateAdditionalColumns() override;

	virtual void PasteStocksFromString(const char* cursor, size_t size, bool replace) override;

	virtual RowTotal* CreateRowTotal() override;
	virtual MarketSorterRowTotal* DoCreateRowTotal();
	virtual void LineSelected() override;
	virtual void BeforeDestroy() override;
	virtual void AccountChanged() override;

#ifdef FIRM_VALUES
	void AccountAggregatorChanged();
	void UpdateAccountAggregatorInfo();
	void UpdateAccountAggregatorValues(RowSortable* row);
	const AccountAggregator* m_accountAggregator;
	SymbolMap m_untradeableSymbols;
	SymbolMap::const_iterator m_untradeableSymbolsEnd;
#endif
	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;
//	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
//	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
//	DECLARE_MESSAGE_MAP()

	virtual void AddMenuItems(CMenu& menu);
	virtual void PostAddMenuItems(CMenu& menu);
	virtual void AddRowPropertiesMenuItems(CMenu& popupMenu);
	virtual void PostAddRowPropertiesMenuItems(CMenu& popupMenu);
	virtual void AddAdditionalActiveSymbolMenuItems(CMenu& popupMenu, const unsigned __int64& numSymbol){}
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual void Populate();//{}//bool remove);//, unsigned int addPositionFilter);

	virtual void DoPaintTitle(const RECT& interRect, CDC& dc) override;
	virtual void UpdateTitleRects();
	virtual void OnTitleResize();
	virtual void SizeHorizontal(int cx, int cy, int oldX, int oldY);

//	virtual void Repopulate(){}
	virtual void RepopulateOnFiltering(){Repopulate();}

	virtual void RowInserted(RowSortable* row);
	virtual void RowRemoved(RowSortable* row);

	virtual bool ProcessKeyDown(unsigned char key, unsigned char modifier, bool repeat, TakionFrame* fromWindow) override;

	bool UpdateTimeFrame(unsigned short minutes, bool sortingChanged);
	bool DoUpdateTimeFrame(bool sortingChanged);
	void UpdateTimeFrameValues(RowSortable* row);
	void RepaintTimeFrameValues() const;

	void UpdateRsiMhParams();
	void UpdateRsiDaysParams();

	void UpdateAccountInfo();
	void UpdatePositionValues(RowSortable* row);
	void RepaintPositionValues() const;
	void RepaintPositionValuesAtRow(RowSortable* row) const;
	bool isSortedByPosition() const;

//	bool ProcessRowBelonging(RowSortable* row, unsigned char belongs, bool sortingChanged);

//	virtual bool AddNewAccounts(){return false;}
//	bool InsertAccountRowIntoRowSet(AccountRow* row);

//	void DestroyPotentialRows();
//	RowMap m_potentialRows;

//	unsigned int m_accountFilter;

	FnPaintInfo m_paintInfoFunction[MS_COLUMN_COUNT];
	FnCompare m_compareFunction[MS_COLUMN_COUNT];
	FnCompare m_compareAheadFunction[MS_COLUMN_COUNT];
	MarketSorterFilter m_filter;
	void DoApplyFilter(const TakionFilter& filter, bool forceFilterChanged);

	bool AssignTokenExpressionByName(const char* name);
	void PopulateByTokenExpression();
	const TokenExpressionCollection* m_textFilter;
	std::string m_textFilterName;

	CRect m_hiRect;
	CRect m_xRect;
	CRect m_loRect;
	int m_hiloWidth;
	int m_xWidth;
	void ResetHiLoCount();
	unsigned int m_hiCount;
	unsigned int m_loCount;

	bool m_marketSorterConnected;
	bool m_marketSorterLoaded;
	COLORREF m_colorDisconnected;
	COLORREF m_colorNotLoaded;
	unsigned short m_timeFrame;

	COLORREF m_dayHighColor;
	COLORREF m_dayLowColor;

	COLORREF m_colorThermographRed;
	COLORREF m_colorThermographGreen;
	COLORREF m_thermographRedColors[thermographSize];
	COLORREF m_thermographGreenColors[thermographSize];

	COLORREF m_invalidColor;

//	bool m_sortThermograhPrintByTotal;
//	bool m_sortThermograhQuoteByTotal;
	virtual void ActiveSymbolAboutToChange(const unsigned __int64& newActiveSymbol
#ifndef TAKION_NO_OPTIONS
		,const unsigned __int64& newActiveOptionBlock
#endif
		);
	virtual bool ActiveSymbolChanged();
	MarketSorterRow* m_prevTopRow;
	MarketSorterRow* m_nextTopRow;

//	COLORREF m_topActiveColor;
//	COLORREF m_warningColor;

	void ClearHiLoMap();
	unsigned int m_hiLoFlashSecond;
	HiLoMap m_hiLoMap;
	HiLoMap::const_iterator m_hiLoMapEnd;

	void ClearDayHiLoMap();
	unsigned int m_dayHiLoFlashSecond;
	HiLoMap m_dayHiLoMap;
	HiLoMap::const_iterator m_dayHiLoMapEnd;

	bool m_hiLoFlashUseBackground;
	bool m_hiLoFlashEntireRow;

	UInt64StrMap m_commentMap;
	UInt64StrMap::const_iterator m_commentMapEnd;

	void SecurityRefreshed(const Security* security);
	bool DoSelectVisibleSecurity(const Security* security);
	bool DoSelectVisibleNumericSymbol(const unsigned __int64& numericSymbol);
	UInt64HashSet m_initialSelectionSet;
	UInt64HashSet::const_iterator m_initialSelectionSetEnd;

	bool m_selectedActive;
	
	void SetNotifyExtensions(const bool notify);
	bool m_notifyExtensions;

	bool m_includeStockActive;
	bool m_excludeStockActive;

	bool m_zeroPriceEmpty;

	bool m_saveSelection;

	bool m_timeFrameInMinutes;
//	bool m_useTimeFrameInMinutes;
	unsigned short m_timeFrameInSecondsValue;
private:
	MarketSorterWindow(const MarketSorterWindow& other);
	MarketSorterWindow& operator=(const MarketSorterWindow& other);
};

class TGUI_API MarketSorterRow : public RowSortable, public SecurityChartRow
{
friend class MarketSorterWindow;
public:
	MarketSorterRow(MarketSorterWindow* parent, Security* security, const Position* position, bool potential = false);
	virtual ~MarketSorterRow();
	virtual bool isUseOddLotPrints() const override{return m_marketSorterWindow->isUseOddLotPrints();}
	virtual const void* GetBaseObject() const override{return m_security;}
	virtual bool GetPaintTextInfo(unsigned short columnId, std::string& text, COLORREF& color) const override;//, UINT& horizontalJustification) const override;
	virtual bool PaintCell(CDC& dc, const Column* column, const CRect& rect, UINT verticalJustification, int horizontalOffset) const override;//, unsigned char horizontalAlignment) const;
	virtual bool CellToString(std::string& info, unsigned short columnId) const override;
	virtual COLORREF GetRowColor() const override;
	virtual COLORREF GetCellColor(unsigned short columnId) const override;
	virtual COLORREF GetCellBkColor(unsigned short columnId) const override;
	virtual COLORREF GetRowBkColor() const override;

	virtual RowValue* CreateCell(unsigned short id) override;

	virtual bool hasInventory() const override{return m_position && m_position->GetInventory() != NULL;}

//	bool isUseTimeFrameInMinutes() const{return m_marketSorterWindow->isUseTimeFrameInMinutes();}
	unsigned short GetTimeFrameInSeconds() const{return m_marketSorterWindow->GetTimeFrameInSeconds();}

	virtual void InvalidateRsiMhCellIfVisible() const override//SecurityChartRow
	{
		m_windowSortable->InvalidateConstRowCellIfVisible(this, MarketSorterWindow::MS_RSI_MH);
	}

	virtual void InvalidateRsiDaysCellIfVisible() const override//SecurityChartRow
	{
		m_windowSortable->InvalidateConstRowCellIfVisible(this, MarketSorterWindow::MS_RSI_DAYS);
	}

	COLORREF GetFlashColor() const
	{
		return m_dayHiloSecond ? m_hiReached ? m_marketSorterWindow->GetDayHighColor() : m_marketSorterWindow->GetDayLowColor():
			m_hiloSecond ? m_hiReached ? m_marketSorterWindow->GetPositiveTickColor() : m_marketSorterWindow->GetNegativeTickColor():
			0xFFFFFFFF;
	}
	virtual bool Lock(bool wait) const override;
//	virtual void LockWait() const override;
	virtual void Unlock() const override;
	virtual bool SetPosition(const Position* position);
	bool SetSymbolUntradeable(unsigned char untradeable);
//	bool LockPosition();
//	void LockPositionWait();
//	void UnlockPosition();
	virtual bool isSortValueChanged() const;
	virtual bool isChainSortValueChanged() const;
/*
	virtual short Compare(const RowSortable& other) const;
	virtual short CompareAhead(const RowSortable& other) const;
	virtual short CompareChain(const RowSortable& other) const;
	virtual short CompareChainAhead(const RowSortable& other) const;
*/
	virtual short DefaultCompare(const RowSortable& other) const override;

	virtual bool CompareFunction(const RowSortable& other, unsigned short sortId, short& ret) const override;
	virtual bool CompareFunctionAhead(const RowSortable& other, unsigned short sortId, short& ret) const override;
	virtual short PreCompare(const RowSortable& other) const override;

	virtual const char* GetStringValue(unsigned short id) const override;
	virtual const unsigned __int64 GetUInt64Value(unsigned short id) const override;
	virtual const unsigned int GetUIntValue(unsigned short id) const override;

	virtual void Update(bool dynamicOnly) override;
	virtual bool UpdateRowColor() override;//should be called only inside a lock
	virtual void UpdateAndInvalidate(CRect& rowRect, bool dynamicOnly) override;

	virtual void Initialize() override;//should be called only inside a lock

	virtual const char* GetRowSecuritySymbol(const CPoint* point = NULL) const override{return m_security ? m_security->GetSymbol() : NULL;}
	virtual const unsigned __int64& GetRowNumericSymbol() const override{return m_security ? m_security->GetNumericSymbol() : uint64Zero;}
	virtual const PositionData* GetRowPosition(const CPoint* point = NULL) const override{return m_position;}

	const unsigned __int64& GetNumericSymbol() const{return m_security ? m_security->GetNumericSymbol() : uint64Zero;}

	DECLARE_NED_NEW

	virtual const Security* GetSelectedSecurity() const override;

	virtual bool SetTimeFrame(unsigned short minutes, unsigned short timeFrameInSeconds) override;

	static const unsigned short thermographLength = 16;

	const Thermograph& GetThermographQuotesGreen() const{return m_thermographQuotesGreen;}
	const Thermograph& GetThermographQuotesRed() const{return m_thermographQuotesRed;}
	const Thermograph& GetThermographPrintsGreen() const{return m_thermographPrintsGreen;}
	const Thermograph& GetThermographPrintsRed() const{return m_thermographPrintsRed;}

	const unsigned int& GetHiLoSecond() const{return m_hiloSecond;}
	bool isHiReached() const{return m_hiReached;}
	void NullifyHiLoSecond(){m_hiloSecond = 0;}

	const unsigned int& GetDayHiLoSecond() const{return m_dayHiloSecond;}
	void NullifyDayHiLoSecond(){m_dayHiloSecond = 0;}

	MarketSorterWindow* GetMarketSorterWindow(){return m_marketSorterWindow;}
	const MarketSorterWindow* GetMarketSorterWindow() const{return m_marketSorterWindow;}

	const char* const& GetComment() const{return m_comment;}
	const char* const& GetNote() const{return m_note;}

	void PaintSymbol(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareSymbol(const MarketSorterRow& other) const;
/*
#ifdef _DEBUG
	void PaintRefNumber(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
#endif
*/
//	void PaintExchange(std::string& text, COLORREF& color, UINT& horizontalJustification) const;
//	short CompareExchange(const MarketSorterRow& other) const;
//	void PaintMarketCategory(std::string& text, COLORREF& color, UINT& horizontalJustification) const;
//	short CompareMarketCategory(const MarketSorterRow& other) const;
//	void PaintRoundLot(std::string& text, COLORREF& color, UINT& horizontalJustification) const;
//	short CompareRoundLot(const MarketSorterRow& other) const;
//	void PaintRoundLotsOnly(std::string& text, COLORREF& color, UINT& horizontalJustification) const;
//	short CompareRoundLotsOnly(const MarketSorterRow& other) const;
//	void PaintDescription(std::string& text, COLORREF& color, UINT& horizontalJustification) const;
//	short CompareDescription(const MarketSorterRow& other) const;
//	void PaintTestStock(std::string& text, COLORREF& color, UINT& horizontalJustification) const;
//	short CompareTestStock(const MarketSorterRow& other) const;
//	void PaintSecurityCode(std::string& text, COLORREF& color, UINT& horizontalJustification) const;
//	short CompareSecurityCode(const MarketSorterRow& other) const;
//	void PaintIpo(std::string& text, COLORREF& color, UINT& horizontalJustification) const;
//	short CompareIpo(const MarketSorterRow& other) const;

//There is a message that can change SecurityType
//	void PaintSecurityType(std::string& text, COLORREF& color, UINT& horizontalJustification) const;
//	short CompareSecurityType(const MarketSorterRow& other) const;

//	void PaintBancruptcy(std::string& text, COLORREF& color, UINT& horizontalJustification) const;
//	short CompareBancruptcy(const MarketSorterRow& other) const;
//	void PaintExDistribution(std::string& text, COLORREF& color, UINT& horizontalJustification) const;
//	short CompareExDistribution(const MarketSorterRow& other) const;
//	void PaintExRights(std::string& text, COLORREF& color, UINT& horizontalJustification) const;
//	short CompareExRights(const MarketSorterRow& other) const;
//	void PaintExDividend(std::string& text, COLORREF& color, UINT& horizontalJustification) const;
//	short CompareExDividend(const MarketSorterRow& other) const;
//	void PaintSpecialDividend(std::string& text, COLORREF& color, UINT& horizontalJustification) const;
//	short CompareSpecialDividend(const MarketSorterRow& other) const;
//	void PaintRule19C3(std::string& text, COLORREF& color, UINT& horizontalJustification) const;
//	short CompareRule19C3(const MarketSorterRow& other) const;
//	void PaintItsEligible(std::string& text, COLORREF& color, UINT& horizontalJustification) const;
//	short CompareItsEligible(const MarketSorterRow& other) const;
	void PaintPopOrdinal(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short ComparePopOrdinal(const MarketSorterRow& other) const;

	void PaintComment(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareComment(const MarketSorterRow& other) const;
	void PaintNote(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareNote(const MarketSorterRow& other) const;

	short CompareThermographPrints(const MarketSorterRow& other) const;
	short CompareThermographPrintsAhead(const MarketSorterRow& other) const;
	short CompareThermographQuotes(const MarketSorterRow& other) const;
	short CompareThermographQuotesAhead(const MarketSorterRow& other) const;
protected:
	bool SetComment(const char* const comment);
	bool SetNote(const char* const note);
	virtual void ProcessPrints(){}
	bool UpdatePrintsAndQuotes(bool lock);
	bool UpdateQuotes(bool lock);
	virtual void Notify(const Message* message, const Observable* from, const Message* info = NULL) override;
	virtual void IncrementHiCount();
	virtual void DecrementHiCount();
	virtual void IncrementLoCount();
	virtual void DecrementLoCount();
	virtual void LowReached(bool dayLowReached) override{HighLowReached(false, dayLowReached);}
	virtual void HighReached(bool dayHighReached) override{HighLowReached(true, dayHighReached);}
	void HighLowReached(bool high, bool dayHighLowReached);
	MarketSorterWindow* m_marketSorterWindow;

	char* m_comment;
	char* m_note;

	Thermograph m_thermographQuotesGreen;
	Thermograph m_thermographQuotesRed;
	Thermograph m_thermographPrintsGreen;
	Thermograph m_thermographPrintsRed;

	int m_quotesThermographValueRed;
	int m_quotesThermographValueGreen;
	int m_printsThermographValueRed;
	int m_printsThermographValueGreen;

	COLORREF m_securityColor;

	unsigned int m_hiloSecond;
	unsigned int m_dayHiloSecond;
	bool m_hiReached;

//	UCharAsBoolCopyRowValue* m_untradeableSymbolRowValue;
	UntradebleRowValue* m_untradeableSymbolRowValue;
};

class TGUI_API MarketSorterRowTotal : public RowTotal
{
public:
	MarketSorterRowTotal(MarketSorterWindow* window, unsigned short columnCount = MarketSorterWindow::MS_COLUMN_COUNT):
		RowTotal(columnCount + window->GetAdditionalColumnCount(), window),
		m_size(NULL),
		m_onOpenSize(NULL),
		m_onCloseSize(NULL),
		m_pnlOpenLevel1(NULL),
		m_pnlOpenPrint(NULL),
		m_ticketAverage(NULL),
		m_pnlClosed(NULL),
		m_sharesTraded(NULL),
		m_gpsLevel1(NULL),
		m_gpsPrint(NULL),
		m_untradeableCount(NULL)
//		m_refPriceChangedCount(NULL)
	{
	}
	void SetSizePtr(UIntRowValue* const& value){m_size = value;}
	void SetOnOpenSizePtr(UIntRowValue* const& value){m_onOpenSize = value;}
	void SetOnCloseSizePtr(UIntRowValue* const& value){m_onCloseSize = value;}
	void SetUntradeableCountPtr(UIntRowValue* const& value){m_untradeableCount = value;}
//	void SetRefPriceChangedCountPtr(UIntRowValue* const& value){m_refPriceChangedCount = value;}

	void SetPnlOpenLevel1Ptr(MoneyRowValue* const& value){m_pnlOpenLevel1 = value;}
	void SetPnlOpenPrintPtr(MoneyRowValue* const& value){m_pnlOpenPrint = value;}
	void SetTicketAveragePtr(MoneyRowValue* const& value){m_ticketAverage = value;}
	void SetPnlClosedPtr(MoneyRowValue* const& value){m_pnlClosed = value;}
	void SetSharesTradedPtr(UIntRowValue* const& value){m_sharesTraded = value;}

	void SetGpsLevel1Ptr(SignedPriceRowValue* const& value){m_gpsLevel1 = value;}
	void SetGpsPrintPtr(SignedPriceRowValue* const& value){m_gpsPrint = value;}

	const UIntRowValue* const& GetSizePtr() const{return m_size;}
	const UIntRowValue* const& GetOnOpenSizePtr() const{return m_onOpenSize;}
	const UIntRowValue* const& GetOnCloseSizePtr() const{return m_onCloseSize;}

	const MoneyRowValue* const& GetPnlOpenLevel1Ptr() const{return m_pnlOpenLevel1;}
	const MoneyRowValue* const& GetPnlOpenPrintPtr() const{return m_pnlOpenPrint;}
	const MoneyRowValue* const& GetTicketAveragePtr() const{return m_ticketAverage;}
	const MoneyRowValue* const& GePnlClosedPtr() const{return m_pnlClosed;}
	const UIntRowValue* const& GetSharesTradedPtr() const{return m_sharesTraded;}
	const SignedPriceRowValue* const& GetGpsLevel1Ptr() const{return m_gpsLevel1;}
	const SignedPriceRowValue* const& GetGpsPrintPtr() const{return m_gpsPrint;}
	const UIntRowValue* const& GetUntradeableCountPtr() const{return m_untradeableCount;}
//	const UIntRowValue* const& GetRefPriceChangedCountPtr() const{return m_refPriceChangedCount;}
protected:
	virtual void UpdateNonCumulativeValues(const Row* row, bool dynamicOnly);
	virtual void AddNonCumulativeValues(const Row* row);
	virtual void RemoveNonCumulativeValues(const Row* row);
	virtual void ResetNonCumulativeValues();
	UIntRowValue* m_size;
	UIntRowValue* m_onOpenSize;
	UIntRowValue* m_onCloseSize;

	MoneyRowValue* m_pnlOpenLevel1;
	MoneyRowValue* m_pnlOpenPrint;
	MoneyRowValue* m_ticketAverage;
	MoneyRowValue* m_pnlClosed;
	UIntRowValue* m_sharesTraded;
	SignedPriceRowValue* m_gpsLevel1;
	SignedPriceRowValue* m_gpsPrint;
	UIntRowValue* m_untradeableCount;
//	UIntRowValue* m_refPriceChangedCount;
};
///////////////////////////////////////
#ifndef TAKION_NO_OPTIONS

class OptionRow;
class OptionPairRow;
class OptionRowTotal;
//class OptionPairRowTotal;

class TGUI_API BaseOptionSorterFilter : public MarketSorterFilter//StockFilter
{
public:
	virtual void Copy(const TakionFilter& other);

	virtual bool isBaseOptionSorterFilter() const override{return true;}
	void CopyMyFields(const BaseOptionSorterFilter& other, unsigned int doNotCopyFlags);
	virtual void CopySymbolFilterOfOtherKind(const SymbolFilter& other, unsigned int doNotCopyFlags) override
	{
		if(other.isBaseOptionSorterFilter())CopyMyFields((const BaseOptionSorterFilter&)other, doNotCopyFlags);
		MarketSorterFilter::CopySymbolFilterOfOtherKind(other, doNotCopyFlags);
	}
	bool MyFieldsEqual(const BaseOptionSorterFilter& other, unsigned int doNotCopyFlags) const;
	virtual bool isSymbolIntersectionEqual(const SymbolFilter& other, unsigned int doNotCopyFlags) const override
	{
		return MarketSorterFilter::isSymbolIntersectionEqual(other, doNotCopyFlags) && (!other.isBaseOptionSorterFilter() || MyFieldsEqual((const BaseOptionSorterFilter&)other, doNotCopyFlags));
	}
	virtual bool operator==(const TakionFilter& other) const override
	{
		return MarketSorterFilter::operator==(other) && MyFieldsEqual((const BaseOptionSorterFilter&)other, 0);
	}

	virtual void toString(std::string& str) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;

	virtual bool isFiltering() const override;
	virtual bool isEmpty() const override;

	virtual bool SecurityBelongs(const SecurityChartRow* securityChartRow) const{return false;}

	virtual bool SecurityPotentiallyBelongs(const Security* security) const;
	virtual unsigned char isPotentialFilterSame(const TakionFilter& filter) const;//0 - same; 1 - to add; 2 - to remove; 3 - to add and remove
	virtual bool isFilterSame(const TakionFilter& filter) const;

	virtual void Reset();

	bool OptionBelongs(const Security* option) const;
	bool OptionRowBelongs(const OptionRow* optionRow) const;
	bool OptionPairRowBelongs(const OptionPairRow* optionPairRow) const;

	unsigned short GetInTheMoneyCount() const{return m_inTheMoneyCount;}
	unsigned short GetOutTheMoneyCount() const{return m_outTheMoneyCount;}
	bool isUseInTheMoney() const{return m_useInTheMoney;}
	bool isUseOutTheMoney() const{return m_useOutTheMoney;}
	bool isUseInOutMoney() const{return m_useInTheMoney || m_useOutTheMoney;}

	const unsigned __int64& GetSuffixFilter() const{return m_suffixFilter;}
	const unsigned char& GetExpirationTypeFilter() const{return m_expirationTypeFilter;}

	void SetInTheMoneyCount(unsigned short count){m_inTheMoneyCount = count;}
	void SetOutTheMoneyCount(unsigned short count){m_outTheMoneyCount = count;}
	void SetUseInTheMoney(bool use){m_useInTheMoney = use;}
	void SetUseOutTheMoney(bool use){m_useOutTheMoney = use;}
	void SetSuffixFilter(const unsigned __int64& filter){m_suffixFilter = filter;}
	void SetExpirationTypeFilter(const unsigned char& filter){m_expirationTypeFilter = filter;}

	TakionRangePositive<unsigned short>& GetExpirationDaysRange(){return m_expirationDaysRange;}
	const TakionRangePositive<unsigned short>& GetExpirationDaysRange() const{return m_expirationDaysRange;}
	TakionRangePositive<unsigned int>& GetOpenInterestRange(){return m_openInterestRange;}
	const TakionRangePositive<unsigned int>& GetOpenInterestRange() const{return m_openInterestRange;}
protected:
	BaseOptionSorterFilter();
	bool m_useInTheMoney;
	unsigned short m_inTheMoneyCount;
	bool m_useOutTheMoney;
	unsigned short m_outTheMoneyCount;
	TakionRangePositive<unsigned short> m_expirationDaysRange;
	TakionRangePositive<unsigned int> m_openInterestRange;
	unsigned __int64 m_suffixFilter;
	unsigned char m_expirationTypeFilter;
};

class TGUI_API OptionSorterFilter : public BaseOptionSorterFilter//StockFilter
{
public:
	OptionSorterFilter();
	virtual void Copy(const TakionFilter& other);

	virtual TakionFilter* CreateFilterCopy() const override;
	virtual unsigned char isA() const override{return FT_OPTION_SORTER;}
	virtual bool isOptionSorterFilter() const override{return true;}
	void CopyMyFields(const OptionSorterFilter& other, unsigned int doNotCopyFlags);
	virtual void CopySymbolFilterOfOtherKind(const SymbolFilter& other, unsigned int doNotCopyFlags) override
	{
		if(other.isOptionSorterFilter())CopyMyFields((const OptionSorterFilter&)other, doNotCopyFlags);
		BaseOptionSorterFilter::CopySymbolFilterOfOtherKind(other, doNotCopyFlags);
	}
	bool MyFieldsEqual(const OptionSorterFilter& other, unsigned int doNotCopyFlags) const;
	virtual bool isSymbolIntersectionEqual(const SymbolFilter& other, unsigned int doNotCopyFlags) const override
	{
		return BaseOptionSorterFilter::isSymbolIntersectionEqual(other, doNotCopyFlags) && (!other.isOptionSorterFilter() || MyFieldsEqual((const OptionSorterFilter&)other, doNotCopyFlags));
	}
	virtual bool operator==(const TakionFilter& other) const override
	{
		return BaseOptionSorterFilter::operator==(other) && MyFieldsEqual((const OptionSorterFilter&)other, 0);
	}

	virtual void toString(std::string& str) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;

	virtual bool isFiltering() const override;
	virtual bool isEmpty() const override;

	virtual bool SecurityBelongs(const SecurityChartRow* securityChartRow) const{return false;}

	virtual bool SecurityPotentiallyBelongs(const Security* security) const override;
	virtual unsigned char isPotentialFilterSame(const TakionFilter& filter) const override;//0 - same; 1 - to add; 2 - to remove; 3 - to add and remove
	virtual bool isFilterSame(const TakionFilter& filter) const override;

	virtual void Reset() override;

	bool OptionBelongs(const Security* option) const;
	bool OptionRowBelongs(const OptionRow* optionRow) const;

	const unsigned char& GetCallPutFilter() const{return m_callPutFilter;}

	void SetCallPutFilter(const unsigned char& filter){m_callPutFilter = filter;}

protected:
	unsigned char m_callPutFilter;
};

class TGUI_API OptionChainFilter : public BaseOptionSorterFilter//StockFilter
{
public:
	OptionChainFilter();
	virtual void Copy(const TakionFilter& other);

	virtual TakionFilter* CreateFilterCopy() const override;
	virtual unsigned char isA() const override{return FT_OPTION_CHAIN;}
	virtual bool isOptionChainFilter() const override{return true;}
	void CopyMyFields(const OptionChainFilter& other, unsigned int doNotCopyFlags);
	virtual void CopySymbolFilterOfOtherKind(const SymbolFilter& other, unsigned int doNotCopyFlags) override
	{
		if(other.isOptionChainFilter())CopyMyFields((const OptionChainFilter&)other, doNotCopyFlags);
		BaseOptionSorterFilter::CopySymbolFilterOfOtherKind(other, doNotCopyFlags);
	}
	bool MyFieldsEqual(const OptionChainFilter& other, unsigned int doNotCopyFlags) const;
	virtual bool isSymbolIntersectionEqual(const SymbolFilter& other, unsigned int doNotCopyFlags) const override
	{
		return BaseOptionSorterFilter::isSymbolIntersectionEqual(other, doNotCopyFlags) && (!other.isOptionChainFilter() || MyFieldsEqual((const OptionChainFilter&)other, doNotCopyFlags));
	}
	virtual bool operator==(const TakionFilter& other) const override
	{
		return BaseOptionSorterFilter::operator==(other) && MyFieldsEqual((const OptionChainFilter&)other, 0);
	}

	virtual void toString(std::string& str) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;

	virtual bool SecurityBelongs(const SecurityChartRow* securityChartRow) const override {return false;}

	virtual bool SecurityPotentiallyBelongs(const Security* security) const override;
	virtual unsigned char isPotentialFilterSame(const TakionFilter& filter) const override;//0 - same; 1 - to add; 2 - to remove; 3 - to add and remove
	virtual bool isFilterSame(const TakionFilter& filter) const override;

	virtual void Reset() override;

	bool OptionBelongs(const Security* option) const;
//	bool OptionRowBelongs(const OptionRow* optionRow) const;
/*
	const unsigned char& GetCallPutFilter() const{return m_callPutFilter;}
	void SetCallPutFilter(const unsigned char& filter){m_callPutFilter = filter;}

protected:
	unsigned char m_callPutFilter;
*/
};

class TGUI_API BaseDialogOptionSorterFilter : public BaseDialogMarketSorterFilter
{
public:
	void Display(const TakionFilter& filter, TakionTool* receipient, unsigned int code, CWnd* parent, int x, int y);
	virtual bool isFilterChanged() const override;
	virtual bool isFilterValid() const override;
	virtual bool isFilterEmpty() const override;
	virtual void SetFilterEmpty() override;
	unsigned short GetInTheMoneyCount() const;
	unsigned short GetOutTheMoneyCount() const;
	static const unsigned __int64 suffixFilterAll;

	void UpdateMyFields(BaseOptionSorterFilter& other) const;
	virtual void UpdateSymbolFilterOfOtherKind(SymbolFilter& other) const override
	{
		BaseDialogMarketSorterFilter::UpdateSymbolFilterOfOtherKind(other);
		if(other.isBaseOptionSorterFilter())UpdateMyFields((BaseOptionSorterFilter&)other);
	}
	bool MyFieldsIntersectionDifferent(const BaseOptionSorterFilter& other, unsigned int doNotCopyFlags) const;
	virtual bool isSymbolFilterOfOtherKindIntersectionDifferent(const SymbolFilter& other, unsigned int doNotCopyFlags) const override
	{
		return BaseDialogMarketSorterFilter::isSymbolFilterOfOtherKindIntersectionDifferent(other, doNotCopyFlags) || other.isBaseOptionSorterFilter() && MyFieldsIntersectionDifferent((const BaseOptionSorterFilter&)other, doNotCopyFlags);
	}

	void MyFieldsToControls(const BaseOptionSorterFilter& other, unsigned int doNotCopyFlags);
	virtual void CopySymbolFilterOfOtherKindToControls(const SymbolFilter& other, unsigned int doNotCopyFlags) override
	{
		BaseDialogMarketSorterFilter::CopySymbolFilterOfOtherKindToControls(other, doNotCopyFlags);
		if(other.isBaseOptionSorterFilter())MyFieldsToControls((const BaseOptionSorterFilter&)other, doNotCopyFlags);
	}
protected:
	BaseDialogOptionSorterFilter(TakionMainWnd* mainWnd, bool toDestroyOnFocus = false, TakionFrame* receipient = NULL, CWnd* parent = NULL);
	virtual void DoDataExchange(CDataExchange* pDX);
//	virtual void Apply();
	virtual BOOL OnInitDialog();
	virtual void BeforeShow() override;
	virtual void UpdateFilterValues() override;
//	virtual bool EnableToolTips(bool enable) override;
	virtual void ToolTipsEnabled(bool enable) override;

	CheckBoxOwnerDraw m_CheckBoxInMoney;
	UnsignedNumberTypeSpin<unsigned short> m_SpinInMoney;

	CheckBoxOwnerDraw m_CheckBoxOutMoney;
	UnsignedNumberTypeSpin<unsigned short> m_SpinOutMoney;

	RangeGroup<unsigned short> m_expirationDays;
	RangeGroup<unsigned int> m_openInterest;


//	CStatic m_StaticSuffix;
	ListBoxFilterString<unsigned __int64, ('9' - '0') + ('Z' - 'A') + 3> m_ListBoxSuffix;

	CStatic m_StaticExpirationType;
	ListBoxFilterString<unsigned char, OET_Count> m_ListBoxExpirationType;

	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);

	afx_msg void OnUseInMoney();
	afx_msg void OnUseOutMoney();
	afx_msg void OnUseExpirationDays();
	afx_msg void OnUseOpenInterest();
	afx_msg LRESULT OnSpinChange(WPARAM w, LPARAM l);
	afx_msg LRESULT OnListBoxChecked(WPARAM w, LPARAM l);

	DECLARE_MESSAGE_MAP()
	virtual void NamedFilterSelChange(const SymbolFilter* oldFilter, const SymbolFilter* newFilter, COLORREF intersectionColor, CBrush* intersectionBrush, COLORREF regularColor, int intersectionDeflation, int regularDeflation) override;
};

class TGUI_API DialogOptionSorterFilter : public BaseDialogOptionSorterFilter
{
public:
	DialogOptionSorterFilter(TakionMainWnd* mainWnd, bool toDestroyOnFocus = false, TakionFrame* receipient = NULL, CWnd* parent = NULL);
//	void Display(const TakionFilter& filter, TakionFrame* receipient, unsigned int code, CWnd* parent, int x, int y);
	virtual bool isFilterChanged() const override;
	virtual bool isFilterValid() const override;
	virtual bool isFilterEmpty() const override;
	virtual void SetFilterEmpty() override;

	void UpdateMyFields(OptionSorterFilter& other) const;
	virtual void UpdateSymbolFilterOfOtherKind(SymbolFilter& other) const override
	{
		BaseDialogOptionSorterFilter::UpdateSymbolFilterOfOtherKind(other);
		if(other.isOptionSorterFilter())UpdateMyFields((OptionSorterFilter&)other);
	}
	bool MyFieldsIntersectionDifferent(const OptionSorterFilter& other, unsigned int doNotCopyFlags) const;
	virtual bool isSymbolFilterOfOtherKindIntersectionDifferent(const SymbolFilter& other, unsigned int doNotCopyFlags) const override
	{
		return BaseDialogOptionSorterFilter::isSymbolFilterOfOtherKindIntersectionDifferent(other, doNotCopyFlags) || other.isOptionSorterFilter() && MyFieldsIntersectionDifferent((const OptionSorterFilter&)other, doNotCopyFlags);
	}

	void MyFieldsToControls(const OptionSorterFilter& other, unsigned int doNotCopyFlags);
	virtual void CopySymbolFilterOfOtherKindToControls(const SymbolFilter& other, unsigned int doNotCopyFlags) override
	{
		BaseDialogOptionSorterFilter::CopySymbolFilterOfOtherKindToControls(other, doNotCopyFlags);
		if(other.isOptionSorterFilter())MyFieldsToControls((const OptionSorterFilter&)other, doNotCopyFlags);
	}
protected:
	virtual void DoDataExchange(CDataExchange* pDX);
	virtual BOOL OnInitDialog();
	virtual void BeforeShow() override;
	virtual void UpdateFilterValues() override;
//	virtual bool EnableToolTips(bool enable) override;
	virtual void ToolTipsEnabled(bool enable) override;

	CStatic m_StaticCallPut;
	ListBoxFilterString<unsigned char, OCPF_Count> m_ListBoxCallPut;

	afx_msg LRESULT OnListBoxChecked(WPARAM w, LPARAM l);

	DECLARE_MESSAGE_MAP()
	virtual void NamedFilterSelChange(const SymbolFilter* oldFilter, const SymbolFilter* newFilter, COLORREF intersectionColor, CBrush* intersectionBrush, COLORREF regularColor, int intersectionDeflation, int regularDeflation) override;
};

class TGUI_API DialogOptionChainFilter : public BaseDialogOptionSorterFilter
{
public:
	DialogOptionChainFilter(TakionMainWnd* mainWnd, bool toDestroyOnFocus = false, TakionFrame* receipient = NULL, CWnd* parent = NULL);
//	void Display(const TakionFilter& filter, TakionFrame* receipient, unsigned int code, CWnd* parent, int x, int y);
/*
	virtual bool isFilterChanged() const;
	virtual bool isFilterValid() const;
protected:
	virtual void DoDataExchange(CDataExchange* pDX);
	virtual BOOL OnInitDialog();
	virtual void BeforeShow();
	virtual void UpdateFilterValues();
	DECLARE_MESSAGE_MAP()
*/
/*
	ListBoxFilterString<unsigned char, OCPF_Count> m_ListBoxCallPut;

	afx_msg LRESULT OnListBoxChecked(WPARAM w, LPARAM l);

*/
};

class TGUI_API OptionBaseWindow : public RowWindowSortableAccount//, public Observer
{
public:
	virtual COLORREF GetBkColor() const override;
	unsigned int GetNextMenuId() const;
//	virtual RowSortable* SelectRow(const Security* surity){return NULL;}
	virtual RowSortable* SelectSecurity(const Security* security){return NULL;}

	void UpdateOptionColors();
	void DoUpdateOptionColors();
	void RemoveOptionColors();

	virtual const VectorSetting<UIntSetting>& GetColors() const = 0;//takionConfig->m_optionChainColors;
	virtual bool isColorRecycle() const = 0;

	const bool& isUseInOutMoneyColors() const{return m_useInOutMoneyColors;}
	const COLORREF& GetDayHighColor() const{return m_dayHighColor;}
	const COLORREF& GetDayLowColor() const{return m_dayLowColor;}

	const bool& isSnapshotsOnly() const{return m_snapshotsOnly;}
	virtual bool CanBeSnapshotsOnly() const{return true;}

	virtual bool isSortedByUnderlier() const{return false;}
	virtual bool areUnderlierColumnsUsed() const{return true;}
	const bool& isUnderlierColumnsUsed() const{return m_underlierColumnsUsed;}
	void SetUseExpColors(bool use);
	void SetUseInOutMoneyColors(bool use);
	virtual void InvalidateInOutMoneyColumns() const{}

	void ToggleExpirationTypeFlag(const unsigned char& flag);

	virtual unsigned __int64 GetSuffixFilter() const{return 0;}
	virtual void SetSuffixFilter(const unsigned __int64& suffixFilter){}
	virtual unsigned char GetExpirationTypeFilter() const{return 0;}
	virtual void SetExpirationTypeFilter(unsigned char expirationTypeFilter){}

	virtual bool isUseInOutMoney() const{return false;}
//	virtual void ClearAll(){DestroyRows();}
	virtual void MarketSorterCleanup();

	virtual void CurrentAccountLoaded() override;
	virtual void CurrentAccountConstraintsLoaded() override;
	virtual void AllAccountsDeleted() override;

	virtual bool UpdateDataGraphicsColorsCustom(const GraphicsColorCollection* colorCollection) override;
	virtual bool UpdateDataGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL) override;
	void UpdateDataColors(bool dataColorChanged, bool resizorColorChanged);

	virtual void AppendWindowMenuInfo(std::string& menuText) const override;

	virtual bool CanLink() const override{return true;}
	virtual bool CanFilterBySymbol() const override{return false;}//true;}//false;}
	virtual void OnUnlink() override;
	virtual void SetEquitySymbol(const char* symbol, unsigned char basket, bool force, bool addToStockChain) override;
	virtual void SetEquityNumericSymbol(const unsigned __int64& symbol, unsigned char basket, bool force, bool addToStockChain) override{SetEquitySymbol((const char*)&symbol, basket, force, addToStockChain);}
	virtual bool HasVolumeColumns() const override{return true;}
	virtual bool CanPopulateSelectedIntoActiveCommandWindow() const{return true;}
	virtual bool isContentsChangeOnAccountChange() const override{return false;}

	virtual void fromScratch() override;
	virtual void toString(std::string& str, unsigned int contentModifier) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual void FilterToString(std::string& str) const{}

	virtual void SetAccount(const Account* account) override;

	const std::string& GetUnderlierSymbol() const{return m_underlierSymbol;}
//	Underlier* GetUnderlier(){return m_underlier;}
	const Underlier* GetUnderlier() const{return m_underlier;}
//	Security* GetSecurity(){return m_security;}
	virtual const Security* GetSecurity() const override{return m_security;}

	bool SubscribeToUnderlier(const char* symbol);
//	virtual Underlier* ObtainUnderlier(const char* symbol, bool subscribe) const{return NULL;}
//	virtual void ReleaseUnderlier(const Underlier* underlier) const{}

	const Price& GetStrikePriceFixed() const{return m_strikePriceFixed;}
	const COLORREF& GetColorInTheMoney() const{return m_colorInTheMoney;}
	const COLORREF& GetColorOutOfTheMoney() const{return m_colorOutOfTheMoney;}
	const COLORREF& GetBkColorInTheMoney() const{return m_colorBkInTheMoney;}
	const COLORREF& GetBkColorOutOfTheMoney() const{return m_colorBkOutOfTheMoney;}

	void SubscribeSelected();
	void UnsubscribeSelected();
	void ResubscribeSelected();
	const unsigned short& GetTimeFrame() const{return m_timeFrame;}

	const unsigned int& GetUnderlierLastPrint() const{return m_underlierLastPrint;}
//	const unsigned int& GetUnderlierMidPoint() const{return m_underlierMidPoint;}
	virtual void RepaintUnderlierValues(){}
	virtual void AppendTitleStrategy(std::string& str, const char* const& prefix = NULL) const{}
	virtual bool isFilteringEnabled() const{return true;}
	virtual bool isBasketEnabled() const{return true;}
	virtual bool isOptionChain() const{return false;}
	virtual void OnMouseForcedReleaseCapture() override{RowWindowSortableAccount::OnMouseForcedReleaseCapture();}

protected:
	OptionBaseWindow(const CBitmap* bitmap,
		unsigned int workspace,
		bool pinned = false,
		int minVisibleSize = 15,
		int minWidth = 20,
		int maxWidth = 0,
		int minHeight = 20,
		int maxHeight = 0,
		int minBorderWidth = 2,
		int maxBorderWidth = 2,
		const char* className = "TakionTool",
		int minTitleHeight = 0,
		int maxTitleHeight = 15,
		int titleHeight = 15,
		bool topResizor = true);

//	virtual bool DoSubscribeToUnderlier(){return false;}
	virtual bool DoSubscribeToUnderlier(bool resubscribe);

	virtual void NextDayStarted() override;

	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;
//	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
//	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
//	DECLARE_MESSAGE_MAP()

	virtual void BeforeDestroy() override;
	virtual bool DoUpdateColumnUse(const UseChangeSet& use, const UseChangeSet& unuse
#ifdef SECONDARY_ROWS
		, bool secondary
#endif
		) override;
	void UpdateUnderlierColumnsUsed();

	virtual void OnLevel1Updated() override;
	virtual void OnLevel2Updated() override;
	void UpdateLevel1Values();
	void NullifyLevel1Values();
	void UpdateUnderlierValues();

	void SetEntitledToOptionData(const bool entitled);

	unsigned int m_underlierLastPrint;
//	unsigned int m_underlierMidPoint;

	virtual void OnSuccessfulCreate() override;

	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;

	virtual void AccountChanged() override;

	virtual void AcceptText(const char* text, unsigned int code) override;

	virtual void FilterFromString(const char*& cursor, const unsigned __int64& version, bool clone, unsigned int contentModifier){}

	virtual bool ProcessKeyDown(unsigned char key, unsigned char modifier, bool repeat, TakionFrame* fromWindow) override;

	void UpdateStrikeOrdinal(bool force);
	virtual void OnUpdateStrikeOrdinal(){}

	virtual void UpdateStrikeOrdinalRows(){}

	virtual bool UpdateOptionPairMap(){return false;}//used only in OptionChainWindow

	virtual void UpdateAccountInfo();

	virtual void AddMenuItems(CMenu& menu) override;
	virtual void AddAdditionalFilterMenuItems(CMenu& popupMenu){}
	virtual void AddRowPropertiesMenuItems(CMenu& popupMenu) override;

	virtual void Populate();

	void ClearAndRepopulate();

	virtual void UnderlierRefreshed();
	void UpdateUnderlierSuffixes();

	virtual void DoUpdateTitle() override;

	unsigned __int64 m_allSuffixFlags;
	typedef std::map<char, unsigned __int64> SuffixMap;
	SuffixMap m_suffixMap;
	SuffixMap::const_iterator m_suffixMapEnd;

	bool SetOptionDataConnected(const bool connected);
	void SetOptionDataLoaded(const bool loaded);
	void SetOptionSubscriptionFailed(const bool failed);

	bool m_optionDataConnected;
	bool m_entitledToOptionData;
	bool m_optionDataLoaded;
	bool m_subscriptionFailed;

	bool m_useExpColors;
	bool m_useInOutMoneyColors;

	bool m_selectedActive;

	bool m_underlierColumnsUsed;

	bool m_snapshotsOnly;
	void SetSnapshotsOnly(bool snapshotsOnly);

	bool SetUnderlier(const Underlier* underlier);
	virtual void AddObserverToUnderlier()
	{
		if(m_underlier)m_underlier->AddObserver(this);
	}
	virtual void UnderlierSet(){}
	virtual void UnderlierSecuritySet(){}
	std::string m_underlierSymbol;
	const Underlier* m_underlier;
	bool SetUnderlierSecurity(const Security* security);
	const Security* m_security;
	bool SetUnderlierPosition(const Position* position);
	const Position* m_underlierPosition;

	Price m_strikePriceFixed;

	COLORREF m_colorDisconnected;
	COLORREF m_colorNoEntitlement;
	COLORREF m_colorNotLoaded;
	COLORREF m_colorSubscriptionFailed;

	COLORREF m_dayHighColor;
	COLORREF m_dayLowColor;

	COLORREF m_colorLevel1Resizor;
	COLORREF m_colorInTheMoney;
	COLORREF m_colorOutOfTheMoney;
	COLORREF m_colorBkInTheMoney;
	COLORREF m_colorBkOutOfTheMoney;
	COLORREF m_colorThermographRed;
	COLORREF m_colorThermographGreen;

	unsigned short m_timeFrame;
};

class TGUI_API OptionWindow : public OptionBaseWindow//, public Observer
{
public:
	virtual const char* GetToolId() const override{return toolOptionId;}
	virtual ~OptionWindow();

//	virtual RowSortable* SelectRow(const Security* security) override{return SelectRowByObject(security);}
	virtual RowSortable* SelectSecurity(const Security* security) override{return SelectRowByObject(security);}
	virtual const VectorSetting<UIntSetting>& GetColors() const override;
	virtual bool isColorRecycle() const override;
	virtual void InvalidateInOutMoneyColumns() const override
	{
		if(m_hWnd)
		{
			InvalidateDataAtColumn(OP_BID);
			InvalidateDataAtColumn(OP_ASK);
		}
	}
	virtual unsigned __int64 GetSuffixFilter() const override{return m_filter.GetSuffixFilter();}
	virtual void SetSuffixFilter(const unsigned __int64& suffixFilter) override{m_filter.SetSuffixFilter(suffixFilter);}
	virtual unsigned char GetExpirationTypeFilter() const override{return m_filter.GetExpirationTypeFilter();}
	virtual void SetExpirationTypeFilter(unsigned char expirationTypeFilter) override{m_filter.SetExpirationTypeFilter(expirationTypeFilter);}
	virtual bool isUseInOutMoney() const override{return m_filter.isUseInOutMoney();}

	virtual void DestroyRows() override;
//	virtual COLORREF GetBkColor() const override;

	virtual bool isTickable() const override{return true;}
//	virtual void AllAccountsDeleted() override;
	enum ColumnId : unsigned short
	{
		OP_SYMBOL,
		OP_CALL_PUT,
		OP_STRIKE_PRICE,
		OP_EXPIRATION_DATE,
//		OP_EXCHANGE,
		OP_BID,
		OP_ASK,
		OP_SPREAD,
		OP_CLOSE_PRICE,
		OP_TODAYS_CLOSE_PRICE,
		OP_OPEN_PRICE,
		OP_DAY_HIGH_PRICE,
		OP_DAY_LOW_PRICE,
		OP_DAY_RANGE,
		OP_DAY_VOLUME,
		OP_DELTA,
		OP_OPEN_INTEREST,
		OP_IMPLIED_VOLATILITY,

		OP_DAY_NET_CHANGE,
		OP_DAY_NET_PERCENT_CHANGE,
		OP_YESTERDAY_VOLUME,
		OP_LAST_TRADE,
		OP_LAST_PRINT_TIME,
		OP_LAST_PRINT_SIZE,
		OP_DAY_FIRST_PRICE,
		OP_DAY_RANGE_PERCENT,
		OP_DAY_VWAP,
		OP_BID_NET_CHANGE,
		OP_ASK_NET_CHANGE,
		OP_DAY_LAST_PRICE_IN_RANGE,
		OP_EXT_RANGE,
		OP_L1_BID_SIZE,
		OP_L1_ASK_SIZE,
		OP_NITE_CHANGE,
		OP_NITE_PERCENT_CHANGE,
		OP_OPEN_CHANGE,
		OP_OPEN_PERCENT_CHANGE,

		OP_POS_SIZE,
		OP_POS_ORDERS,
		OP_POS_LONG_ORDERS,
		OP_POS_SHORT_ORDERS,
		OP_POS_OPNL_L1,
		OP_POS_OPNL_PRINT,
		OP_POS_PNL_CLOSED,
		OP_POS_INVESTMENT,
		OP_POS_MPNL_L1,
		OP_POS_SHARES_TRADED,
		OP_POS_TICKET_AVERAGE,
		OP_POS_MARKED_TICKET_AVERAGE,
		OP_POS_GPS_L1,
		OP_POS_GPS_PRINT,
		OP_POS_BP_USED,
		OP_POS_INVESTMENT_COST,
		OP_LAST_NBBO_TRADE,
		OP_POS_OPNL_NBBO_PRINT,

		OP_THERMOGRAPH_PRINTS,
		OP_THERMOGRAPH_QUOTES,
		OP_BID_TICK,

		OP_L1_DELAY,

		OP_SUFFIX,
		OP_EXPIRATION_TYPE,

		OP_SUBSCRIBED,

		OP_EXPIRATION_DAYS,

		OP_IN_MONEY_ORDINAL,
		OP_OUT_MONEY_ORDINAL,
		OP_EXPIRATION_ORDINAL,

		OP_POS_MPNL_NBBO_PRINT,
		OP_POS_MARKED_TICKET_AVERAGE_HI,
		OP_POS_MARKED_TICKET_AVERAGE_LO,

		OP_CONTRACT_SIZE,
		OP_TIER_SIZE,

		OP_FROM_HIGH,
		OP_FROM_HIGH_PERCENT,

		OP_FROM_LOW,
		OP_FROM_LOW_PERCENT,

		OP_POS_CONTRACTS_TRADED,

		OP_POS_OPNL_L1_COST,
		OP_POS_OPNL_PRINT_COST,

		OP_LEVEL2_INVALID,

		OP_TCLOSE_NET,
		OP_TCLOSE_PERCENT_NET,

		OP_INTRINSIC,
		OP_TIME_VALUE,

		OP_LAST_TRADE_TICK,

		OP_CUSTOM_PRICE_BASE,

		OP_EXPIRATION_DAY_OF_WEEK,

		OP_TIER_COST,
		OP_CUSTOM_DATE,
		OP_IRR,
		OP_POS_ME_USED,

#ifdef _DEBUG
		OP_REF,
#endif
		OP_COLUMN_COUNT
	};
//	void UpdateAlignTitleValues();
//	void UpdateTitleValueCollection();
/*
	void UpdateOptionColors();
	void DoUpdateOptionColors();
	void RemoveOptionColors();
*/
	virtual unsigned short GetBuiltInColumnCount() const override{return OP_COLUMN_COUNT;}
//	virtual unsigned short GetAdditionalColumnCount() const;
//	virtual void toString(std::string& str, unsigned int contentModifier) const override;
//	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
//	virtual void fromScratch() override;
	virtual void FilterToString(std::string& str) const override{m_filter.toString(str);}

	virtual bool isSortedByUnderlier() const override;
	virtual bool areUnderlierColumnsUsed() const override;
	virtual void RepaintUnderlierValues() override;

	virtual void AddToSpecificToolCollection() override;
	virtual void UpdateGraphics() override;

	virtual void UpdateDataGraphics(const Graphics* graphics) override;
//	virtual bool UpdateDataGraphicsColorsCustom(const GraphicsColorCollection* colorCollection) override;
//	virtual bool UpdateDataGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL) override;
//	void UpdateDataColors(bool dataColorChanged, bool resizorColorChanged);

//	virtual void MarketSorterCleanup();
//	virtual const TakionFilter* GetFilter() const{return &m_filter;}

	virtual void SelectPositionRows(unsigned int filter) override;//PositionStatus

	virtual void ApplyPriceValue(unsigned int code, RowSortableSet& rowSet, unsigned short numberColumnId, const Price& value) override;;

	virtual bool CanDragClient(UINT nFlags, CPoint point) const override;

	virtual Row* CreateRow(const void* object, bool potential) override;

	typedef void (OptionRow::*FnPaintInfo)(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	typedef short (OptionRow::*FnCompare)(const OptionRow& other) const;

	bool AddOptionFunctions(unsigned short id, FnPaintInfo fnPaint, FnCompare fnCompare, FnCompare fnCompareAhead);

	inline const FnPaintInfo& GetFnPaintInfo(const unsigned short& id) const{return id < OP_COLUMN_COUNT ? m_paintInfoFunction[id] : NULL;}
	inline const FnCompare& GetFnCompare(const unsigned short& id) const{return id < OP_COLUMN_COUNT ? m_compareFunction[id] : NULL;}
	inline const FnCompare& GetFnCompareAhead(const unsigned short& id) const{return id < OP_COLUMN_COUNT ? m_compareAheadFunction[id] : NULL;}

//	virtual void CopySelectedStocksToClipboard() const;
//	virtual void CopyAllStocksToClipboard() const;
//	virtual void StockToString(std::string& info, const Row* row) const;

	virtual unsigned short GetSymbolColumn() const override{return OP_SYMBOL;}

/*
	virtual bool PasteStocksFromClipboard(bool replace);
	virtual void RemoveSelectedStocks();
*/
/*
	void AddAccountFilter(unsigned int filter);
	void RemoveAccountFilter(unsigned int filter);
	void SwitchAccountFilter(AccountStatus accountFilter); 

	unsigned int GetAccountFilter() const{return m_accountFilter;}
	bool SetAccountFilter(unsigned int accountFilter, unsigned int& addFilter);
*/
	virtual bool HasMillisecondColumns() const override{return true;}
//	virtual bool HasVolumeColumns() const override{return true;}

//	bool SecurityBelongs(const SecurityChartRow* securityChartRow) const;
	bool SecurityBelongs(const Security* security) const;
	bool SecurityPotentiallyBelongs(const Security* security) const;
	virtual bool StockPotentiallyBelongs(const Security* security) const{return false;}

	virtual bool ObjectPotentiallyBelongs(const void* object) const override;//no need to call inside lock
	virtual bool RowFiltersIn(const RowSortable* row) const override;//should be called inside lock
	virtual unsigned char RowBelongs(const RowSortable* row) const override;//should be called inside lock
	virtual unsigned char ExistingRowBelongs(const RowSortable* row) const override;//should be called inside lock
	bool RowInOutMoneyBelongs(const OptionRow* row) const;

//	virtual void ApplyFilter(const TakionFilter& filter) override;

	bool isSortThermograhPrintByTotal() const{return m_filter.isSortPrintsByActivity();}//m_sortThermograhPrintByTotal;}
	bool isSortThermograhQuoteByTotal() const{return m_filter.isSortQuotesByActivity();}//m_sortThermograhQuoteByTotal;}

	virtual void UpdateTitleGraphics(const Graphics* graphics) override;

	virtual const char* GetSettingsTabPath(const CPoint& point) const override;
	virtual const void* GetGraphicsTabInitInfo(const CPoint& point) const override;

//	virtual void AcceptText(const char* text, unsigned int code);
//	void SelectSymbol(const char* symbol);

//	virtual void AddSymbol(const char* symbol);
	virtual bool CanClearSymbols() const override;
	virtual void ClearSymbols() override;

//	virtual void SetAccount(const Account* account);

//	const COLORREF& GetWarningColor() const{return m_warningColor;}
//	const COLORREF& GetTopActiveColor() const{return m_topActiveColor;}

//	const COLORREF& GetDayHighColor() const{return m_dayHighColor;}
//	const COLORREF& GetDayLowColor() const{return m_dayLowColor;}
/*
	static const unsigned int maxHiLoFlashSecond = 5;
	unsigned int GetHiLoFlashSecond() const{return m_hiLoFlashSecond;};
	void SetHiLoFlashSecond(unsigned int second);
	void AddHiLoFlashRow(OptionRow* row);
	void RemoveHiLoFlashRow(OptionRow* row);

	unsigned int GetDayHiLoFlashSecond() const{return m_dayHiLoFlashSecond;};
	void SetDayHiLoFlashSecond(unsigned int second);
	void AddDayHiLoFlashRow(MarketSorterRow* row);
	void RemoveDayHiLoFlashRow(MarketSorterRow* row);

	void CurrentSecondChanged(unsigned int currentSecond);

	typedef std::set<MarketSorterRow*> HiLoSet;
	typedef std::map<unsigned int, HiLoSet> HiLoMap;

	bool isHiLoFlashUseBackground() const{return m_hiLoFlashUseBackground;}
	void SetHiLoFlashUseBackground(bool useBackground);

	bool isHiLoFlashEntireRow() const{return m_hiLoFlashEntireRow;}
	void SetHiLoFlashEntireRow(bool entireRow);
*/
//	virtual bool CanPopulateSelectedIntoActiveCommandWindow() const{return true;}

//	virtual void CurrentAccountLoaded();
//	virtual void CurrentAccountConstraintsLoaded();
	virtual bool HasLastSymbolCommands() const override{return true;}
	virtual bool GetLastSecuritySymbol(std::string& symbol) const override;

	virtual int GetHourRectLeft() const override;

	static const unsigned short thermographSize = 16;
	static const unsigned short thermographDepth = 16;
//	const COLORREF* GetThermographRedColors() const{return m_thermographRedColors;}
//	const COLORREF* GetThermographGreenColors() const{return m_thermographGreenColors;}
	virtual const COLORREF* GetThermographRedColors() const override{return m_thermographRedColors;}
	virtual const COLORREF* GetThermographGreenColors() const override{return m_thermographGreenColors;}

//	virtual void AppendWindowMenuInfo(std::string& menuText) const override;
/*
	const std::string& GetUnderlierSymbol() const{return m_underlierSymbol;}
	Underlier* GetUnderlier(){return m_underlier;}
	const Underlier* GetUnderlier() const{return m_underlier;}
//	Security* GetSecurity(){return m_security;}
	virtual const Security* GetSecurity() const override{return m_security;}

	const Price& GetStrikePriceFixed() const{return m_strikePriceFixed;}
	COLORREF GetColorInTheMoney() const{return m_colorInTheMoney;}
	COLORREF GetColorOutOfTheMoney() const{return m_colorOutOfTheMoney;}
	COLORREF GetBkColorInTheMoney() const{return m_colorBkInTheMoney;}
	COLORREF GetBkColorOutOfTheMoney() const{return m_colorBkOutOfTheMoney;}
*/
//	void ToggleExpirationTypeFlag(const unsigned char& flag);
	void ToggleCallPutFlag(const unsigned char& flag);
//	void SetUseExpColors(bool use);
//	void SetUseInOutMoneyColors(bool use);
//	void SetIndexOption(bool indexOption);
//	const bool& isIndexOption() const{return m_indexOption;}

//	void SubscribeSelected();
//	virtual bool isContentsChangeOnAccountChange() const{return false;}

	virtual bool hasInventoryView() const override{return true;}

	virtual SymbolFilter* GetFilterCopy() const override;
	virtual unsigned char GetNativeFilterType() const override{return m_filter.isA();}
	virtual const TakionFilter* GetFilter() const override{return &m_filter;}
protected:
	OptionWindow(const CBitmap* bitmap,
		unsigned int workspace,
		bool pinned = false,
		int minVisibleSize = 15,
		int minWidth = 20,
		int maxWidth = 0,
		int minHeight = 20,
		int maxHeight = 0,
		int minBorderWidth = 2,
		int maxBorderWidth = 2,
		const char* className = "TakionTool",
		int minTitleHeight = 0,
		int maxTitleHeight = 15,
		int titleHeight = 15,
		bool topResizor = true);

	virtual void FilterFromString(const char*& cursor, const unsigned __int64& version, bool clone, unsigned int contentModifier) override
	{
		OptionSorterFilter filter(m_filter);
		filter.fromString(cursor, version, clone, contentModifier);
//		m_filter.Copy(filter);
		ApplyFilter(filter, true);
	}

	virtual void OnSuccessfulCreate() override;

	virtual void DisplayClientMenu(UINT nFlags, CPoint point) override;

	virtual bool UpdateHistoryLoadBkColor() override;
//	virtual void UpdateCurrentAccount();

//	void ClearAndRepopulate();

	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;
//	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
//	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
//	DECLARE_MESSAGE_MAP()

	virtual void Notify(const Message* message, const Observable* from, const Message* info = NULL) override;
	virtual void SecurityDoubleClicked(UINT nFlags, const CPoint& point) override;
//	virtual void RowLeftClicked(Row* row, size_t ord, const CPoint& point);
/*
	OptionWindow(const CBitmap* bitmap,
		unsigned int workspace,
		bool pinned = false,
		unsigned short builtInColumns = OP_COLUMN_COUNT,
		int minVisibleSize = 15,
		int minWidth = 20,
		int maxWidth = 0,
		int minHeight = 20,
		int maxHeight = 0,
		int minBorderWidth = 2,
		int maxBorderWidth = 2,
		const char* className = "TakionTool",
		int minTitleHeight = 0,
		int maxTitleHeight = 15,
		int titleHeight = 15);
*/
//	virtual void PasteStocksFromString(const char* cursor, size_t size, bool replace);
/*
	COLORREF m_colorLevel1Resizor;
	COLORREF m_colorInTheMoney;
	COLORREF m_colorOutOfTheMoney;
	COLORREF m_colorBkInTheMoney;
	COLORREF m_colorBkOutOfTheMoney;
	COLORREF m_colorThermographRed;
	COLORREF m_colorThermographGreen;
*/
	COLORREF m_thermographRedColors[thermographSize];
	COLORREF m_thermographGreenColors[thermographSize];

	virtual RowTotal* CreateRowTotal() override;
	virtual OptionRowTotal* DoCreateRowTotal();
	virtual void LineSelected() override;
	virtual void BeforeDestroy() override;
//	virtual void AccountChanged() override;

	virtual void AddAdditionalFilterMenuItems(CMenu& popupMenu) override;
//	virtual void AddMenuItems(CMenu& menu) override;

	virtual void PostAddMenuItems(CMenu& menu) override;
//	virtual void AddRowPropertiesMenuItems(CMenu& popupMenu) override;
	virtual void PostAddRowPropertiesMenuItems(CMenu& popupMenu) override;
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;

//	virtual void Populate();//{}//bool remove);//, unsigned int addPositionFilter);

	virtual void DoPaintTitle(const RECT& interRect, CDC& dc) override;
	virtual void UpdateTitleRects() override;
	virtual void OnTitleResize() override;
	virtual void SizeHorizontal(int cx, int cy, int oldX, int oldY) override;

	virtual void Repopulate() override;

	virtual void RowInserted(RowSortable* row) override;
	virtual void RowRemoved(RowSortable* row) override;

//	virtual bool ProcessKeyDown(unsigned char key, unsigned char modifier, bool repeat, TakionFrame* fromWindow) override;
/*
	void UnderlierRefreshed();
	void UpdateUnderlierSuffixes();
	unsigned __int64 m_allSuffixFlags;
	typedef std::map<char, unsigned __int64> SuffixMap;
	SuffixMap m_suffixMap;
	SuffixMap::const_iterator m_suffixMapEnd;
*/
	virtual void UpdateAccountInfo() override;
	void UpdatePositionValues(RowSortable* row);
	void RepaintPositionValues() const;

	FnPaintInfo m_paintInfoFunction[OP_COLUMN_COUNT];
	FnCompare m_compareFunction[OP_COLUMN_COUNT];
	FnCompare m_compareAheadFunction[OP_COLUMN_COUNT];
/*
	bool SetOptionDataConnected(const bool connected);
	void SetOptionDataLoaded(const bool loaded);
	void SetOptionSubscriptionFailed(const bool failed);

	bool m_optionDataConnected;
	bool m_entitledToOptionData;
	bool m_optionDataLoaded;
	bool m_subscriptionFailed;
*/
/*
	COLORREF m_colorDisconnected;
	COLORREF m_colorNoEntitlement;
	COLORREF m_colorNotLoaded;
	COLORREF m_colorSubscriptionFailed;

	COLORREF m_dayHighColor;
	COLORREF m_dayLowColor;
*/
//	COLORREF m_topActiveColor;
//	COLORREF m_warningColor;

//	bool m_selectedActive;

	virtual void ActiveSymbolAboutToChange(const unsigned __int64& newActiveSymbol
		,const unsigned __int64& newActiveOptionBlock
		);
	virtual bool ActiveSymbolChanged();
	OptionRow* m_prevTopRow;
	OptionRow* m_nextTopRow;
/*

	void ClearHiLoMap();
	unsigned int m_hiLoFlashSecond;
	HiLoMap m_hiLoMap;

	void ClearDayHiLoMap();
	unsigned int m_dayHiLoFlashSecond;
	HiLoMap m_dayHiLoMap;

	bool m_hiLoFlashUseBackground;
	bool m_hiLoFlashEntireRow;

	bool m_includeStockActive;
	bool m_excludeStockActive;
*/
	void RepaintInOutMoneyValues() const;
//	void UpdateTitle();
/*
	bool SetUnderlier(Underlier* underlier);
	std::string m_underlierSymbol;
	Underlier* m_underlier;
	bool SetUnderlierSecurity(const Security* security);
	const Security* m_security;
	bool SetUnderlierPosition(const Position* position);
	const Position* m_underlierPosition;
*/
	OptionSorterFilter m_filter;
	virtual void DoApplyFilter(const TakionFilter& filter, bool forceFilterChanged) override;

//	void UpdateStrikeOrdinal(bool force);
	virtual void OnUpdateStrikeOrdinal() override;
	virtual void UpdateStrikeOrdinalRows() override;
//	Price m_strikePriceFixed;

//	bool m_useExpColors;
//	bool m_useInOutMoneyColors;
};

class TGUI_API OptionBaseRow : public RowSortable
{
friend class OptionBaseWindow;
public:
//	const unsigned int& GetExpirationOrdinal() const{return m_expirationOrdinal;}
	virtual COLORREF GetRowBkColor() const override{return m_bkColor;}
	virtual void Subscribe(){}
	virtual void Unsubscribe(){}
	virtual void Resubscribe(){}
	virtual bool Lock(bool wait) const override;
	virtual void Unlock() const override;
	virtual unsigned int GetExpirationOrdinal() const{return 0xFFFFFFFF;}
	virtual void RemoveObservers(){}
protected:
	OptionBaseRow(OptionBaseWindow* parent, bool potential = false);
	virtual void InvalidateOrdinals()
	{
//		m_expirationOrdinal = 0xFFFFFFFF;
	}
	OptionBaseWindow* m_optionBaseWindow;
//	COLORREF m_optionColor;
	COLORREF m_bkColor;
//	unsigned int m_expirationOrdinal;
};

class TGUI_API OptionRow : public OptionBaseRow, public Observer
{
friend class OptionWindow;
public:
	OptionRow(OptionWindow* parent, const Security* security, const Position* position, bool potential = false);
	virtual ~OptionRow();
	virtual const void* GetBaseObject() const override{return m_security;}
	virtual bool GetPaintTextInfo(unsigned short columnId, std::string& text, COLORREF& color) const override;//, UINT& horizontalJustification) const override;
	virtual bool PaintCell(CDC& dc, const Column* column, const CRect& rect, UINT verticalJustification, int horizontalOffset) const override;//, unsigned char horizontalAlignment) const;
	virtual bool CellToString(std::string& info, unsigned short columnId) const override;

	virtual void Subscribe() override;
	virtual void Unsubscribe() override;
	virtual void Resubscribe() override;

	const unsigned int& GetInMoneyOrdinal() const{return m_inMoneyOrdinal;}
	const unsigned int& GetOutMoneyOrdinal() const{return m_outMoneyOrdinal;}

	virtual bool hasInventory() const override{return m_position && m_position->GetInventory() != NULL;}

	virtual COLORREF GetRowColor() const override;
	virtual COLORREF GetCellColor(unsigned short columnId) const override;
	virtual COLORREF GetCellBkColor(unsigned short columnId) const override;

	virtual RowValue* CreateCell(unsigned short id) override;

	virtual bool Lock(bool wait) const override;
//	virtual void LockWait() const override;
	virtual void Unlock() const override;
	virtual bool SetPosition(const Position* position);

	virtual void UpdateAndInvalidate(CRect& rowRect, bool dynamicOnly) override;
	virtual void Update(bool dynamicOnly) override;
	virtual void Initialize() override;//should be called only inside a lock

	virtual bool isSortValueChanged() const override;
	virtual bool isChainSortValueChanged() const override;
/*
	virtual short Compare(const RowSortable& other) const;
	virtual short CompareAhead(const RowSortable& other) const;
	virtual short CompareChain(const RowSortable& other) const;
	virtual short CompareChainAhead(const RowSortable& other) const;
*/
	virtual short DefaultCompare(const RowSortable& other) const override;

	virtual short PreCompare(const RowSortable& other) const override;
	virtual bool CompareFunction(const RowSortable& other, unsigned short sortId, short& ret) const override;
	virtual bool CompareFunctionAhead(const RowSortable& other, unsigned short sortId, short& ret) const override;

	virtual bool UpdateRowColor() override;//should be called only inside a lock
	virtual bool SetSecurity(const Security* security);
	virtual void RemoveObservers() override;
	virtual unsigned int GetExpirationOrdinal() const override{return m_security ? m_security->GetExpirationOrdinal() : 0xFFFFFFFF;}

//	Security* GetSecurity(){return m_security;}
	const Security* const& GetSecurity() const{return m_security;}

	virtual const PositionData* GetRowPosition(const CPoint* point = NULL) const override{return m_position;}
//	Position* GetPosition(){return m_position;}
	const Position* const& GetPosition() const{return m_position;}
	virtual const char* GetRowSecuritySymbol(const CPoint* point = NULL) const override{return m_security ? m_security->GetSymbol() : NULL;}
	virtual const unsigned __int64& GetRowNumericSymbol() const override{return m_security ? m_security->GetNumericSymbol() : uint64Zero;}

	virtual const Security* GetSelectedSecurity() const;

	static const unsigned short thermographLength = 16;

	const Thermograph& GetThermographQuotesGreen() const{return m_thermographQuotesGreen;}
	const Thermograph& GetThermographQuotesRed() const{return m_thermographQuotesRed;}
	const Thermograph& GetThermographPrintsGreen() const{return m_thermographPrintsGreen;}
	const Thermograph& GetThermographPrintsRed() const{return m_thermographPrintsRed;}

	void PaintSymbol(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareSymbol(const OptionRow& other) const;
	void PaintSuffix(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareSuffix(const OptionRow& other) const;
	void PaintCall(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareCall(const OptionRow& other) const;
	void PaintExpiration(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareExpiration(const OptionRow& other) const;
	void PaintExpirationDayOfWeek(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareExpirationDayOfWeek(const OptionRow& other) const;
	void PaintExpirationDays(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareExpirationDays(const OptionRow& other) const;
	void PaintStrike(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareStrike(const OptionRow& other) const;
	void PaintExpirationType(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareExpirationType(const OptionRow& other) const;
	void PaintInMoneyOrdinal(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareInMoneyOrdinal(const OptionRow& other) const;
	void PaintOutMoneyOrdinal(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareOutMoneyOrdinal(const OptionRow& other) const;
	void PaintExpirationOrdinal(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareExpirationOrdinal(const OptionRow& other) const;
//	short CompareSymbol(const OptionRow& other) const;
	short CompareThermographPrints(const OptionRow& other) const;
	short CompareThermographPrintsAhead(const OptionRow& other) const;
	short CompareThermographQuotes(const OptionRow& other) const;
	short CompareThermographQuotesAhead(const OptionRow& other) const;
	void PaintContractSize(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareContractSize(const OptionRow& other) const;

	DECLARE_NED_NEW

	virtual const char* GetStringValue(unsigned short id) const override;
	virtual const unsigned int GetUIntValue(unsigned short id) const override;
	virtual const unsigned __int64 GetUInt64Value(unsigned short id) const override;
	Price GetPriceValue(unsigned short id) const override;

protected:
	virtual void InvalidateOrdinals() override
	{
		OptionBaseRow::InvalidateOrdinals();
		m_inMoneyOrdinal = m_outMoneyOrdinal = 0xFFFFFFFF;
	}
	virtual void Notify(const Message* message, const Observable* from, const Message* info = NULL) override;
	bool UpdatePrints(bool lock);
	OptionWindow* m_optionWindow;
	const Security* m_security;//option
	const Position* m_position;

//	COLORREF m_optionColor;
//	COLORREF m_bkColor;

	Thermograph m_thermographQuotesGreen;
	Thermograph m_thermographQuotesRed;
	Thermograph m_thermographPrintsGreen;
	Thermograph m_thermographPrintsRed;

	int m_quotesThermographValueRed;
	int m_quotesThermographValueGreen;
	int m_printsThermographValueRed;
	int m_printsThermographValueGreen;

	unsigned int m_inMoneyOrdinal;
	unsigned int m_outMoneyOrdinal;
};

class TGUI_API OptionRowTotal : public RowTotal
{
public:
	OptionRowTotal(OptionWindow* window, unsigned short columnCount = OptionWindow::OP_COLUMN_COUNT):
//		RowTotal(columnCount, window),
		RowTotal(columnCount + window->GetAdditionalColumnCount(), window),
		m_size(NULL),
		m_pnlOpenLevel1(NULL),
		m_pnlOpenPrint(NULL),
		m_mpnlNbboPrint(NULL),
		m_ticketAverage(NULL),
		m_markedTicketAverage(NULL),
		m_markedTicketAverageHi(NULL),
		m_markedTicketAverageLo(NULL),
		m_pnlClosed(NULL),
		m_sharesTraded(NULL),
		m_gpsLevel1(NULL),
		m_gpsPrint(NULL)
	{
	}
	void SetSizePtr(UIntRowValue* value){m_size = value;}

	void SetPnlOpenLevel1Ptr(MoneyRowValue* value){m_pnlOpenLevel1 = value;}
	void SetPnlOpenPrintPtr(MoneyRowValue* value){m_pnlOpenPrint = value;}

	void SetMpnlNbboPrintPtr(MoneyRowValue* value){m_mpnlNbboPrint = value;}
//	void SetMpnlNbboPrintHiPtr(MoneyRowValue* value){m_mpnlNbboPrintHi = value;}
//	void SetMpnlNbboPrintLoPtr(MoneyRowValue* value){m_mpnlNbboPrintLo = value;}

	void SetTicketAveragePtr(MoneyRowValue* value){m_ticketAverage = value;}
	void SetMarkedTicketAveragePtr(MoneyRowValue* value){m_markedTicketAverage = value;}
	void SetMarkedTicketAverageHiPtr(MoneyRowValue* value){m_markedTicketAverageHi = value;}
	void SetMarkedTicketAverageLoPtr(MoneyRowValue* value){m_markedTicketAverageLo = value;}
	void SetPnlClosedPtr(MoneyRowValue* value){m_pnlClosed = value;}
	void SetSharesTradedPtr(UIntRowValue* value){m_sharesTraded = value;}

	void SetGpsLevel1Ptr(SignedPriceRowValue* value){m_gpsLevel1 = value;}
	void SetGpsPrintPtr(SignedPriceRowValue* value){m_gpsPrint = value;}

protected:
	virtual void UpdateNonCumulativeValues(const Row* row, bool dynamicOnly);
	virtual void AddNonCumulativeValues(const Row* row);
	virtual void RemoveNonCumulativeValues(const Row* row);
	virtual void ResetNonCumulativeValues();

	void AddNonCumulativeMinMaxValues(const Row* row);

	UIntRowValue* m_size;

	MoneyRowValue* m_pnlOpenLevel1;
	MoneyRowValue* m_pnlOpenPrint;
	MoneyRowValue* m_mpnlNbboPrint;
	MoneyRowValue* m_ticketAverage;
	MoneyRowValue* m_markedTicketAverage;
	MoneyRowValue* m_markedTicketAverageHi;
	MoneyRowValue* m_markedTicketAverageLo;
	MoneyRowValue* m_pnlClosed;
	UIntRowValue* m_sharesTraded;
	SignedPriceRowValue* m_gpsLevel1;
	SignedPriceRowValue* m_gpsPrint;
};

class OptionPair : public OptionKey
{
public:
	OptionPair(const OptionKey& first = OptionKey(), const Security* security1 = NULL, const Security* security2 = NULL):
		OptionKey(first),
		m_security1(security1),
		m_security2(security2),
		m_expirationDays(CalculateExpirationDays()),
		m_expirationTypeChar(CalculateExpirationTypeAsChar()),
		m_expirationDayOfWeek(CalculateExpirationDayOfWeek())
	{
		if(!isCall())
		{
			SetCall(true);
			m_security1 = security2;
			m_security2 = security1;
		}
	}

	OptionPair(const Security* security1, const Security* security2):
		OptionKey(*security1->GetOptionInfo()),
		m_security1(security1),
		m_security2(security2),
		m_expirationDays(CalculateExpirationDays()),
		m_expirationTypeChar(CalculateExpirationTypeAsChar()),
		m_expirationDayOfWeek(CalculateExpirationDayOfWeek())
	{
		if(!isCall())
		{
			SetCall(true);
			m_security1 = security2;
			m_security2 = security1;
		}
	}
	const Security* const& GetSecurity1() const{return m_security1;}
	const Security* const& GetSecurity2() const{return m_security2;}
//	const Security* const& GetSecurityRef1() const{return m_security1;}
//	const Security* const& GetSecurityRef2() const{return m_security2;}
	const Security* const& GetSecurity(bool first) const{return first ? m_security1 : m_security2;}
//	const Security* const& GetSecurityRef(bool first) const{return first ? m_security1 : m_security2;}

	const unsigned int& GetContractSize() const
	{
		return m_security1 ? m_security1->GetContractSize():
			m_security2 ? m_security2->GetContractSize():
			defaultContractSize;
	}

	const unsigned int& GetExpirationOrdinal() const
	{
		return m_security1 ? m_security1->GetExpirationOrdinal():
			m_security2 ? m_security2->GetExpirationOrdinal():
			Security::uintMinusOne;
	}

	const unsigned int& GetExpirationDays() const{return m_expirationDays;}
	const char& GetExpirationTypeChar() const{return m_expirationTypeChar;}
	const unsigned char& GetExpirationDayOfWeek() const{return m_expirationDayOfWeek;}

	unsigned char WhichSecurity(const OptionKey& optionKey) const
	{
		return isEqualExceptCallPut(optionKey) ? optionKey.isCall() ? 1 : 2 : 0;
	}
	unsigned char SetSecurity(const Security* security)
	{
		const OptionKey* optionKey = security->GetOptionInfo();
		if(optionKey && isEqualExceptCallPut(*optionKey))
		{
			if(optionKey->isCall())
			{
				m_security1 = security;
				return 1;
			}
			else
			{
				m_security2 = security;
				return 2;
			}
		}
		return 0;
	}
protected:
	const Security* m_security1;
	const Security* m_security2;
	unsigned int m_expirationDays;
	char m_expirationTypeChar;
	unsigned char m_expirationDayOfWeek;
};

//class OptionPairRow;
class OptionChainRowTotal;

class TGUI_API OptionChartRow2 : public SecurityChartRow
{
public:
	OptionChartRow2(OptionPairRow* row, const Security* security, const Position* position, unsigned short timeFrame, unsigned short timeFrameInSeconds):
		SecurityChartRow(security, position, timeFrame, timeFrameInSeconds),
		m_row(row)
	{
	}
protected:
	virtual void Notify(const Message* message, const Observable* from, const Message* info = NULL) override;
	OptionPairRow* m_row;
};

class TGUI_API OptionChainWindow : public OptionBaseWindow
{
public:
	virtual const char* GetToolId() const override{return toolOptionChainId;}
//	virtual TakionTool* Clone() const;
	virtual ~OptionChainWindow();

//	virtual RowSortable* SelectRow(const Security* security) override{return SelectSecurity(security);}
	virtual RowSortable* SelectSecurity(const Security* security) override;

	virtual const VectorSetting<UIntSetting>& GetColors() const override;
	virtual bool isColorRecycle() const override;

	virtual void InvalidateInOutMoneyColumns() const override
	{
		if(m_hWnd)
		{
			InvalidateDataAtColumn(OC_CALL_BID);
			InvalidateDataAtColumn(OC_CALL_ASK);
			InvalidateDataAtColumn(OC_PUT_BID);
			InvalidateDataAtColumn(OC_PUT_ASK);
		}
	}
	virtual unsigned __int64 GetSuffixFilter() const override{return m_filter.GetSuffixFilter();}
	virtual void SetSuffixFilter(const unsigned __int64& suffixFilter) override{m_filter.SetSuffixFilter(suffixFilter);}
	virtual unsigned char GetExpirationTypeFilter() const override{return m_filter.GetExpirationTypeFilter();}
	virtual void SetExpirationTypeFilter(unsigned char expirationTypeFilter) override{m_filter.SetExpirationTypeFilter(expirationTypeFilter);}
	virtual bool isUseInOutMoney() const override{return m_filter.isUseInOutMoney();}

//	virtual COLORREF GetBkColor() const override;
	enum ColumnId : unsigned short
	{
		OC_CALL_OI_VOLUME,
		OC_CALL_DAY_VOLUME,
		OC_CALL_DELTA,
		OC_CALL_IMPLIED_VOLATILITY,
		OC_CALL_BID,
		OC_CALL_ASK,
		OC_STRIKE_PRICE,
		OC_EXPIRATION_DATE,
		OC_SUFFIX,
		OC_PUT_BID,
		OC_PUT_ASK,
		OC_PUT_IMPLIED_VOLATILITY,
		OC_PUT_DELTA,
		OC_PUT_DAY_VOLUME,
		OC_PUT_OI_VOLUME,
		OC_SYMBOL,
		OC_EXPIRATION_TYPE,
		OC_EXPIRATION_DAYS,
		OC_CALL_IN_MONEY_ORDINAL,
		OC_CALL_OUT_MONEY_ORDINAL,
		OC_PUT_IN_MONEY_ORDINAL,
		OC_PUT_OUT_MONEY_ORDINAL,

		OC_CALL_THERMOGRAPH_PRINTS,
		OC_CALL_THERMOGRAPH_QUOTES,
		OC_PUT_THERMOGRAPH_PRINTS,
		OC_PUT_THERMOGRAPH_QUOTES,

		OC_EXPIRATION_ORDINAL,
		OC_CONTRACT_SIZE,

		OC_CALL_CLOSE_PRICE,
		OC_PUT_CLOSE_PRICE,

		OC_CALL_LAST_TRADE,
		OC_PUT_LAST_TRADE,

		OC_CALL_DAY_NET_CHANGE,
		OC_PUT_DAY_NET_CHANGE,

		OC_CALL_DAY_NET_PERCENT_CHANGE,
		OC_PUT_DAY_NET_PERCENT_CHANGE,

		OC_CALL_OPEN_CHANGE,
		OC_PUT_OPEN_CHANGE,

		OC_CALL_OPEN_PERCENT_CHANGE,
		OC_PUT_OPEN_PERCENT_CHANGE,

		OC_CALL_DAY_HIGH_PRICE,
		OC_PUT_DAY_HIGH_PRICE,

		OC_CALL_DAY_LOW_PRICE,
		OC_PUT_DAY_LOW_PRICE,

		OC_CALL_FROM_HIGH,
		OC_PUT_FROM_HIGH,

		OC_CALL_FROM_HIGH_PERCENT,
		OC_PUT_FROM_HIGH_PERCENT,

		OC_CALL_FROM_LOW,
		OC_PUT_FROM_LOW,

		OC_CALL_FROM_LOW_PERCENT,
		OC_PUT_FROM_LOW_PERCENT,

		OC_CALL_LEVEL2_INVALID,
		OC_PUT_LEVEL2_INVALID,

		OC_CALL_SUBSCRIBED,
		OC_PUT_SUBSCRIBED,

		OC_CALL_INTRINSIC,
		OC_PUT_INTRINSIC,

		OC_CALL_TIME_VALUE,
		OC_PUT_TIME_VALUE,

		OC_CALL_LAST_TRADE_TICK,
		OC_PUT_LAST_TRADE_TICK,

		OC_EXPIRATION_DAY_OF_WEEK,

		OC_COLUMN_COUNT
	};
//	void UpdateAlignTitleValues();
//	void UpdateTitleValueCollection();
/*
	void UpdateOptionColors();
	void DoUpdateOptionColors();
	void RemoveOptionColors();
*/
	virtual unsigned short GetBuiltInColumnCount() const override{return OC_COLUMN_COUNT;}
//	virtual void toString(std::string& str, unsigned int contentModifier) const override;
//	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
//	virtual void fromScratch() override;
	virtual void FilterToString(std::string& str) const override{m_filter.toString(str);}

	virtual bool isSortedByUnderlier() const override;
	virtual bool areUnderlierColumnsUsed() const override;
	virtual void RepaintUnderlierValues() override;

	virtual Row* CreateRow(const void* object, bool potential) override;
//	virtual void SetAccount(const Account* account) override;

//	virtual bool HasVolumeColumns() const override{return true;}

//	virtual bool CanLink() const override{return true;}
//	virtual bool CanFilterBySymbol() const override{return false;}//true;}//false;}
//	virtual void OnUnlink() override;
//	virtual void SetEquityNumericSymbol(const unsigned __int64& symbol, unsigned char basket, bool force, bool addToStockChain) override{SetEquitySymbol((const char*)&symbol, basket, force, addToStockChain);}
//	virtual void SetEquitySymbol(const char* symbol, unsigned char basket, bool force, bool addToStockChain) override;

	virtual void AddToSpecificToolCollection() override;
	virtual void UpdateGraphics() override;

	virtual void UpdateDataGraphics(const Graphics* graphics) override;
//	virtual bool UpdateDataGraphicsColorsCustom(const GraphicsColorCollection* colorCollection) override;
//	virtual bool UpdateDataGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL) override;
//	void UpdateDataColors(bool dataColorChanged, bool resizorColorChanged);

//	virtual bool CanPopulateSelectedIntoActiveCommandWindow() const{return true;}
////
	bool SecurityBelongs(const Security* security) const;
	bool SecurityPotentiallyBelongs(const Security* security) const;

	virtual bool ObjectPotentiallyBelongs(const void* object) const override;//no need to call inside lock
	virtual bool RowFiltersIn(const RowSortable* row) const override;//should be called inside lock
	virtual unsigned char RowBelongs(const RowSortable* row) const override;//should be called inside lock
	virtual unsigned char ExistingRowBelongs(const RowSortable* row) const override;//should be called inside lock
	bool RowInOutMoneyBelongs(const OptionPairRow* row) const;

//	virtual void ApplyFilter(const TakionFilter& filter) override;

	const bool& isSortThermograhPrintByTotal() const{return m_filter.isSortPrintsByActivity();}//m_sortThermograhPrintByTotal;}
	const bool& isSortThermograhQuoteByTotal() const{return m_filter.isSortQuotesByActivity();}//m_sortThermograhQuoteByTotal;}

	virtual void UpdateTitleGraphics(const Graphics* graphics) override;
////
	virtual const char* GetSettingsTabPath(const CPoint& point) const override;
	virtual const void* GetGraphicsTabInitInfo(const CPoint& point) const override;

//	virtual void MarketSorterCleanup();
	void SelectPositionRows(unsigned int filter);

//	unsigned int GetNextMenuId() const;

	static bool isColumnCall(unsigned short columnId);
	static bool isColumnPut(unsigned short columnId);

	typedef void (OptionPairRow::*FnPaintInfo)(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	typedef short (OptionPairRow::*FnCompare)(const OptionPairRow& other) const;

	bool AddOptionChainFunctions(unsigned short id, FnPaintInfo fnPaint, FnCompare fnCompare, FnCompare fnCompareAhead);

	inline const FnPaintInfo& GetFnPaintInfo(const unsigned short& id) const{return id < OC_COLUMN_COUNT ? m_paintInfoFunction[id] : NULL;}
	inline const FnCompare& GetFnCompare(const unsigned short& id) const{return id < OC_COLUMN_COUNT ? m_compareFunction[id] : NULL;}
	inline const FnCompare& GetFnCompareAhead(const unsigned short& id) const{return id < OC_COLUMN_COUNT ? m_compareAheadFunction[id] : NULL;}

//	virtual void AccountDeleted(const Account* account);//defined in RowWindowSortableAccount 
//	virtual void NewAccount(Account* account);//defined in RowWindowSortableAccount 
//	virtual void CurrentAccountConstraintsLoaded();//defined in RowWindowSortableAccount
//	virtual void AllAccountsDeleted() override;

//	virtual void CurrentAccountLoaded() override;

//	unsigned short GetTimeFrame() const{return m_timeFrame;}

//	void ApplyValue(RowSet& rowSet, const SignedPrice& value);
//	void ApplyValue(OptionPairRow* row, const SignedPrice& value);

//	bool isSortByValue() const;
	bool isSortBySecurity(bool firstSecurity) const;
	bool isSortByPosition(bool firstSecurity) const;

//	void RemoveSelected();
	virtual void ClearAll() override;

	typedef CMap<OptionKey, const OptionKey&, OptionPair*, OptionPair*> OptionPairMap;
	const OptionPair* FindOptionPair(const OptionKey& key) const
	{
		const OptionPairMap::CPair* found;
		if(key.isCall())
		{
			found = m_optionPairMap.PLookup(key);
		}
		else
		{
			OptionKey callKey(key);
			callKey.SetCall(true);
			found = m_optionPairMap.PLookup(callKey);
		}
		return found ? found->value : NULL;
	}
//	virtual void AcceptText(const char* text, unsigned int code) override;
//	void SelectSymbol(const char* symbol);

//	virtual void AddSymbol(const char* symbol);
	virtual bool CanClearSymbols() const override;
	virtual void ClearSymbols() override;

	bool UpdateOptionSide(OptionPairRow* row, bool lockRow, bool call, bool dynamicOnly);

	virtual int GetHourRectLeft() const override;

	static const unsigned short thermographSize = 16;
	static const unsigned short thermographDepth = 16;
//	const COLORREF* GetThermographRedColors() const{return m_thermographRedColors;}
//	const COLORREF* GetThermographGreenColors() const{return m_thermographGreenColors;}
	virtual const COLORREF* GetThermographRedColors() const override{return m_thermographRedColors;}
	virtual const COLORREF* GetThermographGreenColors() const override{return m_thermographGreenColors;}

	virtual bool isOptionChain() const override{return true;}

//	virtual void AppendWindowMenuInfo(std::string& menuText) const override;
/*
	const std::string& GetUnderlierSymbol() const{return m_underlierSymbol;}
	Underlier* GetUnderlier(){return m_underlier;}
	const Underlier* GetUnderlier() const{return m_underlier;}
//	Security* GetSecurity(){return m_security;}
	virtual const Security* GetSecurity() const override{return m_security;}
*/
//	virtual void SetAccount(Account* account);
	virtual bool CanDragClient(UINT nFlags, CPoint point) const override;
/*
	bool SecurityBelongs(const Security* security) const;
	bool SecurityPotentiallyBelongs(const Security* security) const;
	virtual bool ObjectPotentiallyBelongs(const void* object) const;//no need to call inside lock
	virtual bool RowFiltersIn(const RowSortable* row) const;//should be called inside lock
	virtual unsigned char RowBelongs(const RowSortable* row) const;//should be called inside lock
	virtual unsigned char ExistingRowBelongs(const RowSortable* row) const;//should be called inside lock
*/
/*
	const Price& GetStrikePriceFixed() const{return m_strikePriceFixed;}
	const COLORREF& GetColorInTheMoney() const{return m_colorInTheMoney;}
	const COLORREF& GetColorOutOfTheMoney() const{return m_colorOutOfTheMoney;}
	const COLORREF& GetBkColorInTheMoney() const{return m_colorBkInTheMoney;}
	const COLORREF& GetBkColorOutOfTheMoney() const{return m_colorBkOutOfTheMoney;}
*/

//	const COLORREF& GetWarningColor() const{return m_warningColor;}
//	const COLORREF& GetTopActiveColor() const{return m_topActiveColor;}

//	const COLORREF& GetDayHighColor() const{return m_dayHighColor;}
//	const COLORREF& GetDayLowColor() const{return m_dayLowColor;}
//	void ToggleExpirationTypeFlag(const unsigned char& flag);
//	void SetUseExpColors(bool use);
//	void SetUseInOutMoneyColors(bool use);
//	const bool& isUseInOutMoneyColors() const{return m_useInOutMoneyColors;}
//	void SetIndexOption(bool indexOption);
//	const bool& isIndexOption() const{return m_indexOption;}
//	void SubscribeSelected();
//	virtual bool isContentsChangeOnAccountChange() const override{return false;}

//	virtual bool hasInventoryView() const{return true;}
	virtual SymbolFilter* GetFilterCopy() const override;
	virtual unsigned char GetNativeFilterType() const override{return m_filter.isA();}
	virtual const TakionFilter* GetFilter() const override{return &m_filter;}
protected:
	OptionChainWindow(const CBitmap* bitmap,
		unsigned int workspace,
		bool pinned = false,
		int minVisibleSize = 15,
		int minWidth = 20,
		int maxWidth = 0,
		int minHeight = 20,
		int maxHeight = 0,
		int minBorderWidth = 2,
		int maxBorderWidth = 2,
		const char* className = "TakionTool",
		int minTitleHeight = 0,
		int maxTitleHeight = 15,
		int titleHeight = 15,
		bool topResizor = true);

//	virtual void UpdateCurrentAccount();

//	void ClearAndRepopulate();

//	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
//	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
//	DECLARE_MESSAGE_MAP()

	virtual void FilterFromString(const char*& cursor, const unsigned __int64& version, bool clone, unsigned int contentModifier) override
	{
		OptionChainFilter filter(m_filter);
		filter.fromString(cursor, version, clone, contentModifier);
		ApplyFilter(filter, true);
//		m_filter.Copy(filter);
	}
	virtual bool UpdateHistoryLoadBkColor() override;

	virtual void SecurityDoubleClicked(UINT nFlags, const CPoint& point) override;
//	void ApplyNewSecurity(OptionPairRow* row, Security* security, unsigned char whichSecurity);
//	void ApplyNewPosition(OptionPairRow* row, Position* position, unsigned char whichSecurity);
////
//	virtual void Populate();//{}//bool remove);//, unsigned int addPositionFilter);

	virtual void DoPaintTitle(const RECT& interRect, CDC& dc) override;
	virtual void UpdateTitleRects();
	virtual void OnTitleResize();
	virtual void SizeHorizontal(int cx, int cy, int oldX, int oldY);

	virtual void Repopulate() override;

	virtual void RowInserted(RowSortable* row);
	virtual void RowRemoved(RowSortable* row);

//	virtual bool ProcessKeyDown(unsigned char key, unsigned char modifier, bool repeat, TakionFrame* fromWindow) override;
/*
	void UnderlierRefreshed();
	void UpdateUnderlierSuffixes();
	unsigned __int64 m_allSuffixFlags;
	typedef std::map<char, unsigned __int64> SuffixMap;
	SuffixMap m_suffixMap;
	SuffixMap::const_iterator m_suffixMapEnd;
*/
////
//	virtual void UpdateAccountInfo() override;
	void UpdatePositionValues(RowSortable* row);
	void RepaintPositionValues() const;

//	virtual void OnSuccessfulCreate();
//	virtual void ToolAdded();

//	virtual void NextDayStarted() override;
	virtual void Notify(const Message* message, const Observable* from, const Message* info) override;

//	virtual void LineSelected();
	virtual void BeforeDestroy();
//	virtual void AccountChanged();

//	virtual void AddMenuItems(CMenu& menu);

	virtual void PostAddMenuItems(CMenu& menu);
//	virtual void AddRowPropertiesMenuItems(CMenu& popupMenu);
	virtual void PostAddRowPropertiesMenuItems(CMenu& popupMenu);
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

	FnPaintInfo m_paintInfoFunction[OC_COLUMN_COUNT];
	FnCompare m_compareFunction[OC_COLUMN_COUNT];
	FnCompare m_compareAheadFunction[OC_COLUMN_COUNT];
//	afx_msg LRESULT OnAddOptionPair(WPARAM startMinute, LPARAM lengthMinute);
//	DECLARE_MESSAGE_MAP()

	void ClearOptionChainRowsTemporarily(RowSortableHashSet& rowHashSet);

//	unsigned short m_timeFrame;

//	void SetValueToSelectedRows(const SignedPrice& value);

	void AddOptionPair(Security* security);

//	void AddOptionPair(const OptionPairKey& key);
//	OptionPair* RemoveOptionPair(OptionPair* optionPair);
	bool DestroyOptionPairMap();
	virtual bool UpdateOptionPairMap() override;
	OptionPairMap m_optionPairMap;
//	SymbolOptionPairMap m_symbolOptionPairMap;
/*
	bool SetOptionDataConnected(const bool connected);
	void SetOptionDataLoaded(const bool loaded);
	void SetOptionSubscriptionFailed(const bool failed);
	bool m_optionDataConnected;
	bool m_entitledToOptionData;
	bool m_optionDataLoaded;
	bool m_subscriptionFailed;
*/
//	COLORREF m_topActiveColor;
//	COLORREF m_warningColor;
/*
	COLORREF m_colorDisconnected;
	COLORREF m_colorNoEntitlement;
	COLORREF m_colorNotLoaded;
	COLORREF m_colorSubscriptionFailed;

	COLORREF m_dayHighColor;
	COLORREF m_dayLowColor;

	COLORREF m_colorLevel1Resizor;
	COLORREF m_colorInTheMoney;
	COLORREF m_colorOutOfTheMoney;
	COLORREF m_colorBkInTheMoney;
	COLORREF m_colorBkOutOfTheMoney;
	COLORREF m_colorThermographRed;
	COLORREF m_colorThermographGreen;
*/
	COLORREF m_thermographRedColors[thermographSize];
	COLORREF m_thermographGreenColors[thermographSize];

//	bool m_selectedActive;

	virtual void ActiveSymbolAboutToChange(const unsigned __int64& newActiveSymbol
		,const unsigned __int64& newActiveOptionBlock
		) override;
	virtual bool ActiveSymbolChanged() override;
	OptionPairRow* m_prevTopRow;
	OptionPairRow* m_nextTopRow;

	virtual RowTotal* CreateRowTotal() override;
	virtual OptionChainRowTotal* DoCreateRowTotal();

//	void UpdateTitle();
	void RepaintInOutMoneyValues() const;
/*
	bool SetUnderlier(Underlier* underlier);
	std::string m_underlierSymbol;
	Underlier* m_underlier;
	bool SetUnderlierSecurity(const Security* security);
	const Security* m_security;
	bool SetUnderlierPosition(const Position* position);
	const Position* m_underlierPosition;
*/
	OptionChainFilter m_filter;
	virtual void DoApplyFilter(const TakionFilter& filter, bool forceFilterChanged) override;

//	void UpdateStrikeOrdinal(bool force);
	virtual void OnUpdateStrikeOrdinal() override;
	virtual void UpdateStrikeOrdinalRows() override;
//	Price m_strikePriceFixed;

//	bool m_useExpColors;
//	bool m_useInOutMoneyColors;
};

class TGUI_API OptionPairRow : public OptionBaseRow, public SecurityChartRow
{
friend class OptionChartRow2;
friend class OptionChainWindow;
public:
	OptionPairRow(OptionChainWindow* parent, OptionPair* optionPair, const Position* position1, const Position* position2, bool potential = false);
	virtual ~OptionPairRow();
	virtual const void* GetBaseObject() const override{return m_optionPair;}
	virtual bool GetPaintTextInfo(unsigned short columnId, std::string& text, COLORREF& color) const override;//, UINT& horizontalJustification) const override;
	virtual bool PaintCell(CDC& dc, const Column* column, const CRect& rect, UINT verticalJustification, int horizontalOffset) const override;//, unsigned char horizontalAlignment) const;
	virtual COLORREF GetRowColor() const override;
	virtual COLORREF GetCellColor(unsigned short columnId) const override;
	virtual COLORREF GetCellBkColor(unsigned short columnId) const override;

	virtual void Subscribe() override;
	virtual void Unsubscribe() override;
	virtual void Resubscribe() override;
//	virtual COLORREF GetRowBkColor() const override;

//	bool isColumnCall(unsigned short columnId) const;
//	bool isColumnPut(unsigned short columnId) const;

	const unsigned int& GetCallInMoneyOrdinal() const{return m_callInMoneyOrdinal;}
	const unsigned int& GetCallOutMoneyOrdinal() const{return m_callOutMoneyOrdinal;}
	const unsigned int& GetPutInMoneyOrdinal() const{return m_putInMoneyOrdinal;}
	const unsigned int& GetPutOutMoneyOrdinal() const{return m_putOutMoneyOrdinal;}

	virtual RowValue* CreateCell(unsigned short id) override;

	OptionPair* const& GetOptionPair(){return m_optionPair;}
	const OptionPair* const& GetOptionPair() const{return m_optionPair;}

	virtual bool SetPosition(const Position* position);
	bool SetPosition1(const Position* position);
	bool SetPosition2(const Position* position);
	bool SetPositionSide(const Position* position, bool call);

	virtual bool SetSecurity(const Security* security);
	virtual bool SetSecurity1(const Security* security);
	virtual bool SetSecurity2(const Security* security);

//	Security* GetSecurity1(){return m_security;}
//	Security* GetSecurity2(){return m_optionPair->GetSecurity2();}

	const Security* const& GetSecurity1() const{return m_security;}
	const Security* const& GetSecurity2() const{return m_optionPair->GetSecurity2();}
	const Security* const& GetSecurity1or2(const bool& first) const{return m_optionPair->GetSecurity(first);}

//	Position* GetPosition2(){return m_optionChartRow.GetPosition();}
	const Position* const& GetPosition1() const{return m_position;}
	const Position* const& GetPosition2() const{return m_optionChartRow.GetPosition();}
	const Position* const& GetPosition1or2(const bool& first) const{return first ? m_position : m_optionChartRow.GetPosition();}
//	const OptionKey& GetFirstKey() const{return m_optionPair->GetFirst();}
//	const OptionKey& GetSecondKey() const{return m_optionPair->GetSecond();}

	const unsigned int& GetStrikePrice() const{return m_optionPair->GetStrikePrice();}
	unsigned int GetExpirationDate() const{return m_optionPair->GetExpirationDate();}
	virtual unsigned int GetExpirationOrdinal() const override{return m_optionPair->GetExpirationOrdinal();}

	virtual bool Lock(bool wait) const override;
//	virtual void LockWait() const override;
	virtual void Unlock() const override;

	bool Lock1(bool wait) const;
	bool Lock2(bool wait) const;
//	void LockWait1() const;
//	void LockWait2() const;
	void Unlock1() const;
	void Unlock2() const;

	bool LockSide(bool call, bool wait) const;
//	void LockWaitSide(bool call) const;
	void UnlockSide(bool call) const;
	void UpdateRowValueSideIterators()
	{
		m_callRowValuesBegin = m_callRowValues.begin();
		m_callRowValuesEnd = m_callRowValues.end();
		m_putRowValuesBegin = m_putRowValues.begin();
		m_putRowValuesEnd = m_putRowValues.end();

		m_dynamicCallRowValuesBegin = m_dynamicCallRowValues.begin();
		m_dynamicCallRowValuesEnd = m_dynamicCallRowValues.end();
		m_dynamicPutRowValuesBegin = m_dynamicPutRowValues.begin();
		m_dynamicPutRowValuesEnd = m_dynamicPutRowValues.end();
	}
	virtual bool DestroyCell(unsigned short id);

	virtual bool isSortValueChanged() const;
	virtual bool isChainSortValueChanged() const;

	bool isOptionSideSortValueChanged(bool call) const;
	bool isOptionSideChainSortValueChanged(bool call) const;

	short CompareOptionSideAhead(const RowSortable& other, bool call) const;
	short CompareOptionSideChainAhead(const RowSortable& other, bool call) const;
/*
	virtual short Compare(const RowSortable& other) const;
	virtual short CompareAhead(const RowSortable& other) const;
	virtual short CompareChain(const RowSortable& other) const;
	virtual short CompareChainAhead(const RowSortable& other) const;
*/
	virtual short DefaultCompare(const RowSortable& other) const override;

	virtual short PreCompare(const RowSortable& other) const override;
	virtual bool CompareFunction(const RowSortable& other, unsigned short sortId, short& ret) const override;
	virtual bool CompareFunctionAhead(const RowSortable& other, unsigned short sortId, short& ret) const override;

	virtual void Update(bool dynamicOnly) override;
	virtual bool UpdateRowColor() override;//should be called only inside a lock
	virtual void UpdateAndInvalidate(CRect& rowRect, bool dynamicOnly) override;

	virtual void Initialize();//should be called only inside a lock

	virtual const char* GetRowSecuritySymbol(const CPoint* point = NULL) const override;
	virtual const unsigned __int64& GetRowNumericSymbol() const override{return m_security ? m_security->GetNumericSymbol() : m_optionPair->GetSecurity2() ? m_optionPair->GetSecurity2()->GetNumericSymbol() : uint64Zero;}
	virtual const PositionData* GetRowPosition(const CPoint* point = NULL) const override;

	DECLARE_NED_NEW

	virtual const char* GetStringValue(unsigned short id) const override;
	virtual const unsigned int GetUIntValue(unsigned short id) const override;
	virtual const unsigned __int64 GetUInt64Value(unsigned short id) const override;
	Price GetPriceValue(unsigned short id) const override;

	virtual const Security* GetSelectedSecurity() const override;

	static const unsigned short thermographLength = 16;

	const Thermograph& GetThermographCallQuotesGreen() const{return m_thermographCallQuotesGreen;}
	const Thermograph& GetThermographCallQuotesRed() const{return m_thermographCallQuotesRed;}
	const Thermograph& GetThermographCallPrintsGreen() const{return m_thermographCallPrintsGreen;}
	const Thermograph& GetThermographCallPrintsRed() const{return m_thermographCallPrintsRed;}

	const Thermograph& GetThermographPutQuotesGreen() const{return m_thermographPutQuotesGreen;}
	const Thermograph& GetThermographPutQuotesRed() const{return m_thermographPutQuotesRed;}
	const Thermograph& GetThermographPutPrintsGreen() const{return m_thermographPutPrintsGreen;}
	const Thermograph& GetThermographPutPrintsRed() const{return m_thermographPutPrintsRed;}

	OptionChainWindow* GetOptionChainWindow(){return m_optionChainWindow;}
	const OptionChainWindow* GetOptionChainWindow() const{return m_optionChainWindow;}

	void PaintSymbol(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareSymbol(const OptionPairRow& other) const;
	void PaintSuffix(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareSuffix(const OptionPairRow& other) const;
//	void PaintCall(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
//	short CompareCall(const OptionPairRow& other) const;
	void PaintExpiration(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareExpiration(const OptionPairRow& other) const;
	void PaintExpirationDayOfWeek(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareExpirationDayOfWeek(const OptionPairRow& other) const;
	void PaintStrike(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareStrike(const OptionPairRow& other) const;
	void PaintExpirationType(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareExpirationType(const OptionPairRow& other) const;
	void PaintExpirationDays(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareExpirationDays(const OptionPairRow& other) const;

	void PaintCallInMoneyOrdinal(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareCallInMoneyOrdinal(const OptionPairRow& other) const;
	void PaintCallOutMoneyOrdinal(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareCallOutMoneyOrdinal(const OptionPairRow& other) const;
	void PaintPutInMoneyOrdinal(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short ComparePutInMoneyOrdinal(const OptionPairRow& other) const;
	void PaintPutOutMoneyOrdinal(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short ComparePutOutMoneyOrdinal(const OptionPairRow& other) const;

	void PaintExpirationOrdinal(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareExpirationOrdinal(const OptionPairRow& other) const;

	short CompareThermographCallPrints(const OptionPairRow& other) const;
	short CompareThermographCallPrintsAhead(const OptionPairRow& other) const;
	short CompareThermographCallQuotes(const OptionPairRow& other) const;
	short CompareThermographCallQuotesAhead(const OptionPairRow& other) const;

	short CompareThermographPutPrints(const OptionPairRow& other) const;
	short CompareThermographPutPrintsAhead(const OptionPairRow& other) const;
	short CompareThermographPutQuotes(const OptionPairRow& other) const;
	short CompareThermographPutQuotesAhead(const OptionPairRow& other) const;

	void PaintContractSize(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareContractSize(const OptionPairRow& other) const;
	virtual void RemoveObservers() override;
protected:
	virtual void InvalidateOrdinals() override
	{
		OptionBaseRow::InvalidateOrdinals();
		m_callInMoneyOrdinal = m_callOutMoneyOrdinal = m_putInMoneyOrdinal = m_putOutMoneyOrdinal = 0xFFFFFFFF;
	}
	void UpdateSecurity();

	void UpdateSide(bool call, bool dynamicOnly);
	void UpdateSideAndInvalidate(CRect& rowRect, bool call, bool dynamicOnly);//don't call this function. It is called by Takion.

	bool UpdatePrints(bool lock);
	bool UpdatePrintsSide(bool lock, bool call);
	virtual void Notify(const Message* message, const Observable* from, const Message* info = NULL) override;

	OptionChartRow2 m_optionChartRow;
	OptionPair* m_optionPair;
	OptionChainWindow* m_optionChainWindow;

//	COLORREF m_optionColor;
//	COLORREF m_bkColor;

	Thermograph m_thermographCallQuotesGreen;
	Thermograph m_thermographCallQuotesRed;
	Thermograph m_thermographCallPrintsGreen;
	Thermograph m_thermographCallPrintsRed;
	Thermograph m_thermographPutQuotesGreen;
	Thermograph m_thermographPutQuotesRed;
	Thermograph m_thermographPutPrintsGreen;
	Thermograph m_thermographPutPrintsRed;

	int m_callQuotesThermographValueRed;
	int m_callQuotesThermographValueGreen;
	int m_callPrintsThermographValueRed;
	int m_callPrintsThermographValueGreen;
	int m_putQuotesThermographValueRed;
	int m_putQuotesThermographValueGreen;
	int m_putPrintsThermographValueRed;
	int m_putPrintsThermographValueGreen;

	unsigned int m_callInMoneyOrdinal;
	unsigned int m_callOutMoneyOrdinal;
	unsigned int m_putInMoneyOrdinal;
	unsigned int m_putOutMoneyOrdinal;

	bool SetRowValue(unsigned short id, RowValue* value, bool dynamic);
	RowValueList m_callRowValues;
	RowValueList::iterator m_callRowValuesBegin;
	RowValueList::iterator m_callRowValuesEnd;
	RowValueList m_putRowValues;
	RowValueList::iterator m_putRowValuesBegin;
	RowValueList::iterator m_putRowValuesEnd;

	RowValueList m_dynamicCallRowValues;
	RowValueList::iterator m_dynamicCallRowValuesBegin;
	RowValueList::iterator m_dynamicCallRowValuesEnd;
	RowValueList m_dynamicPutRowValues;
	RowValueList::iterator m_dynamicPutRowValuesBegin;
	RowValueList::iterator m_dynamicPutRowValuesEnd;
};

class TGUI_API OptionChainRowTotal : public RowTotal
{
public:
	OptionChainRowTotal(OptionChainWindow* window):
		RowTotal(OptionChainWindow::OC_COLUMN_COUNT, window)
/*
		m_size(NULL),
		m_pnlOpenLevel1(NULL),
		m_pnlOpenPrint(NULL),
		m_ticketAverage(NULL),
		m_markedTicketAverage(NULL),
		m_pnlClosed(NULL),
		m_sharesTraded(NULL),
		m_gpsLevel1(NULL),
		m_gpsPrint(NULL)
*/
	{
		UpdateRowValueSideIterators();
	}
/*
	void SetSizePtr(UIntRowValue* value){m_size = value;}

	void SetPnlOpenLevel1Ptr(MoneyRowValue* value){m_pnlOpenLevel1 = value;}
	void SetPnlOpenPrintPtr(MoneyRowValue* value){m_pnlOpenPrint = value;}
	void SetTicketAveragePtr(MoneyRowValue* value){m_ticketAverage = value;}
	void SetMarkedTicketAveragePtr(MoneyRowValue* value){m_markedTicketAverage = value;}
	void SetPnlClosedPtr(MoneyRowValue* value){m_pnlClosed = value;}
	void SetSharesTradedPtr(UIntRowValue* value){m_sharesTraded = value;}

	void SetGpsLevel1Ptr(SignedPriceRowValue* value){m_gpsLevel1 = value;}
	void SetGpsPrintPtr(SignedPriceRowValue* value){m_gpsPrint = value;}
*/
	void AdjustRowSide(const Row* row, bool call, bool dynamicOnly);
	void UpdateRowValueSideIterators()
	{
		m_callRowValuesBegin = m_callRowValues.begin();
		m_callRowValuesEnd = m_callRowValues.end();
		m_putRowValuesBegin = m_putRowValues.begin();
		m_putRowValuesEnd = m_putRowValues.end();
		
		m_dynamicCallRowValuesBegin = m_dynamicCallRowValues.begin();
		m_dynamicCallRowValuesEnd = m_dynamicCallRowValues.end();
		m_dynamicPutRowValuesBegin = m_dynamicPutRowValues.begin();
		m_dynamicPutRowValuesEnd = m_dynamicPutRowValues.end();
	}
	bool SetRowValue(unsigned short id, RowValue* value, bool dynamic, bool cumulative, unsigned short additionalId);
protected:
	virtual void UpdateNonCumulativeValues(const Row* row, bool dynamicOnly);
	virtual void AddNonCumulativeValues(const Row* row);
	virtual void RemoveNonCumulativeValues(const Row* row);
	virtual void ResetNonCumulativeValues();

	void UpdateNonCumulativeValuesSide(const Row* row, bool call, bool dynamicOnly);
/*
	UIntRowValue* m_size;

	MoneyRowValue* m_pnlOpenLevel1;
	MoneyRowValue* m_pnlOpenPrint;
	MoneyRowValue* m_ticketAverage;
	MoneyRowValue* m_markedTicketAverage;
	MoneyRowValue* m_pnlClosed;
	UIntRowValue* m_sharesTraded;
	SignedPriceRowValue* m_gpsLevel1;
	SignedPriceRowValue* m_gpsPrint;
*/
	RowValueList m_callRowValues;
	RowValueList::iterator m_callRowValuesBegin;
	RowValueList::iterator m_callRowValuesEnd;
	RowValueList m_putRowValues;
	RowValueList::iterator m_putRowValuesBegin;
	RowValueList::iterator m_putRowValuesEnd;

	RowValueList m_dynamicCallRowValues;
	RowValueList::iterator m_dynamicCallRowValuesBegin;
	RowValueList::iterator m_dynamicCallRowValuesEnd;
	RowValueList m_dynamicPutRowValues;
	RowValueList::iterator m_dynamicPutRowValuesBegin;
	RowValueList::iterator m_dynamicPutRowValuesEnd;
};

#endif
///////////////////////////////////////
class IndexSorterRow;

class TGUI_API IndexSorterWindow : public RowWindowSortable, public Observer
{
public:
	virtual const char* GetToolId() const override{return toolIndexSorterId;}
//	virtual ~IndexSorterWindow(){DestroyPotentialRows();}

	virtual COLORREF GetBkColor() const override;

	virtual bool isTickable() const override{return true;}
	virtual bool HasDoubleClickAction() const override{return false;}
	virtual bool RowHasSecuritySymbol() const override{return false;}
	enum ColumnId : unsigned short
	{
		I_SYMBOL,
		I_LAST_VALUE,
		I_TICK,
		I_DAY_NET_CHANGE,
		I_DAY_NET_PERCENT_CHANGE,
		I_CLOSE_VALUE,
		I_DAY_HIGH_VALUE,
		I_DAY_LOW_VALUE,
		I_DAY_RANGE,
		I_DAY_RANGE_PERCENT,
		I_OPEN_VALUE,
		I_TODAYS_CLOSE_VALUE,

		I_FIRST_VALUE,
		I_NET_CHANGE,
		I_NET_PERCENT_CHANGE,
		I_HIGH_VALUE,
		I_LOW_VALUE,
		I_RANGE,
		I_RANGE_PERCENT,
		I_HILO_COUNT,
		I_HILO_COUNT_REPEAT,

		I_NAME,
		I_TICK_COUNT,
		I_TICK_COUNT_REPEAT,

		I_CHART_LOADED,

		I_CALC,

		I_LAST_TIME,

		I_COLUMN_COUNT
	};
	virtual unsigned short GetBuiltInColumnCount() const override{return I_COLUMN_COUNT;}
	virtual void toString(std::string& str, unsigned int contentModifier) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual void fromScratch() override;

	virtual void AddToSpecificToolCollection() override;

	virtual void UpdateDataGraphics(const Graphics* graphics) override;
	virtual bool UpdateDataGraphicsColorsCustom(const GraphicsColorCollection* colorCollection) override;
	virtual bool UpdateDataGraphicsColors(const Graphics* graphics, const GraphicsColorCollection* colorCollection = NULL) override;

//	virtual void ApplyFilter(const TakionFilter& filter) override;

//	const bool& isHideAll() const{return m_filter.isHideAll();}
	const unsigned int& GetCalcIndexFilter() const{return m_filter.GetCalcIndexFilter();}

	virtual bool HasMoneyColumns() const override{return false;}

	bool IndexBelongs(const IndexChartRow* indexChartRow) const;
	bool IndexPotentiallyBelongs(const Index* index) const;

	virtual Row* CreateRow(const void* object, bool potential) override;

	typedef void (IndexSorterRow::*FnPaintInfo)(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	typedef short (IndexSorterRow::*FnCompare)(const IndexSorterRow& other) const;

	bool AddIndexSorterFunctions(unsigned short id, FnPaintInfo fnPaint, FnCompare fnCompare, FnCompare fnCompareAhead);

	inline const FnPaintInfo& GetFnPaintInfo(const unsigned short& id) const{return id < I_COLUMN_COUNT ? m_paintInfoFunction[id] : NULL;}
	inline const FnCompare& GetFnCompare(const unsigned short& id) const{return id < I_COLUMN_COUNT ? m_compareFunction[id] : NULL;}
	inline const FnCompare& GetFnCompareAhead(const unsigned short& id) const{return id < I_COLUMN_COUNT ? m_compareAheadFunction[id] : NULL;}

	void SetMarketSorterConnected(bool connected);
	void SetMarketSorterLoaded(bool loaded);

	virtual bool ObjectPotentiallyBelongs(const void* object) const override;//no need to call inside lock
	virtual bool RowFiltersIn(const RowSortable* row) const override;//should be called inside lock
	virtual unsigned char RowBelongs(const RowSortable* row) const override;//should be called inside lock
	virtual unsigned char ExistingRowBelongs(const RowSortable* row) const override;//should be called inside lock

	const unsigned short& GetTimeFrame() const{return m_timeFrame;}
	virtual void UpdateTitleGraphics(const Graphics* graphics) override;
	const unsigned int& GetHiCount() const{return m_hiCount;}
	const unsigned int& GetLoCount() const{return m_loCount;}
	void IncrementHiCount();
	void DecrementHiCount();
	void IncrementLoCount();
	void DecrementLoCount();

	virtual void AcceptText(const char* text, unsigned int code) override;
	RowSortable* SelectSymbol(const char* symbol);

//	COLORREF GetTopActiveColor() const{return m_topActiveColor;}
//	const COLORREF& GetWarningColor() const{return m_warningColor;}
	virtual bool CanHaveTotal() const{return false;}
//	virtual bool HasMillisecondColumns() const{return true;}
	virtual int GetHourRectLeft() const;

	void UpdateDescription();

	virtual SymbolFilter* GetFilterCopy() const override;
	virtual unsigned char GetNativeFilterType() const override{return m_filter.isA();}
	virtual const TakionFilter* GetFilter() const override{return &m_filter;}
protected:
	IndexSorterWindow(const CBitmap* bitmap, unsigned int workspace, bool pinned = false);
	virtual void TitleFontChanged() override;
	virtual void ClearRowsTemporarily() override;
//	virtual RowTotal* CreateRowTotal() const;
//	virtual void LineSelected();
	virtual void BeforeDestroy() override;
	virtual void AddMenuItems(CMenu& menu) override;
	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;
	virtual void Populate();//{}//bool remove);//, unsigned int addPositionFilter);

	virtual void DoPaintTitle(const RECT& interRect, CDC& dc) override;
	virtual void UpdateTitleRects() override;
	virtual void OnTitleResize() override;
	virtual void SizeHorizontal(int cx, int cy, int oldX, int oldY) override;

//	virtual void Repopulate(){}

	virtual void RowInserted(RowSortable* row) override;
	virtual void RowRemoved(RowSortable* row) override;

	virtual bool ProcessKeyDown(unsigned char key, unsigned char modifier, bool repeat, TakionFrame* fromWindow) override;

	bool UpdateTimeFrame(unsigned short minutes, bool sortingChanged);
//	bool DoUpdateTimeFrame(bool sortingChanged);
	void UpdateTimeFrameValues(RowSortable* row);
	void RepaintTimeFrameValues() const;

	bool AddIndexFunctions(unsigned short id, FnPaintInfo fnPaint, FnCompare fnCompare, FnCompare fnCompareAhead);
	FnPaintInfo m_paintInfoFunction[I_COLUMN_COUNT];
	FnCompare m_compareFunction[I_COLUMN_COUNT];
	FnCompare m_compareAheadFunction[I_COLUMN_COUNT];

	IndexFilter m_filter;
	virtual void DoApplyFilter(const TakionFilter& filter, bool forceFilterChanged) override;

	CRect m_hiRect;
	CRect m_xRect;
	CRect m_loRect;
	int m_hiloWidth;
	int m_xWidth;
	unsigned int m_hiCount;
	unsigned int m_loCount;

	bool m_marketSorterConnected;
	bool m_marketSorterLoaded;
	COLORREF m_colorDisconnected;
	COLORREF m_colorNotLoaded;
	unsigned short m_timeFrame;
};

class TGUI_API IndexSorterRow : public RowSortable, public IndexChartRow
{
public:
	IndexSorterRow(IndexSorterWindow* parent, Index* index, bool potential = false);
	virtual const void* GetBaseObject() const override{return m_index;}
	virtual bool GetPaintTextInfo(unsigned short columnId, std::string& text, COLORREF& color) const override;//, UINT& horizontalJustification) const override;
//	virtual bool PaintCell(CDC& dc, const Column* column, const CRect& rect, UINT verticalJustification, int horizontalOffset) const override;//, unsigned char horizontalAlignment) const;
//	virtual void CellToString(std::string& info, unsigned short columnId) const override;
	virtual COLORREF GetRowColor() const override;
//	virtual COLORREF GetCellColor(unsigned short columnId) const;
	virtual RowValue* CreateCell(unsigned short id) override;
	virtual bool Lock(bool wait) const override;
//	virtual void LockWait() const override;
	virtual void Unlock() const override;
//	virtual bool isSortValueChanged() const;
//	virtual short Compare(const RowSortable& other) const;
//	virtual short CompareAhead(const RowSortable& other) const;
//	virtual void Update(bool dynamicOnly);
//	virtual bool UpdateRowColor();//should be called only inside a lock
//	virtual void UpdateAndInvalidate(CRect& rowRect, bool dynamicOnly);

	virtual short DefaultCompare(const RowSortable& other) const override;
	virtual bool CompareFunction(const RowSortable& other, unsigned short sortId, short& ret) const override;
	virtual bool CompareFunctionAhead(const RowSortable& other, unsigned short sortId, short& ret) const override;

	void PaintSymbol(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareSymbol(const IndexSorterRow& other) const;
	void PaintDescription(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareDescription(const IndexSorterRow& other) const;
	void PaintCalculatable(std::string& text, COLORREF& color) const;//, UINT& horizontalJustification) const;
	short CompareCalculatable(const IndexSorterRow& other) const;

	virtual void Initialize();//should be called only inside a lock

//	virtual const std::string* GetRowSecuritySymbol(const CPoint* point) const{return m_security ? &m_security->GetSymbolStr() : NULL;}

	DECLARE_NED_NEW

//	virtual const Security* GetSelectedSecurity() const;
protected:
//	bool UpdatePrints(bool lock);
	virtual void Notify(const Message* message, const Observable* from, const Message* info = NULL) override;
	virtual void IncrementHiCount() override;
	virtual void DecrementHiCount() override;
	virtual void IncrementLoCount() override;
	virtual void DecrementLoCount() override;
	IndexSorterWindow* m_indexSorterWindow;

	COLORREF m_indexColor;
};

class TGUI_API CommandRemovablePopupWnd : public TakionPopupWnd//TakionMessageBox
{
public:
	CommandRemovablePopupWnd(TakionMainWnd* mainWnd, int defaultResult = IDCANCEL);
	virtual ~CommandRemovablePopupWnd();
	virtual void BeforeDestroy();
	virtual void AccountRemoved(const Account* account){}
	virtual void AllAccountsRemoved(){}
protected:
//	afx_msg void OnNcRButtonDown(UINT nFlags, CPoint point);
//	DECLARE_MESSAGE_MAP()
//	virtual void DisplayMenu(CPoint point){}
	virtual void OnSuccessfulCreate();
};

class TGUI_API DialogPinnable : public CommandRemovablePopupWnd//TakionMessageBox
{
public:
protected:
	DialogPinnable(TakionMainWnd* const& mainWnd,
		BoolSetting& pinnable,
		IntSetting& pinX,
		IntSetting& pinY,
		const bool& topLeftCorner,
		const int& defaultResult = IDCANCEL):

		CommandRemovablePopupWnd(mainWnd, defaultResult),
		m_topLeftCorner(topLeftCorner),
		m_pinnable(pinnable),
		m_pinX(pinX),
		m_pinY(pinY)
	{}
	virtual void AddMenuItems(CMenu& menu) override;
	virtual void PostAddMenuItems(CMenu& menu) override;
	//	virtual void DisplayMenu(CPoint point);
	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;
	virtual void OnSuccessfulCreate();
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;
	bool m_topLeftCorner;
	BoolSetting& m_pinnable;
	IntSetting& m_pinX;
	IntSetting& m_pinY;
};

class TGUI_API DialogAdminBroadcast : public CommandRemovablePopupWnd//TakionMessageBox
{
public:
	DialogAdminBroadcast(TakionMainWnd* mainWnd, COLORREF bkColor, COLORREF blinkBkColor);
	bool Display(const char* caption, const char* text);
protected:
	virtual void OnSuccessfulCreate();
};

class TGUI_API DialogTrigger : public DialogPinnable//TakionMessageBox
{
public:
	DialogTrigger(TakionMainWnd* mainWnd, COLORREF bkColor, COLORREF blinkBkColor);
	bool Display(const char* caption, const char* text, const unsigned __int64& numericSymbol);
protected:
//	virtual void OnSuccessfulCreate();
	virtual void BeforeDestroy() override;
	unsigned __int64 m_numericSymbol;
	std::string m_text;
};

#ifndef TAKION_NO_OPTIONS
class TGUI_API DialogOptionStuck : public DialogPinnable
{
public:
	DialogOptionStuck(TakionMainWnd* mainWnd, COLORREF bkColor, COLORREF blinkBkColor);
	bool Display(const unsigned __int64& numericSymbol, const unsigned __int64& optionBlock);
protected:
//	afx_msg void OnOK();
//	afx_msg void OnCancel();
//	virtual void OnSuccessfulCreate();
	virtual void BeforeDestroy() override;
	unsigned __int64 m_numericSymbol;
	unsigned __int64 m_optionBlock;
//	std::string m_text;
};
#endif

class TGUI_API DialogAlert : public DialogPinnable//TakionMessageBox
{
public:
	DialogAlert(TakionMainWnd* mainWnd, const AlertKeySetting& key, const AlertValueSetting* valueSetting, bool invalid, const __int64* valueForRenewal);
	virtual void Renew() override;
protected:
//	virtual void OnSuccessfulCreate() override;
//	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;
	virtual void BeforeDestroy() override;
//	virtual void DisplayMenu(CPoint point);
	AlertKeySetting m_keySetting;
	AlertValueSetting m_valueSetting;
	bool m_renewable;
};

class TGUI_API DialogPositionAlert : public DialogPinnable//TakionMessageBox
{
public:
	DialogPositionAlert(TakionMainWnd* mainWnd, const Position* position, bool lastAlert, const char* stringMillisecond, COLORREF bkColor, COLORREF blinkBkColor);
	bool Display();//const char* caption, const char* text);
	virtual void Renew();
	virtual void AccountRemoved(const Account* account);
	virtual void AllAccountsRemoved();
protected:
//	virtual void OnSuccessfulCreate();
//	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual void BeforeDestroy();

	bool Exclude();
//	void DisplayMenu(CPoint point);
	std::string m_symbol;
	std::string m_text;
	const Position* m_position;
	bool m_lastAlert;
};

class PosManRingVector;
class AdditionalColumnDll;
class PositionAlert;

enum ConnectionStatus : unsigned char
{
	CS_LIVE,
	CS_SIMULATION,
	CS_NOCONNECTION
};

class FirmPositionWindow;
class OrderSizeAggregate;
class OrderPriceAggregate;

class AccountOrderedMap;

class TGUI_API PositionMenuItem
{
public:
	PositionMenuItem(const unsigned __int64& numericSymbol,
#ifndef TAKION_NO_OPTIONS
		const unsigned __int64& optionBlock,
#endif
		const std::string& symbol,
		const Price& price,
		const int& size,
		const bool& checked,
		const bool& enabled):
		m_numericSymbol(numericSymbol),
#ifndef TAKION_NO_OPTIONS
		m_optionBlock(optionBlock),
#endif
		m_symbol(symbol),
		m_price(price),
		m_size(size),
		m_checked(checked),
		m_enabled(enabled),
		m_highlighted(false)
	{}
	PositionMenuItem(const Position* position, const bool& inventoryView, const bool& checked, const bool& enabled):
		m_numericSymbol(0),//position->GetNumericSymbol()),
#ifndef TAKION_NO_OPTIONS
		m_optionBlock(0),//position->GetOptionBlock()),
#endif
		m_size(0),
		m_checked(checked),
		m_enabled(enabled),
		m_highlighted(false)
	{
		InitParams(position, inventoryView);
	}
	PositionMenuItem():
		m_numericSymbol(0),
#ifndef TAKION_NO_OPTIONS
		m_optionBlock(0),
#endif
		m_size(0),
		m_checked(false),
		m_enabled(false),
		m_highlighted(false)
	{}
	const unsigned __int64& GetNumericSymbol() const{return m_numericSymbol;}
	void SetNumericSymbol(const unsigned __int64& numericSymbol){m_numericSymbol = numericSymbol;}
#ifndef TAKION_NO_OPTIONS
	const unsigned __int64& GetOptionBlock() const{return m_optionBlock;}
#endif
	void InitParams(const Position* position, const bool& inventoryView)
	{
		SetNumericSymbol(position->GetNumericSymbol());
#ifndef TAKION_NO_OPTIONS
		m_optionBlock = position->GetOptionBlock();
		m_symbol.clear();
		position->GetOptionSymbol(m_symbol, false);
#else
		m_text = position->GetSymbol();
#endif
		m_size = position->GetSizeInv(inventoryView);
		m_price = position->GetAveragePriceInv(inventoryView);

		m_text = m_symbol;
		m_text += ' ';
		char num[33];
		m_text += U_SignedNumberToStrWithCommasNoDecDigits(m_size, num, sizeof(num), true, ' ');
		m_text += '$';
		U_PriceToStr(m_text, position->GetAveragePriceInv(inventoryView), 4, 0, true, '\0', true);
	}
	const std::string& GetText() const{return m_text;}
	const std::string& GetSymbol() const{return m_symbol;}
	const bool& isChecked() const{return m_checked;}
	void SetChecked(const bool& checked){m_checked = checked;}
	void ToggleCheck(){m_checked = !m_checked;}
	const bool& isEnabled() const{return m_enabled;}
	void SetEnabled(const bool& enabled){m_enabled = enabled;}
	const int& GetSize() const{return m_size;}
	void SetSize(const int& size){m_size = size;}
	const Price& GetPrice() const{return m_price;}
	bool operator==(const PositionMenuItem& other) const
	{
		return m_checked == other.m_checked && !strcmp(m_symbol.c_str(), other.m_symbol.c_str());
	}
	int Compare(const PositionMenuItem& other) const
	{
		return m_checked == other.m_checked ? strcmp(m_symbol.c_str(), other.m_symbol.c_str()):
			m_checked ? -1 : 1;
	}
	bool operator<(const PositionMenuItem& other) const
	{
		return Compare(other) < 0;
	}
	const bool& isHighlighted() const{return m_highlighted;}
	bool SetHighlighted(const bool& highlighted)
	{
		if(highlighted != m_highlighted)
		{
			m_highlighted = highlighted;
			return true;
		}
		return false;
	}
protected:
	unsigned __int64 m_numericSymbol;
#ifndef TAKION_NO_OPTIONS
	unsigned __int64 m_optionBlock;
#endif
	std::string m_symbol;
	std::string m_text;
	Price m_price;
	int m_size;
	bool m_checked;
	bool m_enabled;
	bool m_highlighted;
};

class TGUI_API ListBoxPositionStock : public ListBoxOwnerDraw//ListBoxFit
{
public:
	ListBoxPositionStock(int itemHeight = 0, bool rbuttonSelection = false, bool rbuttonMenu = false, bool draggable = false, const char* tooltipText = NULL) :
		ListBoxOwnerDraw(itemHeight, rbuttonSelection, rbuttonMenu, draggable, tooltipText),
		m_colorLong(RGB(0, 96, 0)),
		m_colorShort(RGB(96, 0, 0)),
		m_colorFlat(0),
		m_colorHighlight(RGB(192, 192, 192))
	{
		m_checkable = 1;
	}
	virtual bool isItemChecked(const void* item) const override{return ((const PositionMenuItem*)item)->isChecked();}

	virtual const char* GetItemName(const void* item) const override
	{
		return ((const PositionMenuItem*)item)->GetSymbol().c_str();
	}
	virtual int Compare(const void* item1, const void* item2) const override
	{
		return ((const PositionMenuItem*)item1)->Compare(*(const PositionMenuItem*)item1);
	}
	virtual COLORREF GetStringColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override
	{
		return lpDrawItemStruct->itemState & ODS_SELECTED ? GetSysColor(COLOR_HIGHLIGHTTEXT) :
			GetSelectedBkColor(lpDrawItemStruct);
	}
	virtual COLORREF GetSelectedBkColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override
	{
		const PositionMenuItem* item = (const PositionMenuItem*)lpDrawItemStruct->itemData;
		const int size = item->GetSize();
		return size < 0 ? m_colorShort:
			size > 0  ? m_colorLong:
			m_colorFlat;
	}

	virtual COLORREF GetBkColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override
	{
		const PositionMenuItem* item = (const PositionMenuItem*)lpDrawItemStruct->itemData;
		return item->isHighlighted() ? m_colorHighlight : GetSysColor(COLOR_MENU);
	}
	const COLORREF& GetColorShort() const{return m_colorShort;}
	const COLORREF& GetColorLong() const{return m_colorLong;}
	const COLORREF& GetColorFlat() const{return m_colorFlat;}
	const COLORREF& GetColorHighlight() const{return m_colorHighlight;}
	virtual void DestroyItem(const void* item) const override;//{delete (PositionMenuItem*)item;}
protected:
	virtual void AddMenuItems(CMenu& menu) override;
	virtual void SetItemChecked(void* item, unsigned int i, bool checked) override{((PositionMenuItem*)item)->SetChecked(checked);}
	virtual void DoDrawItem(const DRAWITEMSTRUCT* lpDrawItemStruct, const CRect& drawItemRect) override
	{
		const PositionMenuItem* item = (const PositionMenuItem*)lpDrawItemStruct->itemData;

		const std::string& text = item->GetText();
		SetBkMode(lpDrawItemStruct->hDC, TRANSPARENT);

		CRect r(drawItemRect);
		r.left += 2;

//		HGDIOBJ oldFont = lpDrawItemStruct->itemID == m_itemBold && m_fontBold ? SelectObject(lpDrawItemStruct->hDC, *m_fontBold) : NULL;
		const COLORREF oldTextColor = SetTextColor(lpDrawItemStruct->hDC, GetStringColor(lpDrawItemStruct));

		DrawText(lpDrawItemStruct->hDC, text.c_str(), -1, &r, DT_LEFT|DT_VCENTER|DT_SINGLELINE|DT_NOCLIP|DT_NOPREFIX);

		SetTextColor(lpDrawItemStruct->hDC, oldTextColor);

//		if(oldFont)SelectObject(lpDrawItemStruct->hDC, oldFont);
	}
	COLORREF m_colorLong;
	COLORREF m_colorShort;
	COLORREF m_colorFlat;
	COLORREF m_colorHighlight;
};

class TGUI_API DialogPositionStock : public DialogReset
{
public:
	DialogPositionStock(TakionMainWnd* mainWnd, bool toDestroyOnFocus = false, TakionTool* receipient = NULL, CWnd* parent = NULL);
	void Display(TakionTool* receipient, unsigned int code, const Account* account, bool inventoryView, CWnd* parent, const CPoint& mousePoint);
	virtual HWND GetFirstTabControl() const override;
	virtual bool DoReset() override;
	virtual bool isChanged() const override;
protected:
	virtual BOOL PreTranslateMessage(MSG* pMsg) override;
	virtual void DoDataExchange(CDataExchange* pDX) override;
	virtual void DoApply() override;
	virtual BOOL OnInitDialog() override;
	virtual void Resize(bool widthChanged = true, bool heightChanged = true) override;
	virtual void FinishDialog(int result) override;
	virtual void BeforeShow() override;

	virtual void ToolTipsEnabled(bool enable) override;

	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnSearch();
	afx_msg void OnSearchChange();
	LRESULT OnPositionStockChecked(WPARAM w, LPARAM l);
	DECLARE_MESSAGE_MAP()

	ListBoxPositionStock m_ListBoxPositionStock;
	EditNoContext m_EditSearch;
	CButton m_ButtonSearch;

	int m_lbWidth;
	int m_lbHeight;
	int m_lbBorderSize;
	int m_controlHeight;
	int m_controlWidth;
	int m_clientWidth;
	int m_buttonWidth;
	int m_buttonHeight;
	std::string m_searchString;
	bool m_searchDone;

	void MoveControls(bool moveDialog);
};

class TGUI_API InventoryValue
{
public:
	InventoryValue(const int& inventorySize, const Price& inventoryCost, const bool& inventoryFloating, const bool& checked):
		m_inventoryCost(inventoryCost),
		m_inventorySize(inventorySize),
		m_inventoryFloating(inventoryFloating),
		m_checked(checked)
	{}
	InventoryValue():
		m_inventorySize(0),
		m_inventoryFloating(false),
		m_checked(false)
	{}
	virtual ~InventoryValue(){}
	const int& GetInventorySize() const{return m_inventorySize;}
	bool SetInventorySize(const int& inventorySize)
	{
		if(inventorySize != m_inventorySize)
		{
			m_inventorySize = inventorySize;
			return true;
		}
		return false;
	}
	void IncrementInventorySize(const int& inventorySize){m_inventorySize += inventorySize;}
	void DecrementInventorySize(const int& inventorySize){m_inventorySize -= inventorySize;}

	const Price& GetInventoryCost() const{return m_inventoryCost;}
	bool SetInventoryCost(const Price& inventoryCost)
	{
		if(inventoryCost != m_inventoryCost)
		{
			m_inventoryCost = inventoryCost;
			return true;
		}
		return false;
	}

	const bool& isInventoryFloating() const{return m_inventoryFloating;}
	bool SetInventoryFloating(const bool& inventoryFloating)
	{
		if(inventoryFloating != m_inventoryFloating)
		{
			m_inventoryFloating = inventoryFloating;
			return true;
		}
		return false;
	}

	const bool& isChecked() const{return m_checked;}
	void SetChecked(const bool& checked){m_checked = checked;}

	void SetValues(const int& inventorySize, const Price& inventoryCost, const bool& inventoryFloating, const bool& checked)
	{
		m_inventoryCost = inventoryCost;
		m_inventorySize = inventorySize;
		m_inventoryFloating = inventoryFloating;
		m_checked = checked;
	}
	bool operator==(const InventoryValue& other) const
	{
		return m_inventoryCost == other.m_inventoryCost
			&& m_inventorySize == other.m_inventorySize
			&& m_inventoryFloating == other.m_inventoryFloating
			&& m_checked == other.m_checked;
	}
	bool operator!=(const InventoryValue& other) const{return !operator==(other);}
protected:
	Price m_inventoryCost;
	int m_inventorySize;
	bool m_inventoryFloating;
	bool m_checked;
};


class LinkExternalManual;
class LinkOtherTakion;

#define DELETE_FILTER_DIALOGS

class TGUI_API TakionMainWnd : public MainMessageLoopWnd, public Observer//, public TakionFrame
{
friend class StopExitWnd;
friend class TakionTool;
friend class DialogTextEntry;
friend class DialogTextEntryHandleCommand;
friend class TakionConfig;
friend class DialogSymbolFilter;
friend class DialogListView;
friend class PositionWindow;
friend class AccountWindow;
#ifndef TAKION_NO_OPTIONS
friend class DialogOptionStuck;
#endif
#ifdef DELETE_FILTER_DIALOGS
friend class DialogMarketSorterFilter;
#endif

public:
	virtual ~TakionMainWnd();

	virtual const char* GetWindowName() const override{return "TakionMainWnd";}

	static const char* GetTakionMainFrameClassName(){return takionMainFrameClassName.c_str();}
	static void FillExePath(char* buf, const unsigned int buflen, const char* exePathEnd = NULL);
	static void FillFilePathOrExePath(char* buf, const unsigned int buflen, const std::string* filePath, const char* exePathEnd = NULL);

	static const unsigned int maxHiLoFlashSecond = 5;
	static const unsigned int backupCount = 20;

	static void ClearCustomColors(COLORREF* cursor, unsigned int arrayLength)
	{
		for(; arrayLength; --arrayLength, ++cursor)
		{
			*cursor = RGB(255, 255, 255);
		}
	}
	static void InitCustomColors(COLORREF* cursor, unsigned int arrayLength, const VectorSetting<UIntHexSetting>& customColors);
	static void UpdateCustomColors(VectorSetting<UIntHexSetting>& customColors, const COLORREF* colors, const unsigned int arrayLength);

	void InitPositionKeyCheckedCollection(const Account* account, const bool inventoryView);//, CheckedOpenPositionMap& checkedPositionMap)

	const char* GetActiveStockSymbol() const;

//	bool MapCommandInSettings(const Command* command);
	bool MapKeyCommandInSettings(const KeyCommandPair* kcPair);
	bool FindCommandInSettings(const Command* command);
	virtual bool GetCommandTab(const Command* command, std::string& tab) const{return false;}

	virtual bool FindKeyInSettings(const Key& key);

	virtual bool ShowNewsUrl(const std::string& url) const{return false;}

	virtual void GetGtcOrdersFilePath(std::string& filePath) const{filePath.clear();}
	virtual void GetGtcSpidersFilePath(std::string& filePath) const{filePath.clear();}
	bool GtcOrdersFileExists(std::string* filePath = NULL) const;
	bool GtcSpidersFileExists(std::string* filePath = NULL) const;

	virtual HINSTANCE GetUiHInstance() const override;

//Temp Tier Size
#ifndef TAKION_NO_OPTIONS
	typedef CMap<OptionSymbolKey, const OptionSymbolKey&, unsigned int, unsigned int> TierSizeMap;
#else
	typedef CMap<unsigned __int64, const unsigned __int64&, unsigned int, unsigned int> TierSizeMap;
#endif
	const TierSizeMap& GetTierSizeMap() const{return m_tierSizeMap;}
	TierSizeMap& GetTierSizeMap(){return m_tierSizeMap;}
	bool AddTierSize(const unsigned __int64& symbol,
#ifndef TAKION_NO_OPTIONS
		const unsigned __int64& optionKey,
#endif
		unsigned int tierSize);
	bool RemoveTierSize(const unsigned __int64& symbol
#ifndef TAKION_NO_OPTIONS
		,const unsigned __int64& optionKey
#endif
		);
	void ClearTempTierSizes()
	{
		if(m_tierSizeMap.GetCount())
		{
			m_tierSizeMap.RemoveAll();
			TempTierSizesRemoved();
		}
	}
	unsigned int FindTierSize(const unsigned __int64& symbol
#ifndef TAKION_NO_OPTIONS
		,const unsigned __int64& optionKey
#endif
		) const
	{
		const TierSizeMap::CPair* found = m_tierSizeMap.PLookup(
#ifndef TAKION_NO_OPTIONS
			OptionSymbolKey(symbol, OptionKey(optionKey))
#else
			symbol
#endif
			);
		return found ? found->value : 0xFFFFFFFF;
	}
	void UpdateRememberTempTier();

	typedef std::map<std::string, OrderSizeAggregate*> NamedOrderSizeMap;
	NamedOrderSizeMap& GetNamedOrderSizeAggregate(){return m_namedOrderSizeMap;}
	const OrderSizeAggregate* FindNamedOrderSize(const std::string& name) const;
	void NamedOrderSizeChanged(const OrderSizeAggregate* orderSize);
	void NamedOrderSizeDeleted(const OrderSizeAggregate* orderSize);

	typedef std::map<std::string, OrderPriceAggregate*> NamedOrderPriceMap;
	NamedOrderPriceMap& GetNamedOrderPriceAggregate(){return m_namedOrderPriceMap;}
	const OrderPriceAggregate* FindNamedOrderPrice(const std::string& name) const;

	void NamedOrderPriceChanged(const OrderPriceAggregate* orderPrice);
	void NamedOrderPriceDeleted(const OrderPriceAggregate* orderPrice);

	typedef std::vector<OrderSize*> OrderSizeVector;
	const OrderSizeVector& GetOrderSizeCopy() const{return m_orderSizeCopy;}
	unsigned int GetOrderSizeCopyCount() const{return (unsigned int)m_orderSizeCopy.size();}
	void ClearAndDestroyOrderSizeCopy();
	void AddOrderSizeCopy(const OrderSize* orderSize);

	typedef std::vector<OrderPrice*> OrderPriceVector;
	const OrderPriceVector& GetOrderPriceCopy() const{return m_orderPriceCopy;}
	unsigned int GetOrderPriceCopyCount() const{return (unsigned int)m_orderPriceCopy.size();}
	void ClearAndDestroyOrderPriceCopy();
	void AddOrderPriceCopy(const OrderPrice* orderPrice);

//	typedef std::map<std::string, const Account*> StringAccountMap;
	AccountOrderedMap* const& GetAccountMap(){return m_accountMap;}
	const AccountOrderedMap* const& GetAccountMap() const{return m_accountMap;}

	virtual bool isNewsDllCompatible() const{return true;}
	bool UpdateBkColor();

	virtual bool CanLoadAllAccountOrdersAndExecutions() const{return false;}
	virtual bool AreAllAccountOrdersLoading() const{return false;}
	virtual bool AreAllAccountExecutionsLoading() const{return false;}
	virtual bool LoadAllAccountOrdersAndExecutions(bool orders, bool executions){return false;}

	virtual Account* GetDefaultAccount() const{return NULL;}
	void SetDefaultAccountAsCurrent()
	{
		Account* account = GetDefaultAccount();
		if(account)SetCurrentAccount(account);
	}
//	Account* GetCurrentAccount(){return m_currentAccount;}
	const Account* GetCurrentAccount() const{return m_currentAccount;}
	Account* GetCurrentAccount(){return m_currentAccount;}
	void SetCurrentAccount(Account* account);
	virtual void SetAccountById(const char* id)
	{
		Account* account = FindAccountByStr(id);
		if(account)
		{
			SetCurrentAccount(account);
		}
	}

	const Account* GetCommandWindowCurrentAccount() const
	{
		return m_activeCommandTool ? m_activeCommandTool->GetCurrentAccount() : m_currentAccount;
	}

	void MakeAllWindowsOnTop(bool onTop);
	void MakeAllWindowsLocked(bool locked);

	bool GetDisconnectedBasePrice(Price& basePrice, char side) const;

	const unsigned int& GetCurrentOcoId() const{return m_currentAccount ? m_currentAccount->GetCurrentOcoId() : InventoryData::uintZero;}
	void SetNextOcoId(){if(m_currentAccount)m_currentAccount->SetCurrentOcoId(0);}
	void SetOcoId(const unsigned int& ocoId){if(m_currentAccount)m_currentAccount->SetCurrentOcoId(ocoId);}
	void ResetOcoId(){if(m_currentAccount)m_currentAccount->ResetCurrentOcoId();}

	ConnectionStatus GetConnectionStatus() const{return m_connectionStatus;}
	bool SetConnectionStatus(ConnectionStatus connectionStatus);

	const unsigned char& GetEsignalLinkGroup() const{return m_esignalLinkGroup;}
	const unsigned char& GetEsignalLinkId() const{return m_esignalLinkId;}

	const unsigned char& GetBloombergLinkGroup() const{return m_bloombergLinkGroup;}
	const unsigned char& GetBloombergLinkId() const{return m_bloombergLinkId;}
	const bool& isBloombergDllLoaded() const{return m_bloombergDllLoaded;}

	static const unsigned char esignalGroupCount = 14;

	typedef std::set<TakionTool*> Tools;
	Tools* GetWindowGroup(const unsigned char& group){return group <= esignalGroupCount ? m_toolGroups + group : NULL;}
	void AddToolToGroup(TakionTool* tool)
	{
		const unsigned char group = tool->GetLinkGroup();
		if(group <= esignalGroupCount)m_toolGroups[group].insert(tool);
	}
	void RemoveToolFromGroup(TakionTool* tool)
	{
		const unsigned char group = tool->GetLinkGroup();
		if(group <= esignalGroupCount)m_toolGroups[group].erase(tool);
	}

	const unsigned char& GetTakionLinkId() const{return m_takionLinkId;}

	const bool& isExtLinkWaitRefresh() const{return m_extLinkWaitRefresh;}
	const bool& isExtLinkRecipient() const{return m_extLinkRecipient;}

#ifdef EXT_LINK_USE_DBL_CLK_TO_ERASE
	const CPoint* GetPointExtLinkSimulateDoubleClick() const{return m_extLinkPointSimulateDoubleClick;}
	const CPoint* GetPointExtLinkSimulateDoubleClick(const char& at) const{return at < ELSDC_Count ? m_extLinkPointSimulateDoubleClick + at : NULL;}
	void SetPointExtLinkSimulateDoubleClick(const char& at, const CPoint& point){if(at < ELSDC_Count)m_extLinkPointSimulateDoubleClick[at] = point;}
	void SetPointExtLinkSimulateDoubleClick(const CPoint* ptCursorSrc)
	{
		CPoint* ptCursor = m_extLinkPointSimulateDoubleClick;
		for(unsigned char j = 0; j < ELSDC_Count; ++j, ++ptCursor, ++ptCursorSrc)
		{
			*ptCursor = *ptCursorSrc;
		}
	}
#endif
	void PassKeyStrokeAndCommandToExtensions(unsigned char key, unsigned char modifier, bool repeat, Command* c);
	void PassSymbolTypedToExtensions(const char* symbol, unsigned char securityType, bool valid, bool fromKeyboard, unsigned int ordinal);
	void PassSecurityRefreshedToExtensions(const char* symbol, const Security* security, bool wasLoaded, unsigned int ordinal);
	void PassActiveMmBoxChangedToExtensions(const char* symbol, const Security* security, bool wasLoaded, unsigned int ordinal);
	bool PassMainThreadIdleStateToExtensions(unsigned int idleCount, bool takionIdleDone);
	virtual void PassMainThreadAvailableDataProcessedToExtensions();
//	void CallExtensionMessageReport(unsigned char connectionType, const Message* message, bool outgoing);

	virtual void LoadRsiMhData(const bool load){}
	virtual const Price* FindRsiMhPriceArray(const unsigned __int64& numericSymbol, unsigned short& size, bool& loaded) const{return NULL;}

	virtual void LoadRsiDaysData(const bool load){}
	virtual const Price* FindRsiDaysPriceArray(const unsigned __int64& numericSymbol, unsigned short& size, bool& loaded) const{return NULL;}

	void MarketSorterNotifyAdded(const MarketSorterWindow* ms);
	void MarketSorterNotifyRemoved(const MarketSorterWindow* ms);
	void MarketSorterNotifyPrefixChanged(const MarketSorterWindow* ms, const char* from);
	void NotifyMarketSorterSymbol(const MarketSorterWindow* ms, const Security* security, const bool added);
	void MarketSorterNotifyAllRowsRemoved(const MarketSorterWindow* ms);

	bool isCloseDialogsOnEscape() const{return m_configBase->m_closeDialogsOnEscape.GetValue();}
	virtual void CloseOrderBoxIfDisplayed();
	virtual bool isDialogOrderVisible() const{return false;}
	static const bool falseValue;
	static const bool trueValue;
#ifdef FIRM_VALUES
//	virtual const bool& CanSeeFirmPositions() const{return falseValue;}//m_canSeeFirmPositions;}//falseValue;}
	const bool& CanSeeFirmPositions() const{return m_canSeeFirmPositions;}
	virtual TakionIterator* CreateAccountAggregatorIterator() const{return NULL;}
	virtual void LockAccountAggregatorStorage() const{}
	virtual const AccountAggregator* GetNextAccountAggregator(TakionIterator* iterator) const{return NULL;}
	virtual void UnlockAccountAggregatorStorage() const{}
	virtual const AccountAggregator* FindAccountAggregator(const AccountAggregatorId& accountAggregatorId){return NULL;}
	void AddFirmPositionWnd(FirmPositionWindow* tool);//{m_firmPositionWnds.AddObject(tool);}
	void RemoveFirmPositionWnd(FirmPositionWindow* tool);//{m_firmPositionWnds.RemoveObject(tool);}
	virtual void UpdateCanSeeFirmPositions();
#endif
	virtual void UpdateTitleValues(ValueType valueType){}

	virtual unsigned int GetLocMocMillisecond() const{return 0;}

//	virtual unsigned int GetNsdqLocMocMillisecond() const{return 0;}
	virtual unsigned int GetNsdqMocMillisecond() const{return 0;}
	virtual unsigned int GetNsdqLocMillisecond() const{return 0;}

	virtual unsigned int GetNsdqLooMooMillisecond() const{return 0;}

//	virtual bool isVersionValid() const{return true;}

	virtual const Command* FindCommandForDialogOrderOnly(const std::string& name) const{return NULL;}
	virtual Command* FindCommandForDialogOrderOnly(const std::string& name){return NULL;}

	virtual const bool& isUserSupervisor() const{return falseValue;}
	virtual const bool& isUserSupervisorLive() const{return falseValue;}
	virtual const bool& isUserSupervisorInSimulation() const{return falseValue;}
	virtual unsigned int GetUserTypeLive() const{return 0;}
	virtual unsigned int GetUserTypeInSimulation() const{return 0;}
	virtual unsigned int GetUserType() const{return 0;}
	virtual bool isSimulation() const{return true;}
	virtual bool isPreMarket() const{return false;}
	virtual bool isMarketOpen() const{return true;}
	virtual bool isMarketClosedForTheDay() const{return false;}
	virtual unsigned char GetMarketState() const{return MSTATE_MARKET;}
	virtual unsigned short GetCloseMarketMinute() const{return 960;}
	bool isLogAppActivate() const{return m_logAppActivate && (m_logAppActivate == 1 || isMarketClosedForTheDay());}
	virtual bool isSortBySize() const{return false;}
	virtual bool isHideSlowQuotes() const{return false;}
	virtual const unsigned char* GetBookSortRank() const{return NULL;}

	virtual const unsigned int* GetLineCount(bool open) const{return NULL;}
	virtual const unsigned int* GetExchangeFilterMask(bool open) const{return NULL;}

	virtual void AddCustomPriceBaseToNumericSymbol(const unsigned __int64& numericSymbol,
#ifndef TAKION_NO_OPTIONS
		const unsigned __int64& optionKey,
#endif
		unsigned int compactPrice) const{}

	virtual void RemoveCustomPriceBaseFromNumericSymbol(const unsigned __int64& numericSymbol
#ifndef TAKION_NO_OPTIONS
		, const unsigned __int64& optionKey
#endif
		) const{}

	virtual void AddCustomDateToNumericSymbol(const unsigned __int64& numericSymbol,
#ifndef TAKION_NO_OPTIONS
		const unsigned __int64& optionKey,
#endif
		unsigned int date) const{}

	virtual void RemoveCustomDateFromNumericSymbol(const unsigned __int64& numericSymbol
#ifndef TAKION_NO_OPTIONS
		, const unsigned __int64& optionKey
#endif
		) const{}

	virtual TakionIterator* CreateAccountIterator() const{return NULL;}
	virtual void LockAccountStorage() const{}
	virtual Account* GetNextAccount(TakionIterator* iterator) const{return NULL;}
	virtual void UnlockAccountStorage() const{}

	virtual Account* FindAccount(const AccountId& id){return NULL;}
	
	Account* FindAccountByStr(const char* const& id){return FindAccount(AccountId(id));}

	virtual unsigned int GetOrderSizeAbsoluteCap() const{return 0;}

	virtual TakionIterator* CreateDestinationIterator() const{return NULL;}
	virtual const Destination* GetNextDestination(TakionIterator* iterator) const{return NULL;}

	virtual void CancelReplaceOrderWithAdjustment(Order* order, int x, int y,
		bool replaceNative,
		const SignedPrice& replacePriceOffset,
		bool replacePriceOffsetPercent,
		bool replacePriceReverseForSell,
		bool marketOrder,
		int replaceSizeOffset,
		bool replaceSizeReverseForSell,
		bool preBorrow,
		const Price& preBorrowPrice,
		unsigned char displaySizeMode,//0 - size fraction, 1 - round lot, 2 - no change
		unsigned int displaySize,
		unsigned int displaySizeFraction)
	{}

	virtual const char* GetCommandToolClassName() const{return defaultClassName.c_str();}

	virtual void toString(std::string& str, unsigned int contentModifier) const override;
	virtual void fromString(const char*& cursor, unsigned __int64 version, bool clone, unsigned int contentModifier) override;
	virtual void fromScratch() override;

	virtual Observable* GetExtensionObservable(){return NULL;}

	virtual bool isMarketSorterLoaded() const{return false;}
	virtual bool isAllAccountsLoaded() const{return true;}
	virtual void WriteMessageToMainThread(const Message* message){}
	virtual Observable* GetNewEquityObservable(){return NULL;}
	virtual Observable* GetNewRsiObservable(){return NULL;}
	virtual Security* FindSortableEquity(const char* symbol) const{return NULL;}
	virtual Security* FindSortableEquityByNumericSymbol(const unsigned __int64& symbol) const{return NULL;}
	virtual Security* FindSortableEquityWithNoIncrementUnsubscribe(const char* symbol) const{return NULL;}
	virtual Security* FindSortableEquityByNumericSymbolWithNoIncrementUnsubscribe(const unsigned __int64& symbol) const{return NULL;}
	virtual Security* ObtainSortableEquity(const char* symbol, bool subscribe = true) const{return NULL;}
	virtual Security* ObtainSortableEquityByNumericSymbol(const unsigned __int64& symbol, bool subscribe = true) const{return NULL;}
	virtual Index* FindIndex(const char* symbol) const{return NULL;}
	virtual Security* FindStock(const char* symbol) const{return NULL;}
	virtual Security* ObtainStock(const char* symbol, bool subscribe) const{return NULL;}
	virtual Security* FindStockByNumericSymbol(const unsigned __int64& symbol) const{return NULL;}
	virtual Security* FindStockByNumericSymbolWithNoIncrementUnsubscribe(const unsigned __int64& symbol) const{return NULL;}
	virtual Security* ObtainStockByNumericSymbol(const unsigned __int64& symbol, bool subscribe) const{return NULL;}
	virtual void ReleaseStock(const Security* security) const{}

#ifndef TAKION_NO_OPTIONS
	static const unsigned int optionSuffixCount = 64;
	virtual Underlier* ObtainUnderlier(const char* symbol, bool subscribe) const{return NULL;}
	virtual void ReleaseUnderlier(const Underlier* underlier) const{}
//	virtual Security* FindOptionByUnderlierSymbol(const char* underlierSymbol, const OptionKey& optionKey) const{return NULL;}
	virtual Security* FindOptionByUnderlierSymbol(const char* underlierSymbol, const OptionSymbolKey& optionKey) const{return NULL;}
	virtual Security* ObtainOptionByUnderlierSymbol(const char* underlierSymbol, const OptionKey& optionKey, bool subscribe) const{return NULL;}
//	virtual Security* FindOptionByUnderlierNumericSymbol(const unsigned __int64& underlierSymbol, const OptionKey& optionKey) const{return NULL;}
	virtual Security* FindOptionByUnderlierNumericSymbol(const unsigned __int64& underlierSymbol, const OptionSymbolKey& optionKey) const{return NULL;}
	virtual Security* ObtainOptionByUnderlierNumericSymbol(const unsigned __int64& underlierSymbol, const OptionKey& optionKey, bool subscribe) const{return NULL;}
	virtual Security* FindOptionByRootNumericSymbol(const unsigned __int64& rootSymbol, const unsigned __int64& optionBlock) const{return NULL;}
	virtual Security* ObtainOptionByRootNumericSymbol(const unsigned __int64& rootSymbol, const OptionKey& optionKey, bool subscribe) const{return NULL;}
	virtual Security* FindOptionByRootNumericSymbolWithNoIncrementUnsubscribe(const unsigned __int64& rootSymbol, const unsigned __int64& optionBlock) const{return NULL;}
	void UpdateOptionAlignTitleValues();
	void UpdateOptionTitleValueCollection();
	void UpdateOptionColors();
	void UpdateOptionChainAlignTitleValues();
	void UpdateOptionChainTitleValueCollection();
	void UpdateOptionChainColors();

//	bool SetStockOptionByParamsInCommandTool(const char* symbol, const OptionKey& optionKey, unsigned char basket, bool force, unsigned int ordinal = 0xFFFFFFFF)
	bool SetStockOptionByParamsInCommandTool(const char* symbol, const OptionSymbolKey& optionKey, unsigned char basket, bool force, unsigned int ordinal = 0xFFFFFFFF)
	{
		const Security* security = FindOptionByUnderlierSymbol(symbol, optionKey);
		return security && SetStockOptionInCommandTool(security, basket, force, ordinal);
	}
	virtual bool SetStockOptionInCommandTool(const Security* security, unsigned char basket, bool force, unsigned int ordinal = 0xFFFFFFFF);

	DialogOptionSorterFilter* GetOptionSorterFilterDialog();//{return m_optionSorterFilterDialog;}
	DialogOptionChainFilter* GetOptionChainFilterDialog();//{return m_optionChainFilterDialog;}
	const int& GetOptionFilterMenuWidth() const{return m_optionFilterMenuWidth;}

	virtual bool HasTradingCommandsWithFilteredOptions(bool optionsFilteredIn) const;//Trading Commands that includes / exclude Options
	virtual unsigned char HasTradingCommandsWithOptionsFilteredInOut() const;//1 - there are Trading Commands that include Options | 2 - there are Trading Commands that exclude Options
	virtual void IncludeOptionsInAllCommands(bool exclude);
//	bool HasTradingCommandsWithNoOptions() const{return HasTradingCommandsWithFilteredOptions(false);}//Trading Commands that exclude Options
//	bool HasTradingCommandsWithOptions() const{return HasTradingCommandsWithFilteredOptions(true);}//Trading Commands that include Options
#endif
	typedef StrAsNumberArray<size_t, 24 / sizeof(size_t)> NamedValueId;
	typedef CMap<NamedValueId, const NamedValueId&, NamedValue*, NamedValue*&> NamedValueMap;

	const NamedValueMap& GetLevel1ValueMap() const{return m_level1ValueMap;}
	const NamedValue* FindLevel1Value(const NamedValueId& name) const;
	NamedValue* FindLevel1Value(const NamedValueId& name);
	const NamedValue* FindLevel1Value(const std::string& name) const{return FindLevel1Value(NamedValueId(name));}
	NamedValue* FindLevel1Value(const std::string& name){return FindLevel1Value(NamedValueId(name));}

	typedef CMap<unsigned __int64, const unsigned __int64&, unsigned int, unsigned int&> UInt64CountMap;
	const UInt64CountMap& GetOpenBasketMap() const{return m_openBasketMap;}
	unsigned int OpenBasketContains(const unsigned __int64& numericSymbol) const
	{
		const UInt64CountMap::CPair* found = m_openBasketMap.PLookup(numericSymbol);
		return found ? found->value : 0;
	}
	bool OpenBasketRemoveSymbol(const unsigned __int64& numericSymbol)
	{
		UInt64CountMap::CPair* found = m_openBasketMap.PLookup(numericSymbol);
		if(found)
		{
			if(found->value > 1)--found->value;
			else
			{
				m_openBasketMap.RemoveKey(numericSymbol);
				return true;
			}
		}
		return false;
	}
	bool OpenBasketClear()
	{
		if(!m_openBasketMap.IsEmpty())
		{
			m_openBasketMap.RemoveAll();
			return true;
		}
		return false;
	}
	bool OpenBasketAddSymbol(const unsigned __int64& numericSymbol)
	{
		UInt64CountMap::CPair* found = m_openBasketMap.PLookup(numericSymbol);
		if(found)
		{
			++found->value;
			return false;
		}
		else
		{
			m_openBasketMap[numericSymbol] = 1;//.SetAt(numericSymbol, 1uint);
			return true;
		}
	}
	void UpdateOpenBasketChange(bool remove);

	virtual const char* GetSettingsTabPath(const CPoint& point) const override;
//	virtual void* GetSettingsTabInitInfo(const CPoint& point) const{return NULL;}
	virtual const void* GetGraphicsTabInitInfo(const CPoint& point) const override;

	virtual bool isTradingLocked() const{return false;}
	virtual void ToggleLockTrading(){}

	virtual bool isDefaultOnlyTradingAllowed() const{return true;}
	bool isDefaultOnlyTradingAllowedOrOneAccount() const{return isDefaultOnlyTradingAllowed() || GetAccountCount() < 2;}
	virtual void ToggleDefaultOnlyTrading(){}

	virtual ExtensionDll* CreateExtensionObject(const char* absolutePath) const{return NULL;}
	bool LoadExtension(ExtensionDll* extension, bool existing, CWnd* errorMessageParentWnd = NULL);
	bool LoadExtensionByPath(const std::string& path, ExtensionWindow* fromExtensionWindow, const bool load);
	bool UnloadExtension(ExtensionDll* extension);
	bool UnloadExtensionByPath(const std::string& path);
	void LoadTakionFolderExtensions(const bool load);
	void LoadAutoExtensions(const bool load);
	bool MakeExtensionAutoLoad(const std::string& absolutePath, std::string* error, const bool load);
	bool RemoveExtensionAutoLoad(const std::string& absolutePath, std::string* error);
	bool ClearExtensionAutoLoad(std::string* error);
	void SelectExtension(const char* absolutePath);
	unsigned char isExtensionAutoLoad(const std::string& absolutePath) const;
	unsigned char isExtensionAutoLoad(const ExtensionDll* extension) const;
//	void SetBkColor(COLORREF color);

	void ShowNewsStory(const std::string& story, const char* title, bool storyError);
	bool ShowWorkspaceNewsStoryWindows(bool hide);
	bool HasVisibleStoryWindow() const;
	void ShowNewsStoryInVisibleWindows(const std::string& story, const char* title, bool error);

	void CloseAllNewsContentsWindows(bool workspaceOnly);
	void ToggleWorkspaceNewsContentsWindows();

	int GetWorkspaceRight() const{return m_workspaceResizor.GetRect().left - m_clientRect.left;}
	int GetToolboxLeft() const{return m_clientRect.right - m_toolboxResizor.GetRect().right;}
	int GetTitleBottom() const{return m_titleResizor.GetRect().top - m_clientRect.top;}
	int GetValueLeft() const{return m_valueResizor.GetRect().left - m_workspaceResizor.GetRect().right;}

	bool CalculateWorkRect(int& dx, int& dy);
//	const bool& isLocked() const{return m_locked;}
	virtual void SetLocked(const bool& locked) override;
	void ToggleLocked(){SetLocked(!m_locked);}
	const bool& isAlphabetizeWindowsInMenu() const{return m_alphabetizeWindowsInMenu;}
	const bool& isApplicationActive() const{return m_applicationActive;}
	bool isPaintAsActive() const{return m_applicationActive && m_modalList.empty();}
	const bool& isExiting() const{return m_exiting;}
	const bool& isToolboxPressed() const{return m_toolboxPressed;}

#if (_MSC_VER > 1600)
	typedef std::unordered_map<HMODULE, ExtensionDll*> ModuleExtensionMap;
	typedef std::unordered_map<std::string, ExtensionDll*> ExtensionMap;
#else
	typedef std::hash_map<HMODULE, ExtensionDll*> ModuleExtensionMap;
	typedef std::hash_map<std::string, ExtensionDll*> ExtensionMap;
#endif
	unsigned int GetIncompatibleExtensionCount() const{return (unsigned int)m_incompatibleExtensionMap.size();}
	const ModuleExtensionMap& GetIncompatibleExtensionMap() const{return m_incompatibleExtensionMap;}
	ModuleExtensionMap& GetIncompatibleExtensionMap(){return m_incompatibleExtensionMap;}
	ExtensionDll* FindIncompatibleExtension(const HMODULE hmodule)
	{
		ModuleExtensionMap::iterator found = m_incompatibleExtensionMap.find(hmodule);
		return found == m_incompatibleExtensionMapEnd ? NULL : found->second;
	}

	unsigned int GetLoadedExtensionCount() const{return (unsigned int)m_loadedExtensionMap.size();}
	const ModuleExtensionMap& GetLoadedExtensionMap() const{return m_loadedExtensionMap;}
	ModuleExtensionMap& GetLoadedExtensionMap(){return m_loadedExtensionMap;}
	ExtensionDll* FindLoadedExtension(const HMODULE hmodule)
	{
		ModuleExtensionMap::iterator found = m_loadedExtensionMap.find(hmodule);
		return found == m_loadedExtensionMapEnd ? NULL : found->second;
	}
	ExtensionDll* RemoveExtension(const HMODULE hmodule);

	const ExtensionMap& GetExtensionMap() const{return m_extensionMap;}
	ExtensionMap& GetExtensionMap(){return m_extensionMap;}
	ExtensionDll* FindExtension(const std::string& absolutePath)
	{
		ExtensionMap::iterator found = m_extensionMap.find(absolutePath);
		return found == m_extensionMapEnd ? NULL : found->second;
	}
	bool AddExtension(ExtensionDll* extension);
	ExtensionDll* RemoveExtension(const std::string& absolutePath);
	ExtensionDll* RemoveExtension(ExtensionDll* extension);
	void ClearExtensions();
	void UpdateExtensionRow(ExtensionDll* extension);
	void UpdateExtensionRow(HMODULE hmodule);
	void UpdateExtensionRow(const std::string& absolutePath);
	void UpdateAllExtensionRows();

//	const unsigned int& GetIdleInterruptCount() const{return m_idleInterruptCount;}
//	const unsigned int& GetIdleCount() const{return m_idleCount;}

	virtual LRESULT GetHitTest(const CPoint& point) const;
	virtual bool DoIdleTasks(LONG lCount);

	virtual int GetInitialLeft() const;
	virtual int GetInitialTop() const;
	virtual int GetInitialWidth() const;
	virtual int GetInitialHeight() const;

	virtual TakionTool* CreateTool(const char* id, const CBitmap* bitmap, CRect* rect, const char* cursor, bool clone = false, unsigned int contentModifier = 0, unsigned __int64 version = 0);
	virtual void OnToolDestroyed(TakionTool* tool);
	virtual void OnToolShown(TakionTool* tool);

	virtual bool CreateTakionWnd(const CRect* rect, bool adjustToScreen);

	virtual CMenu* GetSysMenu() const;

//	void GetOrderErrorAsString(std::string& error, const Account* account, const char* symbol, char side, bool borrow, unsigned int orderSize, unsigned char errorCode, const Money& moneyValue, const Money& moneyConstraint, unsigned int uintValue, unsigned int uintConstraint);
//	void GetCancelErrorAsString(std::string& error, const Account* account, const char* symbol, char side, unsigned int clientId, unsigned char errorCode, const Money& moneyValue, const Money& moneyConstraint, unsigned int uintValue, unsigned int uintConstraint);

	virtual void DisplayHardBuyingPowerHit(const Account* account, const Money& investment, const Money& hardBuyingPower, bool hardBpHit);
	virtual void DisplayHardMarginExcessHit(const Account* account, const Money& investment, const Money& hardMarginExcess, bool hardMeHit);
	virtual void DisplayAutoAction(const Account* account, const char* symbol,
#ifndef TAKION_NO_OPTIONS
		const unsigned __int64& optionBlock,
#endif
		bool close, const Money& moneyValue, const Money& moneyConstraint);
	void DisplayOrderError(const Account* account,
		const char* symbol,
		char side,
		bool borrow,
		unsigned int orderSize,
		unsigned char errorCode,
		const Money& moneyValue,
		const Money& moneyConstraint,
		unsigned int uintValue,
		unsigned int uintConstraint,
		unsigned int l1Bid,
		unsigned int l1Ask,
#ifdef FIRM_VALUES
		char firmSide = 0,
#endif
		unsigned int clientId = 0,
		std::string* errorStr = NULL);
	void DisplayCancelError(const Account* account,
		const char* symbol,
		char side,
		unsigned int clientId,
		unsigned char errorCode,
		const Money& moneyValue,
		const Money& moneyConstraint,
		unsigned int uintValue,
		unsigned int uintConstraint,
		unsigned int l1Bid,
		unsigned int l1Ask,
#ifdef FIRM_VALUES
		char firmSide = 0,
#endif
		std::string* errorStr = NULL);

	void DisplayCancelAlertError(const char* symbol,
		unsigned int l1Bid,
		unsigned int l1Ask,
		const std::string& errorText);

	virtual void ExecuteOrderInSimulation(Order* order){}

	virtual bool DisplayNewOrder(const Order* order);
	virtual bool DisplayCanceledOrder(const Order* order);
	virtual void DisplayExecution(const Execution* execution, bool executionInfo = false);
	virtual bool DisplayCancelRejected(const Order* order);
	void DisplayAdminBroadcastMessage(const char* text);
	void DisplayAdminMessage(const std::string& message);
	void DisplayFocusTakenMessage(const std::string& message);
	void AddPosManMessage(const unsigned __int64& numericSymbol,
		const char* symbol,
		const Price& bid,
		const Price& ask,
		unsigned int bidSize,
		unsigned int askSize,
		unsigned int printPrice,
		unsigned int printSize,
		unsigned int posPrice,
		int posSize,
		unsigned int posinventoryPrice,
		int posInventorySize,
		unsigned int lastExecPrice,
		int lastExecSize,
		unsigned int lastExecMmid,
		unsigned short roundLot,
		const std::string& message,
		PosManMessageType type,
		const std::string* inventoryMessage = NULL,
		PosManMessageType inventoryType = PMT_COUNT);
	void AddPosManMessage(const std::string& message, PosManMessageType type)
	{
		AddPosManMessage(0,
			NULL,
			Price::priceZero,
			Price::priceZero,
			0,//unsigned int bidSize,
			0,//unsigned int askSize,
			0,//unsigned int printPrice,
			0,//unsigned int printSize,
			0,//unsigned int posPrice,
			0,//int posSize,
			0,//unsigned int posInventoryPrice,
			0,//int posInventorySize,
			0,//unsigned int lastExecPrice,
			0,//int lastExecSize,
			0,//unsigned int lastExecMmid,
			1,//unsigned short roundLot
			message,
			type);
	}
	unsigned int GetPosManMessageCount() const;
	const PosManMessage* GetPosManMessageAt(unsigned int at) const;
	const PosManMessage* GetPosManMessageFromBack(unsigned int at) const;

	TakionTool* CreateClone(const TakionTool* tool);
	TakionTool* CreateToolCopy(const char* cursor, const CBitmap* bitmap, bool pinned, bool isClone, unsigned __int64 exeVersion, const CRect* toolRect);

	typedef std::map<ExecutionIdAsNumberArray, Price, lessStrAsNumberArrayAsStr<ExecutionIdAsNumberArray> > SPMap;
	typedef std::map<AccountId, SPMap, lessAccountIdAsStr> SSPMap;
	SSPMap& GetPositionCostMap(){return m_positionCostMap;}
//	const SPMap* FindAccountPositionCostMap(const std::string& id) const;
	const SPMap* FindAccountPositionCostMap(const AccountId& id) const;
	const SSPMap& GetPositionCostMap() const{return m_positionCostMap;}
	void SerializePositionCost(bool in, const char* fileName, const char* exeVersion, bool rememberFileName, unsigned int flags);
	void SaveCurrentPositionCost(const char* fileName);
	void SetPositionCost(const SSPMap& positionCostMap, bool clear, SSPMap& changedPositionCostMap);
	void SendPositionCost(const SSPMap& positionCostMap);
	void SetAndSendPositionCost(const SSPMap& positionCostMap, bool clear);

	typedef std::vector<ToolSet*> ToolCollectionVector;
	ToolSet* GetWorkspace(unsigned int i){return i < (unsigned int)m_workspaceVector.size() ? m_workspaceVector[i] : NULL;}
	ToolSet* GetLayer(unsigned int i){return i < (unsigned int)m_layerVector.size() ? m_layerVector[i] : NULL;}
	ToolSet* GetWorkspaceOrLayer(unsigned int i){return i < TakionTool::maxWorkspace ? GetWorkspace(i) : GetLayer(i - TakionTool::maxWorkspace);}
	void ClearWorkspaces();
	void DestroyWorkspaces();
	void SetWorkspace(unsigned int workspace);
	void SetLastWorkspace();
	void ToggleLayer(unsigned int layer);
	void ShowTools(unsigned int workspace, bool keepPinned);
//	void HideToolsExceptWorkspace(unsigned int workspace, bool keepPinned);
	void UpdateActiveTool();
//	unsigned int GetNextOrdinal(){return ++m_nextOrdinal;}

	void HideWindow(TakionTool* tool);
	void UnhideWindow(TakionTool* tool);
	bool WindowBelongs(TakionTool* tool) const;

	bool UnhideBelongingWindowWithNoActivation(TakionTool* tool);

	unsigned int GetWorkspaceCount() const{return (unsigned int)m_workspaceVector.size();}
	unsigned int GetLayerCount() const{return (unsigned int)m_layerVector.size();}

	void RestoreConfig();
	virtual void ApplyConfig(unsigned int flags, bool applyExternalValues);
	unsigned char SaveConfig(const std::string& fileNameStr, bool createBackup);//0 - error, 1 - saved, 2 - not saved because layout has not changed
	unsigned char SaveConfigAndDisplayError(const std::string& pathName, bool displayError, bool posManMessage, bool createBackup);//0 - error, 1 - saved, 2 - not saved because layout has not changed
	bool SaveConfigAndLog(const std::string& pathName, const char* prefix, bool createBackup);
	unsigned char SaveConfigAsAndDisplayError(bool displayError, bool posManMessage, bool createBackup);//0 - error, 1 - saved, 2 - not saved because layout has not changed

	virtual bool UpdateGraphics(const Graphics* graphics);

	TakionTool* GetActiveTool(){return m_activeTool;}
	void SetActiveTool(TakionTool* tool);

	CancelOrderWindow* GetActiveCancelOrderWindow(){return m_activeCancelOrderTool;}
	void SetActiveCancelOrderWindow(CancelOrderWindow* tool, bool cancelActive);

	AlertWindow* GetActiveCancelAlertWindow(){return m_activeCancelAlertTool;}
	void SetActiveCancelAlertWindow(AlertWindow* tool, bool cancelActive);

	TakionTool* GetActiveIncludeStockWindow(){return m_activeIncludeStockTool;}
	void SetActiveIncludeStockWindow(TakionTool* tool, bool includeStockActive);

	TakionTool* GetActiveExcludeStockWindow(){return m_activeExcludeStockTool;}
	void SetActiveExcludeStockWindow(TakionTool* tool, bool excludeStockActive);

	void SetActiveCommandTool(TakionTool* tool);
	TakionTool* GetActiveCommandTool(){return m_activeCommandTool;}
	const TakionTool* GetActiveCommandTool() const{return m_activeCommandTool;}

	const char* GetActiveStringSymbolPtr(unsigned char& basket) const
	{
		const TakionTool* tool = GetActiveCommandTool();
		return tool ? tool->GetStringSymbolPtr(basket) : NULL;
	}

	TakionTool* GetDefaultCommandTool(){return m_defaultCommandTool;}
	void SetDefaultCommandTool(TakionTool* tool);
	virtual void PropagateTempTierSize(unsigned int tierSize);
	virtual void PropagateActiveSymbol(const char* symbol, unsigned char basket, unsigned int ordinal);

	virtual void PropagateStockAddedToActiveBasket(const unsigned __int64& numericSymbol, unsigned int ordinal);
	virtual void PropagateStockRemovedFromActiveBasket(const unsigned __int64& numericSymbol, unsigned int ordinal);
	virtual void PropagateStocksClearedFromActiveBasket(unsigned int ordinal);

	virtual bool SetSymbolInActiveCommandTool(const char* symbol, unsigned char basket, bool force);
	virtual bool SetSymbolInCommandTool(const char* symbol, unsigned char basket, bool force, unsigned int ordinal = 0xFFFFFFFF);

//	virtual TakionTool* GetFirstCommandTool(){return NULL;}
	typedef std::vector<TakionTool*> ToolVector;
	void MoveToNextCommandTool(bool reverse);
	TakionTool* GetFirstCommandTool();

	const ToolSet& GetTools() const{return m_tools;}
	const ToolVector& GetCommandTools() const{return m_commandTools;}
	virtual unsigned int GetCommandToolCount() const{return (unsigned int)m_commandTools.size();}
	TakionTool* GetCommandToolAt(unsigned int at){return at < GetCommandToolCount() ? m_commandTools[at] : NULL;}

	const WindowSet& GetOtherTakionMainWnds() const{return m_otherTakionMainWnds;}
	void SendSymbolToWindowGroup(unsigned char group, const char* symbol);

	void ActivateTool();
	virtual bool ProcessKeyDown(unsigned char key, unsigned char modifier, bool repeat, TakionFrame* fromWindow) override;
	virtual bool ProcessKeyUp(unsigned char key, unsigned char modifier, TakionFrame* fromWindow) override;

	bool InvokeToggleCommand();

	const KeyCommandMapping& GetKeyCommandMapping() const{return m_keyCommandMapping;}
	KeyCommandMapping& GetKeyCommandMapping(){return m_keyCommandMapping;}

	virtual bool AddCommand(Command* command);
	virtual Command* RemoveCommand(const std::string& name);
	virtual Command* RenameCommand(Command* command, const char* newName);
	void DestroyCommands(){m_keyCommandMapping.DestroyCommands();}
	void ClearMapping(){m_keyCommandMapping.ClearMapping();}
	const Command* FindCommand(const std::string& name) const{return m_keyCommandMapping.FindCommand(name);}
	Command* FindCommand(const std::string& name){return m_keyCommandMapping.FindCommand(name);}
	virtual const Command* FindCommandAmongAll(const std::string& name) const{return FindCommand(name);}
	virtual Command* FindCommandAmongAll(const std::string& name){return FindCommand(name);}
	KeyCommandMapping::CommandMap& GetAllCommands(){return m_keyCommandMapping.GetAllCommands();}
	const KeyCommandMapping::CommandMap& GetAllCommands() const{return m_keyCommandMapping.GetAllCommands();}
	const Command* const* GetMappedCommands() const{return m_keyCommandMapping.GetMappedCommands();}
	Command** GetMappedCommands(){return m_keyCommandMapping.GetMappedCommands();}

	virtual void CommandAdded(Command* command);
	virtual void CommandRemoved(Command* command);
	virtual void BeforeCommandRenamed(Command* command, KeyCommandPair*& keyPair, KeyCommandPair*& keySelected, KeyCommandPair*& commandPair, KeyCommandPair*& commandSelected);
	virtual void CommandRenamed(Command* command, KeyCommandPair* keyPair, KeyCommandPair* keySelected, KeyCommandPair* commandPair, KeyCommandPair* commandSelected);
	virtual void CommandMapped(const Key& key, Command* command);
	virtual void CommandUnmapped(const Key& key, Command* command);

	KeyCommandMapping::KeySet& GetAllKeys(){return m_keyCommandMapping.GetAllKeys();}
	const KeyCommandMapping::KeySet& GetAllKeys() const{return m_keyCommandMapping.GetAllKeys();}
	KeyCommandMapping::KeySetSorted& GetAllKeysSorted(){return m_keyCommandMapping.GetAllKeysSorted();}
	const KeyCommandMapping::KeySetSorted& GetAllKeysSorted() const{return m_keyCommandMapping.GetAllKeysSorted();}

	bool MapCommand(const Key& key, Command* command, bool overridePreviousMapping = true){return m_keyCommandMapping.MapCommand(key, command, overridePreviousMapping);}
	bool UnmapCommand(Command* command){return m_keyCommandMapping.UnmapCommand(command);}
	bool UnmapCommandAndUpdateCommandTab(Command* command)
	{
		if(command)
		{
			const Key key = command->GetKey();
			if(UnmapCommand(command))
			{
				CommandUnmapped(key, command);
				return true;
			}
		}
		return false;
	}
	Command* UnmapKey(const Key& key){return m_keyCommandMapping.UnmapKey(key);}

	virtual Command* UnmapKeyCommand(const Key& key, const Command* command)
	{
		return UnmapKey(key);
	}
	bool UnmapKeyAndUpdateCommandTab(const Key& key, const Command* command)
	{
		Command* c = UnmapKeyCommand(key, command);
		if(c)
		{
			CommandUnmapped(key, c);
			return true;
		}
		return false;
	}
	virtual Command* GetMappedCommand(const Key& key){return m_keyCommandMapping.GetMappedCommand(key);}
	virtual Command* GetMappedCommandStrict(const Key& key){return m_keyCommandMapping.GetMappedCommandStrict(key);}

	Command* FindLeafSettingCommand(const TakionSettingDialog* leaf)
	{
		if(leaf)
		{
			std::string tabPath;
			leaf->GetTabPath(tabPath, "S");
			return FindCommand(tabPath);
		}
		return NULL;
	}
	bool MapLeafSettingCommandInSettings(const TakionSettingDialog* leaf)
	{
		Command* command = FindLeafSettingCommand(leaf);
		if(command)
		{
			return MapKeyCommandInSettings(&KeyCommandPair(command));
		}
		return false;
	}
	bool UnmapLeafSettingCommand(const TakionSettingDialog* leaf)
	{
		return UnmapCommandAndUpdateCommandTab(FindLeafSettingCommand(leaf));
	}

	typedef std::map<std::string, CommandAggregate*> AggregateCommandMap;
	AggregateCommandMap& GetAggregateCommandMap(){return m_aggregateCommandMap;}
	CommandAggregate* FindAggregateCommand(const std::string& name);

	typedef std::map<std::string, SymbolToActiveCommandWindowCommand*> SymbolToActiveCommandWindowCommandMap;
	SymbolToActiveCommandWindowCommandMap& GetSymbolToActiveCommandWindowCommandMap(){return m_symbolToActiveCommandWindowCommandMap;}
	SymbolToActiveCommandWindowCommand* FindSymbolToActiveCommandWindowCommand(const std::string& name);
	unsigned int GetSymbolToActiveCommandWindowCommandCount() const{return (unsigned int)m_symbolToActiveCommandWindowCommandMap.size();}
	const int& GetSymbolToCommandWindowMenuWidth() const{return m_symbolToCommandWindowMenuWidth;}

	typedef std::map<std::string, ActivateWindowCommand*> ActivateWindowCommandMap;
	ActivateWindowCommandMap& GetActivateWindowCommandMap(){return m_activateWindowCommandMap;}
	ActivateWindowCommand* FindActivateWindowCommand(const std::string& name);
	unsigned int GetActivateWindowCommandCount() const{return (unsigned int)m_activateWindowCommandMap.size();}
	const int& GetActivateWindowMenuWidth() const{return m_activateWindowMenuWidth;}

	typedef std::map<std::string, SymbolFilter*> NamedFilterMap;
	const NamedFilterMap& GetNamedFilterMap() const{return m_namedFilterMap;}
	const NamedFilterMap::const_iterator& GetNamedFilterMapEnd() const{return m_namedFilterMapEnd;}

//	NamedFilterMap& GetNamedFilterMap(){return m_namedFilterMap;}
	void ClearAndDestroyNamedFilters();
	unsigned int GetNamedFilterCount() const{return (unsigned int)m_namedFilterMap.size();}
	bool AddNamedFilter(const std::string& name, SymbolFilter* filter);
	SymbolFilter* RemoveNamedFilter(const std::string& name);
	bool RemoveAndDestroyNamedFilter(const std::string& name);
	SymbolFilter* FindNamedFilter(const std::string& name)
	{
		NamedFilterMap::iterator found = m_namedFilterMap.find(name);
		return found == m_namedFilterMap.end() ? NULL : found->second;
	}
	const SymbolFilter* FindNamedFilter(const std::string& name) const
	{
		NamedFilterMap::const_iterator found = m_namedFilterMap.find(name);
		return found == m_namedFilterMapEnd ? NULL : found->second;
	}

	typedef std::map<SymbolFilter*, NamedFilterItem*> NamedFilterItemMap;
	bool ApplyNamedFilters(const NamedFilterItemMap& namedFilterItemMap);

	void RefreshNamedFilters();

	const int& GetMapMenuWidth() const{return m_mapMenuWidth;}
	const int& GetUnmapMenuWidth() const{return m_unmapMenuWidth;}
	const int& GetActiveStockMenuWidth() const{return m_activeStockMenuWidth;}
	const int& GetInventoryMenuWidth() const{return m_inventoryMenuWidth;}
	const int& GetScrollMenuWidth() const{return m_scrollMenuWidth;}
	const int& GetDblClickMenuWidth() const{return m_dblClickMenuWidth;}
	const int& GetCancelOrdersMenuWidth() const{return m_cancelOrdersMenuWidth;}
//	const int& GetSettingsMenuWidth() const{return m_settingsMenuWidth;}
//	const int& GetGraphicsMenuWidth() const{return m_graphicsMenuWidth;}
	const int& GetDefaultMenuWidth() const{return m_defaultMenuWidth;}
	const int& GetPhantomMenuWidth() const{return m_phantomMenuWidth;}
	const int& GetPhantomShortMenuWidth() const{return m_phantomShortMenuWidth;}
	const int& GetDataMonitorMenuWidth() const{return m_dataMonitorMenuWidth;}
	const int& GetHtmlViewerMenuWidth() const{return m_htmlViewerMenuWidth;}
	const int& GetColumnsMenuWidth() const{return m_columnsMenuWidth;}
	const int& GetMassCancelMenuWidth() const{return m_massCancelMenuWidth;}
//	const int& GetFindMenuWidth() const{return m_findMenuWidth;}
	const int& GetGtcMenuWidth() const{return m_gtcMenuWidth;}
	const int& GetPrefixMenuWidth() const{return m_prefixMenuWidth;}
	const int& GetCustomGraphicsMenuWidth() const{return m_customGraphicsMenuWidth;}

	const int& GetCopyNameMenuWidth() const{return m_copyNameMenuWidth;}
	const int& GetPasteFilterMenuWidth() const{return m_pasteFilterMenuWidth;}
	const int& GetColumnMenuWidth() const{return m_columnMenuWidth;}
	const int& GetExpandedColumnMenuWidth() const{return m_expandedColumnMenuWidth;}

	const int& GetCornerMenuWidth() const{return m_cornerMenuWidth;}
	const int& GetAlphabetizeMenuWidth() const{return m_alphabetizeMenuWidth;}

	const int& GetAboutMenuWidth() const{return m_aboutMenuWidth;}
	const int& GetMainMenuWidth() const{return m_mainMenuWidth;}
	const int& GetDayStatusMenuWidth() const{return m_dayStatusMenuWidth;}
	const int& GetLockMenuWidth() const{return m_lockMenuWidth;}
	const int& GetOnTopMenuWidth() const{return m_onTopMenuWidth;}
	const int& GetLoadHistoryMenuWidth() const{return m_loadHistoryMenuWidth;}
	const int& GetCommandMenuWidth() const{return m_commandMenuWidth;}

	const int& GetBackupMenuWidth() const{return m_backupMenuWidth;}
	const int& GetFreezeMenuWidth() const{return m_freezeMenuWidth;}
	const int& GetHeadlinePropertiesMenuWidth() const{return m_headlinePropertiesMenuWidth;}
	const int& GetLayoutMenuWidth() const{return m_layoutMenuWidth;}
	const int& GetLayoutCompleteMenuWidth() const{return m_layoutCompleteMenuWidth;}
	const int& GetRestoreLayoutMenuWidth() const{return m_restoreLayoutMenuWidth;}

	const int& GetViewMenuWidth() const{return m_viewMenuWidth;}
	const int& GetViewNameMenuWidth() const{return m_viewNameMenuWidth;}

	const int& GetNamedFilterMenuWidth() const{return m_namedFilterMenuWidth;}

	const int& GetAllExtensionsMenuWidth() const{return m_allExtensionsMenuWidth;}
	const int& GetPositionMenuWidth() const{return m_positionMenuWidth;}
	const int& GetHelpMenuWidth() const{return m_helpMenuWidth;}
	const int& GetOddLotMenuWidth() const{return m_oddLotMenuWidth;}
	const int& GetEditCommandMenuWidth() const{return m_editCommandMenuWidth;}

//	virtual void GetMaxAccountName(std::string& accountName) const{}
//	int GetAccountMenuWidth() const{return m_accountMenuWidth;}
	const int& GetWordCurrentMenuWidth() const{return m_wordCurrentMenuWidth;}

	const int& GetSysMenuWidth() const{return m_sysMenuWidth;}
	const int& GetToolMenuWidth() const{return m_toolMenuWidth;}
	const int& GetTruncateMenuWidth() const{return m_truncateMenuWidth;}
	const int& GetSizeInSharesMenuWidth() const{return m_sizeInSharesMenuWidth;}
	const int& GetPriceDecMenuWidth() const{return m_priceDecMenuWidth;}
	const int& GetDecDigitsMenuWidth() const{return m_decDigitMenuWidth;}
	const int& GetVarMenuWidth() const{return m_varMenuWidth;}
	const int& GetWindowLinkMenuWidth() const{return m_windowLinkMenuWidth;}
	const int& GetTimeFrameMinutesMenuWidth() const{return m_timeFrameMinutesMenuWidth;}
	const int& GetTickFlashMenuWidth() const{return m_tickFlashMenuWidth;}
	const int& GetHiloFlashMenuWidth() const{return m_hiloFlashMenuWidth;}
	const int& GetDayHiloFlashMenuWidth() const{return m_dayHiloFlashMenuWidth;}
	const int& GetAllMenuWidth() const{return m_allMenuWidth;}
	const int& GetPositionFilterMenuWidth() const{return m_positionFilterMenuWidth;}
	const int& GetAccountFilterMenuWidth() const{return m_accountFilterMenuWidth;}
	const int& GetOrderFilterMenuWidth() const{return m_orderFilterMenuWidth;}
	const int& GetAlertFilterMenuWidth() const{return m_alertFilterMenuWidth;}
	const int& GetExecutionFilterMenuWidth() const{return m_executionFilterMenuWidth;}
	const int& GetEcnBookMenuWidth() const{return m_ecnBookMenuWidth;}
	const int& GetMarketCenterMenuWidth() const{return m_marketCenterMenuWidth;}
	const int& GetNewBasketMenuWidth() const{return m_newBasketMenuWidth;}
	const int& GetUnExcludeMenuWidth() const{return m_unExcludeMenuWidth;}
	const int& GetSizeFilterMenuWidth() const{return m_sizeFilterMenuWidth;}
	const int& GetTestDurationMenuWidth() const{return m_testDurationMenuWidth;}
	const int& GetPositionManagerShowMenuWidth() const{return m_positionManagerShowMenuWidth;}
	const int& GetHighlightTokenMenuWidth() const{return m_highlightTokenMenuWidth;}
	const int& GetVisitUrlMenuWidth() const{return m_visitUrlMenuWidth;}
	const int& GetVisitSelectedUrlMenuWidth() const{return m_visitSelectedUrlMenuWidth;}
	const int& GetXTriggeredMenuWidth() const{return m_XTriggeredMenuWidth;}
	const int& GetFilterMenuWidth() const{return m_filterMenuWidth;}
#ifndef TAKION_NO_OPTIONS
	const int& GetOptionMenuWidth() const{return m_optionMenuWidth;}
#endif
	typedef std::map<std::string, ExtensionKeystrokeCommand*> ExtensionKeystrokeCommandMap;
	ExtensionKeystrokeCommandMap& GetExtensionKeystrokeCommandMap(){return m_extensionKeystrokeCommandMap;}
	ExtensionKeystrokeCommand* FindExtensionKeystrokeCommand(const std::string& name);

	typedef std::map<std::string, NewsCommand*> NewsCommandMap;
	NewsCommandMap& GetNewsCommandMap(){return m_newsCommandMap;}
	CustomCommand* FindNewsCommand(const std::string& name);

	typedef std::map<std::string, EmailCommand*> EmailCommandMap;
	EmailCommandMap& GetEmailCommandMap(){return m_emailCommandMap;}
	CustomCommand* FindEmailCommand(const std::string& name);

	inline void InvokeCommand(Command* const& command, const Key* const& key, const bool& repeat)//, bool aggregate = false);
	{
		DoInvokeCommand(command, key, repeat, true);
	}
	void InvokeCommandForSecurity(Command* command,
		Account* account,
		const Security* security,
		const Position* position,
		unsigned int sendId,
		unsigned int tierSize,
		int count,
		bool closeout,
		bool closeOnly,
		bool passiveOnly,
		bool blockAggressiveOrders,
		unsigned char inventoryMode,
		bool fromExtension);
//	TakionTool* GetNextTool(TakionTool* tool, bool reverse);
	void MoveToNextTool(bool reverse);
	void MoveToNextWorkspace(bool reverse);
	void MoveToNextPopulatedWorkspace(bool reverse);

	bool RemoveToolFromVisibleTools(TakionTool* tool);
	void AddToolToVisibleTools(TakionTool* tool);

	void SetToolWorkspaceToCurrent(TakionTool* tool);

	TakionSettingMainDialog& GetSettingDialog(){return m_settingDialog;}

//	bool CloseModalDialogs();
	virtual void ShowSettingDialog(const char* tabToOpen, const void* initInfo = NULL);

	void RestorePositionInventory(PositionData* position);
	void RestoreAccountInventory(Account* account);
	void RememberPreviousInventoryMap();
	const TakionConfig::AccountInventoryMap& GetPreviousInventoryMap() const{return m_prevInventoryMap;}

	unsigned int GetWorkspace() const{return m_workspace;}
	unsigned int GetLastWorkspace() const{return m_lastWorkspace;}

	virtual TakionSettingAbout* CreateSettingAboutDialog(TakionSettingTabDialog* parentTab);
	void InitializeMainWndBeforeCreation();

	const unsigned char& GetCurrentClearingFirmOrdinal() const{return m_currentClearingFirmOrdinal;}
	const unsigned char& GetCurrentStockLoanFirmOrdinal() const{return m_currentStockLoanFirmOrdinal;}
	const Price& GetBorrowPriceMultiplier() const{return m_borrowPriceMultiplier;}

	void SetTimeFrequency(unsigned int timeFrequency);

	DialogListString& GetListDialog(){return m_listDialog;}
	DialogListChar& GetCharDialog(){return m_charDialog;}
	DialogListDestination& GetDestinationDialog(){return m_destinationDialog;}
	DialogListRouting& GetRoutingDialog(){return m_routingDialog;}
	DialogListAccount& GetAccountDialog(){return m_accountDialog;}
	DialogListTakionTool& GetTakionToolDialog(){return m_takionToolDialog;}
	DialogListView& GetViewDialog(){return m_viewDialog;}
//	DialogListPositionStock& GetPositionStockDialog(){return m_positionStockDialog;}
	DialogPositionStock& GetPositionStockDialog(){return m_positionStockDialog;}

	DialogTextEntry& GetSymbolEntryDialog(){return m_symbolEntryDialog;}
	DialogSpinPriceEntry& GetPriceEntryDialog(){return m_priceEntryDialog;}
	DialogDateEntry& GetDateEntryDialog(){return m_dateEntryDialog;}

#ifndef TAKION_NO_OPTIONS
	DialogListOptionExpirationDate& GetOptionExpirationDateDialog(){return m_optionExpirationDateDialog;}
	DialogListOptionStrikePrice& GetOptionStrikePriceDialog(){return m_optionStrikePriceDialog;}
#endif

	DialogReplaceOrder* GetReplaceOrderDialog();

	DialogSymbolIntNumber* GetIntNumberDialog();//{return m_intNumberDialog;}
	DialogSymbolUIntNumber* GetUIntNumberDialog();//{return m_uintNumberDialog;}
	DialogSymbolPrice* GetPriceDialog();//{return m_priceDialog;}
	DialogSymbolDate* GetDateDialog();//{return m_dateDialog;}
	DialogSymbolString* GetSymbolStringDialog();//{return m_symbolStringDialog;}
	DialogColumns* GetColumnsDialog();
/*
	DialogColumns* GetColumnsDialog(RowWindow* receipient
#ifdef SECONDARY_ROWS
		, bool secondary
#endif
		);//{return m_columnsDialog;}
*/
	DialogDuration* GetDurationDialog();//{return m_durationDialog;}
	DialogTime* GetTimeDialog();//{return m_timeDialog;}
	DialogTime* GetMinuteDialog();//{return m_minuteDialog;}
	DialogScrollerCap* GetDialogScrollerCap();//{return m_scrollerCapDialog;}
	DialogUnsignedPercent* GetDialogUnsignedPercent();//{return m_unsignedPercentDialog;}
	DialogSignedPercent* GetDialogSignedPercent();//{return m_signedPercentDialog;}
	DialogFont* GetFontDialog();//{return m_fontDialog;}
	DialogGraphicsColor* GetGraphicsColorDialog();//{return m_graphicsColorDialog;}

//	DialogListDLL* GetListDllDialog();

	DialogPrintFilterSize* GetDialogPrintFilterSize();//{return m_dialogPrintFilterSize;}
	DialogStockPrintFilter* GetStockPrintFilterDialog();//{return m_stockPrintFilterDialog;}
	DialogMarketSorterFilter* GetMarketSorterFilterDialog();//{return m_marketSorterFilterDialog;}
	DialogNewsHeadlineSecurityFilter* GetNewsHeadlineSecurityFilterDialog();//{return m_newsHeadlineSecurityFilterDialog;}
	DialogIndexSorterFilter* GetIndexSorterFilterDialog();//{return m_indexSorterFilterDialog;}
	DialogHiLoScrollerFilter* GetHiLoScrollerFilterDialog();//{return m_hiloScrollerFilterDialog;}
	DialogMmFilter& GetMmFilterDialog(){return m_mmFilterDialog;}
	DialogEcnAttribution& GetEcnAttributionDialog(){return m_mmEcnAttributionDialog;}
	const unsigned char& GetMaxQuoteFilterCount() const{return m_maxQuoteFilterCount;}

	DialogPickItemsLevel1& GetDialogPickItemsLevel1(){return m_dialogPickItemsLevel1;}
	DialogPickItemsTitle& GetDialogPickItemsTitle(){return m_dialogPickItemsTitle;}

	virtual void AlternateMessageLoopEntered(bool interrupt, unsigned short source);
	const bool& isAlternateMessageLoop() const{return m_alternateMessageLoop;}

	const TakionTool::NamedValueIdVector& GetDefaultLevel1Tokens() const{return m_defaultLevel1Tokens;}
	const TakionTool::NamedValueIdVectorVector& GetDefaultMmTitleTokens() const{return m_defaultMmTitleTokens;}

	virtual void UpdateLevel1ValueCollection();
	virtual void UpdateMmTitleValueCollection();

	virtual void UpdateChartInfoValueCollection(){}
	virtual void UpdateValueCollection(){}
	virtual void UpdateShowTooltips();

	void AddShowTimeWindow(TakionTitleTool* tool){m_showTimeWnds.AddObject(tool);}
	void RemoveShowTimeWindow(TakionTitleTool* tool){m_showTimeWnds.RemoveObject(tool);}

	void AddSecurityTopActiveWindow(RowWindowSortable* tool){m_securityTopActiveWnds.AddObject(tool);}
	void RemoveSecurityTopActiveWindow(RowWindowSortable* tool){m_securityTopActiveWnds.RemoveObject(tool);}

	void AddHiLoFlashMarketSorterWindow(MarketSorterWindow* tool){m_hiloFlashMarketSorterWnds.AddObject(tool);}
	void RemoveHiLoFlashMarketSorterWindow(MarketSorterWindow* tool){m_hiloFlashMarketSorterWnds.RemoveObject(tool);}

	void AddHiliteHeadlineWindow(NewsHeadlineWnd* tool){m_hiliteHeadlineWnds.AddObject(tool);}
	void RemoveHiliteHeadlineWindow(NewsHeadlineWnd* tool){m_hiliteHeadlineWnds.RemoveObject(tool);}

	void AddTickFlashWindow(RowWindowSortable* tool){m_tickFlashWnds.AddObject(tool);}
	void RemoveTickFlashWindow(RowWindowSortable* tool){m_tickFlashWnds.RemoveObject(tool);}

	void AddRowWnd(RowWindow* tool){m_rowWnds.AddObject(tool);}
	void RemoveRowWnd(RowWindow* tool){m_rowWnds.RemoveObject(tool);}

	void AddAccountWnd(AccountWindow* tool){m_accountWnds.AddObject(tool);}
	void RemoveAccountWnd(AccountWindow* tool){m_accountWnds.RemoveObject(tool);}

	void AddClearingFirmWnd(ClearingFirmWindow* tool){m_clearingFirmWnds.AddObject(tool);}
	void RemoveClearingFirmWnd(ClearingFirmWindow* tool){m_clearingFirmWnds.RemoveObject(tool);}

//	void AddAccountTopActiveWnd(AccountWindow* tool){m_accountTopActiveWnds.AddObject(tool);}
//	void RemoveAccountTopActiveWnd(AccountWindow* tool){m_accountTopActiveWnds.RemoveObject(tool);}

	void AddPrintWnd(PrintWnd* tool){m_printWnds.AddObject(tool);}
	void RemovePrintWnd(PrintWnd* tool){m_printWnds.RemoveObject(tool);}

	void AddHistoricalPrintWnd(HistoricalPrintWnd* tool){m_historicalPrintWnds.AddObject(tool);}
	void RemoveHistoricalPrintWnd(HistoricalPrintWnd* tool){m_historicalPrintWnds.RemoveObject(tool);}

	void AddNewsHeadlineWnd(NewsHeadlineWnd* tool){m_newsHeadlineWnds.AddObject(tool);}
	void RemoveNewsHeadlineWnd(NewsHeadlineWnd* tool){m_newsHeadlineWnds.RemoveObject(tool);}

	void AddNewsContentsWnd(NewsContentsWnd* tool){m_newsContentsWnds.AddObject(tool);}
	void RemoveNewsContentsWnd(NewsContentsWnd* tool){m_newsContentsWnds.RemoveObject(tool);}

	void AddMarketSorterWnd(MarketSorterWindow* tool){m_marketSorterWnds.AddObject(tool);}
	void RemoveMarketSorterWnd(MarketSorterWindow* tool){m_marketSorterWnds.RemoveObject(tool);}

#ifndef TAKION_NO_OPTIONS
	void AddOptionWnd(OptionWindow* tool){m_optionWnds.AddObject(tool);}
	void RemoveOptionWnd(OptionWindow* tool){m_optionWnds.RemoveObject(tool);}

	void AddOptionChainWnd(OptionChainWindow* tool){m_optionChainWnds.AddObject(tool);}
	void RemoveOptionChainWnd(OptionChainWindow* tool){m_optionChainWnds.RemoveObject(tool);}
#endif
	void AddIndexSorterWnd(IndexSorterWindow* tool){m_indexSorterWnds.AddObject(tool);}
	void RemoveIndexSorterWnd(IndexSorterWindow* tool){m_indexSorterWnds.RemoveObject(tool);}
	void UpdateIndexDescriptions();

	void AddPositionWnd(PositionWindow* tool){m_positionWnds.AddObject(tool);}
	void RemovePositionWnd(PositionWindow* tool){m_positionWnds.RemoveObject(tool);}

	void AddDefaultInventoryWnd(TakionTool* tool){m_defaultInventoryWnds.AddObject(tool);}
	void RemoveDefaultInventoryWnd(TakionTool* tool){m_defaultInventoryWnds.RemoveObject(tool);}
/*
	void AddDefaultInventoryPositionWnd(PositionWindow* tool){m_defaultInventoryPositionWnds.AddObject(tool);}
	void RemoveDefaultInventoryPositionWnd(PositionWindow* tool){m_defaultInventoryPositionWnds.RemoveObject(tool);}

	void AddDefaultInventoryAccountWnd(AccountWindow* tool){m_defaultInventoryAccountWnds.AddObject(tool);}
	void RemoveDefaultInventoryAccountWnd(AccountWindow* tool){m_defaultInventoryAccountWnds.RemoveObject(tool);}
*/
	void AddBasketFilterPositionWnd(PositionWindow* tool){m_basketFilterPositionWnds.AddObject(tool);}
	void RemoveBasketFilterPositionWnd(PositionWindow* tool){m_basketFilterPositionWnds.RemoveObject(tool);}

	void AddOrderWnd(OrderWindow* tool){m_orderWnds.AddObject(tool);}
	void RemoveOrderWnd(OrderWindow* tool){m_orderWnds.RemoveObject(tool);}

	void AddExecutionWnd(ExecutionWindow* tool){m_executionWnds.AddObject(tool);}
	void RemoveExecutionWnd(ExecutionWindow* tool){m_executionWnds.RemoveObject(tool);}

	void AddPositionManagerWnd(PositionManagerWindow* tool){m_positionManagerWnds.AddObject(tool);}
	void RemovePositionManagerWnd(PositionManagerWindow* tool){m_positionManagerWnds.RemoveObject(tool);}

	void AddPositionManagerFocusTakenWnd(PositionManagerWindow* tool){m_positionManagerFocusTakenWnds.AddObject(tool);}
	void RemovePositionManagerFocusTakenWnd(PositionManagerWindow* tool){m_positionManagerFocusTakenWnds.RemoveObject(tool);}

	void AddHiLoScrollerWnd(HiLoScroller* tool){m_hiLoScrollerWnds.AddObject(tool);}
	void RemoveHiLoScrollerWnd(HiLoScroller* tool){m_hiLoScrollerWnds.RemoveObject(tool);}

	void AddSecurityScrollerWnd(SecurityScrollerWindow* tool){m_securityScrollerWnds.AddObject(tool);}
	void RemoveSecurityScrollerWnd(SecurityScrollerWindow* tool){m_securityScrollerWnds.RemoveObject(tool);}

	void AddHtmlViewer(TakionHtmlViewer* tool){m_htmlViewers.AddObject(tool);}
	void RemoveHtmlViewer(TakionHtmlViewer* tool){m_htmlViewers.RemoveObject(tool);}
	bool AddHelpHtmlViewer(TakionHtmlViewer* tool);
	bool RemoveHelpHtmlViewer(TakionHtmlViewer* tool);
	virtual bool ShowHelp(const std::string& url) const override;

	void AddDataMonitor(TakionDataMonitor* tool){m_dataMonitors.AddObject(tool);}
	void RemoveDataMonitor(TakionDataMonitor* tool){m_dataMonitors.RemoveObject(tool);}

	void AddTopMostWnd(TakionTool* tool){m_topMostWnds.AddObject(tool);}
	void RemoveTopMostWnd(TakionTool* tool){m_topMostWnds.RemoveObject(tool);}

	void AddAlert(Alert* alert);
	void CancelAlert(Alert* alert);
//	bool AddSecurityAlert(const char* symbol, COLORREF color, AlertType alertType, const SignedPrice& price, const SignedPrice& from, const unsigned int& volume, const char* note, unsigned int expirationDate);
	bool AddSecurityAlert(const unsigned __int64& numericSymbol,
#ifndef TAKION_NO_OPTIONS
		const unsigned __int64& optionBlock,
#endif
		COLORREF color,
		AlertType alertType,
		const SignedPrice& price,
//		const SignedPrice& from,
		const unsigned __int64& volume,
		const int& imbalance,
		const char* note,
		bool popup,
		unsigned int expirationDate);
	bool AddSecurityAlert(const AlertKeySetting& keySetting, const AlertValueSetting& alertValueSetting);
	void ClearAlerts();
	void UpdateAlert(Alert* alert);
	void ClearTriggeredAlerts();
	void AddExtensionWnd(ExtensionWindow* tool){m_extensionWnds.AddObject(tool);}
	void RemoveExtensionWnd(ExtensionWindow* tool){m_extensionWnds.RemoveObject(tool);}

	ExtensionWindow* GetOneExtensionWindow();
	void LoadSelectedExtension(bool unload);
	void ToggleLoadSelectedExtension();

	void AddAlertWnd(AlertWindow* tool){m_alertWnds.AddObject(tool);}
	void RemoveAlertWnd(AlertWindow* tool){m_alertWnds.RemoveObject(tool);}

	int CalculateExtraHeight(unsigned char spacing, int height) const;
	int CalculateExtraWidth(unsigned char spacing, int height) const;

	virtual void UpdateAccount(const Account* account);
	virtual void DeleteAccount(const Account* account);
	virtual void DeleteAllAccounts();
	virtual void NewAccount(const Account* account);

	const Key& GetLastCommandKey() const{return m_lastCommandKey;}

	virtual void ExecuteDebuggingCommand(){}//For debuggingOnly

	typedef std::vector<std::string> StringVector;
	typedef std::map<unsigned __int64, std::string, std::greater<unsigned __int64> > FileMap;

	typedef std::set<WindowLinkParamsBase*, lessPtr<WindowLinkParamsBase*> > WindowLinkParamsSet;
	typedef std::map<HWND, WindowLinkParamsBase*> ApiWindowLinkMap;
	const WindowLinkParamsSet& GetApiLinks() const{return m_apiLinks;}
	void SendSymbolToAllApiLinks(const char* symbol, unsigned int ordinal);
	void SendInitToAllApiLinks(bool startup);

	static const unsigned char maxExtLinkCount = 64;
	static const unsigned char maxManualExtLinkCount = 64;
	static const unsigned char maxToolCount = 128;
	static const unsigned short maxWindowCount = 1024;
	typedef std::vector<LinkExternal*> LinkExternalVector;
	typedef std::set<LinkExternal*> LinkExternalSet;
	unsigned char GetLinkExternalCount() const{return (unsigned char)m_linkExternalVector.size();}
	LinkExternalVector& GetLinkExternalVector(){return m_linkExternalVector;}
	LinkExternalSet& GetLinkExternalSet(){return m_linkExternalSet;}
	LinkExternal* GetLinkExternal(const unsigned char& id){return id < GetLinkExternalCount() ? m_linkExternalVector[id] : NULL;}
	LinkExternal* GetLinkESignal(){return GetLinkExternal(m_esignalLinkId);}
	LinkExternal* GetLinkBloomberg(){return GetLinkExternal(m_bloombergLinkId);}
	LinkExternal* GetLinkTakion(){return GetLinkExternal(m_takionLinkId);}
	LinkOtherTakion* GetLinkTakionDirectly(){return m_linkOtherTakion;}
	bool AddExternalLink(LinkExternal* link);
	void ToggleExternalLink(unsigned char id);
	void SendSymbolToExternalLinks(const char* symbol, unsigned int mmOrdinal);
	void SetActiveToolInExternalLinks(TakionTool* tool);
	HWND isExternalWindowLinkable(HWND hWnd, LinkExternal*& link) const;
	virtual void EstablishAllExternalLinks(bool force);

	bool isInExternalLinkThread(std::string& extLinkName) const;
//	void SetExtLinkAdvancedGETSleepMilliseconds(unsigned int milliseconds);
	virtual void UpdateExtLinkParams();

	HWND GetDesktop() const{return m_desktop;}
	HWND GetMainWindowToLink(HWND entryHwnd) const;
//	typedef std::hash_map<HWND, LinkExternalManual*> LinkExternalManualMap;
	typedef std::map<HWND, LinkExternalManual*> LinkExternalManualMap;
	const LinkExternalManualMap& GetLinkExternalManualMap() const{return m_linkExternalManualMap;}
	void ToggleExternalManualLink(unsigned char id);
	bool AddExternalManualLink(HWND entryHwnd, HWND mainWindow = NULL, TakionTool* fromTool = NULL);//, bool focus);
	void ClearExternalManualLinks();
	void ClearInvalidExternalManualLinks();
	LinkExternalManual* FindExternalManualLink(const HWND& hwnd)
	{
		LinkExternalManualMap::iterator found = m_linkExternalManualMap.find(hwnd);
		return found == m_linkExternalManualMapEnd ? NULL : found->second;
	}
	LinkExternal* GetExternalManualLinkAt(const unsigned char& id){return id < GetExternalManualLinkCount() ? m_linkExternalManualVector[id] : NULL;}
	LinkExternalVector& GetLinkExternalManualVector(){return m_linkExternalManualVector;}
	unsigned char GetExternalManualLinkCount() const{return (unsigned char)m_linkExternalManualVector.size();}
//	virtual unsigned int GetAccountCount() const{return 0;}
	const Account* GetAccountAt(unsigned int at) const;//{return NULL;}
	unsigned int GetAccountCount() const;//{return (unsigned int)m_accountMap.size();}

	const int& GetLinkMenuWidth() const{return m_linkMenuWidth;}
	const int& GetNewWindowMenuWidth() const{return m_newWindowMenuWidth;}
	const int& GetWindowMenuWidth() const{return m_windowMenuWidth;}
	const int& GetAccountMenuWidth() const{return m_accountMenuWidth;}
	HMENU GetMySystemMenu(){return m_mySystemMenu;}
	HMENU GetLayoutSystemMenu(){return m_layoutSystemMenu;}
	HMENU GetLayoutRecoverSystemMenu(){return m_layoutRecoverSystemMenu;}
	HMENU GetViewSystemMenu(){return m_viewSystemMenu;}
	HMENU GetExtLinkSystemMenu(){return m_extLinkSystemMenu;}
	HMENU GetBloombergLinkSystemMenu(){return m_bloombergLinkSystemMenu;}
	HMENU GetEsignalLinkSystemMenu() { return m_esignalLinkSystemMenu; }
	HMENU GetHelpSystemMenu(){return m_helpSystemMenu;}
	HMENU GetCostSystemMenu(){return m_costSystemMenu;}
	HMENU GetLockSystemMenu(){return m_lockSystemMenu;}
	HMENU GetOnTopSystemMenu(){return m_onTopSystemMenu;}
	HMENU GetLoadHistorySystemMenu(){return m_loadHistorySystemMenu;}
	HMENU GetCommandSystemMenu(){return m_commandSystemMenu;}
	HMENU GetNewWindowSystemMenu(){return m_newWindowSystemMenu;}
	HMENU GetWindowSystemMenu(){return m_windowSystemMenu;}
	HMENU GetCornerSystemMenu(){return m_cornerSystemMenu;}
	HMENU GetWorkspaceSystemMenu(){return m_workspaceSystemMenu;}
	HMENU GetAccountSystemMenu(){return m_accountSystemMenu;}

	bool RecoverLayout(unsigned int ordinal);

	const unsigned short& GetPosManMovesCount() const{return m_posManMovesCount;}
	const unsigned short& GetPosManJoinsCount() const{return m_posManJoinsCount;}
	const unsigned short& GetPosManPrintsCount() const{return m_posManPrintsCount;}
	const unsigned short& GetPosManPrintsOddCount() const{return m_posManPrintsOddCount;}
	Observable* GetQuoteMoveObservable(){return m_quoteMoveObservable;}
	virtual void IncrementPosManMovesCount();
	virtual void IncrementPosManJoinsCount();
	virtual void IncrementPosManPrintsCount();
	virtual void IncrementPosManPrintsOddCount();
	virtual bool DecrementPosManMovesCount();
	virtual bool DecrementPosManJoinsCount();
	virtual bool DecrementPosManPrintsCount();
	virtual bool DecrementPosManPrintsOddCount();

	void UpdateApiLinks();
	void UpdatePhantomPositions();
	void UpdateAccountPhantomPositions(Account* account);

	virtual void RepaintActiveTitle();
	unsigned int GetModalCount() const{return (unsigned int)m_modalList.size();}
	bool isModalListEmpty() const{return m_modalList.empty();}
//	bool MouseClickedOutsideModalDialog(const MSLLHOOKSTRUCT* mouseHookStruct);
	const unsigned short& GetTotalMinute() const{return m_totalMinute;}

	void AddLinkedWnd(TakionTool* tool);
	void RemoveLinkedWnd(TakionTool* tool);
#ifndef TAKION_NO_OPTIONS
	typedef CMap<OptionSymbolBlockKey, const OptionSymbolBlockKey&, int, int> PositionSizeMap;
	const int* GetPositionSize(const OptionSymbolBlockKey& symbol) const{const PositionSizeMap::CPair* found = m_positionSizeMap.PLookup(symbol); return found ? &found->value : NULL;}
	const int* GetPositionInventorySize(const OptionSymbolBlockKey& symbol) const{const PositionSizeMap::CPair* found = m_positionInventorySizeMap.PLookup(symbol); return found ? &found->value : NULL;}
#else
	typedef CMap<unsigned __int64, unsigned __int64, int, int> PositionSizeMap;
	const int* GetPositionSize(unsigned __int64 symbol) const{const PositionSizeMap::CPair* found = m_positionSizeMap.PLookup(symbol); return found ? &found->value : NULL;}
	const int* GetPositionInventorySize(unsigned __int64 symbol) const{const PositionSizeMap::CPair* found = m_positionInventorySizeMap.PLookup(symbol); return found ? &found->value : NULL;}
#endif

	typedef CMap<unsigned __int64, unsigned __int64, std::string, std::string&> AcceleratorMap;
	const std::string* GetAcceleratorSymbol(const char* accelerator) const{const AcceleratorMap::CPair* found = m_acceleratorMap.PLookup(U_RepresentStringAsUnsignedNumber<unsigned __int64>(accelerator, sizeof(unsigned __int64) - 1)); return found ? &found->value : NULL;}
	const std::string* GetAcceleratorSymbol(unsigned __int64 accelerator) const{const AcceleratorMap::CPair* found = m_acceleratorMap.PLookup(accelerator); return found ? &found->value : NULL;}
	void UpdateAccelerators();

	virtual void UpdatePositionAlert(bool useChanged, bool allAccountsChanged, bool timesChanged);
	virtual void UpdatePositionAlertExclusion(const std::set<std::string>& prevSet, const bool excluded);
//	virtual void ExcludePositionAlert(const std::string& symbol);
	virtual void RemovePositionFromAlersUntilFlat(const Position* position, bool removeFromPositionTimeMap);

	typedef std::set<Alert*, lessPtr<Alert*> > AlertSet;
	const AlertSet& GetAlertSet() const{return m_alertSet;}
	const AlertSet& GetAlertTriggeredSet() const{return m_alertTriggeredSet;}
	void ClearAndDestroyAlerts();
	void ClearAndDestroyTriggeredAlerts();

	void UpdateTriggeredAlerts();
	void UpdateAlerts();
	void ExpireAlerts();

	typedef std::set<Alert*> TimeAlertSet;
	typedef std::map<unsigned int, TimeAlertSet> TimeAlertMap;
	bool InitializeAlert(Alert* alert, AlertValueSetting* valueSetting);
	void TriggerAlert(Alert* alert, bool invalid);//, const std::string& value);
//	typedef std::hash_set<DialogAlert*> AlertDialogSet;
	void AddAlertDialog(CommandRemovablePopupWnd* dlg){m_alertDialogs.PushFrontChainItem(dlg);}//insert(dlg);}
	void RemoveAlertDialog(CommandRemovablePopupWnd* dlg){m_alertDialogs.Remove(dlg);}//erase(dlg);}
	void ClearAndDestroyAlertDialogs();
	void CloseAlertDialogs();
	void CloseLastAlertDialog(bool first, bool renew);
	virtual Alert* CreateAlert(const AlertFinder& alertFinder, const AlertValueSetting& valueSetting) const{return NULL;}

	unsigned int GetMainThreadId() const{return m_mainThreadId;}
	const std::string& GetTraderId() const{return m_traderId;}
	const std::string& GetPassword() const{return m_password;}
	const std::string& GetNewsPassword() const{return m_newsPassword;}

	const std::string& GetCurrentViewName() const{return m_currentViewName;}
	void SaveView(const std::string& viewName);
	void SaveDefaultView() const;
	void SetView(const std::string& viewName, const WindowViewSetting* setting);
	void SetDefaultView();

	virtual const char* GetPasswordStr() const override{return m_password.c_str();}

	virtual bool isInRectForClientMenu(const CPoint& point) const;

	void CornerTotal();

	virtual void RefreshTopMostWindows();
//	const TakionWindowThread* GetWindowThread() const{return m_windowThread;}
	virtual const char* GetDestinationNameById(const unsigned __int64& id, const Account* account) const{return "";}
	virtual const char* GetOrderTypeNameByOrderType(unsigned int orderType) const{return "";}

	typedef std::map<std::string, ColumnInfo*> ColumnInfoMap;
	const ColumnInfoMap& GetColumnInfoMap() const{return m_columnInfoMap;}
	const ColumnInfo* FindColumnInfo(const std::string& name) const{ColumnInfoMap::const_iterator found = m_columnInfoMap.find(name);return found == m_columnInfoMap.end() ? NULL : found->second;}
	ColumnInfo* FindColumnInfo(const std::string& name){ColumnInfoMap::iterator found = m_columnInfoMap.find(name);return found == m_columnInfoMap.end() ? NULL : found->second;}

	const ColumnInfoMap& GetFactoryColumnInfoMap() const{return m_factoryColumnInfoMap;}
	const ColumnInfo* FindFactoryColumnInfo(const std::string& name) const{ColumnInfoMap::const_iterator found = m_factoryColumnInfoMap.find(name);return found == m_factoryColumnInfoMap.end() ? NULL : found->second;}

	virtual bool UpdateColumnInfo(const ColumnInfo& columnInfo, UseChangeMap& useChangeMap);
	void SaveColumns();
	void UnuseUnselectedColumns();

#ifdef SECONDARY_ROWS
	const ColumnInfoMap& GetSecondaryColumnInfoMap() const{return m_secondaryColumnInfoMap;}
	const ColumnInfo* FindSecondaryColumnInfo(const std::string& name) const{ColumnInfoMap::const_iterator found = m_secondaryColumnInfoMap.find(name);return found == m_secondaryColumnInfoMap.end() ? NULL : found->second;}
	ColumnInfo* FindSecondaryColumnInfo(const std::string& name){ColumnInfoMap::iterator found = m_secondaryColumnInfoMap.find(name);return found == m_secondaryColumnInfoMap.end() ? NULL : found->second;}
	const ColumnInfoMap& GetSecondaryFactoryColumnInfoMap() const{return m_secondaryFactoryColumnInfoMap;}
	const ColumnInfo* FindSecondaryFactoryColumnInfo(const std::string& name) const{ColumnInfoMap::const_iterator found = m_secondaryFactoryColumnInfoMap.find(name);return found == m_secondaryFactoryColumnInfoMap.end() ? NULL : found->second;}
	virtual bool UpdateSecondaryColumnInfo(const ColumnInfo& columnInfo, UseChangeMap& useChangeMap);
	void SaveSecondaryColumns();
	void UnuseUnselectedSecondaryColumns();

	void AddBasketFilterAccountWnd(AccountWindow* tool){m_basketFilterAccountWnds.AddObject(tool);}
	void RemoveBasketFilterAccountWnd(AccountWindow* tool){m_basketFilterAccountWnds.RemoveObject(tool);}

	const int& GetSecondaryRowsMenuWidth() const{return m_secondaryRowsMenuWidth;}
#endif
	typedef std::map<COLORREF, std::string> ColorNameMap;
	typedef std::map<std::string, COLORREF> NameColorMap;
	const ColorNameMap& GetColorNameMap() const{return m_colorNameMap;}
	const NameColorMap& GetNameColorMap() const{return m_nameColorMap;}
	const COLORREF* FindColorByName(const std::string& name) const{NameColorMap::const_iterator found = m_nameColorMap.find(name); return found == m_nameColorMapEnd ? NULL : &found->second;}
	const std::string* FindNameByColor(const COLORREF& color) const{ColorNameMap::const_iterator found = m_colorNameMap.find(color); return found == m_colorNameMapEnd ? NULL : &found->second;}

	const unsigned int& GetCurrentDayMillisecond() const{return m_currentDayMillisecond;}
	const unsigned int& GetCurrentHour() const{return m_currentHour;}
	const unsigned int& GetCurrentMinute() const{return m_currentMinute;}
	const unsigned int& GetCurrentSecond() const{return m_currentSecond;}
	const unsigned int& GetTotalCurrentSecond() const{return m_totalCurrentSecond;}//m_totalMinute * 60 + m_currentSecond
	const unsigned int& GetTimeLayoutSaved() const{return m_timeLayoutSaved;}

	const unsigned char& GetCurrentHourDigit1() const{return m_currentHourDigit1;}
	const unsigned char& GetCurrentHourDigit2() const{return m_currentHourDigit2;}
	const unsigned char& GetCurrentMinuteDigit1() const{return m_currentMinuteDigit1;}
	const unsigned char& GetCurrentMinuteDigit2() const{return m_currentMinuteDigit2;}
	const unsigned char& GetCurrentSecondDigit1() const{return m_currentSecondDigit1;}
	const unsigned char& GetCurrentSecondDigit2() const{return m_currentSecondDigit2;}

	const unsigned int& GetCurrentDayServerMillisecond() const{return m_currentDayServerMillisecond;}
	const unsigned int& GetCurrentServerHour() const{return m_currentServerHour;}
	const unsigned int& GetCurrentServerMinute() const{return m_currentServerMinute;}
	const unsigned int& GetCurrentServerSecond() const{return m_currentServerSecond;}

	const unsigned int& GetStartExitTime() const{return m_startExitTime;}
	const unsigned int& GetLingerCount() const{return m_lingerCount;}
	const bool& isCancelDefaultAccountOrders() const{return m_cancelDefaultAccountOrders;}
	const bool& isCancelOtherAccountOrders() const{return m_cancelOtherAccountOrders;}

	const bool& isInventoryView() const{return m_inventoryView;}
	void SetInventoryView(const bool inventoryView);
	void ToggleInventoryView(){SetInventoryView(!m_inventoryView);}

	void InvalidateIdleRect();

	void AddPositionToPositionAlerts(const Position* position);

	const char* GetSoundEventName(unsigned char i) const{return i < SE_Count ? m_soundEventName[i] : NULL;}
	const char* const* GetSoundEventNames() const{return m_soundEventName;}

	const std::string* GetSoundEventFileName(unsigned char i) const{return i < SE_Count ? m_soundEventFileName + i : NULL;}
	void SetSoundEventFileName(unsigned char i, const std::string& fileName){if(i < SE_Count)m_soundEventFileName[i] = fileName;}
	void InitSoundEventFiles();
/*
	const char* GetSoundFileContent(unsigned char i) const{return i < SE_Count ? m_soundFileContent[i] : NULL;}
	const char* const* GetSoundFileContents() const{return m_soundFileContent;}
	void SetSoundEventContent(unsigned char i, const char* fileContenet){if(i < SE_Count)m_soundFileContent[i] = fileContenet;}
	void LoadSoundEventFiles(bool reload);
*/

	bool PlayTakionEventSound(unsigned char sound) const;
	void SetActiveCommand(Command* command);

	const std::string& GetToolCopy() const{return m_toolCopy;}
	const std::string& GetToolCopyId() const{return m_toolCopyId;}
	bool isToolCopyEmpty() const{return m_toolCopy.empty() || !m_copyBitmap;}
	void ClearToolCopy()
	{
		m_toolCopy.clear();
		m_copyBitmap = NULL;
		m_toolCopyId.clear();
	}
	void RememberToolCopy(const TakionTool* tool);
	bool GetPendingOrderCount(unsigned int& accountCount,

		unsigned int& defaultAccountOrders,
		unsigned int& defaultAccountAlgos,
		unsigned int& defaultAccountGtcOrderCount,
		unsigned int& defaultAccountGtcAlgoCount,

		unsigned int& otherAccountOrders,
		unsigned int& otherAccountAlgos,
		unsigned int& otherAccountGtcOrderCount,
		unsigned int& otherAccountGtcAlgoCount) const;
	virtual bool GetDefaultAccoutPendingOrderCount(unsigned int& defaultAccountOrderCount,
		unsigned int& defaultAccountAlgoCount,
		unsigned int& defaultAccountGtcOrderCount,
		unsigned int& defaultAccountGtcAlgoCount) const
	{
		return false;
	}
	virtual bool GetOtherAccoutPendingOrderCount(unsigned int& accountCount,
		unsigned int& otherAccountOrderCount,
		unsigned int& otherAccountAlgoCount,
		unsigned int& otherAccountGtcOrderCount,
		unsigned int& otherAccountGtcAlgoCount) const
	{
		return false;
	}
	virtual void OnKeyMenu();
	virtual void AltKeyDown(bool up);

	void PutVenuesToClipboard() const;
	virtual void VenuesToString(std::string& venues) const{}

	void UpdateWorkspaceFont(unsigned int workspace);
	void UpdateWorkspace();

	unsigned short GetMarketSorterTimeFrame() const{return m_marketSorterTimeFrame;}
	virtual void UpdateEquityTimeFrame();

	typedef std::map<std::string, InventoryValue> StrInventoryMap;
	virtual void UpdateAccountInventory(Account* account, const StrInventoryMap& positionMap, const int size, const unsigned char securityTypeHidden, const bool allPositions, const bool notify){}

#if (_MSC_VER > 1600)
	typedef std::unordered_set<std::string> StringSet;
#else
	typedef std::hash_set<std::string> StringSet;
#endif

	static const PositionWindow::FnPaintInfo& GetPositionFnPaintInfo(const unsigned short& id){return id < PositionWindow::POS_COLUMN_COUNT ? m_positionPaintInfoFunction[id] : NULL;}
	static const PositionWindow::FnCompare& GetPositionFnCompare(const unsigned short& id){return id < PositionWindow::POS_COLUMN_COUNT ? m_positionCompareFunction[id] : NULL;}
	static const PositionWindow::FnCompare& GetPositionFnCompareAhead(const unsigned short& id){return id < PositionWindow::POS_COLUMN_COUNT ? m_positionCompareAheadFunction[id] : NULL;}

	static const OrderWindow::FnPaintInfo& GetOrderFnPaintInfo(const unsigned short& id){return id < OrderWindow::ORD_COLUMN_COUNT ? m_orderPaintInfoFunction[id] : NULL;}
	static const OrderWindow::FnCompare& GetOrderFnCompare(const unsigned short& id){return id < OrderWindow::ORD_COLUMN_COUNT ? m_orderCompareFunction[id] : NULL;}
	static const OrderWindow::FnCompare& GetOrderFnCompareAhead(const unsigned short& id){return id < OrderWindow::ORD_COLUMN_COUNT ? m_orderCompareAheadFunction[id] : NULL;}

	static const ExecutionWindow::FnPaintInfo GetExecutionFnPaintInfo(const unsigned short& id){return id < ExecutionWindow::EXE_COLUMN_COUNT ? m_executionPaintInfoFunction[id] : NULL;}
	static const ExecutionWindow::FnCompare GetExecutionFnCompare(const unsigned short& id){return id < ExecutionWindow::EXE_COLUMN_COUNT ? m_executionCompareFunction[id] : NULL;}
	static const ExecutionWindow::FnCompare GetExecutionFnCompareAhead(const unsigned short& id){return id < ExecutionWindow::EXE_COLUMN_COUNT ? m_executionCompareAheadFunction[id] : NULL;}
/*
	static const ExecutionWindow::FnPaintInfo& GetExecutionFnPaintInfo(const unsigned short& id){return m_executionPaintInfoFunction[id];}//id < ExecutionWindow::EXE_COLUMN_COUNT ? m_executionPaintInfoFunction[id] : NULL;}
	static const ExecutionWindow::FnCompare& GetExecutionFnCompare(const unsigned short& id){return m_executionCompareFunction[id];}//id < ExecutionWindow::EXE_COLUMN_COUNT ? m_executionCompareFunction[id] : NULL;}
	static const ExecutionWindow::FnCompare& GetExecutionFnCompareAhead(const unsigned short& id){return m_executionCompareAheadFunction[id];}//id < ExecutionWindow::EXE_COLUMN_COUNT ? m_executionCompareAheadFunction[id] : NULL;}
*/
/*
	bool AddToolToCollection(TakionTool* tool);
	bool AddHiddenTool(TakionTool* tool);
	bool AddPinnedTool(TakionTool* tool);
	bool RemovePinnedTool(TakionTool* tool);
*/
	typedef std::list<TakionTool*> ToolList;

	typedef std::map<unsigned __int64, std::string, lessUIntAsStr<unsigned __int64> > UInt64StrMap;
	const UInt64StrMap& GetSecurityNoteMap() const{return m_securityNoteMap;}
	const std::string* FindSecurityNote(const unsigned __int64& symbol) const
	{
		UInt64StrMap::const_iterator found = m_securityNoteMap.find(symbol);
		return found == m_securityNoteMapEnd ? NULL : &found->second;
	}
	const char* GetSecurityNote(const unsigned __int64& symbol) const
	{
		UInt64StrMap::const_iterator found = m_securityNoteMap.find(symbol);
		return found == m_securityNoteMapEnd ? "" : found->second.c_str();
	}
	const char* GetSecurityNote(const Security* const& security) const
	{
		return
#ifndef TAKION_NO_OPTIONS
			security->GetOptionInfo() ? "" :
#endif
			GetSecurityNote(security->GetNumericSymbol());
	}
	void AddSecurityNote(const unsigned __int64& symbol, const std::string& note);
	void RemoveSecurityNote(const unsigned __int64& symbol);
	void ClearSecurityNotes();
	bool PasteSecurityNotes(bool clearOld);

	const std::string* GetHiloFlashSecondMenuText() const{return m_hiloFlashSecondMenuText;}
	const std::string* GetDayHiloFlashSecondMenuText() const{return m_dayHiloFlashSecondMenuText;}
	const std::string* GetHiloFlashSecondMenuTextAt(const unsigned int& at) const{return at < maxHiLoFlashSecond ? m_hiloFlashSecondMenuText + at : NULL;}
	const std::string* GetDayHiloFlashSecondMenuTextAt(const unsigned int& at) const{return  at < maxHiLoFlashSecond ? m_dayHiloFlashSecondMenuText + at : NULL;}
	const AdditionalColumnDll* GetAdditionalColumnDll() const {return m_additionalColumnDll;}

	typedef ToolCollection<std::set<TakionTool*, lessAlphabeticalTool> > AlphabeticalTools;
	const AlphabeticalTools& GetHiddenTools() const{return m_hiddenTools;}
	int MeasureWindowsMenuItems(CDC* dc, CFont* font, CFont* fontBold, AlphabeticalTools& hiddenBelongingTools) const;
//	void GetHiddenBelongingTools(AlphabeticalTools& hiddenBelongingTools) const;

	typedef ToolCollection<std::set<TakionTool*, lessTool> > VisibleTools;
	const VisibleTools& GetVisibleTools() const{return m_visibleTools;}

	const Tools& GetPinnedTools() const{return m_pinnedTools;}

	bool AddToolToCollection(TakionTool* tool);
	bool AddHiddenTool(TakionTool* tool);
	bool AddPinnedTool(TakionTool* tool);

//	typedef std::map<std::string, TokenExpressionCollection*> TokenExpressionMap;
	TokenExpressionCollection* AddTokenExpression(TokenExpressionCollection* expression);
	TokenExpressionCollection* RemoveTokenExpression(const std::string& name);
	void LinkTokenExpressions();
	void ClearAndDestroyTokenExpressions();
	const TokenExpressionCollection* FindTokenExpression(const std::string& expressionName) const
	{
		TokenExpressionMap::const_iterator found = m_tokenExpressionMap.find(expressionName);
		return found == m_tokenExpressionMapEnd ? NULL : found->second;
	}
	TokenExpressionCollection* FindTokenExpression(const std::string& expressionName)
	{
		TokenExpressionMap::iterator found = m_tokenExpressionMap.find(expressionName);
		return found == m_tokenExpressionMapEnd ? NULL : found->second;
	}
	TokenExpressionMap& GetTokenExpressionMap(){return m_tokenExpressionMap;}
	const TokenExpressionMap& GetTokenExpressionMap() const{return m_tokenExpressionMap;}
	unsigned int GetTokenExpressionCount() const{return (unsigned int)m_tokenExpressionMap.size();}
	void UpdateTokenExpressions();
	TokenExpressionCollection* RenameTokenExpression(TokenExpressionCollection* expression, const char* newName);
	TokenExpressionCollection* ObtainTokenExpression(const std::string& name);
	void TokenExpressionAdded(const TokenExpressionCollection* expression);
	void TokenExpressionRemoved(const TokenExpressionCollection* expression);
	void UpdateTokenExpressionAddedInWindows(const TokenExpressionCollection* expression);
	void UpdateTokenExpressionRemovedInWindows(const TokenExpressionCollection* expression);
	void UpdateTokenExpressionChangedInWindows(const TokenExpressionCollection* expression);
	const int& GetTokenExpressionMenuWidth() const{return m_tokenExpressionMenuWidth;}
	void UpdateTokenExpressionMenuWidth(const TokenExpressionCollection* exceptExpression);

	typedef std::map<StrUCharKey, unsigned char> ExpressionMap;
	const ExpressionMap* GetExpressionMapCopy() const{return m_expressionMapCopy;}
	ExpressionMap* GetExpressionMapCopy(){return m_expressionMapCopy;}
	ExpressionMap* ObtainExpressionMapCopy();
	void ClearExpressionMapCopy(){if(m_expressionMapCopy)m_expressionMapCopy->clear();}
	void DestroyExpressionMapCopy();
//	void AddExpressionMapCopyElement()

	void SetNewsContentsLastState(const char* state)
	{
		if(state && *state)
		{
			m_newsContentsLastState = state;
		}
		else
		{
			m_newsContentsLastState.clear();
		}
	}
	const COLORREF& GetBkColorIncompatible() const{return m_bkColorIncompatible;}

	void FilterMnemonicRemoved(unsigned int mnemonic);

	typedef std::vector<AtomicPriceRange> AtomicPriceRangeVector;
	unsigned int GetAtomicPriceRangeCopyCount() const{return (unsigned int)m_atomicPriceRangeCopy.size();}
	const AtomicPriceRangeVector& GetAtomicPriceRangeCopy() const{return m_atomicPriceRangeCopy;}
	AtomicPriceRangeVector& GetAtomicPriceRangeCopy(){return m_atomicPriceRangeCopy;}
	void ClearAtomicPriceRangeCopy(){m_atomicPriceRangeCopy.clear();}
	void AddAtomicPriceRangeToCopy(const AtomicPriceRange& atomicPriceRange){m_atomicPriceRangeCopy.push_back(atomicPriceRange);}
/*
#if (_MSC_VER > 1600)
	typedef std::unordered_map<unsigned int, const char*> UIntMap;
#else
	typedef std::hash_map<unsigned int, const char*> UIntMap;
#endif
*/
	typedef CMap<unsigned int, const unsigned int&, const char*, const char* const&> UIntMap;

	const UIntMap& GetUrlCountryCodes() const{return m_urlCountryCodes;}
	bool EndsWithUrlCountryCode(const std::string& str) const
	{
		static const unsigned int minLen = 3;
		static const unsigned int maxLen = 5;
		const unsigned int len = (unsigned int)str.length();
		if(len > minLen)
		{
			const unsigned int capLen = len > maxLen ? maxLen : len;
			const char* const endChar = str.c_str() + len;
			const char* charCursor = endChar - 1;//endChar;
			unsigned int dotLen = 0;
			for(; dotLen < capLen; ++dotLen, --charCursor)
			{
				if(*charCursor == '.')
				{
//					return m_urlCountryCodes.find(U_RepresentStringAsUnsignedNumber<unsigned int>(endChar - dotLen)) != m_urlCountryCodesEnd;
					return m_urlCountryCodes.PLookup(U_RepresentStringAsUnsignedNumber<unsigned int>(endChar - dotLen)) != NULL;
				}
			}
		}
		return false;
	}
	const char* FindCountryByCode(const unsigned int& code) const
	{
//		UIntMap::const_iterator it = m_urlCountryCodes.find(code);
//		return it == m_urlCountryCodesEnd ? NULL : it->second;
		const UIntMap::CPair* found = m_urlCountryCodes.PLookup(code);
		return found ? found->value : NULL;
	}
	const char* FindCountryByCode(const char* const& code) const
	{
		return FindCountryByCode(U_RepresentStringAsUnsignedNumber<unsigned int>(code));
	}
	void ClearQuoteFilterCopy();
	const unsigned int& GetExchangeQuoteFilterCopy() const{return m_exchangeQuoteFilterCopy;}
	const unsigned char* const& GetEcnQuoteFilterCopy() const{return m_ecnQuoteFilterCopy;}
	void CopyQuoteFilter(const unsigned int& exchangeQuoteFilter, const unsigned char* ecnQuoteFilter);

	typedef std::vector<PositionMenuItem> PositionMenuItemVector;
	const PositionMenuItemVector& GetPositionMenuItemVector() const{return m_positionMenuItemVector;}
	PositionMenuItemVector& GetPositionMenuItemVector(){return m_positionMenuItemVector;}
	unsigned int GetPositionMenuItemVectorCount() const{return (unsigned int)m_positionMenuItemVector.size();}
	void ClearPositionMenuItemVector(){m_positionMenuItemVector.clear(); m_positionMenuItemMaxWidth = 0;}
	void AddPositionMenuItem(const PositionMenuItem& positionMenuItem){m_positionMenuItemVector.push_back(positionMenuItem);}
	const PositionMenuItem* GetPositionMenuItemAt(const unsigned int& at) const{return at < (unsigned int)m_positionMenuItemVector.size() ? &m_positionMenuItemVector[at] : NULL;}
	const int& GetPositionMenuItemMaxWidth() const{return m_positionMenuItemMaxWidth;}
	int& GetPositionMenuItemMaxWidth(){return m_positionMenuItemMaxWidth;}
	void CornerAlertDialogs();

	const StringVector& GetMnemonicVector() const{return m_mnemonicVector;}
	const char* GetMnemonicAt(const unsigned int& at) const{return at < (unsigned int)m_mnemonicVector.size() ? m_mnemonicVector[at].c_str() : NULL;}
	void UpdateMnemonicVector();
protected:
	TakionMainWnd(const char* traderId,
		const char* password,
		const char* newsPassword,
		const char* viewName,
		bool autoLoadCustomExtensions,
		bool autoLoadTakionFolderExtensions,
		ConnectionStatus connectionStatus,
		int minVisibleSize,
		int minWidth,
		int maxWidth,
		int minHeight,
		int maxHeight,
		int borderWidth,
		int workspaceWidth,
		int toolbarWidth,
		int maxTitleHeight,
		int resizorWidth,
		int resizorCursorOffset,
		const char* className,
//		COLORREF bkColor,
		unsigned int timeFrequency,
		unsigned char maxQuoteFilterCount);

	inline void ReplaceSelectedOrder(CancelOrderWindow* const& window,
		const bool& replaceNative,
		const SignedPrice& replacePriceOffset,
		const bool& replacePriceOffsetPercent,
		const bool& replacePriceReverseForSell,
		const bool& marketOrder,
		const int& replaceSizeOffset,
		const bool& replaceSizeReverseForSell,
		const bool& preBorrow,
		const Price& preBorrowPrice,
		const bool& adjustable,
		const bool& adjustableOrderBox,
		const bool& adjustableOnly,
		const unsigned char& displaySizeMode,//0 - size fraction, 1 - round lot, 2 - no change
		const unsigned int& displaySize,
		const unsigned int& displaySizeFraction,
		const bool& fromExtension)
	{
		window->DoReplaceSelectedOrder(replaceNative,
			replacePriceOffset,
			replacePriceOffsetPercent,
			replacePriceReverseForSell,
			marketOrder,
			replaceSizeOffset,
			replaceSizeReverseForSell,
			preBorrow,
			preBorrowPrice,
			adjustable,
			adjustableOrderBox,
			adjustableOnly,
			displaySizeMode,//0 - size fraction, 1 - round lot, 2 - no change
			displaySize,
			displaySizeFraction,
			fromExtension);
	}

	virtual void IncrementCalculatePositionLeverageCount(){}
	virtual void DecrementCalculatePositionLeverageCount(){}
	virtual void NullifyCalculatePositionLeverageCount(){}

	void ClearToolsAndFillPool(ToolPool& pool, ToolList& extensionToolList);
	void CreateViewWindows(const WindowMapSetting& windowMap, const unsigned __int64& savedVersion, unsigned int defaultCommandToolOrdinal, ToolPool& pool, ToolList& extensionToolList);
	void AdjustMainWndDimensions(const WindowViewSetting* windowViewSetting);

	void ViewAdded(const std::string& viewName);
	void ViewRemoved(const std::string& viewName);
	void UpdateViewMenuWidth(const std::string& exceptView);
	void UpdateViewMenuWidth();

	void DoInvokeCommand(Command* command, const Key* key, const bool repeat, bool fromExtension = true);

	virtual void AddAdditionalLayoutMenuItems(HMENU layoutMenu){}
//	virtual void NotifyExtensionLoaded(const ExtensionDll* extension){}//Done in AddLoadedExtension

	virtual void AfterDialogClose(TakionDialog* dlg) override;

	virtual void DoInitializeMainWndBeforeCreation();
	void CreateSettingCommands(TakionSettingDialog* settingDialog, std::string& commandName);

	static const std::string takionMainFrameClassName;

	friend class TakionGuiApp;
	static bool AddPositionFunctions(unsigned short id, PositionWindow::FnPaintInfo fnPaint, PositionWindow::FnCompare fnCompare, PositionWindow::FnCompare fnCompareAhead)
	{
		if(id < PositionWindow::POS_COLUMN_COUNT)
		{
			m_positionPaintInfoFunction[id] = fnPaint;
			m_positionCompareFunction[id] = fnCompare;
			m_positionCompareAheadFunction[id] = fnCompareAhead;
			return true;
		}
		return false;
	}
	static PositionWindow::FnPaintInfo m_positionPaintInfoFunction[PositionWindow::POS_COLUMN_COUNT];
	static PositionWindow::FnCompare m_positionCompareFunction[PositionWindow::POS_COLUMN_COUNT];
	static PositionWindow::FnCompare m_positionCompareAheadFunction[PositionWindow::POS_COLUMN_COUNT];

	static bool AddOrderFunctions(unsigned short id, OrderWindow::FnPaintInfo fnPaint, OrderWindow::FnCompare fnCompare, OrderWindow::FnCompare fnCompareAhead)
	{
		if(id < OrderWindow::ORD_COLUMN_COUNT)
		{
			m_orderPaintInfoFunction[id] = fnPaint;
			m_orderCompareFunction[id] = fnCompare;
			m_orderCompareAheadFunction[id] = fnCompareAhead;
			return true;
		}
		return false;
	}
	static OrderWindow::FnPaintInfo m_orderPaintInfoFunction[OrderWindow::ORD_COLUMN_COUNT];
	static OrderWindow::FnCompare m_orderCompareFunction[OrderWindow::ORD_COLUMN_COUNT];
	static OrderWindow::FnCompare m_orderCompareAheadFunction[OrderWindow::ORD_COLUMN_COUNT];

	static bool AddExecutionFunctions(unsigned short id, ExecutionWindow::FnPaintInfo fnPaint, ExecutionWindow::FnCompare fnCompare, ExecutionWindow::FnCompare fnCompareAhead)
	{
		if(id < ExecutionWindow::EXE_COLUMN_COUNT)
		{
			m_executionPaintInfoFunction[id] = fnPaint;
			m_executionCompareFunction[id] = fnCompare;
			m_executionCompareAheadFunction[id] = fnCompareAhead;
			return true;
		}
		return false;
	}
	static ExecutionWindow::FnPaintInfo m_executionPaintInfoFunction[ExecutionWindow::EXE_COLUMN_COUNT];
	static ExecutionWindow::FnCompare m_executionCompareFunction[ExecutionWindow::EXE_COLUMN_COUNT];
	static ExecutionWindow::FnCompare m_executionCompareAheadFunction[ExecutionWindow::EXE_COLUMN_COUNT];

	virtual bool ProcessKeyFromDialog(TakionDialogInterface* dlg, const Key& key, bool repeat) override;
	virtual bool ProcessKeyFromSettingDialog(TakionSettingDialog* dlg, const Key& key, bool repeat) override;

	virtual bool ProcessKeyFromExtension(const Key& key, bool repeat) override;

	virtual void AddCheckBoxesToExitMessageBox(TakionMessageBox& mb){}

	void ProcessAccountInventoryNotification(const char* accountId, const StrInventoryMap& positionMap, unsigned char hiddenSecurityTypes, bool leaveInLayout);
	void UpdateInventoryPositionSizeOrPhantom(const Account* account, const StrInventoryMap& positionMap);

	void DestroyPositionAlertMap();

	void SetPositionSizeOrPhantom(const Position* position);

//	virtual void DoSendPositionCost(Account* account, const std::string& positionSymbol, const Price& cost){}
	virtual void DoSendPositionCost(Account* account
//		,const std::string& positionSymbol
		,const unsigned __int64& symbol
#ifndef TAKION_NO_OPTIONS
		,const unsigned __int64& optionBlock
#endif
		,const Price& cost){}
	void SendAccountPositionCost(Account* account);

	void UnlinkExternalLinks();
	void ClearExternalLinks();

	void RemoveAlert(Alert* alert);

	void AddMarketSorterColumnInfo(ColumnInfo& columnInfo);

	void InitAggregateCommandsRepeatKey();

	void ClearAndDestroyLevel1Values();
	void AddLevel1Value(NamedValue* nv);
	NamedValueMap m_level1ValueMap;

	UInt64CountMap m_openBasketMap;

	AtomicPriceRangeVector m_atomicPriceRangeCopy;

	virtual NewsContentsWnd* CreateNewsContentsWnd(){return NULL;}
//	TakionWindowThread* CreateWindowThread() const{return m_windowThread ? m_windowThread : DoCreateWindowThread();}
//	virtual TakionWindowThread* DoCreateWindowThread() const{return NULL;}
	virtual void NextDayStarted(unsigned int date);
	virtual void SystemTimeChanged(unsigned int prevMillisecond, unsigned int currentMillisecond, unsigned int prevDate, unsigned int todaysDate);

	bool AddDayStatusMenu();
	void DeleteDayStatusMenu();

	virtual void AdjustToChangedScreen(int dx, int dy);

	bool Reconfig(const char* traderId, const char* layout, const char* layoutFolder);
	
	void DisconnectAlerts();

	void SymbolToActiveCommandWindowCommandAdded(const Command* command);
	void SymbolToActiveCommandWindowCommandRemoved(const Command* command);

	void ActivateWindowCommandAdded(const Command* command);
	void ActivateWindowCommandRemoved(const Command* command);

	void AppendToolBox(CBitmap* bitmap, const char* toolName);

	virtual void EnableAllWindows(BOOL enable);

	void InvalidateThermographs() const;

	void AddCommandTool(TakionTool* tool);
	void RemoveCommandTool(TakionTool* tool);
	void ClearCommandTools();

	void UpdateCommandToolLinks();

	void CurrentAccountLoaded();
	void AccountLoaded(const Account* account);
	void AllAccountsLoaded();
	void LoggedToExecutor();
	void CurrentAccountConstraintsLoaded();
	virtual void CurrentAccountSelected(bool clearingFirmChanged, bool stockLoanFirmChanged, bool borrowMultiplierChanged){}
	virtual void AdjustControls(bool noMove){}

	virtual void OnToolboxResized(){}
	virtual void OnWorkspaceResized(){}
	virtual void UpdateMainGraphics(const Graphics* graphics);
	virtual void UpdateMainTitleGraphics(const Graphics* graphics);
	virtual void UpdateMainLabelGraphics(const Graphics* graphics);
	virtual void UpdateMainValueGraphics(const Graphics* graphics);
	virtual void UpdateColumnGraphics(const Graphics* graphics);
	virtual void UpdateTitleGraphics(const Graphics* graphics);
	virtual void UpdateBorderGraphics(const Graphics* graphics);

	void UpdateDataGraphics();

	virtual void DCCreated();

	virtual void DoPaint(const RECT& rcPaint, CDC& dc);
	virtual void DoSize(UINT nType, int cx, int cy, int oldX, int oldY);
	virtual void PreSuccessfulCreate();
	virtual void OnSuccessfulCreate();
	virtual void CleanupOnEndSession(){}
	virtual void BeforeDestroy();
	virtual void MouseLeft();
	virtual void NcMouseLeft();
	virtual void DoActivate(UINT state, bool minimized) override;//, CWnd* pWndOther) override;
	virtual void DoMinimize(UINT nID, LPARAM lParam);
	virtual void DoRestore(UINT nID, LPARAM lParam);
	virtual void OnSetWorkspace(){}
	virtual void BeforeClearTools();

	virtual bool ResizeMouseArea(const CPoint& point, bool locked);
	virtual unsigned char UpdateResizeCursor(const CPoint& point, bool locked);
	virtual void OnMouseForcedReleaseCapture() override;

	virtual TakionTool* DoCreateTool(const char* id,
		const CBitmap* bitmap,
//		CRect* rect,
		unsigned int workspace,
		bool pinned);
//		bool visible)

	virtual void NewSecond(){}

//	void UpdateWorkspace();

	void UpdateSymbolToActiveCommandWindowCommands();
	void UpdateActivateWindowCommands();
	void UpdateExtensionKeystrokeCommands();
	void UpdateNewsCommands();
	void UpdateEmailCommands();

	void UpdateAggregateCommands();
	void LinkAggregateCommands();

	virtual void UpdateLinks();// override;

	virtual void MarketSorterCleanup();// override;
	virtual void MarketSorterLoaded();// override;

	virtual void OnSetBkColor() override;

	bool MenuCommand(DWORD loword);

	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) override;
	virtual BOOL PreTranslateMessage(MSG* pMsg) override;
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;

	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;

//	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
//	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnSetFocus(CWnd *pOldWnd);
	afx_msg void OnActivateApp(BOOL bActive, DWORD dwThreadID);
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
	afx_msg void OnEnterIdle(UINT nWhy, CWnd* pWho);
	afx_msg LRESULT OnKickIdle(WPARAM w, LPARAM l);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnSettingChange(UINT uFlags, const char* lpszSection);
	afx_msg LRESULT OnDisplayChange(WPARAM, LPARAM);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnNcMouseMove(UINT nHitTest, CPoint point);
	afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);
	afx_msg void OnNcLButtonDblClk(UINT nHitTest, CPoint point);

//	afx_msg void OnNcRButtonDown(UINT nHitTest, CPoint point);
//	afx_msg void OnNcRButtonUp(UINT nHitTest, CPoint point);

//	afx_msg void OnContextMenu(CWnd* pWnd, CPoint pos);

	afx_msg void OnMoving(UINT fwSide, LPRECT pRect);
	afx_msg void OnMove(int x, int y);
	afx_msg void OnExitSizeMove();
	afx_msg void OnCaptureChanged(CWnd *pWnd);
	afx_msg void OnNcLButtonUp(UINT nHitTest, CPoint point);
    afx_msg void OnExitMenuLoop(BOOL bIsTrackPopupMenu);
	afx_msg void OnMButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);
	afx_msg BOOL OnQueryEndSession( );
	afx_msg void OnEndSession(BOOL bEnding);
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	afx_msg void OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu);
	afx_msg BOOL OnCopyData(CWnd* pWnd, COPYDATASTRUCT* pCopyDataStruct);
	afx_msg LRESULT OnSetSymbol(WPARAM w, LPARAM p);
	afx_msg LRESULT OnApiLinkConnected(WPARAM disconnected, LPARAM hwnd);
	afx_msg LRESULT OnOtherTakionStartup(WPARAM shutdown, LPARAM hwnd);
	afx_msg LRESULT PostSymbolToCommandTool(WPARAM ordinal, LPARAM symbol);
	afx_msg LRESULT SendSymbolToCommandTool(WPARAM ordinal, LPARAM symbol);
	afx_msg LRESULT ExecuteCommandForSecurity(WPARAM ordinal, LPARAM executeCommandInfo);
	afx_msg LRESULT ExecuteCommand(WPARAM ordinal, LPARAM executeCommandInfo);
	afx_msg LRESULT DisplayNoteForSecurity(WPARAM ordinal, LPARAM displayNoteInfo);
#ifndef TAKION_NO_OPTIONS
	afx_msg LRESULT OnDisplayStuckOption(WPARAM ordinal, LPARAM optionSymbolBlockKey);
#endif
//	afx_msg LRESULT OnDelayedCreation(WPARAM wparam, LPARAM lparam);
	afx_msg LRESULT OnBufferOverflow(WPARAM wparam, LPARAM error);
	afx_msg LRESULT OnSelectionMade(WPARAM w, LPARAM p);
//	afx_msg LRESULT LingerForCleanup(WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()

	bool CreateTakionWindow(TakionTool* tool, const CRect* rect, const char* cursor, unsigned int contentModifier, bool isClone, unsigned __int64 version);
//	virtual void InitMainWindow();

	void CloseTakion(bool normal = true);
	void DoCloseTakion();
//	void DestroyTools();

	virtual void DestroyLogFiles();

	virtual void StopExiting();

	virtual void InvalidateControls(){}
	ConnectionStatus m_connectionStatus;
	COLORREF m_bkColorLive;
	COLORREF m_bkColorSimulation;
	COLORREF m_bkColorNoConnection;
	COLORREF m_bkColorIncompatible;

	std::string m_traderId;
	std::string m_password;
	std::string m_newsPassword;

	std::string m_currentViewName;

//	static const unsigned int maxHiLoFlashSecond = 5;
	std::string m_hiloFlashSecondMenuText[maxHiLoFlashSecond];
	std::string m_dayHiloFlashSecondMenuText[maxHiLoFlashSecond];

	StringSet m_knownDLLs;
	StringSet::const_iterator m_knownDLLsEnd;

	UInt64StrMap::iterator DoAddSecurityNote(const unsigned __int64& symbol, const std::string& note);
	bool DoSetSecurityNote(UInt64StrMap::iterator& it, const std::string& note);
	UInt64StrMap::iterator DoRemoveSecurityNote(const UInt64StrMap::iterator& it);
	UInt64StrMap m_securityNoteMap;
	UInt64StrMap::const_iterator m_securityNoteMapEnd;

//	unsigned int m_idleInterruptCount;
//	unsigned int m_idleCount;

	bool m_applicationActive;
	bool m_appActivated;
	bool m_exiting;
//	bool m_locked;
	bool m_toolboxPressed;

	int m_toolbarWidth;
	int m_workspaceWidth;
	int m_maxTitleHeight;
	int m_resizorWidth;

	unsigned char m_logAppActivate;

	bool m_alphabetizeWindowsInMenu;

	bool m_moveOnlyMainFrame;
	HCURSOR m_cursorMoveAll;
	HCURSOR m_cursorDragAll;
	HCURSOR m_cursorFinger;
	HCURSOR m_cursorCrosshair;

	HorizontalResizor m_workspaceResizor;
	HorizontalResizor m_toolboxResizor;
	VerticalResizor m_titleResizor;

//	ButtonRowSquareImage m_toolboxRow;
	ToolBar m_toolboxRow;
	TabRowSameSize m_workspaceRow;
	TabRowSameSize m_layerRow;

	COLORREF m_populatedWorkspaceColor;

	void UpdateLabelMetrics();
	void UpdateValueMetrics(short direction, bool fontChanged);
	int m_controlHeight;
	CRect m_tokenRect;
	CRect m_controlRect;
	CRect m_valueRect;
	CRect m_nameRect;

	COLORREF m_bgColorLabel;
	COLORREF m_bgColorTradeAllAccountsLabel;
	COLORREF m_bgColorValue;
	COLORREF m_bgColorTradeAllAccountsValue;
	FontDescription m_fontDescriptionLabel;
	FontDescription m_fontDescriptionValue;
	UIntSet m_valueFontSet;
	UIntSet::const_iterator m_valueFontSetBegin;
	UIntSet::const_iterator m_valueFontSetEnd;
	CFont* m_fontLabel;
	unsigned char m_labelHorizontalSpacing;
	unsigned char m_labelVerticalSpacing;
	unsigned char m_valueHorizontalSpacing;
	unsigned char m_valueVerticalSpacing;
	int m_lineHeight;

	HorizontalResizor m_valueResizor;
	NamedValueCollectionVertical m_valueCollection;

	TokenExpressionMap m_tokenExpressionMap;
	TokenExpressionMap::const_iterator m_tokenExpressionMapEnd;
	int m_tokenExpressionMenuWidth;

	ExpressionMap* m_expressionMapCopy;

	TakionTool::NamedValueIdVector m_defaultLevel1Tokens;
	TakionTool::NamedValueIdVectorVector m_defaultMmTitleTokens;

	virtual void SetShowToolTipsInFilterDialogs(bool showToolTips);//Check the "Tooltips" box
	virtual void DoEnableShowToolTipsInFilterDialogs(bool enable);//Make the Tooltips show up

	bool CreateToolTip();
	void DestroyToolTip();

	void CreateCountToolTips(unsigned int i, const ButtonRow& buttonRow, const char* prefix);
	void DestroyToolTips(unsigned int i, unsigned int to);
	void CreateWorkspaceToolTips();
	void DestroyWorkspaceToolTips();
	void CreateLayerToolTips();
	void DestroyLayerToolTips();
	void CreateToolToolTips();
	void DestroyToolToolTips();

	void CreateValueToolTips();
	void DoCreateValueToolTips();
	void DestroyValueToolTips();
	void DoDestroyValueToolTips();

	void CreateLinkToolTips();
	void DoCreateLinkToolTips();
	void DestroyLinkToolTips();
	void DoDestroyLinkToolTips();
	void UpdateLinkToolTips();

	virtual void EnableControlToolTips(bool enable);

	void UpdateCountToolTipRects(unsigned int i, const ButtonRow& buttonRow);

	void UpdateValueToolTips();
	void UpdateWorkspaceToolTipRects();
	void UpdateLayerToolTipRects();
	void UpdateToolsToolTipRects();

	void ToggleToolTipFilter(unsigned char flag);
	void SetToolTipFilter(unsigned char filter);

	CToolTipCtrl* m_toolTip;
	unsigned int m_valueTooltipCount;
//	unsigned char m_tooltipFilter;

	CRect m_timeRect;
	CRect m_hourRect1;
	CRect m_hourRect2;
	CRect m_timeColonRect1;
	CRect m_minuteRect1;
	CRect m_minuteRect2;
	CRect m_timeColonRect2;
	CRect m_secondRect1;
	CRect m_secondRect2;
	CRect m_secondRect;
	CRect m_idleRect;
	COLORREF m_alternateMessageLoopColor;
	COLORREF m_applicationActiveColor;
	COLORREF m_applicationActiveColorLight;
	COLORREF m_applicationActiveColorDark;
	COLORREF m_applicationInactiveColor;
	int m_timeHeight;
	int m_timeTokenWidth;
	int m_timeSeparatorWidth;
	void CalculateTimeRectHeight();
	void CalculateTimeRectWidth();
	void AdjustTimeRectWidth();

	unsigned int m_currentDayMillisecond;
	unsigned int m_currentHour;
	unsigned int m_currentMinute;
	unsigned int m_currentSecond;
	unsigned int m_totalCurrentSecond;
	unsigned int m_timeLayoutSaved;

	inline bool UpdateTimeToken(unsigned char& myToken, const unsigned char& token, const CRect& rect)
	{
		if(token != myToken)
		{
			myToken = token;
			::InvalidateRect(m_hWnd, &rect, FALSE);
			return true;
		}
		return false;
	}
	unsigned char m_currentHourDigit1;
	unsigned char m_currentHourDigit2;
	unsigned char m_currentMinuteDigit1;
	unsigned char m_currentMinuteDigit2;
	unsigned char m_currentSecondDigit1;
	unsigned char m_currentSecondDigit2;

	unsigned int m_currentDayServerMillisecond;
	unsigned int m_currentServerHour;
	unsigned int m_currentServerMinute;
	unsigned int m_currentServerSecond;

	virtual void TotalMinuteChanged(){}
	unsigned short m_totalMinute;

	unsigned int m_workspace;
	unsigned int m_lastWorkspace;

//	unsigned int m_nextOrdinal;

	unsigned short m_marketSorterTimeFrame;

	bool m_inIdleRect;

	unsigned char m_currentClearingFirmOrdinal;
	unsigned char m_currentStockLoanFirmOrdinal;
	Price m_borrowPriceMultiplier;

	unsigned int m_repeatCommandCount;

	unsigned int m_timeFrequency;
	CFont* m_valueFont;
	COLORREF m_positiveColor;
	COLORREF m_negativeColor;
	COLORREF m_neutralColor;
//	CFont* m_nameFont;

	PosManRingVector* m_posManMessages;

	int m_linkMenuWidth;
	int m_newWindowMenuWidth;
	int m_windowMenuWidth;
	int m_accountMenuWidth;
	int m_cornerMenuWidth;
	int m_alphabetizeMenuWidth;
	int m_aboutMenuWidth;
	int m_mainMenuWidth;
	int m_dayStatusMenuWidth;
	int m_lockMenuWidth;
	int m_onTopMenuWidth;
	int m_loadHistoryMenuWidth;
	int m_commandMenuWidth;
	int m_backupMenuWidth;
	int m_freezeMenuWidth;
	int m_headlinePropertiesMenuWidth;
	int m_layoutMenuWidth;
	int m_layoutCompleteMenuWidth;
	int m_restoreLayoutMenuWidth;

	int m_viewMenuWidth;
	int m_viewNameMenuWidth;

	void UpdateNamedFilterMenuWidth();
	void UpdateNamedFilterMenuWidth(const std::string& except);
	int m_namedFilterMenuWidth;

	int m_allExtensionsMenuWidth;
	int m_positionMenuWidth;
	int m_helpMenuWidth;
	int m_oddLotMenuWidth;
	int m_editCommandMenuWidth;
//	int m_accountMenuWidth;
	int m_wordCurrentMenuWidth;
	int m_sysMenuWidth;
	int m_toolMenuWidth;
	int m_truncateMenuWidth;
	int m_sizeInSharesMenuWidth;
	int m_priceDecMenuWidth;
	int m_decDigitMenuWidth;
	int m_varMenuWidth;
	int m_windowLinkMenuWidth;
	int m_timeFrameMinutesMenuWidth;
	int m_tickFlashMenuWidth;
	int m_hiloFlashMenuWidth;
	int m_dayHiloFlashMenuWidth;
	int m_allMenuWidth;
	int m_positionFilterMenuWidth;
	int m_accountFilterMenuWidth;
	int m_orderFilterMenuWidth;
	int m_alertFilterMenuWidth;
	int m_executionFilterMenuWidth;
	int m_ecnBookMenuWidth;
	int m_marketCenterMenuWidth;
	int m_newBasketMenuWidth;
	int m_unExcludeMenuWidth;
	int m_sizeFilterMenuWidth;
	int m_testDurationMenuWidth;
	int m_positionManagerShowMenuWidth;
	int m_highlightTokenMenuWidth;
	int m_visitUrlMenuWidth;
	int m_visitSelectedUrlMenuWidth;
	int m_XTriggeredMenuWidth;
	int m_filterMenuWidth;
	int m_symbolToCommandWindowMenuWidth;
	int m_activateWindowMenuWidth;
	int m_activeStockMenuWidth;
	int m_inventoryMenuWidth;
	int m_mapMenuWidth;
	int m_unmapMenuWidth;
	int m_scrollMenuWidth;
	int m_dblClickMenuWidth;
	int m_cancelOrdersMenuWidth;
//	int m_settingsMenuWidth;
//	int m_graphicsMenuWidth;
	int m_defaultMenuWidth;
	int m_phantomMenuWidth;
	int m_phantomShortMenuWidth;
	int m_dataMonitorMenuWidth;
	int m_htmlViewerMenuWidth;
	int m_columnsMenuWidth;
	int m_massCancelMenuWidth;
//	int m_findMenuWidth;
	int m_gtcMenuWidth;
	int m_prefixMenuWidth;
	int m_customGraphicsMenuWidth;
	int m_copyNameMenuWidth;
	int m_pasteFilterMenuWidth;
	int m_columnMenuWidth;
	int m_expandedColumnMenuWidth;
#ifndef TAKION_NO_OPTIONS
	int m_optionMenuWidth;
#endif
	HMENU m_mySystemMenu;
	HMENU m_layoutSystemMenu;
	HMENU m_layoutRecoverSystemMenu;
	HMENU m_viewSystemMenu;
	HMENU m_extLinkSystemMenu;
	HMENU m_esignalLinkSystemMenu;
	HMENU m_bloombergLinkSystemMenu;
	HMENU m_helpSystemMenu;
	HMENU m_costSystemMenu;
	HMENU m_lockSystemMenu;
	HMENU m_onTopSystemMenu;
	HMENU m_loadHistorySystemMenu;
	HMENU m_commandSystemMenu;
	HMENU m_newWindowSystemMenu;
	HMENU m_windowSystemMenu;
	HMENU m_cornerSystemMenu;
	HMENU m_workspaceSystemMenu;
	HMENU m_accountSystemMenu;

	bool m_autoLoadCustomExtensions;
	bool m_autoLoadTakionFolderExtensions;
	MapIniValue m_extensionAutoLoad;

	AdditionalColumnDll* m_additionalColumnDll;

	Account* m_currentAccount;

	Command* m_invokedToggleCommand;

	Command* m_activeCommand;

	TakionTool* m_activeTool;
	TakionTool* m_activeCommandTool;
	TakionTool* m_defaultCommandTool;
	CancelOrderWindow* m_activeCancelOrderTool;
	AlertWindow* m_activeCancelAlertTool;

	TakionTool* m_activeIncludeStockTool;
	TakionTool* m_activeExcludeStockTool;

	Key m_lastCommandKey;

	const char* m_soundEventName[SE_Count];
	std::string m_soundEventFileName[SE_Count];
//	const char* m_soundFileContent[SE_Count];

	virtual void TempTierSizesRemoved(){}
	virtual void TempTierSizeSet(const unsigned __int64& symbol,
#ifndef TAKION_NO_OPTIONS
		const unsigned __int64& optionKey,
#endif
		unsigned int tierSize){}
	virtual void TempTierSizeRemoved(const unsigned __int64& symbol
#ifndef TAKION_NO_OPTIONS
		,const unsigned __int64& optionKey
#endif
		){}

	void ClearAndDestroyNamedOrderSizes();
	virtual void UpdateNamedOrderSizes();
	NamedOrderSizeMap m_namedOrderSizeMap;
	virtual void OnNamedOrderSizeChanged(const OrderSizeAggregate* orderSize){}
	virtual void OnNamedOrderSizeDeleted(const OrderSizeAggregate* orderSize){}

	void ClearAndDestroyNamedOrderPrices();
	virtual void UpdateNamedOrderPrices();
	NamedOrderPriceMap m_namedOrderPriceMap;
	virtual void OnNamedOrderPriceChanged(const OrderPriceAggregate* orderPrice){}
	virtual void OnNamedOrderPriceDeleted(const OrderPriceAggregate* orderPrice){}

	OrderSizeVector m_orderSizeCopy;
	OrderPriceVector m_orderPriceCopy;

	TierSizeMap m_tierSizeMap;

	ToolSet m_tools;

//	typedef ToolCollection<std::set<TakionTool*, lessTool> > VisibleTools;

	bool RemovePinnedTool(TakionTool* tool);
	void ShowPinnedTools();

	VisibleTools m_visibleTools;

	AlphabeticalTools m_hiddenTools;

	Tools m_pinnedTools;

	bool SetToolActiveByCount(unsigned short count, bool corner);
	bool UnhideToolByCount(unsigned short count, bool corner);

	ToolCollectionVector m_workspaceVector;
	ToolCollectionVector m_layerVector;

	ToolVector m_commandTools;

	WindowSet m_otherTakionMainWnds;

	void AddWindowsMenuItems(CMenu* pPopupMenu, unsigned int windowIdStart);

	KeyCommandMapping m_keyCommandMapping;

	AggregateCommandMap m_aggregateCommandMap;

	SymbolToActiveCommandWindowCommandMap m_symbolToActiveCommandWindowCommandMap;
	ActivateWindowCommandMap m_activateWindowCommandMap;
	ExtensionKeystrokeCommandMap m_extensionKeystrokeCommandMap;

	NewsCommandMap m_newsCommandMap;
	EmailCommandMap m_emailCommandMap;

	TakionSettingMainDialog m_settingDialog;

	SSPMap m_positionCostMap;

	NamedFilterMap m_namedFilterMap;
	NamedFilterMap::const_iterator m_namedFilterMapEnd;

//	SSIMap m_inventoryMap;
	void DeleteOrderReplaceDialog();
	void DeleteIntNumberDialog();
	void DeleteUIntNumberDialog();
	void DeletePriceDialog();
	void DeleteDateDialog();
	void DeleteSymbolStringDialog();
	void DeleteColumnsDialog();
	void DeleteDurationDialog();
	void DeleteTimeDialog();
	void DeleteMinuteDialog();
	void DeleteScrollerCapDialog();
	void DeleteUnsignedPercentDialog();
	void DeleteSignedPercentDialog();
	void DeleteFontDialog();
	void DeleteGraphicsColorDialog();

//	void DeleteListDllDialog();

	void DeletePrintFilterDialog();
	void DeleteMarketSorterFilterDialog();
	void DeleteStockPrintFilterDialog();
	void DeleteNewsHeadlineSecurityFilterDialog();
	void DeleteIndexSorterFilterDialog();
	void DeleteHiLoScrollerFilterDialog();

	DialogListString m_listDialog;
	DialogListChar m_charDialog;
	DialogListDestination m_destinationDialog;
	DialogListRouting m_routingDialog;
	DialogListAccount m_accountDialog;
	DialogListTakionTool m_takionToolDialog;
	DialogListView m_viewDialog;
	DialogPositionStock m_positionStockDialog;

	DialogTextEntryHandleCommand m_symbolEntryDialog;
	DialogSpinPriceEntry m_priceEntryDialog;
	DialogDateEntry m_dateEntryDialog;

#ifndef TAKION_NO_OPTIONS
	DialogListOptionExpirationDate m_optionExpirationDateDialog;
	DialogListOptionStrikePrice m_optionStrikePriceDialog;
#endif

	DialogReplaceOrder* m_replaceOrderDialog;

	DialogSymbolIntNumber* m_intNumberDialog;
	DialogSymbolUIntNumber* m_uintNumberDialog;
	DialogSymbolPrice* m_priceDialog;
	DialogSymbolDate* m_dateDialog;
	DialogSymbolString* m_symbolStringDialog;
	DialogColumns* m_columnsDialog;
	DialogDuration* m_durationDialog;
	DialogTime* m_timeDialog;
	DialogTime* m_minuteDialog;
	DialogScrollerCap* m_scrollerCapDialog;
	DialogUnsignedPercent* m_unsignedPercentDialog;
	DialogSignedPercent* m_signedPercentDialog;
	DialogFont* m_fontDialog;
	DialogGraphicsColor* m_graphicsColorDialog;

//	DialogListDLL* m_listDllDialog;

	DialogPrintFilterSize* m_dialogPrintFilterSize;
	DialogStockPrintFilter* m_stockPrintFilterDialog;
	DialogMarketSorterFilter* m_marketSorterFilterDialog;
	DialogIndexSorterFilter* m_indexSorterFilterDialog;
	DialogHiLoScrollerFilter* m_hiloScrollerFilterDialog;
	DialogNewsHeadlineSecurityFilter* m_newsHeadlineSecurityFilterDialog;

	unsigned char m_maxQuoteFilterCount;
	unsigned int m_exchangeQuoteFilterCopy;
	unsigned char* m_ecnQuoteFilterCopy;
	DialogMmFilter m_mmFilterDialog;
	DialogEcnAttribution m_mmEcnAttributionDialog;

	DialogPickItemsLevel1 m_dialogPickItemsLevel1;
	DialogPickItemsTitle m_dialogPickItemsTitle;

	PositionMenuItemVector m_positionMenuItemVector;
	int m_positionMenuItemMaxWidth;

	void InitAccountInventory(Account* account);
	void ApplyInventoryDifference();
	TakionConfig::AccountInventoryMap m_prevInventoryMap;

	ToolPtrCollection<RowWindow>::HashSet m_rowWnds;
	ToolPtrCollection<AccountWindow>::HashSet m_accountWnds;
	ToolPtrCollection<ClearingFirmWindow>::HashSet m_clearingFirmWnds;
//	ToolPtrCollection<AccountWindow>::HashSet m_accountTopActiveWnds;
	ToolPtrCollection<PrintWnd>::HashSet m_printWnds;
	ToolPtrCollection<HistoricalPrintWnd>::HashSet m_historicalPrintWnds;
	ToolPtrCollection<NewsHeadlineWnd>::HashSet m_newsHeadlineWnds;
	ToolPtrCollection<NewsContentsWnd>::HashSet m_newsContentsWnds;
	ToolPtrCollection<MarketSorterWindow>::HashSet m_marketSorterWnds;
#ifndef TAKION_NO_OPTIONS
	ToolPtrCollection<OptionWindow>::HashSet m_optionWnds;
	ToolPtrCollection<OptionChainWindow>::HashSet m_optionChainWnds;
	void DeleteOptionSorterFilterDialog();
	void DeleteOptionChainFilterDialog();
	DialogOptionSorterFilter* m_optionSorterFilterDialog;
	DialogOptionChainFilter* m_optionChainFilterDialog;
	int m_optionFilterMenuWidth;
	void AddOptionWindowColumnInfo(ColumnInfo& columnInfo);
	virtual void SubscribeNextOptionOrUnderlier(const unsigned __int64& numericSymbol, const unsigned __int64& optionBlock){}
	void DisplayOptionStuck(const unsigned __int64& numericSymbol, const unsigned __int64& optionBlock);
#endif
	ToolPtrCollection<IndexSorterWindow>::HashSet m_indexSorterWnds;
#ifdef FIRM_VALUES
	ToolPtrCollection<FirmPositionWindow>::HashSet m_firmPositionWnds;
	bool m_canSeeFirmPositions;
#endif
	ToolPtrCollection<PositionWindow>::HashSet m_positionWnds;
	ToolPtrCollection<PositionWindow>::HashSet m_basketFilterPositionWnds;
	ToolPtrCollection<OrderWindow>::HashSet m_orderWnds;
	ToolPtrCollection<ExecutionWindow>::HashSet m_executionWnds;
	ToolPtrCollection<PositionManagerWindow>::HashSet m_positionManagerWnds;
	ToolPtrCollection<PositionManagerWindow>::HashSet m_positionManagerFocusTakenWnds;
	ToolPtrCollection<SecurityScrollerWindow>::HashSet m_securityScrollerWnds;
	ToolPtrCollection<HiLoScroller>::HashSet m_hiLoScrollerWnds;
	ToolPtrCollection<ExtensionWindow>::HashSet m_extensionWnds;
	ToolPtrCollection<AlertWindow>::HashSet m_alertWnds;
	ToolPtrCollection<TakionHtmlViewer>::HashSet m_htmlViewers;
	ToolPtrCollection<TakionDataMonitor>::HashSet m_dataMonitors;

	ToolPtrCollection<TakionTool>::HashSet m_defaultInventoryWnds;
//	ToolPtrCollection<PositionWindow>::HashSet m_defaultInventoryPositionWnds;
//	ToolPtrCollection<AccountWindow>::HashSet m_defaultInventoryAccountWnds;

	ToolPtrCollection<RowWindowSortable>::HashSet m_securityTopActiveWnds;
	ToolPtrCollection<MarketSorterWindow>::HashSet m_hiloFlashMarketSorterWnds;
	ToolPtrCollection<RowWindowSortable>::HashSet m_tickFlashWnds;
	ToolPtrCollection<TakionTitleTool>::HashSet m_showTimeWnds;
	ToolPtrCollection<NewsHeadlineWnd>::HashSet m_hiliteHeadlineWnds;

	ToolPtrCollection<TakionTool>::HashSet m_linkedWnds;

	void ClearTopMostWindows();
	ToolPtrCollection<TakionTool>::HashSet m_topMostWnds;

	typedef std::vector<TakionHtmlViewer*> TakionHtmlViewerVector;
	TakionHtmlViewerVector m_helpViewers;

//	ColoredDraggableDialogSet m_blinkingDialogs;
//	PopupWndSet m_blinkingPopups;

	AccountOrderedMap* m_accountMap;
//	StringAccountMap m_accountMap;

	StringVector m_backupFileVector;
	StringVector m_backupTimestampVector;
//	FileMap m_backupFileMap;

	StringVector m_mnemonicVector;

	unsigned short m_posManMovesCount;
	unsigned short m_posManJoinsCount;
	unsigned short m_posManPrintsCount;
	unsigned short m_posManPrintsOddCount;
	Observable* m_quoteMoveObservable;

	void ClearAndDestroyApiLinks();
	WindowLinkParamsSet m_apiLinks;
	WindowLinkParamsSet::const_iterator m_apiLinksEnd;
	ApiWindowLinkMap m_apiLinkWnds;
	ApiWindowLinkMap::const_iterator m_apiLinkWndsEnd;
	typedef std::map<unsigned int, std::string> UIntStrMap;
	UIntStrMap m_apiLinkPendingSymbolsToPropagate;
	UIntStrMap::const_iterator m_apiLinkPendingSymbolsToPropagateEnd;

	void CalculateExternalLinkMenuWidth(CDC* dc);

	LinkExternalVector m_linkExternalVector;
	LinkExternalSet m_linkExternalSet;
	LinkExternalSet::const_iterator m_linkExternalSetBegin;
	LinkExternalSet::const_iterator m_linkExternalSetEnd;

	void SetExternalManualLink(LinkExternal* link);
	void UnsetExternalManualLink(LinkExternal* link);
	LinkExternalVector m_linkExternalManualVector;
	LinkExternalManualMap m_linkExternalManualMap;
	LinkExternalManualMap::const_iterator m_linkExternalManualMapEnd;
	unsigned __int64 m_externalManualLinkMask;

	static void FillExtLinkRecipientCopyStructure(COPYDATASTRUCT& copyDataStruct, unsigned int dwData);
	void FillExtLinkRecipientCopyStructureAndSend(unsigned int dwData, HWND recipient) const;
	LinkOtherTakion* m_linkOtherTakion;
	Tools m_toolGroups[esignalGroupCount + 1];
	bool m_extLinkRecipient;

	void RemoveExtensionFromWindows(ExtensionDll* extension);
	virtual void DoClearExtensions();
	virtual bool AddLoadedExtension(ExtensionDll* extension);
	virtual ExtensionDll* RemoveLoadedExtension(const HMODULE hmodule);
	ExtensionMap m_extensionMap;
	ExtensionMap::const_iterator m_extensionMapBegin;
	ExtensionMap::const_iterator m_extensionMapEnd;

	ModuleExtensionMap m_loadedExtensionMap;
	ModuleExtensionMap::const_iterator m_loadedExtensionMapBegin;
	ModuleExtensionMap::const_iterator m_loadedExtensionMapEnd;

	ModuleExtensionMap m_incompatibleExtensionMap;
	ModuleExtensionMap::const_iterator m_incompatibleExtensionMapBegin;
	ModuleExtensionMap::const_iterator m_incompatibleExtensionMapEnd;

	void UpdatePositionSizeOrPhantom();
	PositionSizeMap m_positionSizeMap;
	PositionSizeMap m_positionInventorySizeMap;

	AcceleratorMap m_acceleratorMap;

	AlertSet m_alertSet;
	AlertSet m_alertTriggeredSet;
	AlertSet::iterator m_alertSetEnd;
	AlertSet::iterator m_alertTriggeredSetEnd;
	Chain<CommandRemovablePopupWnd*> m_alertDialogs;

	bool m_alternateMessageLoop;

	unsigned int m_mainThreadId;
	Observable* m_extensionObservable;
	ExtensionDll* m_extensionBeingLoaded;
//	bool m_ncLButtonDown;

	unsigned char m_esignalLinkGroup;
	unsigned char m_esignalLinkId;

	unsigned char m_bloombergLinkGroup;
	unsigned char m_bloombergLinkId;
	bool m_bloombergDllLoaded;

	unsigned char m_takionLinkId;

	bool m_extLinkWaitRefresh;

#ifdef EXT_LINK_USE_DBL_CLK_TO_ERASE
	CPoint m_extLinkPointSimulateDoubleClick[ELSDC_Count];
#endif
	mutable unsigned int m_helpRequestCount;

	virtual bool isCleanupBeforeExitDone(){return true;}
	virtual bool CleanupBeforeExit(){return true;}
	StopExitWnd* m_stopExitWnd;
	unsigned int m_startExitTime;
	unsigned int m_lingerCount;

	bool m_cancelDefaultAccountOrders;
	bool m_cancelDefaultAccountOrdersExceptGtc;

	bool m_cancelOtherAccountOrders;
	bool m_cancelOtherAccountOrdersExceptGtc;

//	bool m_closingModalDialogs;

	bool m_inventoryView;

	void DoSetClientDragCursor(HCURSOR cursor);
	void SetClientDragCursor(UINT nFlags, CPoint point);

//	bool m_linking;//in the process of doing Manual linking
	unsigned char m_draggingClientStatus;//0 - not dragging, 1 - mouse button down, waiting for it to move by some value, 2 - dragging
	int m_dragClientInitialX;
	int m_dragClientInitialY;
	HCURSOR m_draggingCursor;
	HWND m_draggingClientOver;
	HWND m_draggingParentOver;
	HWND m_desktop;

	void ApplySavedBuiltInColumnCount();
	void ApplyColumns();
	ColumnInfoMap m_columnInfoMap;
	ColumnInfoMap m_factoryColumnInfoMap;

#ifdef SECONDARY_ROWS
	void ApplySecondaryColumns();
	ColumnInfoMap m_secondaryColumnInfoMap;
	ColumnInfoMap m_secondaryFactoryColumnInfoMap;
	ToolPtrCollection<AccountWindow>::HashSet m_basketFilterAccountWnds;
	int m_secondaryRowsMenuWidth;
#endif

	virtual void AdjustColumnsSavedGlobalInfo();

	void AddColorName(const char* name, COLORREF color);
	ColorNameMap m_colorNameMap;
	NameColorMap m_nameColorMap;
	ColorNameMap::const_iterator m_colorNameMapEnd;
	NameColorMap::const_iterator m_nameColorMapEnd;

	bool RemoveAlertFromTimeSet(Alert* alert);
	TimeAlertMap m_timeAlertMap;
	TimeAlertMap::const_iterator m_timeAlertMapEnd;
	//	TakionWindowThread* m_windowThread;

	std::string m_positionCostFileName;
	std::string m_newPositionCostFileName;

	std::string m_toolCopy;
	std::string m_toolCopyId;
	const CBitmap* m_copyBitmap;

	typedef std::map<unsigned int, PositionAlert*> PositionAlertMap;
	PositionAlertMap m_positionAlertMap;
	PositionAlertMap::iterator m_positionAlertMapEnd;
	void AccountRemoved(const Account* account);
	void FillPositionAlertsWithAccount(const Account* account);
	void RepaintDefaultOnlyTradingAllowed();

	void AddUrlCountryCode(const char* countryCode, const char* countryName);
	UIntMap m_urlCountryCodes;
//	UIntMap::const_iterator m_urlCountryCodesEnd;

	std::string m_newsContentsLastState;
private:
	TakionMainWnd& operator=(const TakionMainWnd& other){return *this;}
	bool m_systemMenuDisplayed;
};

#ifdef __cplusplus
extern "C"
{
#endif

enum TakionSystemMenuIDs
{
	TMID_SC_CORNER_MAIN = 1010,
	TMID_SC_CORNER_ALL = 1011,
//	TMID_SC_CORNER_ACTIVE = 1012,

	TMID_SC_LAST
};

enum TakionMenuIDs
{
	TMID_ABOUT = BaseMenuIDsLast,//75535,
	TMID_STATUS,
	TMID_CLONE,
	TMID_COPY_TOOL,
	TMID_PASTE_TOOL,
	TMID_CORNER_ACTIVE,
	TMID_PIN,
	TMID_ON_TOP,
	TMID_SHOW_TIME,
	TMID_PREFIX_ONLY,
	TMID_ROW_COUNT,
	TMID_TOTAL_COUNT,
	TMID_LAYOUT_OPEN,
	TMID_LAYOUT_SAVE,
	TMID_LAYOUT_SAVEAS,
	TMID_LAYOUT_RESTORE,
	TMID_LAYOUT_SAVE_ALL,
	TMID_LAYOUT_RESTORE_ALL,

	TMID_VIEW_SAVE_AS,
	TMID_VIEW_ORGANIZE,
	TMID_VIEW_DEFAULT,

	TMID_CLIPBOARD_COLUMN_TOOLTIPS,

	TMID_HELP_OPEN_CONFIG,
	TMID_HELP_OPEN_SAVED_CONFIG,
	TMID_HELP_OPEN_INI,
	TMID_HELP_OPEN_LOG,
	TMID_HELP_OPEN_PREV_LOG,
	TMID_HELP_OPEN_POS,
	TMID_HELP_OPEN_POS_NEW,
	TMID_HELP_OPEN_GTC_ORDERS,
	TMID_HELP_OPEN_GTC_SPIDERS,
	TMID_HELP_CLIPBOARD_VENUES,
	TMID_HELP_LOG_BOOKMARK,
	TMID_HELP_SHOW_DLLS,

	TMID_LOCK_TAKION,

	TMID_TITLE_FONT,
	TMID_TITLE_COLOR,
	TMID_FONT,
	TMID_COLOR,
	TMID_CORNER,

	TMID_FREEZE,

	TMID_ON_TOP_ALL,
	TMID_ON_TOP_NONE,
	TMID_LOCK_ALL,
	TMID_LOCK_NONE,

	TMID_EDIT,
	TMID_MAP,
	TMID_UNMAP,

	TMID_FIRE,

	TMID_ADD_TOP,
	TMID_ADD_BOTTOM,
	TMID_MOVE_UP,
	TMID_MOVE_DOWN,

	TMID_SHOW_MOVES,
	TMID_SHOW_JOINS,
	TMID_SHOW_PRINTS,

	TMID_SHOW_FOCUS_TAKEN,

	TMID_SUBSCRIBE,
	TMID_UNSUBSCRIBE,
	TMID_UNSUBSCRIBE_L1,
	TMID_RESUBSCRIBE,

	TMID_ADD_TO_BASKET,
	TMID_REMOVE_FROM_BASKET,

	TMID_INVENTORY_VIEW,
	TMID_NON_INVENTORY_VIEW,

	TMID_INVENTORY_MODE,
	TMID_NON_INVENTORY_MODE,
	TMID_DEFAULT_INVENTORY_MODE,

	TMID_POSITION_SHOW,
	TMID_POSITION_HIDE,
	TMID_REMOVE_INVENTORY,
	TMID_USE_INVENTORY,
	TMID_UNUSE_INVENTORY,
	TMID_SET_INVENTORY_SIZE,
	TMID_SET_INVENTORY_POSITION,

	TMID_NEWS_STOCK,
	TMID_NEWS_UNFILTERED,
	TMID_NEWS_ALL,
	TMID_NEWS_ALL_US,

	ID_NEWS_CONTENTS_TEMPLATE,

	TMID_MARKET_CATEGORY_ALL,
	TMID_MARKET_CATEGORY_NONE,

	TMID_FILTER_ALL,
	TMID_FILTER_NONE,

	TMID_FILTER_ONOPEN_UNDERCOVERED,
	TMID_FILTER_ONOPEN_COVERED,
	TMID_FILTER_ONOPEN_OVERCOVERED,

	TMID_FILTER_ONCLOSE_UNDERCOVERED,
	TMID_FILTER_ONCLOSE_COVERED,
	TMID_FILTER_ONCLOSE_OVERCOVERED,

	TMID_ECN_EXECS_ALL,
	TMID_ECN_EXECS_NONE,

	TMID_PRINTS_ALL,
	TMID_PRINTS_NONE,

	TMID_PRINT_SHOW_ODD_LOT,
	TMID_ECNEXEC_SHOW_ODD_LOT,

	TMID_USE_ODD_LOT_PRINTS,

	TMID_QUOTES_ALL,
	TMID_QUOTES_NONE,

	TMID_SHOW_CHAIN,
	TMID_DISPLAY_LAST_HISTORIC_STORY,
	TMID_FIRST_ONLY,

	TMID_UPDATE_BACKGROUND,
	TMID_UPDATE_FOREGROUND,

	TMID_SOUND_REMOVE,

	TMID_LIVE,
	TMID_TRIGGERED,

	TMID_VALID,
	TMID_INVALID,

	TMID_ALERT_SECURITY_PRINT,
	TMID_ALERT_SECURITY_BID,
	TMID_ALERT_SECURITY_ASK,
	TMID_ALERT_SECURITY_VOLUME,
	TMID_ALERT_TIME,
	TMID_ALERT_SECURITY_INDEX,
	TMID_ALERT_SECURITY_IMBALANCE,
	TMID_ALERT_NEWS,
#ifdef L1_SIZE
	TMID_ALERT_SECURITY_L1_BID_SIZE,
	TMID_ALERT_SECURITY_L1_ASK_SIZE,
#endif
	TMID_ALERT_SECURITY_L2_BID_SIZE,
	TMID_ALERT_SECURITY_L2_ASK_SIZE,
	TMID_ALERT_BORROW_SIZE_AVAILABLE,
	TMID_ALERT_SECURITY_IMB_NY_REFERENCE_PRICE,

	TMID_CLEAR_TRIGGERED,
	
	TMID_LINK,
	TMID_REFRESH_LINK,

	TMID_ACTIVATE_SELECTED,

	TMID_ADD_TAKION_FOLDER,
	TMID_ADD_TAKION_FOLDER_UNLOADED,
	TMID_ADD_ALL,
	TMID_ADD_ALL_UNLOADED,
	TMID_LOAD,
	TMID_UNLOAD,
	TMID_LOAD_ALL,
	TMID_UNLOAD_ALL,

	TMID_MAKE_AUTOLOAD,
	TMID_MAKE_AUTOLOAD_UNLOADED,
	TMID_REMOVE_AUTOLOAD,
	TMID_REPLACE_AUTOLOAD,
	TMID_REPLACE_AUTOLOAD_UNLOADED,

	TMID_MAKE_AUTOLOAD_ALL,
	TMID_MAKE_AUTOLOAD_ALL_UNLOADED,
	TMID_REMOVE_AUTOLOAD_ALL,
	TMID_CLEAR_AUTOLOAD,
	TMID_REPLACE_AUTOLOAD_ALL,
	TMID_REPLACE_AUTOLOAD_ALL_UNLOADED,

	TMID_MUTISELECT,
	TMID_HIDE_SELECTION_NEVER,
	TMID_HIDE_SELECTION_ALWAYS,
	TMID_HIDE_SELECTION_INACTIVE,

	TMID_SELECT_ENABLED,

	TMID_HIGHLIGHT,
	TMID_HIGHLIGHT_TOKENS,
	TMID_HIGHLIGHT_FILTER,

	TMID_USE_ALL,
	TMID_UNUSE_ALL,
	TMID_USE_RANGE,
	TMID_UNUSE_RANGE,

	TMID_FOLLOW_ALL,
	TMID_UNFOLLOW_ALL,
	TMID_FOLLOW_RANGE,
	TMID_UNFOLLOW_RANGE,

	TMID_SELECTED_TO_USED_RANGE,
	TMID_USED_TO_SELECTED_RANGE,
	TMID_SELECTED_TO_USED_ALL,
	TMID_USED_TO_SELECTED_ALL,

	TMID_GRID_VERTICAL,
	TMID_GRID_HORIZONTAL,

	TMID_FACTORY_SETTINGS,

	TMID_FILTER_FLAT,
	TMID_FILTER_LONG,

	TMID_FILTER_BUY,
	TMID_FILTER_SELL,
	TMID_FILTER_SHORT,

	TMID_FILTER_ORDER_SHORT,
	TMID_FILTER_ORDER_PENDING,
	TMID_FILTER_ORDER_BORROW,

	TMID_FILTER_BASKET,

	TMID_FILTER_TODAY,
	TMID_FILTER_OVERNIGHT,

	TMID_FILTER_REAL,
	TMID_FILTER_PHANTOM,

	TMID_FILTER_UNTRADED,
	TMID_FILTER_TRADE,

	TMID_FILTER_BORROW,
	TMID_FILTER_NOT_BORROW,

	TMID_FILTER_NOT_POSTPONED,
	TMID_FILTER_POSTPONED,

	TMID_FILTER_USER_TYPE_IS_0,
	TMID_FILTER_USER_TYPE_GREATER_0,

	TMID_FILTER_MNEMONIC,
	TMID_FILTER_NO_MNEMONIC,

	TMID_FILTER_AUTO_CLOSE,
	TMID_FILTER_NOT_AUTO_CLOSE,

	TMID_FILTER_PENDING,
	TMID_FILTER_NOT_PENDING,

	TMID_FILTER_FILLED,
	TMID_FILTER_CANCELED,
	TMID_FILTER_REJECTED,
	TMID_FILTER_ALGORITHM,
	TMID_FILTER_KICKED,
	TMID_FILTER_BLOCKED,

	TMID_FILTER_NON_STOP,
	TMID_FILTER_STOP_NATIVE,
	TMID_FILTER_STOP_TRAILING,
	TMID_FILTER_STOP_SYNTHETIC,

	TMID_FILTER_DIRECTION_DEAD,
	TMID_FILTER_DIRECTION_CLOSE,
	TMID_FILTER_DIRECTION_OPEN,
	TMID_FILTER_DIRECTION_ADD,

	TMID_FILTER_TIF_ALL,
	TMID_FILTER_TIF_NONE,
	TMID_FILTER_TIF_DAY,
	TMID_FILTER_TIF_GTC,
	TMID_FILTER_TIF_OPG,
	TMID_FILTER_TIF_IOC,
	TMID_FILTER_TIF_FOK,
	TMID_FILTER_TIF_GTX,
	TMID_FILTER_TIF_GTD,
	TMID_FILTER_TIF_ATC,
	TMID_FILTER_TIF_GTT,

	TMID_FILTER_PQOPEN,
	TMID_FILTER_NOT_PQOPEN,
	TMID_FILTER_TCLOSE,
	TMID_FILTER_NOT_TCLOSE,

	TMID_FILTER_INVENTORY,
	TMID_FILTER_NOT_INVENTORY,

	TMID_FILTER_HIDDEN,
	TMID_FILTER_NOT_HIDDEN,

	TMID_FILTER_POS_INVENTORY,
	TMID_FILTER_POS_NOT_INVENTORY,

	TMID_FILTER_POS_HIDDEN,
	TMID_FILTER_POS_NOT_HIDDEN,

	TMID_TIME_FRAME_IN_MINUTES,

	TMID_CANCEL_ORDER,
	TMID_REPLACE_ORDER,
	TMID_ACTIVE_CANCEL_ORDER,
	TMID_ORDER_NO_MASS_CANCEL,
	TMID_ORDER_UNPOSTPONE,
	TMID_ORDER_MAKE_GTC,
	TMID_ORDER_MAKE_NON_GTC,
	TMID_EXECUTE_ORDER_IN_SIMULATION,

	TMID_OCO_NEXT,
	TMID_OCO_NONE,
	TMID_OCO_CURRENT,
	TMID_OCO_ADD,
	TMID_OCO_REMOVE,
	TMID_OCO_CLEAR,

	TMID_ACTIVE_STOCK,
	TMID_ACTIVE_INCLUDE_STOCK,
	TMID_ACTIVE_EXCLUDE_STOCK,

	TMID_NOTIFY_EXTENSIONS,

	TMID_EXT_LINK_WAIT_REFRESH,
	TMID_EXT_LINK_RECIPIENT,

	TMID_ESIGNAL_0,
	TMID_ESIGNAL_1,
	TMID_ESIGNAL_2,
	TMID_ESIGNAL_3,
	TMID_ESIGNAL_4,
	TMID_ESIGNAL_5,
	TMID_ESIGNAL_6,
	TMID_ESIGNAL_7,
	TMID_ESIGNAL_8,
	TMID_ESIGNAL_9,
	TMID_ESIGNAL_10,
	TMID_ESIGNAL_11,
	TMID_ESIGNAL_12,
	TMID_ESIGNAL_13,
	TMID_ESIGNAL_14,
	TMID_ESIGNAL_MINUS_1,

	TMID_TOOL_GROUP_0,
	TMID_TOOL_GROUP_1,
	TMID_TOOL_GROUP_2,
	TMID_TOOL_GROUP_3,
	TMID_TOOL_GROUP_4,
	TMID_TOOL_GROUP_5,
	TMID_TOOL_GROUP_6,
	TMID_TOOL_GROUP_7,
	TMID_TOOL_GROUP_8,
	TMID_TOOL_GROUP_9,
	TMID_TOOL_GROUP_10,
	TMID_TOOL_GROUP_11,
	TMID_TOOL_GROUP_12,
	TMID_TOOL_GROUP_13,
	TMID_TOOL_GROUP_14,
	TMID_TOOL_GROUP_MINUS_1,

	TMID_BLOOMBERG_0,
	TMID_BLOOMBERG_1,
	TMID_BLOOMBERG_2,
	TMID_BLOOMBERG_3,
	TMID_BLOOMBERG_4,
	TMID_BLOOMBERG_5,
	TMID_BLOOMBERG_6,
	TMID_BLOOMBERG_7,
	TMID_BLOOMBERG_8,
	TMID_BLOOMBERG_9,
	TMID_BLOOMBERG_10,
	TMID_BLOOMBERG_11,
	TMID_BLOOMBERG_12,
	TMID_BLOOMBERG_13,
	TMID_BLOOMBERG_14,
//	TMID_BLOOMBERG_ALL,

	TMID_SHOW_MILLISECONDS,
	TMID_TOOLTIP_COLUMN,

	TMID_RECEIVED,
	TMID_SENT,
	TMID_TIMER,
	TMID_START,
	TMID_STOP,
	TMID_START_ALL,
	TMID_STOP_ALL,

	TMID_ALL,
	TMID_NONE,

	TMID_TEST,
	TMID_TEST_DURATION,

	TMID_COMMA_PRICE,
	TMID_COMMA_SIZE,
	TMID_COMMA_MONEY,
	TMID_COMMA_VOLUME,

	TMID_DEC_MONEY_0,
	TMID_DEC_MONEY_1,
	TMID_DEC_MONEY_2,
	TMID_DEC_MONEY_3,
	TMID_DEC_MONEY_4,
	TMID_TRUNCATE_MONEY,

	ID_DEC_2,
	ID_DEC_3,
	ID_DEC_4,
	TMID_TRUNCATE_PRICE,

	ID_SIZE_IN_SHARES,
	ID_PRE_POST_MARKET,
	ID_TRUNCATE,

	ID_DOLLAR_2,
	ID_DOLLAR_3,
	ID_DOLLAR_4,
	ID_DOLLAR_5,
	ID_DOLLAR_6,

	ID_SIZE_2,
	ID_SIZE_3,
	ID_SIZE_4,
	ID_SIZE_5,
	ID_SIZE_6,

	ID_PIN,
	ID_UNPIN,

	ID_TOOLTIP_LEVEL1,
	ID_TOOLTIP_TITLE,

	TMID_COLUMNS,
#ifdef SECONDARY_ROWS
	TMID_2ND_ROWS_NEW_VISIBLE,
	TMID_2ND_ROWS_SHOW_ALL,
	TMID_2ND_ROWS_HIDE_ALL,
	TMID_2ND_ROWS_SHOW,
	TMID_2ND_ROWS_HIDE,
	TMID_2ND_COLUMNS,
	TMID_2ND_GRAPHICS,
	TMID_2ND_FONT,
	TMID_2ND_COLOR,
	TMID_2ND_ROWS_SHOW_PLUS_MINUS_COLOR,
	TMID_DBLCLK_TOGGLE_EXPAND,
#endif

	TMID_LOAD_ALL_ORDERS,
	TMID_LOAD_ALL_EXECUTIONS,
	TMID_LOAD_ALL_ORDERS_AND_EXECUTIONS,

	TMID_ACCOUNT_CURRENT,
	TMID_ACCOUNT_ALL,
	TMID_ACCOUNT_MERGE,
	TMID_ACCOUNT_LIST,

	TMID_WINDOW_LIST,

	TMID_SCROLL_BAR_HORIZONTAL,
	TMID_SCROLL_BAR_VERTICAL,
	TMID_SCROLL_UP,
	TMID_SCROLL_DOWN,

	TMID_SHOW_PLUS_MINUS_COLOR,
	TMID_SHOW_TICKS,
	TMID_TICK_FLASH_1,
	TMID_TICK_FLASH_2,
	TMID_TICK_FLASH_3,
	TMID_USE_BACKGROUND,

	TMID_ENTIRE,
	TMID_HILITE_NON_MARKET,
	TMID_HILITE_POST_MARKET,
	TMID_NON_MARKET_USE_BACKGROUND,
	TMID_NON_MARKET_ENTIRE,

	TMID_BASKET_USE_BACKGROUND,
	TMID_BASKET_ENTIRE,

	TMID_FILTER_SIZE,

	TMID_FILTER,
	TMID_ATTRIBUTION,

	TMID_LIMITS,

	TMID_SECURITY_FILTER,

	TMID_DBLCLK_POPULATE_MM,
	TMID_DBLCLK_MAKE_CURRENT,
	TMID_DBLCLK_CANCEL_ORDER,
	TMID_DBLCLK_VISIT_URL,

	TMID_TOP_ACTIVE,

	TMID_PREFIX,

	TMID_TOTAL,

	TMID_DATA_BITS,
	TMID_DATA_BYTES,

	TMID_USE_FOR_HELP,
	TMID_ACTIVATE_ON_NEW,
	TMID_BACK,
	TMID_FORWARD,
	TMID_HOME,
	TMID_LINK_URL,
	TMID_GOTO,

	TMID_VISIT_URL,
	TMID_VISIT_SELECTED_URL,

	TMID_PHANTOM_BUY,
	TMID_PHANTOM_SELL,
	TMID_PHANTOM_FLIP,
	TMID_PHANTOM_REMOVE,
	TMID_PHANTOM_REMOVE_ALL_VISIBLE,
	TMID_PHANTOM_REMOVE_ALL,

	TMID_CANCEL_ORDERS_ALL,
	TMID_CANCEL_ORDERS_OPENING,

	TMID_OPEN,
	TMID_SAVE,
	TMID_SAVE_AS,

	TMID_SAVE_SELECTION,

	TMID_COPY_ALL,
	TMID_REMOVE_ALL,

	TMID_COPY_NAME,
	TMID_PASTE_NAME,

	TMID_PASTE_STOCKS,
	TMID_NEW_BASKET,
	TMID_EMPTY,

	TMID_TOOLTIP_WORKSPACE,
	TMID_TOOLTIP_LAYER,
	TMID_TOOLTIP_TOOL,
	TMID_TOOLTIP_VALUE,
	TMID_TOOLTIP_CONTROL,

	TMID_SHOW_TOOLTIPS,

	TMID_SAVE_POS_COST,
	TMID_OPEN_POS_COST,
	TMID_CLEAR_POS_COST,
	TMID_SAVE_NEW_POS_COST,

	TMID_SAVE_SELECTED,
	TMID_SAVE_FILTERED,
	TMID_SAVE_ALL,
	TMID_SAVE_SELECTED_AS,
	TMID_SAVE_FILTERED_AS,
	TMID_SAVE_ALL_AS,

	TMID_NOTE_ADD,
	TMID_NOTE_REMOVE,
	TMID_NOTE_CLEAR,
	TMID_NOTE_PASTE,

	TMID_SNAPSHOT_ONLY,
	TMID_REFRESH,

#ifndef TAKION_NO_OPTIONS
	TMID_FILTER_CALL,
	TMID_FILTER_PUT,

	TMID_FILTER_WEEKLY,
	TMID_FILTER_MONTHLY,
	TMID_FILTER_QUARTERLY,

	TMID_USE_EXP_COLORS,
	TMID_USE_INOUT_MONEY_COLORS,
//	TMID_INDEX_OPTION,

	TMID_FILTER_STOCK,
	TMID_FILTER_OPTION,

	TMID_COMMANDS_TRADE_OPTIONS_ALL,
	TMID_COMMANDS_TRADE_OPTIONS_NONE,
#endif
#ifdef _DEBUG
	TMID_DEBUG,
#endif
	TMID_LAST
};

void WINAPI TGUI_Initialize(bool versionValid, const char* exePath, const char* iniFile, const char* productName, const char* companyName, const char* legalCopyright, HICON icon, HICON icon16x16, TakionVisual* visual,
	HANDLE processDataEvent, FEmpty processData, FLong processMainThreadIdleTasks);//, FLong onIdle, FBool fInterrupt);
void WINAPI TGUI_InitializeConfig(TakionConfig* config, TakionConfig* defaultConfig, unsigned int lastMenuId);
void WINAPI TGUI_Terminate();
TakionMainWnd* WINAPI TGUI_GetTakionMainWnd();
//TakionConfig* WINAPI TGUI_GetSavedConfig();
const unsigned __int64& WINAPI TGUI_GetTakionDataHeaderVersion();
const char* WINAPI TGUI_GetTakionDataHeaderVersionStr();

void WINAPI TGUI_CalculateKeySizes(HDC hdc,
	int& modifierWidth,
	int& locknumWidth,
	int& keyWidth,
	int& keyHeight,
	const int& itemHeight,
	HFONT textFont,
	CFont* asciiFont,
	CFont* modifierFont);

void WINAPI TGUI_DrawKey(HDC dc,
	const CRect& rect,
	int modifierWidth,
	int locknumWidth,
	const Key& key,
	CFont* asciiFont,
	CFont* modifierFont,
	COLORREF bkColor,
	COLORREF textColor,
	COLORREF shiftColor,
	COLORREF ctrlColor,
	COLORREF altColor,
	COLORREF capsColor,
	COLORREF numColor,
	COLORREF lightColor,
	COLORREF darkColor,
	bool recessed);

void WINAPI TGUI_SetLogFile(void* logFile);
void* WINAPI TGUI_GetLogFile();

void WINAPI TGUI_DrawCommandMenuItem(const Command* command, HDC hdc, const RECT& rect, COLORREF textColor, bool selected, unsigned char checkable, bool checked, COLORREF foregroundColor = 0xFFFFFFFF);
void WINAPI TGUI_DrawKeyMenuItem(const Key& key, HDC hdc, const RECT& rect, bool selected, bool grayed, unsigned char checkable, bool checked, COLORREF foregroundColor = 0xFFFFFFFF);

//void WINAPI TGUI_DrawNamedFilterMenuItem(const DRAWITEMSTRUCT* lpDrawItemStruct, unsigned char nativeFilterType);

const char* WINAPI TGUI_GetExePath();
const char* WINAPI TGUI_GetExeIniFilePath();

//AdditionalColumnAPI
typedef bool (WINAPI* AcApiBoolCharPtr)(const char* str);
typedef bool (WINAPI* AcApiColumnInfo)(unsigned short i, const char*& columnName, int& width, unsigned char& useTick, bool& sortable, bool& defaultSortAscending, const char*& columnTooltip, unsigned char& followable, UINT& defaultHorizontalJustification);
typedef bool (WINAPI* AcApiIsByUShort)(unsigned short i);

typedef RowValue* (WINAPI* AcApiMsRowValue)(unsigned short i, MarketSorterRow* row, const MarketSorterWindow* msWindow, bool& dynamic);
typedef RowValue* (WINAPI* AcApiMsTotalRowValue)(unsigned short i, const MarketSorterWindow* msWindow, bool& cumulative);
typedef void (WINAPI* AcApiApplyMsPosition)(MarketSorterRow* row, const Position* position);
typedef void (WINAPI* AcApiMsRow)(MarketSorterRow* row);
typedef bool (WINAPI* AcApiBoolMsRow)(MarketSorterRow* row);
typedef void (WINAPI* AcApiConstMsRow)(const MarketSorterRow* row);
typedef bool (WINAPI* AcApiBoolConstMsRow)(const MarketSorterRow* row);
typedef void (WINAPI* AcApiMsWindow)(const MarketSorterWindow* window);
typedef COLORREF (WINAPI* AcApiMsRowCellColor)(unsigned short i, const MarketSorterRow* row);
typedef bool (WINAPI* AcApiMsAddNonCumulative)(RowValue* rowValue, unsigned short i, MarketSorterRowTotal* rowTotal, const Row* row);

typedef RowValue* (WINAPI* AcApiOrdRowValue)(unsigned short i, OrderRow* row, const RowWindowSortable* ordWindow, bool& dynamic);
typedef RowValue* (WINAPI* AcApiOrdTotalRowValue)(unsigned short i, const RowWindowSortable* posWindow, bool& cumulative);
typedef COLORREF (WINAPI* AcApiOrdRowCellColor)(unsigned short i, const OrderRow* row);
typedef bool (WINAPI* AcApiOrdAddNonCumulative)(RowValue* rowValue, unsigned short i, OrderRowTotal* rowTotal, const Row* row);

typedef RowValue* (WINAPI* AcApiPosRowValue)(unsigned short i, PositionRow* row, const RowWindowSortable* posWindow, bool& dynamic);
typedef RowValue* (WINAPI* AcApiPosTotalRowValue)(unsigned short i, const RowWindowSortable* posWindow, bool& cumulative);
typedef COLORREF (WINAPI* AcApiPosRowCellColor)(unsigned short i, const PositionRow* row);
typedef bool (WINAPI* AcApiPosAddNonCumulative)(RowValue* rowValue, unsigned short i, PositionRowTotal* rowTotal, const Row* row);

typedef RowValue* (WINAPI* AcApiActRowValue)(unsigned short i, AccountRow* row, const AccountWindow* actWindow, bool& dynamic);
typedef RowValue* (WINAPI* AcApiActTotalRowValue)(unsigned short i, const AccountWindow* actWindow, bool& cumulative);
typedef COLORREF (WINAPI* AcApiActRowCellColor)(unsigned short i, const AccountRow* row);
typedef bool (WINAPI* AcApiActAddNonCumulative)(RowValue* rowValue, unsigned short i, AccountRowTotal* rowTotal, const Row* row);

//AdditionalColumnApi
bool WINAPI IsTraderIdValid(const char* traderId);

unsigned short WINAPI GetMsAdditionalColumnCount();
RowValue* WINAPI CreateMsRowValue(unsigned short i, MarketSorterRow* row, const MarketSorterWindow* msWindow, bool& dynamic);
RowValue* WINAPI CreateMsTotalRowValue(unsigned short i, const MarketSorterWindow* msWindow, bool& cumulative);
bool WINAPI GetMsColumnInfo(unsigned short i, const char*& columnName, int& width, unsigned char& useTick, bool& sortable, bool& defaultSortAscending, const char*& columnTooltip, unsigned char& followable, UINT& defaultHorizontalJustification);
bool WINAPI IsMsColumnPosition(unsigned short i);
void WINAPI ApplyMsPosition(MarketSorterRow* row, const Position* position);
void WINAPI InvalidateMsPositionColumns(const MarketSorterWindow* window);
void WINAPI InvalidateMsPositionTotals(const MarketSorterWindow* window);
void WINAPI UpdateMsPositionValues(MarketSorterRow* row);
void WINAPI AdjustMsPositionTotals(MarketSorterRow* row);
COLORREF WINAPI GetMsCellColor(unsigned short i, const MarketSorterRow* row);
bool WINAPI AdditionalMsLock(const MarketSorterRow* row);
void WINAPI AdditionalMsLockWait(const MarketSorterRow* row);
void WINAPI AdditionalMsUnlock(const MarketSorterRow* row);
bool WINAPI MsUpdateNonCumulativeRowValue(RowValue* rowValue, unsigned short i, MarketSorterRowTotal* rowTotal, const Row* rowUpdated);
bool WINAPI MsAddNonCumulativeRowValue(RowValue* rowValue, unsigned short i, MarketSorterRowTotal* rowTotal, const Row* rowToAdd);
bool WINAPI MsRemoveNonCumulativeRowValue(RowValue* rowValue, unsigned short i, MarketSorterRowTotal* rowTotal, const Row* rowToRemove);

unsigned short WINAPI GetOrdAdditionalColumnCount();
RowValue* WINAPI CreateOrdRowValue(unsigned short i, OrderRow* row, const RowWindowSortable* ordWindow, bool& dynamic);
RowValue* WINAPI CreateOrdTotalRowValue(unsigned short i, const RowWindowSortable* ordWindow, bool& cumulative);
bool WINAPI GetOrdColumnInfo(unsigned short i, const char*& columnName, int& width, unsigned char& useTick, bool& sortable, bool& defaultSortAscending, const char*& columnTooltip, unsigned char& followable, UINT& defaultHorizontalJustification);
COLORREF WINAPI GetOrdCellColor(unsigned short i, const OrderRow* row);
bool WINAPI OrdUpdateNonCumulativeRowValue(RowValue* rowValue, unsigned short i, OrderRowTotal* rowTotal, const Row* rowUpdated);
bool WINAPI OrdAddNonCumulativeRowValue(RowValue* rowValue, unsigned short i, OrderRowTotal* rowTotal, const Row* rowToAdd);
bool WINAPI OrdRemoveNonCumulativeRowValue(RowValue* rowValue, unsigned short i, OrderRowTotal* rowTotal, const Row* rowToRemove);

unsigned short WINAPI GetPosAdditionalColumnCount();
RowValue* WINAPI CreatePosRowValue(unsigned short i, PositionRow* row, const RowWindowSortable* posWindow, bool& dynamic);
RowValue* WINAPI CreatePosTotalRowValue(unsigned short i, const RowWindowSortable* posWindow, bool& cumulative);
bool WINAPI GetPosColumnInfo(unsigned short i, const char*& columnName, int& width, unsigned char& useTick, bool& sortable, bool& defaultSortAscending, const char*& columnTooltip, unsigned char& followable, UINT& defaultHorizontalJustification);
COLORREF WINAPI GetPosCellColor(unsigned short i, const PositionRow* row);
bool WINAPI PosUpdateNonCumulativeRowValue(RowValue* rowValue, unsigned short i, PositionRowTotal* rowTotal, const Row* rowUpdated);
bool WINAPI PosAddNonCumulativeRowValue(RowValue* rowValue, unsigned short i, PositionRowTotal* rowTotal, const Row* rowToAdd);
bool WINAPI PosRemoveNonCumulativeRowValue(RowValue* rowValue, unsigned short i, PositionRowTotal* rowTotal, const Row* rowToRemove);

unsigned short WINAPI GetActAdditionalColumnCount();
RowValue* WINAPI CreateActRowValue(unsigned short i, AccountRow* row, const AccountWindow* actWindow, bool& dynamic);
RowValue* WINAPI CreateActTotalRowValue(unsigned short i, const AccountWindow* actWindow, bool& cumulative);
bool WINAPI GetActColumnInfo(unsigned short i, const char*& columnName, int& width, unsigned char& useTick, bool& sortable, bool& defaultSortAscending, const char*& columnTooltip, unsigned char& followable, UINT& defaultHorizontalJustification);
COLORREF WINAPI GetActCellColor(unsigned short i, const AccountRow* row);
bool WINAPI ActUpdateNonCumulativeRowValue(RowValue* rowValue, unsigned short i, AccountRowTotal* rowTotal, const Row* rowUpdated);
bool WINAPI ActAddNonCumulativeRowValue(RowValue* rowValue, unsigned short i, AccountRowTotal* rowTotal, const Row* rowToAdd);
bool WINAPI ActRemoveNonCumulativeRowValue(RowValue* rowValue, unsigned short i, AccountRowTotal* rowTotal, const Row* rowToRemove);

///////////////

#ifdef __cplusplus
}
#endif


class TGUI_API AdditionalColumnDll : public BaseExtensionDll
{
public:
	AdditionalColumnDll(const char* absolutePath);
	AdditionalColumnDll(const char* name, const char* path);

	AcApiBoolCharPtr GetIsTraderIdValidFunction() const{return m_IsTraderIdValidFunction;}
//MarketSorterWindow
	ApiGetUShort GetMsAdditionalColumnCountFunction() const{return m_MsAdditionalColumnCountFunction;}
	const unsigned short& AcDllGetMsAdditionalColumnCount() const{return m_msAdditionalColumnCount;}

	AcApiMsRowValue GetMsRowValueFunction() const{return m_MsRowValueFunction;}
	RowValue* AcDllCreateMsRowValue(unsigned short i, MarketSorterRow* row, const MarketSorterWindow* msWindow, bool& dynamic) const{return m_MsRowValueFunction ? m_MsRowValueFunction(i, row, msWindow, dynamic) : NULL;}

	AcApiBoolConstMsRow GetMsRowLockFunction() const{return m_MsRowLockFunction;}
	bool AcDllMsRowLock(const MarketSorterRow* row) const{return !m_MsRowLockFunction || m_MsRowLockFunction(row);}

	AcApiConstMsRow GetMsRowLockWaitFunction() const{return m_MsRowLockWaitFunction;}
	void AcDllMsRowLockWait(const MarketSorterRow* row) const{if(m_MsRowLockWaitFunction)m_MsRowLockWaitFunction(row);}

	AcApiConstMsRow GetMsRowUnlockFunction() const{return m_MsRowUnlockFunction;}
	void AcDllMsRowUnlock(const MarketSorterRow* row) const{if(m_MsRowUnlockFunction)m_MsRowUnlockFunction(row);}

	AcApiMsTotalRowValue GetMsTotalRowValueFunction() const{return m_MsTotalRowValueFunction;}
	RowValue* AcDllCreateMsTotalRowValue(unsigned short i, const MarketSorterWindow* msWindow, bool& cumulative) const{return m_MsTotalRowValueFunction ? m_MsTotalRowValueFunction(i, msWindow, cumulative) : NULL;}

	AcApiColumnInfo GetMsColumnInfoFunction() const{return m_MsColumnInfoFunction;}
	bool AcDllGetMsColumnInfo(unsigned short i, const char*& columnName, int& width, unsigned char& useTicks, bool& sortable, bool& defaultSortAscending, const char*& columnTooltip, unsigned char& followable, UINT& defaultHorizontalJustification) const
	{
		return m_MsColumnInfoFunction ? m_MsColumnInfoFunction(i, columnName, width, useTicks, sortable, defaultSortAscending, columnTooltip, followable, defaultHorizontalJustification) : NULL;
	}

	AcApiIsByUShort GetMsColumnPositionFunction() const{return m_MsColumnPositionFunction;}
	bool AcDllIsMsColumnPosition(unsigned short i) const{return m_MsColumnPositionFunction ? m_MsColumnPositionFunction(i) : false;}

	AcApiApplyMsPosition GetMsApplyPositionFunction() const{return m_MsApplyPositionFunction;}
	void AcDllApplyMsPosition(MarketSorterRow* row, const Position* position) const{if(m_MsApplyPositionFunction)m_MsApplyPositionFunction(row, position);}

	AcApiMsWindow GetMsInvalidatePositionColumnsFunction() const{return m_MsInvalidatePositionColumnsFunction;}
	void AcDllInvalidatePositionColumns(const MarketSorterWindow* window) const{if(m_MsInvalidatePositionColumnsFunction)m_MsInvalidatePositionColumnsFunction(window);}

	AcApiMsWindow GetMsInvalidatePositionTotalsFunction() const{return m_MsInvalidatePositionTotalsFunction;}
	void AcDllInvalidatePositionTotals(const MarketSorterWindow* window) const{if(m_MsInvalidatePositionTotalsFunction)m_MsInvalidatePositionTotalsFunction(window);}

	AcApiMsRow GetMsUpdatePositionValuesFunction() const{return m_MsUpdatePositionValuesFunction;}
	void AcDllUpdatePositionValues(MarketSorterRow* row) const{if(m_MsUpdatePositionValuesFunction)m_MsUpdatePositionValuesFunction(row);}

	AcApiMsRow GetMsAdjustPositionTotalsFunction() const{return m_MsAdjustPositionTotalsFunction;}
	void AcDllAdjustPositionTotals(MarketSorterRow* row) const{if(m_MsAdjustPositionTotalsFunction)m_MsAdjustPositionTotalsFunction(row);}

	AcApiMsRowCellColor GetMsRowCellColorFunction() const{return m_MsRowCellColorFunction;}
	COLORREF AcDllGetMsCellColor(unsigned short i, const MarketSorterRow* row)const{return m_MsRowCellColorFunction ? m_MsRowCellColorFunction(i, row) : 0xFFFFFFFF;}

	AcApiMsAddNonCumulative GetMsUpdateNonCumulativeFunction() const{return m_MsUpdateNonCumulativeFunction;}
	bool AcDllMsUpdateNonCumulativeRowValue(RowValue* rowValue, unsigned short i, MarketSorterRowTotal* rowTotal, const Row* rowUpdated) const
	{
		return m_MsUpdateNonCumulativeFunction && m_MsUpdateNonCumulativeFunction(rowValue, i, rowTotal, rowUpdated);
	}

	AcApiMsAddNonCumulative GetMsAddNonCumulativeFunction() const{return m_MsAddNonCumulativeFunction;}
	bool AcDllMsAddNonCumulativeRowValue(RowValue* rowValue, unsigned short i, MarketSorterRowTotal* rowTotal, const Row* rowToAdd) const
	{
		return m_MsAddNonCumulativeFunction && m_MsAddNonCumulativeFunction(rowValue, i, rowTotal, rowToAdd);
	}

	AcApiMsAddNonCumulative GetMsRemoveNonCumulativeFunction() const{return m_MsRemoveNonCumulativeFunction;}
	bool AcDllMsRemoveNonCumulativeRowValue(RowValue* rowValue, unsigned short i, MarketSorterRowTotal* rowTotal, const Row* rowToRemove) const
	{
		return m_MsRemoveNonCumulativeFunction && m_MsRemoveNonCumulativeFunction(rowValue, i, rowTotal, rowToRemove);
	}

//OrderWindow
	ApiGetUShort GetOrdAdditionalColumnCountFunction() const{return m_OrdAdditionalColumnCountFunction;}
	const unsigned short& AcDllGetOrdAdditionalColumnCount() const{return m_ordAdditionalColumnCount;}

	AcApiOrdRowValue GetOrdRowValueFunction() const{return m_OrdRowValueFunction;}
	RowValue* AcDllCreateOrdRowValue(unsigned short i, OrderRow* row, const RowWindowSortable* ordWindow, bool& dynamic) const{return m_OrdRowValueFunction ? m_OrdRowValueFunction(i, row, ordWindow, dynamic) : NULL;}

	AcApiOrdTotalRowValue GetOrdTotalRowValueFunction() const{return m_OrdTotalRowValueFunction;}
	RowValue* AcDllCreateOrdTotalRowValue(unsigned short i, const RowWindowSortable* ordWindow, bool& cumulative) const{return m_OrdTotalRowValueFunction ? m_OrdTotalRowValueFunction(i, ordWindow, cumulative) : NULL;}

	AcApiColumnInfo GetOrdColumnInfoFunction() const{return m_OrdColumnInfoFunction;}
	bool AcDllGetOrdColumnInfo(unsigned short i, const char*& columnName, int& width, unsigned char& useTicks, bool& sortable, bool& defaultSortAscending, const char*& columnTooltip, unsigned char& followable, UINT& defaultHorizontalJustification) const
	{
		return m_OrdColumnInfoFunction ? m_OrdColumnInfoFunction(i, columnName, width, useTicks, sortable, defaultSortAscending, columnTooltip, followable, defaultHorizontalJustification) : NULL;
	}

	AcApiOrdAddNonCumulative GetOrdUpdateNonCumulativeFunction() const{return m_OrdUpdateNonCumulativeFunction;}
	bool AcDllOrdUpdateNonCumulativeRowValue(RowValue* rowValue, unsigned short i, OrderRowTotal* rowTotal, const Row* rowUpdated) const
	{
		return m_OrdUpdateNonCumulativeFunction && m_OrdUpdateNonCumulativeFunction(rowValue, i, rowTotal, rowUpdated);
	}

	AcApiOrdAddNonCumulative GetOrdAddNonCumulativeFunction() const{return m_OrdAddNonCumulativeFunction;}
	bool AcDllOrdAddNonCumulativeRowValue(RowValue* rowValue, unsigned short i, OrderRowTotal* rowTotal, const Row* rowToAdd) const
	{
		return m_OrdAddNonCumulativeFunction && m_OrdAddNonCumulativeFunction(rowValue, i, rowTotal, rowToAdd);
	}

	AcApiOrdAddNonCumulative GetOrdRemoveNonCumulativeFunction() const{return m_OrdRemoveNonCumulativeFunction;}
	bool AcDllOrdRemoveNonCumulativeRowValue(RowValue* rowValue, unsigned short i, OrderRowTotal* rowTotal, const Row* rowToRemove) const
	{
		return m_OrdRemoveNonCumulativeFunction && m_OrdRemoveNonCumulativeFunction(rowValue, i, rowTotal, rowToRemove);
	}

	AcApiOrdRowCellColor GetOrdRowCellColorFunction() const{return m_OrdRowCellColorFunction;}
	COLORREF AcDllGetOrdCellColor(unsigned short i, const OrderRow* row)const{return m_OrdRowCellColorFunction ? m_OrdRowCellColorFunction(i, row) : 0xFFFFFFFF;}
//PositionWindow
	ApiGetUShort GetPosAdditionalColumnCountFunction() const{return m_PosAdditionalColumnCountFunction;}
	const unsigned short& AcDllGetPosAdditionalColumnCount() const{return m_posAdditionalColumnCount;}

	AcApiPosRowValue GetPosRowValueFunction() const{return m_PosRowValueFunction;}
	RowValue* AcDllCreatePosRowValue(unsigned short i, PositionRow* row, const RowWindowSortable* posWindow, bool& dynamic) const{return m_PosRowValueFunction ? m_PosRowValueFunction(i, row, posWindow, dynamic) : NULL;}

	AcApiPosTotalRowValue GetPosTotalRowValueFunction() const{return m_PosTotalRowValueFunction;}
	RowValue* AcDllCreatePosTotalRowValue(unsigned short i, const RowWindowSortable* posWindow, bool& cumulative) const{return m_PosTotalRowValueFunction ? m_PosTotalRowValueFunction(i, posWindow, cumulative) : NULL;}

	AcApiColumnInfo GetPosColumnInfoFunction() const{return m_PosColumnInfoFunction;}
	bool AcDllGetPosColumnInfo(unsigned short i, const char*& columnName, int& width, unsigned char& useTicks, bool& sortable, bool& defaultSortAscending, const char*& columnTooltip, unsigned char& followable, UINT& defaultHorizontalJustification) const
	{
		return m_PosColumnInfoFunction ? m_PosColumnInfoFunction(i, columnName, width, useTicks, sortable, defaultSortAscending, columnTooltip, followable, defaultHorizontalJustification) : NULL;
	}

	AcApiPosAddNonCumulative GetPosUpdateNonCumulativeFunction() const{return m_PosUpdateNonCumulativeFunction;}
	bool AcDllPosUpdateNonCumulativeRowValue(RowValue* rowValue, unsigned short i, PositionRowTotal* rowTotal, const Row* rowUpdated) const
	{
		return m_PosUpdateNonCumulativeFunction && m_PosUpdateNonCumulativeFunction(rowValue, i, rowTotal, rowUpdated);
	}

	AcApiPosAddNonCumulative GetPosAddNonCumulativeFunction() const{return m_PosAddNonCumulativeFunction;}
	bool AcDllPosAddNonCumulativeRowValue(RowValue* rowValue, unsigned short i, PositionRowTotal* rowTotal, const Row* rowToAdd) const
	{
		return m_PosAddNonCumulativeFunction && m_PosAddNonCumulativeFunction(rowValue, i, rowTotal, rowToAdd);
	}

	AcApiPosAddNonCumulative GetPosRemoveNonCumulativeFunction() const{return m_PosRemoveNonCumulativeFunction;}
	bool AcDllPosRemoveNonCumulativeRowValue(RowValue* rowValue, unsigned short i, PositionRowTotal* rowTotal, const Row* rowToRemove) const
	{
		return m_PosRemoveNonCumulativeFunction && m_PosRemoveNonCumulativeFunction(rowValue, i, rowTotal, rowToRemove);
	}

	AcApiPosRowCellColor GetPosRowCellColorFunction() const{return m_PosRowCellColorFunction;}
	COLORREF AcDllGetPosCellColor(unsigned short i, const PositionRow* row)const{return m_PosRowCellColorFunction ? m_PosRowCellColorFunction(i, row) : 0xFFFFFFFF;}
//AccountWindow
	ApiGetUShort GetActAdditionalColumnCountFunction() const{return m_ActAdditionalColumnCountFunction;}
	const unsigned short& AcDllGetActAdditionalColumnCount() const{return m_actAdditionalColumnCount;}

	AcApiActRowValue GetActRowValueFunction() const{return m_ActRowValueFunction;}
	RowValue* AcDllCreateActRowValue(unsigned short i, AccountRow* row, const AccountWindow* actWindow, bool& dynamic) const{return m_ActRowValueFunction ? m_ActRowValueFunction(i, row, actWindow, dynamic) : NULL;}

	AcApiActTotalRowValue GetActTotalRowValueFunction() const{return m_ActTotalRowValueFunction;}
	RowValue* AcDllCreateActTotalRowValue(unsigned short i, const AccountWindow* actWindow, bool& cumulative) const{return m_ActTotalRowValueFunction ? m_ActTotalRowValueFunction(i, actWindow, cumulative) : NULL;}

	AcApiColumnInfo GetActColumnInfoFunction() const{return m_ActColumnInfoFunction;}
	bool AcDllGetActColumnInfo(unsigned short i, const char*& columnName, int& width, unsigned char& useTicks, bool& sortable, bool& defaultSortAscending, const char*& columnTooltip, unsigned char& followable, UINT& defaultHorizontalJustification) const
	{
		return m_ActColumnInfoFunction ? m_ActColumnInfoFunction(i, columnName, width, useTicks, sortable, defaultSortAscending, columnTooltip, followable, defaultHorizontalJustification) : NULL;
	}

	AcApiActRowCellColor GetActRowCellColorFunction() const{return m_ActRowCellColorFunction;}
	COLORREF AcDllGetActCellColor(unsigned short i, const AccountRow* row)const{return m_ActRowCellColorFunction ? m_ActRowCellColorFunction(i, row) : 0xFFFFFFFF;}

	AcApiActAddNonCumulative GetActUpdateNonCumulativeFunction() const{return m_ActUpdateNonCumulativeFunction;}
	bool AcDllActUpdateNonCumulativeRowValue(RowValue* rowValue, unsigned short i, AccountRowTotal* rowTotal, const Row* rowUpdated) const
	{
		return m_ActUpdateNonCumulativeFunction && m_ActUpdateNonCumulativeFunction(rowValue, i, rowTotal, rowUpdated);
	}

	AcApiActAddNonCumulative GetActAddNonCumulativeFunction() const{return m_ActAddNonCumulativeFunction;}
	bool AcDllActAddNonCumulativeRowValue(RowValue* rowValue, unsigned short i, AccountRowTotal* rowTotal, const Row* rowToAdd) const
	{
		return m_ActAddNonCumulativeFunction && m_ActAddNonCumulativeFunction(rowValue, i, rowTotal, rowToAdd);
	}

	AcApiActAddNonCumulative GetActRemoveNonCumulativeFunction() const{return m_ActRemoveNonCumulativeFunction;}
	bool AcDllActRemoveNonCumulativeRowValue(RowValue* rowValue, unsigned short i, AccountRowTotal* rowTotal, const Row* rowToRemove) const
	{
		return m_ActRemoveNonCumulativeFunction && m_ActRemoveNonCumulativeFunction(rowValue, i, rowTotal, rowToRemove);
	}
protected:
	virtual bool DoLoad();

	virtual void Reset()
	{
		BaseExtensionDll::Reset();
		AdditionalReset();
	}

	virtual void ResetValues()
	{
		BaseExtensionDll::ResetValues();
		AdditionalResetValues();
	}

	void AdditionalReset()
	{
		m_IsTraderIdValidFunction = NULL;

		m_MsAdditionalColumnCountFunction = NULL;
		m_MsRowValueFunction = NULL;
		m_MsTotalRowValueFunction = NULL;
		m_MsColumnInfoFunction = NULL;
		m_MsColumnPositionFunction = NULL;
		m_MsApplyPositionFunction = NULL;
		m_MsInvalidatePositionColumnsFunction = NULL;
		m_MsInvalidatePositionTotalsFunction = NULL;
		m_MsUpdatePositionValuesFunction = NULL;
		m_MsAdjustPositionTotalsFunction = NULL;
		m_MsRowCellColorFunction = NULL;

		m_MsRowLockFunction = NULL;
		m_MsRowLockWaitFunction = NULL;
		m_MsRowUnlockFunction = NULL;

		m_MsUpdateNonCumulativeFunction = NULL;
		m_MsAddNonCumulativeFunction = NULL;
		m_MsRemoveNonCumulativeFunction = NULL;

		m_OrdAdditionalColumnCountFunction = NULL;
		m_OrdRowValueFunction = NULL;
		m_OrdTotalRowValueFunction = NULL;
		m_OrdColumnInfoFunction = NULL;
		m_OrdRowCellColorFunction = NULL;
		m_OrdUpdateNonCumulativeFunction = NULL;
		m_OrdAddNonCumulativeFunction = NULL;
		m_OrdRemoveNonCumulativeFunction = NULL;

		m_PosAdditionalColumnCountFunction = NULL;
		m_PosRowValueFunction = NULL;
		m_PosTotalRowValueFunction = NULL;
		m_PosColumnInfoFunction = NULL;
		m_PosRowCellColorFunction = NULL;
		m_PosUpdateNonCumulativeFunction = NULL;
		m_PosAddNonCumulativeFunction = NULL;
		m_PosRemoveNonCumulativeFunction = NULL;

		m_ActAdditionalColumnCountFunction = NULL;
		m_ActRowValueFunction = NULL;
		m_ActTotalRowValueFunction = NULL;
		m_ActColumnInfoFunction = NULL;
		m_ActRowCellColorFunction = NULL;
		m_ActUpdateNonCumulativeFunction = NULL;
		m_ActAddNonCumulativeFunction = NULL;
		m_ActRemoveNonCumulativeFunction = NULL;
	}

	void AdditionalResetValues()
	{
		m_msAdditionalColumnCount = 0;
		m_ordAdditionalColumnCount = 0;
		m_posAdditionalColumnCount = 0;
		m_actAdditionalColumnCount = 0;
	}
	AcApiBoolCharPtr m_IsTraderIdValidFunction;

	ApiGetUShort m_MsAdditionalColumnCountFunction;
	AcApiMsRowValue m_MsRowValueFunction;
	AcApiMsTotalRowValue m_MsTotalRowValueFunction;
	AcApiColumnInfo m_MsColumnInfoFunction;
	AcApiIsByUShort m_MsColumnPositionFunction;
	AcApiApplyMsPosition m_MsApplyPositionFunction;
	AcApiMsWindow m_MsInvalidatePositionColumnsFunction;
	AcApiMsWindow m_MsInvalidatePositionTotalsFunction;
	AcApiMsRow m_MsUpdatePositionValuesFunction;
	AcApiMsRow m_MsAdjustPositionTotalsFunction;
	AcApiMsRowCellColor m_MsRowCellColorFunction;

	AcApiBoolConstMsRow m_MsRowLockFunction;
	AcApiConstMsRow m_MsRowLockWaitFunction;
	AcApiConstMsRow m_MsRowUnlockFunction;
	AcApiMsAddNonCumulative m_MsUpdateNonCumulativeFunction;
	AcApiMsAddNonCumulative m_MsAddNonCumulativeFunction;
	AcApiMsAddNonCumulative m_MsRemoveNonCumulativeFunction;

	unsigned short m_msAdditionalColumnCount;

	ApiGetUShort m_OrdAdditionalColumnCountFunction;
	AcApiOrdRowValue m_OrdRowValueFunction;
	AcApiOrdTotalRowValue m_OrdTotalRowValueFunction;
	AcApiColumnInfo m_OrdColumnInfoFunction;
	AcApiOrdRowCellColor m_OrdRowCellColorFunction;

	AcApiOrdAddNonCumulative m_OrdUpdateNonCumulativeFunction;
	AcApiOrdAddNonCumulative m_OrdAddNonCumulativeFunction;
	AcApiOrdAddNonCumulative m_OrdRemoveNonCumulativeFunction;
	unsigned short m_ordAdditionalColumnCount;

	ApiGetUShort m_PosAdditionalColumnCountFunction;
	AcApiPosRowValue m_PosRowValueFunction;
	AcApiPosTotalRowValue m_PosTotalRowValueFunction;
	AcApiColumnInfo m_PosColumnInfoFunction;
	AcApiPosRowCellColor m_PosRowCellColorFunction;

	AcApiPosAddNonCumulative m_PosUpdateNonCumulativeFunction;
	AcApiPosAddNonCumulative m_PosAddNonCumulativeFunction;
	AcApiPosAddNonCumulative m_PosRemoveNonCumulativeFunction;
	unsigned short m_posAdditionalColumnCount;

	ApiGetUShort m_ActAdditionalColumnCountFunction;
	AcApiActRowValue m_ActRowValueFunction;
	AcApiActTotalRowValue m_ActTotalRowValueFunction;
	AcApiColumnInfo m_ActColumnInfoFunction;
	AcApiActRowCellColor m_ActRowCellColorFunction;
	AcApiActAddNonCumulative m_ActUpdateNonCumulativeFunction;
	AcApiActAddNonCumulative m_ActAddNonCumulativeFunction;
	AcApiActAddNonCumulative m_ActRemoveNonCumulativeFunction;
	unsigned short m_actAdditionalColumnCount;
};

class TGUI_API ExtensionMainDialog : public ExtensionMainDialogBase
{
public:
	ExtensionMainDialog(int width, int height, const char* title, const char* productName, unsigned __int64 productVersion, const char* configExtension, COLORREF titleColor = RGB(0, 0, 128), int topOffset = 0, bool showTime = false);
	virtual bool CurrentAccountSet(Account* account);
	Account* GetCurrentAccount() const{return m_currentAccount;}
	virtual void TabNcDoubleClicked();
protected:
	Account* m_currentAccount;

	virtual BOOL PreTranslateMessage(MSG* pMsg);
	int m_myWidth;
};

class NewsWire
{
public:
	NewsWire(const char* const& description = "",
		const unsigned int& id = 0,
		const unsigned short& subid = 0,
		const unsigned short& baseid = 0,
		const bool& subwire = false,
		const bool& entitled = false):
		m_description(description),
		m_id(id),
		m_subid(subid),
		m_baseid(baseid),
		m_superId(CalculateSuperIdStatic(m_id, m_subid)),
		m_subwire(subwire),
		m_entitled(entitled)
	{
		U_AppendUnsignedNumberAsString(m_fullName, m_baseid);
		m_fullName += " - ";
		U_AppendUnsignedNumberAsString(m_fullName, m_id);
		if(m_baseid != m_subid)
		{
			m_fullName += " @ ";
			U_AppendUnsignedNumberAsString(m_fullName, m_subid);
		}
		m_fullName += " - ";
		m_fullName += m_description;
	}
	static unsigned __int64 CalculateSuperIdStatic(unsigned int id, unsigned short subid){return ((unsigned __int64)id << 32) | (unsigned __int64)subid;}
	static void GetIdsFromSuperIdStatic(const unsigned __int64& superId, unsigned int& id, unsigned short& subid){id = (unsigned int)(superId >> 32); subid = (unsigned short)(superId & 0xFFFF);}
	unsigned __int64 CalculateSuperId() const{return CalculateSuperIdStatic(m_id, m_subid);}
	const std::string& GetDescription() const{return m_description;}
	const std::string& GetFullName() const{return m_fullName;}
	const unsigned int& GetId() const{return m_id;}
	const unsigned short& GetSubId() const{return m_subid;}
	const unsigned short& GetBaseId() const{return m_baseid;}
	const unsigned __int64& GetSuperId() const{return m_superId;}
	const bool& isSubwire() const{return m_subwire;}
	const bool& isEntitled() const{return m_entitled;}
protected:
	std::string m_fullName;
	std::string m_description;
	unsigned int m_id;
	unsigned short m_subid;
	unsigned short m_baseid;
	unsigned __int64 m_superId;
	bool m_subwire;
	bool m_entitled;
};

class TGUI_API ListBoxNewsWire : public ListBoxOwnerDraw
{
public:
	typedef std::set<unsigned __int64> WireSet;

	ListBoxNewsWire(const WireSet& wireSet);
	const WireSet& GetWireSet() const{return m_wireSet;}
	const WireSet& GetCheckedEntitledWireSet() const{return m_checkedEntitledWireSet;}
	bool SetWireSet(const WireSet& wireSet);
	virtual const char* GetItemName(const void* item) const override
	{
		return ((const NewsWire*)item)->GetFullName().c_str();
	}
	virtual bool isItemChecked(const void* item) const override
	{
		return m_wireSet.find(((const NewsWire*)item)->GetSuperId()) != m_wireSetEnd;
	}
	virtual void GetDrawItemRect(const DRAWITEMSTRUCT* lpDrawItemStruct, CRect& drawItemRect) const override
	{
		ListBoxOwnerDraw::GetDrawItemRect(lpDrawItemStruct, drawItemRect);
		if(((const NewsWire*)lpDrawItemStruct->itemData)->isSubwire())
		{
			drawItemRect.left += lpDrawItemStruct->rcItem.bottom - lpDrawItemStruct->rcItem.top;
		}
	}
	virtual void DestroyItem(const void* item) const override;//{delete (NewsWire*)item;}
	virtual void* CloneItem(const void* item) const override;//{return new NewsWire(*(const NewsWire*)item);}
    virtual int Compare(const void* item1, const void* item2) const override;
	virtual CBrush* GetBkBrush() const override
	{
		return m_entitledCheckedCount ?
			m_entitledCount == m_entitledCheckedCount ? ListBoxOwnerDraw::GetBkBrush() : GetPartialCheckedBrush():
			GetWarningBrush();
	}
	virtual COLORREF GetStringColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override
	{
		return (lpDrawItemStruct->itemState & ODS_SELECTED) ? GetSysColor(COLOR_HIGHLIGHTTEXT) : GetSelectedBkColor(lpDrawItemStruct);
	}
	virtual COLORREF GetBkColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override
	{
//		return m_entitledCheckedCount ? ListBoxOwnerDraw::GetBkColor(lpDrawItemStruct) : GetWarningColor();
		return m_entitledCheckedCount ?
			m_entitledCount == m_entitledCheckedCount ? ListBoxOwnerDraw::GetBkColor(lpDrawItemStruct) : GetPartialCheckedColor():
			GetWarningColor();
	}
	virtual COLORREF GetSelectedBkColor(const DRAWITEMSTRUCT* lpDrawItemStruct) const override
	{
		return ((const NewsWire*)lpDrawItemStruct->itemData)->isEntitled() ? GetSysColor(COLOR_WINDOWTEXT) : m_disabledColor;
	}

	void SetCheckedAllEnabled(bool notify);
	const unsigned int& GetEntitledCheckedCount() const{return m_entitledCheckedCount;}
	const unsigned int& GetEntitledCount() const{return m_entitledCount;}
	void InitCheckedCount();

//	int AddString(const char* item);
//	int InsertString(int i, const char* item);
//	int DeleteString(int i);
//	void ResetContent();
//	bool ClearItemsWithRedraw();
protected:
	virtual void DrawMenuItem(LPDRAWITEMSTRUCT lpDrawItemStruct) override;
	virtual bool MeasureMenuItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) override;
	virtual void OnItemAdded(void* item, unsigned int at, bool checked) override;
	virtual void BeforeItemDeleted(unsigned int at, bool checked) override;
//	virtual void AfterItemDeleted(unsigned int at, bool failed) override;
//	virtual void BeforeItemsCleared() override{}
	virtual void AfterItemsCleared() override;

	virtual void SetItemChecked(void* item, unsigned int i, bool checked) override;
	virtual void ListBoxCreated()
	{
		ListBoxOwnerDraw::ListBoxCreated();
		InitCheckedCount();
	}
	virtual void BeforeDestroy()
	{
		ListBoxOwnerDraw::BeforeDestroy();
		m_entitledCheckedCount = 0;
		m_entitledCount = 0;
		m_checkedEntitledWireSet.clear();
	}
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) override;
	virtual void AddMenuItems(CMenu& menu) override;
	WireSet m_wireSet;
	WireSet::const_iterator m_wireSetEnd;
	WireSet m_checkedEntitledWireSet;
	WireSet::const_iterator m_checkedEntitledWireSetEnd;
	COLORREF m_disabledColor;
	unsigned int m_entitledCount;
	unsigned int m_entitledCheckedCount;
private:
	void ClearChecked();
};

#ifdef __cplusplus
extern "C"
{
#endif

AdditionalColumnDll* WINAPI TGUI_GetAdditionalColumnDll();
void WINAPI TGUI_SetLoadAdditionalColumnDll(bool load);
bool WINAPI TGUI_IsLoadAdditionalColumnDll();

unsigned int WINAPI TGUI_GetCommandToolCount();
unsigned int WINAPI TGUI_GetActiveCommandToolOrdinal();
TakionTool* WINAPI TGUI_GetCommandToolAt(unsigned int ordinal);
TakionTool* WINAPI TGUI_GetActiveCommandTool();
bool WINAPI TGUI_GetCommandToolObjects(unsigned int ordinal, bool& basket, std::string& symbol, const Security*& security, const Account*& account, const Position*& position);
bool WINAPI TGUI_IsInSoundThread();
void WINAPI TGUI_PlaySoundInThread(const std::string& fileName, bool reload);

bool WINAPI TGUI_AddCommand(Command* command);
Command* WINAPI TGUI_RemoveCommand(const char* commandName);
Command* WINAPI TGUI_FindCommand(const char* commandName);
bool WINAPI TGUI_MapCommand(const Key& key, Command* command, bool overridePreviousMapping);
bool WINAPI TGUI_UnmapCommand(Command* command);
Command* WINAPI TGUI_UnmapKey(const Key& key);
Command* WINAPI TGUI_GetMappedCommand(const Key& key);

#ifdef __cplusplus
}
#endif
